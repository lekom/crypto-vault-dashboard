import {
  AccountNotFoundError,
  CHAIN_ID,
  DELEGATOR_CONTRACTS,
  createCaveatBuilder,
  createOpenDelegation,
  createPublicClient,
  createWalletClient,
  custom,
  defineBlock,
  defineChain,
  defineTransaction,
  defineTransactionReceipt,
  domainSeparator,
  encodePacked,
  entryPoint07Address,
  fallback,
  formatLog,
  formatTransaction,
  getAction,
  getContract,
  getTransactionReceipt,
  getUserOperationHash,
  http,
  isHash,
  multicall,
  parseEventLogs,
  parseSignature,
  publicActions,
  readContract,
  serializeAccessList,
  serializeTransaction,
  sha256,
  signTypedData,
  toAccount,
  toRlp,
  toSmartAccount,
  toYParitySignatureArray,
  validateTypedData,
  webSocket,
  zeroAddress,
  zeroHash
} from "./chunk-CGXUAOEY.js";
import "./chunk-BMBH2I46.js";
import {
  AbiEncodingArrayLengthMismatchError,
  AbiEncodingBytesSizeMismatchError,
  AbiEncodingLengthMismatchError,
  BaseError,
  ContractFunctionExecutionError,
  FeeCapTooHighError,
  IntegerOutOfRangeError,
  InvalidAbiEncodingTypeError,
  InvalidAddressError,
  InvalidArrayError,
  InvalidChainIdError,
  TipAboveFeeCapError,
  assertRequest,
  boolToHex,
  concat,
  concatHex,
  defineTransactionRequest,
  encodeAbiParameters,
  encodeFunctionData,
  erc20Abi,
  extract,
  formatTransactionRequest,
  getAddress,
  getCallError,
  hexToBigInt,
  hexToBytes,
  hexToNumber,
  isAddress,
  isHex,
  keccak256,
  maxUint16,
  maxUint256,
  numberToHex,
  pad,
  padHex,
  parseAbi,
  parseAbiItem,
  parseAbiParameters,
  parseAccount,
  size,
  slice,
  stringToHex,
  stringify,
  toBytes,
  toFunctionSelector,
  toHex,
  trim
} from "./chunk-TVZ5MBGC.js";
import "./chunk-Z5Y4QC72.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports, module) {
    !(function(t, e) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
    })(exports, (function() {
      "use strict";
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
        var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
        return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
      } }, m = function(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, v = { s: m, z: function(t2) {
        var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t2(e2, n2) {
        if (e2.date() < n2.date()) return -t2(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: c, y: h, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return void 0 === t2;
      } }, g = "en", D = {};
      D[g] = M;
      var p = "$isDayjsObject", S = function(t2) {
        return t2 instanceof _ || !(!t2 || !t2[p]);
      }, w = function t2(e2, n2, r2) {
        var i2;
        if (!e2) return g;
        if ("string" == typeof e2) {
          var s2 = e2.toLowerCase();
          D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
          var u2 = e2.split("-");
          if (!i2 && u2.length > 1) return t2(u2[0]);
        } else {
          var a2 = e2.name;
          D[a2] = e2, i2 = a2;
        }
        return !r2 && i2 && (g = i2), i2 || !r2 && g;
      }, O = function(t2, e2) {
        if (S(t2)) return t2.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _(n2);
      }, b = v;
      b.l = w, b.i = S, b.w = function(t2, e2) {
        return O(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _ = (function() {
        function M2(t2) {
          this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
        }
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
          this.$d = (function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2) return /* @__PURE__ */ new Date(NaN);
            if (b.u(e2)) return /* @__PURE__ */ new Date();
            if (e2 instanceof Date) return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match($);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          })(t2), this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return b;
        }, m2.isValid = function() {
          return !(this.$d.toString() === l);
        }, m2.isSame = function(t2, e2) {
          var n2 = O(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t2, e2) {
          return O(t2) < this.startOf(e2);
        }, m2.isBefore = function(t2, e2) {
          return this.endOf(e2) < O(t2);
        }, m2.$g = function(t2, e2, n2) {
          return b.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e2) {
          var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t2), l2 = function(t3, e3) {
            var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a);
          }, $2 = function(t3, e3) {
            return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (f2) {
            case h:
              return r2 ? l2(1, 0) : l2(31, 11);
            case c:
              return r2 ? l2(1, M3) : l2(0, M3 + 1);
            case o:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
            case a:
            case d:
              return $2(v2 + "Hours", 0);
            case u:
              return $2(v2 + "Minutes", 1);
            case s:
              return $2(v2 + "Seconds", 2);
            case i:
              return $2(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e2) {
          var n2, o2 = b.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === c || o2 === h) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else l2 && this.$d[l2]($2);
          return this.init(), this;
        }, m2.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function(t2) {
          return this[b.p(t2)]();
        }, m2.add = function(r2, f2) {
          var d2, l2 = this;
          r2 = Number(r2);
          var $2 = b.p(f2), y2 = function(t2) {
            var e2 = O(l2);
            return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
          };
          if ($2 === c) return this.set(c, this.$M + r2);
          if ($2 === h) return this.set(h, this.$y + r2);
          if ($2 === a) return y2(1);
          if ($2 === o) return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return b.w(m3, this);
        }, m2.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid()) return n2.invalidDate || l;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h2 = function(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
          }, d2 = function(t3) {
            return b.s(s2 % 12 || 12, t3, "0");
          }, $2 = f2 || function(t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          };
          return r2.replace(y, (function(t3, r3) {
            return r3 || (function(t4) {
              switch (t4) {
                case "YY":
                  return String(e2.$y).slice(-2);
                case "YYYY":
                  return b.s(e2.$y, 4, "0");
                case "M":
                  return a2 + 1;
                case "MM":
                  return b.s(a2 + 1, 2, "0");
                case "MMM":
                  return h2(n2.monthsShort, a2, c2, 3);
                case "MMMM":
                  return h2(c2, a2);
                case "D":
                  return e2.$D;
                case "DD":
                  return b.s(e2.$D, 2, "0");
                case "d":
                  return String(e2.$W);
                case "dd":
                  return h2(n2.weekdaysMin, e2.$W, o2, 2);
                case "ddd":
                  return h2(n2.weekdaysShort, e2.$W, o2, 3);
                case "dddd":
                  return o2[e2.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return b.s(s2, 2, "0");
                case "h":
                  return d2(1);
                case "hh":
                  return d2(2);
                case "a":
                  return $2(s2, u2, true);
                case "A":
                  return $2(s2, u2, false);
                case "m":
                  return String(u2);
                case "mm":
                  return b.s(u2, 2, "0");
                case "s":
                  return String(e2.$s);
                case "ss":
                  return b.s(e2.$s, 2, "0");
                case "SSS":
                  return b.s(e2.$ms, 3, "0");
                case "Z":
                  return i2;
              }
              return null;
            })(t3) || i2.replace(":", "");
          }));
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, l2) {
          var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
            return b.m(y2, m3);
          };
          switch (M3) {
            case h:
              $2 = D2() / 12;
              break;
            case c:
              $2 = D2();
              break;
            case f:
              $2 = D2() / 3;
              break;
            case o:
              $2 = (g2 - v2) / 6048e5;
              break;
            case a:
              $2 = (g2 - v2) / 864e5;
              break;
            case u:
              $2 = g2 / n;
              break;
            case s:
              $2 = g2 / e;
              break;
            case i:
              $2 = g2 / t;
              break;
            default:
              $2 = g2;
          }
          return l2 ? $2 : b.a($2);
        }, m2.daysInMonth = function() {
          return this.endOf(c).$D;
        }, m2.$locale = function() {
          return D[this.$L];
        }, m2.locale = function(t2, e2) {
          if (!t2) return this.$L;
          var n2 = this.clone(), r2 = w(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function() {
          return b.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      })(), k = _.prototype;
      return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach((function(t2) {
        k[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      })), O.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _, O), t2.$i = true), O;
      }, O.locale = w, O.isDayjs = S, O.unix = function(t2) {
        return O(1e3 * t2);
      }, O.en = D[g], O.Ls = D, O.p = {}, O;
    }));
  }
});

// node_modules/solady/js/solady.js
var require_solady = __commonJS({
  "node_modules/solady/js/solady.js"(exports, module) {
    (function(global2, factory2) {
      "use strict";
      if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = factory2(global2, 1);
        if (typeof exports === "object") {
          exports.LibZip = module.exports.LibZip;
          exports.ERC1967Factory = module.exports.ERC1967Factory;
        }
      } else {
        factory2(global2);
      }
    })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
      "use strict";
      var solady = {};
      var LibZip2 = {};
      solady.LibZip = LibZip2;
      function hexString(data) {
        if (typeof data === "string" || data instanceof String) {
          if (data = data.match(/^[\s\uFEFF\xA0]*(0[Xx])?([0-9A-Fa-f]*)[\s\uFEFF\xA0]*$/)) {
            if (data[2].length % 2) {
              throw new Error("Hex string length must be a multiple of 2.");
            }
            return data[2];
          }
        }
        throw new Error("Data must be a hex string.");
      }
      function byteToString(b) {
        return (b | 256).toString(16).slice(1);
      }
      function parseByte(data, i) {
        return parseInt(data.substr(i, 2), 16);
      }
      function hexToBytes2(data) {
        var a = [], i = 0;
        for (; i < data.length; i += 2) a.push(parseByte(data, i));
        return a;
      }
      function bytesToHex2(a) {
        var o = "0x", i = 0;
        for (; i < a.length; o += byteToString(a[i++])) ;
        return o;
      }
      LibZip2.flzCompress = function(data) {
        var ib = hexToBytes2(hexString(data)), b = ib.length - 4;
        var ht = [], ob = [], a = 0, i = 2, o = 0, j, s, h, d, c, l, r, p, q, e;
        function u24(i2) {
          return ib[i2] | ib[++i2] << 8 | ib[++i2] << 16;
        }
        function hash(x) {
          return 2654435769 * x >> 19 & 8191;
        }
        function literals(r2, s2) {
          while (r2 >= 32) for (ob[o++] = 31, j = 32; j--; r2--) ob[o++] = ib[s2++];
          if (r2) for (ob[o++] = r2 - 1; r2--; ) ob[o++] = ib[s2++];
        }
        while (i < b - 9) {
          do {
            r = ht[h = hash(s = u24(i))] || 0;
            c = (d = (ht[h] = i) - r) < 8192 ? u24(r) : 16777216;
          } while (i < b - 9 && i++ && s != c);
          if (i >= b - 9) break;
          if (--i > a) literals(i - a, a);
          for (l = 0, p = r + 3, q = i + 3, e = b - q; l < e; l++) e *= ib[p + l] === ib[q + l];
          i += l;
          for (--d; l > 262; l -= 262) ob[o++] = 224 + (d >> 8), ob[o++] = 253, ob[o++] = d & 255;
          if (l < 7) ob[o++] = (l << 5) + (d >> 8), ob[o++] = d & 255;
          else ob[o++] = 224 + (d >> 8), ob[o++] = l - 7, ob[o++] = d & 255;
          ht[hash(u24(i))] = i++, ht[hash(u24(i))] = i++, a = i;
        }
        literals(b + 4 - a, a);
        return bytesToHex2(ob);
      };
      LibZip2.flzDecompress = function(data) {
        var ib = hexToBytes2(hexString(data)), i = 0, o = 0, l, f, t, r, h, ob = [];
        while (i < ib.length) {
          if (!(t = ib[i] >> 5)) {
            for (l = 1 + ib[i++]; l--; ) ob[o++] = ib[i++];
          } else {
            f = 256 * (ib[i] & 31) + ib[i + 2 - (t = t < 7)];
            l = t ? 2 + (ib[i] >> 5) : 9 + ib[i + 1];
            i = i + 3 - t;
            r = o - f - 1;
            while (l--) ob[o++] = ob[r++];
          }
        }
        return bytesToHex2(ob);
      };
      LibZip2.cdCompress = function(data) {
        data = hexString(data);
        var o = "0x", z = 0, y = 0, i = 0, c;
        function pushByte(b) {
          o += byteToString((o.length < 4 * 2 + 2) * 255 ^ b);
        }
        function rle(v, d) {
          pushByte(0);
          pushByte(d - 1 + v * 128);
        }
        for (; i < data.length; i += 2) {
          c = parseByte(data, i);
          if (!c) {
            if (y) rle(1, y), y = 0;
            if (++z === 128) rle(0, 128), z = 0;
            continue;
          }
          if (c === 255) {
            if (z) rle(0, z), z = 0;
            if (++y === 32) rle(1, 32), y = 0;
            continue;
          }
          if (y) rle(1, y), y = 0;
          if (z) rle(0, z), z = 0;
          pushByte(c);
        }
        if (y) rle(1, y), y = 0;
        if (z) rle(0, z), z = 0;
        return o;
      };
      LibZip2.cdDecompress = function(data) {
        data = hexString(data);
        var o = "0x", i = 0, j, c, s;
        while (i < data.length) {
          c = (i < 4 * 2) * 255 ^ parseByte(data, i);
          i += 2;
          if (!c) {
            c = (i < 4 * 2) * 255 ^ parseByte(data, i);
            s = (c & 127) + 1;
            i += 2;
            for (j = 0; j < s; ++j) o += byteToString((c >> 7 && j < 32) * 255);
            continue;
          }
          o += byteToString(c);
        }
        return o;
      };
      var ERC1967Factory = {};
      solady.ERC1967Factory = ERC1967Factory;
      ERC1967Factory.address = "0x0000000000006396FF2a80c067f99B3d2Ab4Df24";
      ERC1967Factory.abi = JSON.parse('[{0:[],1:"DeploymentFailed"96"SaltDoesNotStartWithCaller"96"Unauthorized"96"UpgradeFailed",2:3959790,9791],1:"AdminChanged",2:10959790,9792,9791],1:"Deployed",2:10959790,9792],1:"Upgraded",2:10},{0:[{90],1:"adminOf",12:[{9199{0:[{90,{91],1:"changeAdmin",12:[],13:"nonpayable",2:15},{0:[{92,{91],1:"deploy",12:[{9098,{0:[{92,{91,{94],1:"deployAndCall",12:[{9098,{0:[{92,{91,{93],1:"deployDeterministic",12:[{9098,{0:[{92,{91,{93,{94],1:"deployDeterministicAndCall",12:[{9098,{0:[],1:"initCodeHash",12:[{6:19,1:"result",2:19}99{0:[{93],1:"predictDeterministicAddress",12:[{6:7,1:"predicted",2:7}99{0:[{90,{92],1:"upgrade",12:[98,{0:[{90,{92,{94],1:"upgradeAndCall",12:[98]'.replace(/9\d/g, function(m) {
        return ["6:7,1:8,2:7}", "6:7,1:9,2:7}", "6:7,1:11,2:7}", "6:19,1:20,2:19}", "6:17,1:18,2:17}", "},{4:false,0:[", ",2:3},{0:[],1:", "{5:true,", "],13:16,2:15}", "],13:14,2:15},"][m - 90];
      }).replace(/\d+/g, function(m) {
        return '"' + "inputs,name,type,error,anonymous,indexed,internalType,address,proxy,admin,event,implementation,outputs,stateMutability,view,function,payable,bytes,data,bytes32,salt".split(",")[m] + '"';
      }));
      if (typeof define === "function" && define.amd) {
        define("solady", [], function() {
          return solady;
        });
      }
      if (!noGlobal) {
        window2.solady = solady;
      }
      return solady;
    });
  }
});

// node_modules/@moonwell-fi/moonwell-sdk/package.json
var require_package = __commonJS({
  "node_modules/@moonwell-fi/moonwell-sdk/package.json"(exports, module) {
    module.exports = {
      name: "@moonwell-fi/moonwell-sdk",
      description: "TypeScript Interface for Moonwell",
      version: "0.9.7",
      main: "./_cjs/index.js",
      module: "./_esm/index.js",
      types: "./_types/index.d.ts",
      typings: "./_types/index.d.ts",
      sideEffects: false,
      files: [
        "*",
        "!**/*.bench.ts",
        "!**/*.bench-d.ts",
        "!**/*.test.ts",
        "!**/*.test.ts.snap",
        "!**/*.test-d.ts",
        "!**/*.tsbuildinfo",
        "!tsconfig.build.json",
        "!jsr.json"
      ],
      exports: {
        ".": {
          types: "./_types/index.d.ts",
          import: "./_esm/index.js",
          default: "./_cjs/index.js"
        },
        "./actions": {
          types: "./_types/actions/index.d.ts",
          import: "./_esm/actions/index.js",
          default: "./_cjs/actions/index.js"
        },
        "./client": {
          types: "./_types/client/index.d.ts",
          import: "./_esm/client/index.js",
          default: "./_cjs/client/index.js"
        },
        "./common": {
          types: "./_types/common/index.d.ts",
          import: "./_esm/common/index.js",
          default: "./_cjs/common/index.js"
        },
        "./environments": {
          types: "./_types/environments/index.d.ts",
          import: "./_esm/environments/index.js",
          default: "./_cjs/environments/index.js"
        },
        "./package.json": "./package.json"
      },
      typesVersions: {
        "*": {
          actions: [
            "./_types/actions/index.d.ts"
          ]
        }
      },
      peerDependencies: {
        typescript: ">=5.0.4"
      },
      peerDependenciesMeta: {
        typescript: {
          optional: true
        }
      },
      dependencies: {
        "@across-protocol/app-sdk": "^0.2.3",
        "@biconomy/abstractjs": "^1.0.18",
        "@rhinestone/module-sdk": "0.2.7",
        "@types/lodash": "^4.17.9",
        "@types/node": "^22.13.10",
        axios: "^1.7.7",
        dayjs: "^1.11.13",
        lodash: "^4.17.21",
        viem: "^2.26.2"
      },
      license: "MIT",
      homepage: "https://moonwell.fi",
      repository: "moonwell-fi/moonwell-sdk",
      authors: [
        "x0s0l.eth"
      ],
      keywords: [
        "eth",
        "ethereum",
        "dapps",
        "sdk",
        "moonwell",
        "web3",
        "typescript"
      ]
    };
  }
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports, module) {
    (function() {
      var undefined2;
      var VERSION3 = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "A",
        "Å": "A",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "a",
        "å": "a",
        "Ç": "C",
        "ç": "c",
        "Ð": "D",
        "ð": "d",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "Ñ": "N",
        "ñ": "n",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "O",
        "Ø": "O",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "o",
        "ø": "o",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "U",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "u",
        "Ý": "Y",
        "ý": "y",
        "ÿ": "y",
        "Æ": "Ae",
        "æ": "ae",
        "Þ": "Th",
        "þ": "th",
        "ß": "ss",
        // Latin Extended-A block.
        "Ā": "A",
        "Ă": "A",
        "Ą": "A",
        "ā": "a",
        "ă": "a",
        "ą": "a",
        "Ć": "C",
        "Ĉ": "C",
        "Ċ": "C",
        "Č": "C",
        "ć": "c",
        "ĉ": "c",
        "ċ": "c",
        "č": "c",
        "Ď": "D",
        "Đ": "D",
        "ď": "d",
        "đ": "d",
        "Ē": "E",
        "Ĕ": "E",
        "Ė": "E",
        "Ę": "E",
        "Ě": "E",
        "ē": "e",
        "ĕ": "e",
        "ė": "e",
        "ę": "e",
        "ě": "e",
        "Ĝ": "G",
        "Ğ": "G",
        "Ġ": "G",
        "Ģ": "G",
        "ĝ": "g",
        "ğ": "g",
        "ġ": "g",
        "ģ": "g",
        "Ĥ": "H",
        "Ħ": "H",
        "ĥ": "h",
        "ħ": "h",
        "Ĩ": "I",
        "Ī": "I",
        "Ĭ": "I",
        "Į": "I",
        "İ": "I",
        "ĩ": "i",
        "ī": "i",
        "ĭ": "i",
        "į": "i",
        "ı": "i",
        "Ĵ": "J",
        "ĵ": "j",
        "Ķ": "K",
        "ķ": "k",
        "ĸ": "k",
        "Ĺ": "L",
        "Ļ": "L",
        "Ľ": "L",
        "Ŀ": "L",
        "Ł": "L",
        "ĺ": "l",
        "ļ": "l",
        "ľ": "l",
        "ŀ": "l",
        "ł": "l",
        "Ń": "N",
        "Ņ": "N",
        "Ň": "N",
        "Ŋ": "N",
        "ń": "n",
        "ņ": "n",
        "ň": "n",
        "ŋ": "n",
        "Ō": "O",
        "Ŏ": "O",
        "Ő": "O",
        "ō": "o",
        "ŏ": "o",
        "ő": "o",
        "Ŕ": "R",
        "Ŗ": "R",
        "Ř": "R",
        "ŕ": "r",
        "ŗ": "r",
        "ř": "r",
        "Ś": "S",
        "Ŝ": "S",
        "Ş": "S",
        "Š": "S",
        "ś": "s",
        "ŝ": "s",
        "ş": "s",
        "š": "s",
        "Ţ": "T",
        "Ť": "T",
        "Ŧ": "T",
        "ţ": "t",
        "ť": "t",
        "ŧ": "t",
        "Ũ": "U",
        "Ū": "U",
        "Ŭ": "U",
        "Ů": "U",
        "Ű": "U",
        "Ų": "U",
        "ũ": "u",
        "ū": "u",
        "ŭ": "u",
        "ů": "u",
        "ű": "u",
        "ų": "u",
        "Ŵ": "W",
        "ŵ": "w",
        "Ŷ": "Y",
        "ŷ": "y",
        "Ÿ": "Y",
        "Ź": "Z",
        "Ż": "Z",
        "Ž": "Z",
        "ź": "z",
        "ż": "z",
        "ž": "z",
        "Ĳ": "IJ",
        "ĳ": "ij",
        "Œ": "Oe",
        "œ": "oe",
        "ŉ": "'n",
        "ſ": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root2 = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = (function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      })();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator2) {
        var data, result = [];
        while (!(data = iterator2.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = (function runInContext2(context) {
        context = context == null ? root2 : _.defaults(root2.Object(), context, _.pick(root2, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty2 = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = (function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        })();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root2._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = (function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        })();
        var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap && new WeakMap();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash11(value) {
          if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty2.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = /* @__PURE__ */ (function() {
          function object() {
          }
          return function(proto) {
            if (!isObject2(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        })();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash11.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash11
          }
        };
        lodash11.prototype = baseLodash.prototype;
        lodash11.prototype.constructor = lodash11;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end2 = view.end, length = end2 - start2, index = isRight ? end2 : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty2.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty2.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size3 = data.size;
          data.set(key, value);
          this.size += data.size == size3 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject2(value)) {
            return value;
          }
          var isArr = isArray2(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer2(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start2, end2) {
          var length = array.length;
          start2 = toInteger(start2);
          if (start2 < 0) {
            start2 = -start2 > length ? 0 : length + start2;
          }
          end2 = end2 === undefined2 || end2 > length ? length : toInteger(end2);
          if (end2 < 0) {
            end2 += length;
          }
          end2 = start2 > end2 ? 0 : toLength(end2);
          while (start2 < end2) {
            array[start2++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction3(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty2.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start2, end2) {
          return number >= nativeMin(start2, end2) && number < nativeMax(start2, end2);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last2(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer2(object)) {
            if (!isBuffer2(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject2(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction3(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty2.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject2(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject2(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray2(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject2(objValue) || isFunction3(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray2(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start2, end2, step2, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end2 - start2) / (step2 || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start2;
            start2 += step2;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start2) {
          return setToString(overRest(func, start2, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject2(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start2, end2) {
          var index = -1, length = array.length;
          if (start2 < 0) {
            start2 = -start2 > length ? 0 : length + start2;
          }
          end2 = end2 > length ? length : end2;
          if (end2 < 0) {
            end2 += length;
          }
          length = start2 > end2 ? 0 : end2 - start2 >>> 0;
          start2 >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start2];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray2(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last2(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions2) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions2, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray2(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString3(value));
        }
        var castRest = baseRest;
        function castSlice(array, start2, end2) {
          var length = array.length;
          end2 = end2 === undefined2 ? length : end2;
          return !start2 && end2 >= length ? array : baseSlice(array, start2, end2);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root2.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString3(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject2(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray2(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root2 && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start2, end2, step2) {
            if (step2 && typeof step2 != "number" && isIterateeCall(start2, end2, step2)) {
              end2 = step2 = undefined2;
            }
            start2 = toFinite(start2);
            if (end2 === undefined2) {
              end2 = start2;
              start2 = 0;
            } else {
              end2 = toFinite(end2);
            }
            step2 = step2 === undefined2 ? start2 < end2 ? 1 : -1 : toFinite(step2);
            return baseRange(start2, end2, step2, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString3(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString3(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject2(objValue) && isObject2(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject2(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop2 : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty2.call(lodash11, "placeholder") ? lodash11 : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash11.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start2, end2, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size3 = data.size;
            switch (data.type) {
              case "drop":
                start2 += size3;
                break;
              case "dropRight":
                end2 -= size3;
                break;
              case "take":
                end2 = nativeMin(end2, start2 + size3);
                break;
              case "takeRight":
                start2 = nativeMax(start2, end2 - size3);
                break;
            }
          }
          return { "start": start2, "end": end2 };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject2(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray2(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash11[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction3 : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject2(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start2, transform2) {
          start2 = nativeMax(start2 === undefined2 ? func.length - 1 : start2, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start2, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start2 + index];
            }
            index = -1;
            var otherArgs = Array2(start2 + 1);
            while (++index < start2) {
              otherArgs[index] = args[index];
            }
            otherArgs[start2] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root2.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size3) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size3 = size3 === undefined2 ? length : size3;
          while (++index < size3) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size3;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size3, guard) {
          if (guard ? isIterateeCall(array, size3, guard) : size3 === undefined2) {
            size3 = 1;
          } else {
            size3 = nativeMax(toInteger(size3), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size3 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size3));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size3);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat2() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last2(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last2(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start2, end2) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start2 && typeof start2 != "number" && isIterateeCall(array, value, start2)) {
            start2 = 0;
            end2 = length;
          }
          return baseFill(array, value, start2, end2);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last2(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last2(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice2(array, start2, end2) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end2 && typeof end2 != "number" && isIterateeCall(array, start2, end2)) {
            start2 = 0;
            end2 = length;
          } else {
            start2 = start2 == null ? 0 : toInteger(start2);
            end2 = end2 === undefined2 ? length : toInteger(end2);
          }
          return baseSlice(array, start2, end2);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last2(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last2(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq2(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith2(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last2(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last2(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash11(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start2 = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start2)) {
            return this.thru(interceptor);
          }
          value = value.slice(start2, +start2 + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray2(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray2(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter2(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach2(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray2(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray2(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray2(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray2(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray2(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size2(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString2(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray2(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root2.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind2 = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind2));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject2(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start2) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start2 = start2 === undefined2 ? start2 : toInteger(start2);
          return baseRest(func, start2);
        }
        function spread3(func, start2) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start2 = start2 == null ? 0 : nativeMax(toInteger(start2), 0);
          return baseRest(function(args) {
            var array = args[start2], otherArgs = castSlice(args, 0, start2);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle2(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject2(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray2(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(/* @__PURE__ */ (function() {
          return arguments;
        })()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray2 = Array2.isArray;
        var isArrayBuffer2 = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction3(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean2(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer2 = nativeIsBuffer || stubFalse;
        var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
        }
        function isEmpty2(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray2(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty2.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual2(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
        }
        function isFinite(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction3(value) {
          if (!isObject2(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject2(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN(value) {
          return isNumber2(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber2(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject2(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp2 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString2(value) {
          return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined2(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray2(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString2(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject2(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject2(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString3(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty2.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype3, properties) {
          var result2 = baseCreate(prototype3);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults2 = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey2(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty2.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge2 = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction3(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray2(object), isArrLike = isArr || isBuffer2(object) || isTypedArray2(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject2(object)) {
              accumulator = isFunction3(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start2, end2) {
          start2 = toFinite(start2);
          if (end2 === undefined2) {
            end2 = start2;
            start2 = 0;
          } else {
            end2 = toFinite(end2);
          }
          number = toNumber(number);
          return baseInRange(number, start2, end2);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString3(string).toLowerCase());
        }
        function deburr(string) {
          string = toString3(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith2(string, target, position) {
          string = toString3(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end2 = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end2) == target;
        }
        function escape(string) {
          string = toString3(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString3(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad2(string, length, chars) {
          string = toString3(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString3(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString3(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString3(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString3(string), n);
        }
        function replace() {
          var args = arguments, string = toString3(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString3(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp2(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString3(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash11.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString3(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty2.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString3(value).toLowerCase();
        }
        function toUpper(value) {
          return toString3(value).toUpperCase();
        }
        function trim3(string, chars, guard) {
          string = toString3(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end2 = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start2, end2).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString3(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end2 = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end2).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString3(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start2 = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start2).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject2(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString3(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end2 = length - stringSize(omission);
          if (end2 < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end2).join("") : string.slice(0, end2);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end2 += result2.length - end2;
          }
          if (isRegExp2(separator)) {
            if (string.slice(end2).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString3(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end2 : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end2) != end2) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape2(string) {
          string = toString3(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString3(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind2(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction3(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions2 = result2.__actions__ = copyArray(this.__actions__);
                  actions2.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root2._ === this) {
            root2._ = oldDash;
          }
          return this;
        }
        function noop2() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray2(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString3(value)));
        }
        function uniqueId2(prefix) {
          var id = ++idCounter;
          return toString3(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash11.after = after;
        lodash11.ary = ary;
        lodash11.assign = assign;
        lodash11.assignIn = assignIn;
        lodash11.assignInWith = assignInWith;
        lodash11.assignWith = assignWith;
        lodash11.at = at;
        lodash11.before = before;
        lodash11.bind = bind2;
        lodash11.bindAll = bindAll;
        lodash11.bindKey = bindKey;
        lodash11.castArray = castArray;
        lodash11.chain = chain;
        lodash11.chunk = chunk;
        lodash11.compact = compact;
        lodash11.concat = concat2;
        lodash11.cond = cond;
        lodash11.conforms = conforms;
        lodash11.constant = constant;
        lodash11.countBy = countBy;
        lodash11.create = create;
        lodash11.curry = curry;
        lodash11.curryRight = curryRight;
        lodash11.debounce = debounce;
        lodash11.defaults = defaults2;
        lodash11.defaultsDeep = defaultsDeep;
        lodash11.defer = defer;
        lodash11.delay = delay;
        lodash11.difference = difference;
        lodash11.differenceBy = differenceBy;
        lodash11.differenceWith = differenceWith;
        lodash11.drop = drop;
        lodash11.dropRight = dropRight;
        lodash11.dropRightWhile = dropRightWhile;
        lodash11.dropWhile = dropWhile;
        lodash11.fill = fill;
        lodash11.filter = filter2;
        lodash11.flatMap = flatMap;
        lodash11.flatMapDeep = flatMapDeep;
        lodash11.flatMapDepth = flatMapDepth;
        lodash11.flatten = flatten;
        lodash11.flattenDeep = flattenDeep;
        lodash11.flattenDepth = flattenDepth;
        lodash11.flip = flip;
        lodash11.flow = flow;
        lodash11.flowRight = flowRight;
        lodash11.fromPairs = fromPairs;
        lodash11.functions = functions;
        lodash11.functionsIn = functionsIn;
        lodash11.groupBy = groupBy;
        lodash11.initial = initial;
        lodash11.intersection = intersection;
        lodash11.intersectionBy = intersectionBy;
        lodash11.intersectionWith = intersectionWith;
        lodash11.invert = invert;
        lodash11.invertBy = invertBy;
        lodash11.invokeMap = invokeMap;
        lodash11.iteratee = iteratee;
        lodash11.keyBy = keyBy;
        lodash11.keys = keys;
        lodash11.keysIn = keysIn;
        lodash11.map = map;
        lodash11.mapKeys = mapKeys;
        lodash11.mapValues = mapValues;
        lodash11.matches = matches;
        lodash11.matchesProperty = matchesProperty;
        lodash11.memoize = memoize;
        lodash11.merge = merge2;
        lodash11.mergeWith = mergeWith;
        lodash11.method = method;
        lodash11.methodOf = methodOf;
        lodash11.mixin = mixin;
        lodash11.negate = negate;
        lodash11.nthArg = nthArg;
        lodash11.omit = omit;
        lodash11.omitBy = omitBy;
        lodash11.once = once;
        lodash11.orderBy = orderBy;
        lodash11.over = over;
        lodash11.overArgs = overArgs;
        lodash11.overEvery = overEvery;
        lodash11.overSome = overSome;
        lodash11.partial = partial;
        lodash11.partialRight = partialRight;
        lodash11.partition = partition;
        lodash11.pick = pick;
        lodash11.pickBy = pickBy;
        lodash11.property = property;
        lodash11.propertyOf = propertyOf;
        lodash11.pull = pull;
        lodash11.pullAll = pullAll;
        lodash11.pullAllBy = pullAllBy;
        lodash11.pullAllWith = pullAllWith;
        lodash11.pullAt = pullAt;
        lodash11.range = range;
        lodash11.rangeRight = rangeRight;
        lodash11.rearg = rearg;
        lodash11.reject = reject;
        lodash11.remove = remove;
        lodash11.rest = rest;
        lodash11.reverse = reverse;
        lodash11.sampleSize = sampleSize;
        lodash11.set = set;
        lodash11.setWith = setWith;
        lodash11.shuffle = shuffle;
        lodash11.slice = slice2;
        lodash11.sortBy = sortBy;
        lodash11.sortedUniq = sortedUniq;
        lodash11.sortedUniqBy = sortedUniqBy;
        lodash11.split = split;
        lodash11.spread = spread3;
        lodash11.tail = tail;
        lodash11.take = take;
        lodash11.takeRight = takeRight;
        lodash11.takeRightWhile = takeRightWhile;
        lodash11.takeWhile = takeWhile;
        lodash11.tap = tap;
        lodash11.throttle = throttle2;
        lodash11.thru = thru;
        lodash11.toArray = toArray2;
        lodash11.toPairs = toPairs;
        lodash11.toPairsIn = toPairsIn;
        lodash11.toPath = toPath;
        lodash11.toPlainObject = toPlainObject;
        lodash11.transform = transform;
        lodash11.unary = unary;
        lodash11.union = union;
        lodash11.unionBy = unionBy;
        lodash11.unionWith = unionWith;
        lodash11.uniq = uniq2;
        lodash11.uniqBy = uniqBy;
        lodash11.uniqWith = uniqWith2;
        lodash11.unset = unset;
        lodash11.unzip = unzip;
        lodash11.unzipWith = unzipWith;
        lodash11.update = update;
        lodash11.updateWith = updateWith;
        lodash11.values = values;
        lodash11.valuesIn = valuesIn;
        lodash11.without = without;
        lodash11.words = words;
        lodash11.wrap = wrap;
        lodash11.xor = xor;
        lodash11.xorBy = xorBy;
        lodash11.xorWith = xorWith;
        lodash11.zip = zip;
        lodash11.zipObject = zipObject;
        lodash11.zipObjectDeep = zipObjectDeep;
        lodash11.zipWith = zipWith;
        lodash11.entries = toPairs;
        lodash11.entriesIn = toPairsIn;
        lodash11.extend = assignIn;
        lodash11.extendWith = assignInWith;
        mixin(lodash11, lodash11);
        lodash11.add = add;
        lodash11.attempt = attempt;
        lodash11.camelCase = camelCase;
        lodash11.capitalize = capitalize;
        lodash11.ceil = ceil;
        lodash11.clamp = clamp;
        lodash11.clone = clone;
        lodash11.cloneDeep = cloneDeep;
        lodash11.cloneDeepWith = cloneDeepWith;
        lodash11.cloneWith = cloneWith;
        lodash11.conformsTo = conformsTo;
        lodash11.deburr = deburr;
        lodash11.defaultTo = defaultTo;
        lodash11.divide = divide;
        lodash11.endsWith = endsWith2;
        lodash11.eq = eq;
        lodash11.escape = escape;
        lodash11.escapeRegExp = escapeRegExp;
        lodash11.every = every;
        lodash11.find = find;
        lodash11.findIndex = findIndex;
        lodash11.findKey = findKey2;
        lodash11.findLast = findLast;
        lodash11.findLastIndex = findLastIndex;
        lodash11.findLastKey = findLastKey;
        lodash11.floor = floor;
        lodash11.forEach = forEach2;
        lodash11.forEachRight = forEachRight;
        lodash11.forIn = forIn;
        lodash11.forInRight = forInRight;
        lodash11.forOwn = forOwn;
        lodash11.forOwnRight = forOwnRight;
        lodash11.get = get;
        lodash11.gt = gt;
        lodash11.gte = gte;
        lodash11.has = has;
        lodash11.hasIn = hasIn;
        lodash11.head = head;
        lodash11.identity = identity;
        lodash11.includes = includes;
        lodash11.indexOf = indexOf;
        lodash11.inRange = inRange;
        lodash11.invoke = invoke;
        lodash11.isArguments = isArguments;
        lodash11.isArray = isArray2;
        lodash11.isArrayBuffer = isArrayBuffer2;
        lodash11.isArrayLike = isArrayLike;
        lodash11.isArrayLikeObject = isArrayLikeObject;
        lodash11.isBoolean = isBoolean2;
        lodash11.isBuffer = isBuffer2;
        lodash11.isDate = isDate2;
        lodash11.isElement = isElement;
        lodash11.isEmpty = isEmpty2;
        lodash11.isEqual = isEqual2;
        lodash11.isEqualWith = isEqualWith;
        lodash11.isError = isError;
        lodash11.isFinite = isFinite;
        lodash11.isFunction = isFunction3;
        lodash11.isInteger = isInteger;
        lodash11.isLength = isLength;
        lodash11.isMap = isMap;
        lodash11.isMatch = isMatch;
        lodash11.isMatchWith = isMatchWith;
        lodash11.isNaN = isNaN;
        lodash11.isNative = isNative;
        lodash11.isNil = isNil;
        lodash11.isNull = isNull;
        lodash11.isNumber = isNumber2;
        lodash11.isObject = isObject2;
        lodash11.isObjectLike = isObjectLike;
        lodash11.isPlainObject = isPlainObject2;
        lodash11.isRegExp = isRegExp2;
        lodash11.isSafeInteger = isSafeInteger;
        lodash11.isSet = isSet;
        lodash11.isString = isString2;
        lodash11.isSymbol = isSymbol;
        lodash11.isTypedArray = isTypedArray2;
        lodash11.isUndefined = isUndefined2;
        lodash11.isWeakMap = isWeakMap;
        lodash11.isWeakSet = isWeakSet;
        lodash11.join = join;
        lodash11.kebabCase = kebabCase;
        lodash11.last = last2;
        lodash11.lastIndexOf = lastIndexOf;
        lodash11.lowerCase = lowerCase;
        lodash11.lowerFirst = lowerFirst;
        lodash11.lt = lt;
        lodash11.lte = lte;
        lodash11.max = max;
        lodash11.maxBy = maxBy;
        lodash11.mean = mean;
        lodash11.meanBy = meanBy;
        lodash11.min = min;
        lodash11.minBy = minBy;
        lodash11.stubArray = stubArray;
        lodash11.stubFalse = stubFalse;
        lodash11.stubObject = stubObject;
        lodash11.stubString = stubString;
        lodash11.stubTrue = stubTrue;
        lodash11.multiply = multiply;
        lodash11.nth = nth;
        lodash11.noConflict = noConflict;
        lodash11.noop = noop2;
        lodash11.now = now;
        lodash11.pad = pad2;
        lodash11.padEnd = padEnd;
        lodash11.padStart = padStart;
        lodash11.parseInt = parseInt2;
        lodash11.random = random;
        lodash11.reduce = reduce;
        lodash11.reduceRight = reduceRight;
        lodash11.repeat = repeat;
        lodash11.replace = replace;
        lodash11.result = result;
        lodash11.round = round;
        lodash11.runInContext = runInContext2;
        lodash11.sample = sample;
        lodash11.size = size2;
        lodash11.snakeCase = snakeCase;
        lodash11.some = some;
        lodash11.sortedIndex = sortedIndex;
        lodash11.sortedIndexBy = sortedIndexBy;
        lodash11.sortedIndexOf = sortedIndexOf;
        lodash11.sortedLastIndex = sortedLastIndex;
        lodash11.sortedLastIndexBy = sortedLastIndexBy;
        lodash11.sortedLastIndexOf = sortedLastIndexOf;
        lodash11.startCase = startCase;
        lodash11.startsWith = startsWith;
        lodash11.subtract = subtract;
        lodash11.sum = sum;
        lodash11.sumBy = sumBy;
        lodash11.template = template;
        lodash11.times = times;
        lodash11.toFinite = toFinite;
        lodash11.toInteger = toInteger;
        lodash11.toLength = toLength;
        lodash11.toLower = toLower;
        lodash11.toNumber = toNumber;
        lodash11.toSafeInteger = toSafeInteger;
        lodash11.toString = toString3;
        lodash11.toUpper = toUpper;
        lodash11.trim = trim3;
        lodash11.trimEnd = trimEnd;
        lodash11.trimStart = trimStart;
        lodash11.truncate = truncate;
        lodash11.unescape = unescape2;
        lodash11.uniqueId = uniqueId2;
        lodash11.upperCase = upperCase;
        lodash11.upperFirst = upperFirst;
        lodash11.each = forEach2;
        lodash11.eachRight = forEachRight;
        lodash11.first = head;
        mixin(lodash11, (function() {
          var source = {};
          baseForOwn(lodash11, function(func, methodName) {
            if (!hasOwnProperty2.call(lodash11.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        })(), { "chain": false });
        lodash11.VERSION = VERSION3;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash11[methodName].placeholder = lodash11;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start2, end2) {
          start2 = toInteger(start2);
          var result2 = this;
          if (result2.__filtered__ && (start2 > 0 || end2 < 0)) {
            return new LazyWrapper(result2);
          }
          if (start2 < 0) {
            result2 = result2.takeRight(-start2);
          } else if (start2) {
            result2 = result2.drop(start2);
          }
          if (end2 !== undefined2) {
            end2 = toInteger(end2);
            result2 = end2 < 0 ? result2.dropRight(-end2) : result2.take(end2 - start2);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash11[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash11.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash11, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash11.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray2(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray2(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash11[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty2.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash11.prototype.at = wrapperAt;
        lodash11.prototype.chain = wrapperChain;
        lodash11.prototype.commit = wrapperCommit;
        lodash11.prototype.next = wrapperNext;
        lodash11.prototype.plant = wrapperPlant;
        lodash11.prototype.reverse = wrapperReverse;
        lodash11.prototype.toJSON = lodash11.prototype.valueOf = lodash11.prototype.value = wrapperValue;
        lodash11.prototype.first = lodash11.prototype.head;
        if (symIterator) {
          lodash11.prototype[symIterator] = wrapperToIterator;
        }
        return lodash11;
      });
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root2._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root2._ = _;
      }
    }).call(exports);
  }
});

// node_modules/dayjs/plugin/utc.js
var require_utc = __commonJS({
  "node_modules/dayjs/plugin/utc.js"(exports, module) {
    !(function(t, i) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = i() : "function" == typeof define && define.amd ? define(i) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs_plugin_utc = i();
    })(exports, (function() {
      "use strict";
      var t = "minute", i = /[+-]\d\d(?::?\d\d)?/g, e = /([+-]|\d\d)/g;
      return function(s, f, n) {
        var u = f.prototype;
        n.utc = function(t2) {
          var i2 = { date: t2, utc: true, args: arguments };
          return new f(i2);
        }, u.utc = function(i2) {
          var e2 = n(this.toDate(), { locale: this.$L, utc: true });
          return i2 ? e2.add(this.utcOffset(), t) : e2;
        }, u.local = function() {
          return n(this.toDate(), { locale: this.$L, utc: false });
        };
        var r = u.parse;
        u.parse = function(t2) {
          t2.utc && (this.$u = true), this.$utils().u(t2.$offset) || (this.$offset = t2.$offset), r.call(this, t2);
        };
        var o = u.init;
        u.init = function() {
          if (this.$u) {
            var t2 = this.$d;
            this.$y = t2.getUTCFullYear(), this.$M = t2.getUTCMonth(), this.$D = t2.getUTCDate(), this.$W = t2.getUTCDay(), this.$H = t2.getUTCHours(), this.$m = t2.getUTCMinutes(), this.$s = t2.getUTCSeconds(), this.$ms = t2.getUTCMilliseconds();
          } else o.call(this);
        };
        var a = u.utcOffset;
        u.utcOffset = function(s2, f2) {
          var n2 = this.$utils().u;
          if (n2(s2)) return this.$u ? 0 : n2(this.$offset) ? a.call(this) : this.$offset;
          if ("string" == typeof s2 && (s2 = (function(t2) {
            void 0 === t2 && (t2 = "");
            var s3 = t2.match(i);
            if (!s3) return null;
            var f3 = ("" + s3[0]).match(e) || ["-", 0, 0], n3 = f3[0], u3 = 60 * +f3[1] + +f3[2];
            return 0 === u3 ? 0 : "+" === n3 ? u3 : -u3;
          })(s2), null === s2)) return this;
          var u2 = Math.abs(s2) <= 16 ? 60 * s2 : s2;
          if (0 === u2) return this.utc(f2);
          var r2 = this.clone();
          if (f2) return r2.$offset = u2, r2.$u = false, r2;
          var o2 = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
          return (r2 = this.local().add(u2 + o2, t)).$offset = u2, r2.$x.$localOffset = o2, r2;
        };
        var h = u.format;
        u.format = function(t2) {
          var i2 = t2 || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
          return h.call(this, i2);
        }, u.valueOf = function() {
          var t2 = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
          return this.$d.valueOf() - 6e4 * t2;
        }, u.isUTC = function() {
          return !!this.$u;
        }, u.toISOString = function() {
          return this.toDate().toISOString();
        }, u.toString = function() {
          return this.toDate().toUTCString();
        };
        var l = u.toDate;
        u.toDate = function(t2) {
          return "s" === t2 && this.$offset ? n(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : l.call(this);
        };
        var c = u.diff;
        u.diff = function(t2, i2, e2) {
          if (t2 && this.$u === t2.$u) return c.call(this, t2, i2, e2);
          var s2 = this.local(), f2 = n(t2).local();
          return c.call(s2, f2, i2, e2);
        };
      };
    }));
  }
});

// node_modules/viem/_esm/chains/index.js
var chains_exports = {};
__export(chains_exports, {
  abey: () => abey,
  abstract: () => abstract,
  abstractTestnet: () => abstractTestnet,
  acala: () => acala,
  acria: () => acria,
  adf: () => adf,
  agungTestnet: () => agungTestnet,
  aioz: () => aioz,
  alephZero: () => alephZero,
  alephZeroTestnet: () => alephZeroTestnet,
  alienx: () => alienx,
  alienxHalTestnet: () => alienxHalTestnet,
  ancient8: () => ancient8,
  ancient8Sepolia: () => ancient8Sepolia,
  anvil: () => anvil,
  apeChain: () => apeChain,
  apexTestnet: () => apexTestnet,
  arbitrum: () => arbitrum,
  arbitrumGoerli: () => arbitrumGoerli,
  arbitrumNova: () => arbitrumNova,
  arbitrumSepolia: () => arbitrumSepolia,
  arenaz: () => arenaz,
  areonNetwork: () => areonNetwork,
  areonNetworkTestnet: () => areonNetworkTestnet,
  areum: () => areum,
  artelaTestnet: () => artelaTestnet,
  arthera: () => arthera,
  artheraTestnet: () => artheraTestnet,
  assetChain: () => assetChain,
  assetChainTestnet: () => assetChainTestnet,
  astar: () => astar,
  astarZkEVM: () => astarZkEVM,
  astarZkyoto: () => astarZkyoto,
  atletaOlympia: () => atletaOlympia,
  aurora: () => aurora,
  auroraTestnet: () => auroraTestnet,
  auroria: () => auroria,
  autheoTestnet: () => autheoTestnet,
  avalanche: () => avalanche,
  avalancheFuji: () => avalancheFuji,
  b3: () => b3,
  b3Sepolia: () => b3Sepolia,
  bahamut: () => bahamut,
  base: () => base,
  baseGoerli: () => baseGoerli,
  basePreconf: () => basePreconf,
  baseSepolia: () => baseSepolia,
  baseSepoliaPreconf: () => baseSepoliaPreconf,
  basecampTestnet: () => basecampTestnet,
  beam: () => beam,
  beamTestnet: () => beamTestnet,
  bearNetworkChainMainnet: () => bearNetworkChainMainnet,
  bearNetworkChainTestnet: () => bearNetworkChainTestnet,
  berachain: () => berachain,
  berachainBepolia: () => berachainBepolia,
  berachainTestnet: () => berachainTestnet,
  berachainTestnetbArtio: () => berachainTestnetbArtio,
  bevmMainnet: () => bevmMainnet,
  bifrost: () => bifrost,
  birdlayer: () => birdlayer,
  bitTorrent: () => bitTorrent,
  bitTorrentTestnet: () => bitTorrentTestnet,
  bitgert: () => bitgert,
  bitkub: () => bitkub,
  bitkubTestnet: () => bitkubTestnet,
  bitlayer: () => bitlayer,
  bitlayerTestnet: () => bitlayerTestnet,
  bitrock: () => bitrock,
  blast: () => blast,
  blastSepolia: () => blastSepolia,
  bob: () => bob,
  bobSepolia: () => bobSepolia,
  boba: () => boba,
  bobaSepolia: () => bobaSepolia,
  boolBetaMainnet: () => boolBetaMainnet,
  botanix: () => botanix,
  botanixTestnet: () => botanixTestnet,
  bounceBit: () => bounceBit,
  bounceBitTestnet: () => bounceBitTestnet,
  bronos: () => bronos,
  bronosTestnet: () => bronosTestnet,
  bsc: () => bsc,
  bscGreenfield: () => bscGreenfield,
  bscTestnet: () => bscTestnet,
  bsquared: () => bsquared,
  bsquaredTestnet: () => bsquaredTestnet,
  btr: () => btr,
  btrTestnet: () => btrTestnet,
  bxn: () => bxn,
  bxnTestnet: () => bxnTestnet,
  cannon: () => cannon,
  canto: () => canto,
  celo: () => celo,
  celoAlfajores: () => celoAlfajores,
  celoSepolia: () => celoSepolia,
  chang: () => chang,
  chiliz: () => chiliz,
  chips: () => chips,
  citreaTestnet: () => citreaTestnet,
  classic: () => classic,
  coinbit: () => coinbit,
  coinex: () => coinex,
  confluxESpace: () => confluxESpace,
  confluxESpaceTestnet: () => confluxESpaceTestnet,
  coreDao: () => coreDao,
  coreTestnet1: () => coreTestnet1,
  coreTestnet2: () => coreTestnet2,
  corn: () => corn,
  cornTestnet: () => cornTestnet,
  crab: () => crab,
  creatorTestnet: () => creatorTestnet,
  creditCoin3Devnet: () => creditCoin3Devnet,
  creditCoin3Mainnet: () => creditCoin3Mainnet,
  creditCoin3Testnet: () => creditCoin3Testnet,
  cronos: () => cronos,
  cronosTestnet: () => cronosTestnet,
  cronoszkEVM: () => cronoszkEVM,
  cronoszkEVMTestnet: () => cronoszkEVMTestnet,
  crossbell: () => crossbell,
  crossfi: () => crossfi,
  curtis: () => curtis,
  cyber: () => cyber,
  cyberTestnet: () => cyberTestnet,
  dailyNetwork: () => dailyNetwork,
  dailyNetworkTestnet: () => dailyNetworkTestnet,
  darwinia: () => darwinia,
  dbkchain: () => dbkchain,
  dchain: () => dchain,
  dchainTestnet: () => dchainTestnet,
  defichainEvm: () => defichainEvm,
  defichainEvmTestnet: () => defichainEvmTestnet,
  degen: () => degen,
  dfk: () => dfk,
  diode: () => diode,
  disChain: () => disChain,
  dodochainTestnet: () => dodochainTestnet,
  dogechain: () => dogechain,
  domaTestnet: () => domaTestnet,
  donatuz: () => donatuz,
  dosChain: () => dosChain,
  dosChainTestnet: () => dosChainTestnet,
  dreyerxMainnet: () => dreyerxMainnet,
  dreyerxTestnet: () => dreyerxTestnet,
  dustboyIoT: () => dustboyIoT,
  dymension: () => dymension,
  edexa: () => edexa,
  edexaTestnet: () => edexaTestnet,
  edgeless: () => edgeless,
  edgelessTestnet: () => edgelessTestnet,
  edgeware: () => edgeware,
  edgewareTestnet: () => edgewareTestnet,
  eduChain: () => eduChain,
  eduChainTestnet: () => eduChainTestnet,
  ekta: () => ekta,
  ektaTestnet: () => ektaTestnet,
  elastos: () => elastos,
  elastosTestnet: () => elastosTestnet,
  electroneum: () => electroneum,
  electroneumTestnet: () => electroneumTestnet,
  elysiumTestnet: () => elysiumTestnet,
  energy: () => energy,
  eni: () => eni,
  eniTestnet: () => eniTestnet,
  enuls: () => enuls,
  eon: () => eon,
  eos: () => eos,
  eosTestnet: () => eosTestnet,
  eteria: () => eteria,
  etherlink: () => etherlink,
  etherlinkTestnet: () => etherlinkTestnet,
  ethernity: () => ethernity,
  etp: () => etp,
  evmos: () => evmos,
  evmosTestnet: () => evmosTestnet,
  excelonMainnet: () => excelonMainnet,
  expanse: () => expanse,
  exsat: () => exsat,
  exsatTestnet: () => exsatTestnet,
  fantom: () => fantom,
  fantomSonicTestnet: () => fantomSonicTestnet,
  fantomTestnet: () => fantomTestnet,
  fibo: () => fibo,
  filecoin: () => filecoin,
  filecoinCalibration: () => filecoinCalibration,
  filecoinHyperspace: () => filecoinHyperspace,
  fireChain: () => fireChain,
  flame: () => flame,
  flare: () => flare,
  flareTestnet: () => flareTestnet,
  flowMainnet: () => flowMainnet,
  flowPreviewnet: () => flowPreviewnet,
  flowTestnet: () => flowTestnet,
  fluence: () => fluence,
  fluenceStage: () => fluenceStage,
  fluenceTestnet: () => fluenceTestnet,
  fluentTestnet: () => fluentTestnet,
  form: () => form,
  formTestnet: () => formTestnet,
  forma: () => forma,
  formicarium: () => formicarium,
  forta: () => forta,
  foundry: () => foundry,
  fraxtal: () => fraxtal,
  fraxtalTestnet: () => fraxtalTestnet,
  funkiMainnet: () => funkiMainnet,
  funkiSepolia: () => funkiSepolia,
  fuse: () => fuse,
  fuseSparknet: () => fuseSparknet,
  fusion: () => fusion,
  fusionTestnet: () => fusionTestnet,
  garnet: () => garnet,
  gatechain: () => gatechain,
  geist: () => geist,
  genesys: () => genesys,
  giwaSepolia: () => giwaSepolia,
  glideL1Protocol: () => glideL1Protocol,
  glideL2Protocol: () => glideL2Protocol,
  gnosis: () => gnosis,
  gnosisChiado: () => gnosisChiado,
  goChain: () => goChain,
  goat: () => goat,
  gobi: () => gobi,
  godwoken: () => godwoken,
  goerli: () => goerli,
  graphite: () => graphite,
  graphiteTestnet: () => graphiteTestnet,
  gravity: () => gravity,
  gunz: () => gunz,
  guruNetwork: () => guruNetwork,
  guruTestnet: () => guruTestnet,
  ham: () => ham,
  happychainTestnet: () => happychainTestnet,
  haqqMainnet: () => haqqMainnet,
  haqqTestedge2: () => haqqTestedge2,
  hardhat: () => hardhat,
  harmonyOne: () => harmonyOne,
  hashkey: () => hashkey,
  hashkeyTestnet: () => hashkeyTestnet,
  haustTestnet: () => haustTestnet,
  hedera: () => hedera,
  hederaPreviewnet: () => hederaPreviewnet,
  hederaTestnet: () => hederaTestnet,
  hela: () => hela,
  hemi: () => hemi,
  hemiSepolia: () => hemiSepolia,
  holesky: () => holesky,
  hoodi: () => hoodi,
  hpb: () => hpb,
  huddle01Mainnet: () => huddle01Mainnet,
  huddle01Testnet: () => huddle01Testnet,
  humanity: () => humanity,
  humanityTestnet: () => humanityTestnet,
  humanode: () => humanode,
  humanodeTestnet5: () => humanodeTestnet5,
  hychain: () => hychain,
  hychainTestnet: () => hychainTestnet,
  hyperliquidEvmTestnet: () => hyperliquidEvmTestnet,
  iSunCoin: () => iSunCoin,
  icbNetwork: () => icbNetwork,
  idchain: () => idchain,
  immutableZkEvm: () => immutableZkEvm,
  immutableZkEvmTestnet: () => immutableZkEvmTestnet,
  inEVM: () => inEVM,
  initVerse: () => initVerse,
  initVerseGenesis: () => initVerseGenesis,
  injective: () => injective,
  injectiveTestnet: () => injectiveTestnet,
  ink: () => ink,
  inkSepolia: () => inkSepolia,
  iota: () => iota,
  iotaTestnet: () => iotaTestnet,
  iotex: () => iotex,
  iotexTestnet: () => iotexTestnet,
  jbc: () => jbc,
  jbcTestnet: () => jbcTestnet,
  jocMainnet: () => jocMainnet,
  jocTestnet: () => jocTestnet,
  jovay: () => jovay,
  jovaySepolia: () => jovaySepolia,
  juneo: () => juneo,
  juneoBCH1Chain: () => juneoBCH1Chain,
  juneoDAI1Chain: () => juneoDAI1Chain,
  juneoDOGE1Chain: () => juneoDOGE1Chain,
  juneoEUR1Chain: () => juneoEUR1Chain,
  juneoGLD1Chain: () => juneoGLD1Chain,
  juneoLINK1Chain: () => juneoLINK1Chain,
  juneoLTC1Chain: () => juneoLTC1Chain,
  juneoSGD1Chain: () => juneoSGD1Chain,
  juneoSocotraTestnet: () => juneoSocotraTestnet,
  juneoUSD1Chain: () => juneoUSD1Chain,
  juneoUSDT1Chain: () => juneoUSDT1Chain,
  juneomBTC1Chain: () => juneomBTC1Chain,
  kaia: () => kaia,
  kairos: () => kairos,
  kakarotSepolia: () => kakarotSepolia,
  kakarotStarknetSepolia: () => kakarotStarknetSepolia,
  kardiaChain: () => kardiaChain,
  karura: () => karura,
  katana: () => katana,
  kava: () => kava,
  kavaTestnet: () => kavaTestnet,
  kcc: () => kcc,
  kiiTestnetOro: () => kiiTestnetOro,
  kinto: () => kinto,
  klaytn: () => klaytn,
  klaytnBaobab: () => klaytnBaobab,
  koi: () => koi,
  kroma: () => kroma,
  kromaSepolia: () => kromaSepolia,
  l3x: () => l3x,
  l3xTestnet: () => l3xTestnet,
  lavita: () => lavita,
  lens: () => lens,
  lensTestnet: () => lensTestnet,
  lestnet: () => lestnet,
  lightlinkPegasus: () => lightlinkPegasus,
  lightlinkPhoenix: () => lightlinkPhoenix,
  linea: () => linea,
  lineaGoerli: () => lineaGoerli,
  lineaSepolia: () => lineaSepolia,
  lineaTestnet: () => lineaTestnet,
  lisk: () => lisk,
  liskSepolia: () => liskSepolia,
  loadAlphanet: () => loadAlphanet,
  localhost: () => localhost,
  loop: () => loop,
  lukso: () => lukso,
  luksoTestnet: () => luksoTestnet,
  lumiaMainnet: () => lumiaMainnet,
  lumiaTestnet: () => lumiaTestnet,
  lumoz: () => lumoz,
  lumozTestnet: () => lumozTestnet,
  lycan: () => lycan,
  lyra: () => lyra,
  mainnet: () => mainnet,
  mandala: () => mandala,
  manta: () => manta,
  mantaSepoliaTestnet: () => mantaSepoliaTestnet,
  mantaTestnet: () => mantaTestnet,
  mantle: () => mantle,
  mantleSepoliaTestnet: () => mantleSepoliaTestnet,
  mantleTestnet: () => mantleTestnet,
  mantraDuKongEVMTestnet: () => mantraDuKongEVMTestnet,
  mantraEVM: () => mantraEVM,
  mapProtocol: () => mapProtocol,
  matchain: () => matchain,
  matchainTestnet: () => matchainTestnet,
  mchVerse: () => mchVerse,
  megaethTestnet: () => megaethTestnet,
  mekong: () => mekong,
  meld: () => meld,
  memecore: () => memecore,
  merlin: () => merlin,
  merlinErigonTestnet: () => merlinErigonTestnet,
  metachain: () => metachain,
  metachainIstanbul: () => metachainIstanbul,
  metadium: () => metadium,
  metalL2: () => metalL2,
  meter: () => meter,
  meterTestnet: () => meterTestnet,
  metis: () => metis,
  metisGoerli: () => metisGoerli,
  metisSepolia: () => metisSepolia,
  mev: () => mev,
  mevTestnet: () => mevTestnet,
  mint: () => mint,
  mintSepoliaTestnet: () => mintSepoliaTestnet,
  mitosisTestnet: () => mitosisTestnet,
  mode: () => mode,
  modeTestnet: () => modeTestnet,
  monadTestnet: () => monadTestnet,
  moonbaseAlpha: () => moonbaseAlpha,
  moonbeam: () => moonbeam,
  moonbeamDev: () => moonbeamDev,
  moonriver: () => moonriver,
  morph: () => morph,
  morphHolesky: () => morphHolesky,
  morphSepolia: () => morphSepolia,
  nahmii: () => nahmii,
  nautilus: () => nautilus,
  near: () => near,
  nearTestnet: () => nearTestnet,
  neonDevnet: () => neonDevnet,
  neonMainnet: () => neonMainnet,
  neoxMainnet: () => neoxMainnet,
  neoxT4: () => neoxT4,
  newton: () => newton,
  nexi: () => nexi,
  nexilix: () => nexilix,
  nibiru: () => nibiru,
  nitrographTestnet: () => nitrographTestnet,
  oasisTestnet: () => oasisTestnet,
  oasys: () => oasys,
  odysseyTestnet: () => odysseyTestnet,
  okc: () => okc,
  omax: () => omax,
  omni: () => omni,
  omniOmega: () => omniOmega,
  oneWorld: () => oneWorld,
  oortMainnetDev: () => oortMainnetDev,
  opBNB: () => opBNB,
  opBNBTestnet: () => opBNBTestnet,
  openledger: () => openledger,
  optimism: () => optimism,
  optimismGoerli: () => optimismGoerli,
  optimismSepolia: () => optimismSepolia,
  optopia: () => optopia,
  optopiaTestnet: () => optopiaTestnet,
  orderly: () => orderly,
  orderlySepolia: () => orderlySepolia,
  otimDevnet: () => otimDevnet,
  palm: () => palm,
  palmTestnet: () => palmTestnet,
  peaq: () => peaq,
  pgn: () => pgn,
  pgnTestnet: () => pgnTestnet,
  phoenix: () => phoenix,
  planq: () => planq,
  plasma: () => plasma,
  plasmaDevnet: () => plasmaDevnet,
  plasmaTestnet: () => plasmaTestnet,
  playfiAlbireo: () => playfiAlbireo,
  plinga: () => plinga,
  plume: () => plume,
  plumeDevnet: () => plumeDevnet,
  plumeMainnet: () => plumeMainnet,
  plumeSepolia: () => plumeSepolia,
  plumeTestnet: () => plumeTestnet,
  polterTestnet: () => polterTestnet,
  polygon: () => polygon,
  polygonAmoy: () => polygonAmoy,
  polygonMumbai: () => polygonMumbai,
  polygonZkEvm: () => polygonZkEvm,
  polygonZkEvmCardona: () => polygonZkEvmCardona,
  polygonZkEvmTestnet: () => polygonZkEvmTestnet,
  polynomial: () => polynomial,
  polynomialSepolia: () => polynomialSepolia,
  premiumBlockTestnet: () => premiumBlockTestnet,
  pulsechain: () => pulsechain,
  pulsechainV4: () => pulsechainV4,
  pumpfiTestnet: () => pumpfiTestnet,
  pyrope: () => pyrope,
  qMainnet: () => qMainnet,
  qTestnet: () => qTestnet,
  ql1: () => ql1,
  quai: () => quai,
  quaiTestnet: () => quaiTestnet,
  real: () => real,
  redbellyMainnet: () => redbellyMainnet,
  redbellyTestnet: () => redbellyTestnet,
  reddio: () => reddio,
  reddioSepolia: () => reddioSepolia,
  redstone: () => redstone,
  rei: () => rei,
  reyaNetwork: () => reyaNetwork,
  riseTestnet: () => riseTestnet,
  rivalz: () => rivalz,
  rollux: () => rollux,
  rolluxTestnet: () => rolluxTestnet,
  ronin: () => ronin,
  root: () => root,
  rootPorcini: () => rootPorcini,
  rootstock: () => rootstock,
  rootstockTestnet: () => rootstockTestnet,
  rss3: () => rss3,
  rss3Sepolia: () => rss3Sepolia,
  saakuru: () => saakuru,
  saga: () => saga,
  saigon: () => saigon,
  sanko: () => sanko,
  sapphire: () => sapphire,
  sapphireTestnet: () => sapphireTestnet,
  satoshiVM: () => satoshiVM,
  satoshiVMTestnet: () => satoshiVMTestnet,
  scroll: () => scroll,
  scrollSepolia: () => scrollSepolia,
  sei: () => sei,
  seiDevnet: () => seiDevnet,
  seiTestnet: () => seiTestnet,
  seismicDevnet: () => seismicDevnet,
  sepolia: () => sepolia,
  shape: () => shape,
  shapeSepolia: () => shapeSepolia,
  shardeum: () => shardeum,
  shardeumSphinx: () => shardeumSphinx,
  shibarium: () => shibarium,
  shibariumTestnet: () => shibariumTestnet,
  shiden: () => shiden,
  shimmer: () => shimmer,
  shimmerTestnet: () => shimmerTestnet,
  sidraChain: () => sidraChain,
  silicon: () => silicon,
  siliconSepolia: () => siliconSepolia,
  sixProtocol: () => sixProtocol,
  skaleBlockBrawlers: () => skaleBlockBrawlers,
  skaleCalypso: () => skaleCalypso,
  skaleCalypsoTestnet: () => skaleCalypsoTestnet,
  skaleCryptoBlades: () => skaleCryptoBlades,
  skaleCryptoColosseum: () => skaleCryptoColosseum,
  skaleEuropa: () => skaleEuropa,
  skaleEuropaTestnet: () => skaleEuropaTestnet,
  skaleExorde: () => skaleExorde,
  skaleHumanProtocol: () => skaleHumanProtocol,
  skaleNebula: () => skaleNebula,
  skaleNebulaTestnet: () => skaleNebulaTestnet,
  skaleRazor: () => skaleRazor,
  skaleTitan: () => skaleTitan,
  skaleTitanTestnet: () => skaleTitanTestnet,
  sketchpad: () => sketchpad,
  snax: () => snax,
  snaxTestnet: () => snaxTestnet,
  somniaTestnet: () => somniaTestnet,
  soneium: () => soneium,
  soneiumMinato: () => soneiumMinato,
  songbird: () => songbird,
  songbirdTestnet: () => songbirdTestnet,
  sonic: () => sonic,
  sonicBlazeTestnet: () => sonicBlazeTestnet,
  sonicTestnet: () => sonicTestnet,
  sophon: () => sophon,
  sophonTestnet: () => sophonTestnet,
  sova: () => sova,
  sovaSepolia: () => sovaSepolia,
  spicy: () => spicy,
  statusNetworkSepolia: () => statusSepolia,
  statusSepolia: () => statusSepolia,
  step: () => step,
  story: () => story,
  storyAeneid: () => storyAeneid,
  storyOdyssey: () => storyOdyssey,
  storyTestnet: () => storyTestnet,
  stratis: () => stratis,
  superlumio: () => superlumio,
  superposition: () => superposition,
  superseed: () => superseed,
  superseedSepolia: () => superseedSepolia,
  surgeTestnet: () => surgeTestnet,
  swan: () => swan,
  swanProximaTestnet: () => swanProximaTestnet,
  swanSaturnTestnet: () => swanSaturnTestnet,
  swellchain: () => swellchain,
  swellchainTestnet: () => swellchainTestnet,
  swissdlt: () => swissdlt,
  syscoin: () => syscoin,
  syscoinTestnet: () => syscoinTestnet,
  tac: () => tac,
  tacSPB: () => tacSPB,
  taiko: () => taiko,
  taikoHekla: () => taikoHekla,
  taikoJolnir: () => taikoJolnir,
  taikoKatla: () => taikoKatla,
  taikoTestnetSepolia: () => taikoTestnetSepolia,
  taraxa: () => taraxa,
  taraxaTestnet: () => taraxaTestnet,
  teaSepolia: () => teaSepolia,
  telcoinTestnet: () => telcoinTestnet,
  telos: () => telos,
  telosTestnet: () => telosTestnet,
  tenet: () => tenet,
  ternoa: () => ternoa,
  thaiChain: () => thaiChain,
  that: () => that,
  theta: () => theta,
  thetaTestnet: () => thetaTestnet,
  thunderCore: () => thunderCore,
  thunderTestnet: () => thunderTestnet,
  tiktrixTestnet: () => tiktrixTestnet,
  tomb: () => tomb,
  treasure: () => treasure,
  treasureTopaz: () => treasureTopaz,
  tron: () => tron,
  tronNile: () => tronNile,
  tronShasta: () => tronShasta,
  ubiq: () => ubiq,
  ultra: () => ultra,
  ultraTestnet: () => ultraTestnet,
  ultron: () => ultron,
  ultronTestnet: () => ultronTestnet,
  unichain: () => unichain,
  unichainSepolia: () => unichainSepolia,
  unique: () => unique,
  uniqueOpal: () => uniqueOpal,
  uniqueQuartz: () => uniqueQuartz,
  unreal: () => unreal,
  vana: () => vana,
  vanaMoksha: () => vanaMoksha,
  vanar: () => vanar,
  vechain: () => vechain,
  velas: () => velas,
  viction: () => viction,
  victionTestnet: () => victionTestnet,
  vision: () => vision,
  visionTestnet: () => visionTestnet,
  wanchain: () => wanchain,
  wanchainTestnet: () => wanchainTestnet,
  weaveVMAlphanet: () => weaveVMAlphanet,
  wemix: () => wemix,
  wemixTestnet: () => wemixTestnet,
  westendAssetHub: () => westendAssetHub,
  whitechain: () => whitechain,
  whitechainTestnet: () => whitechainTestnet,
  wmcTestnet: () => wmcTestnet,
  worldLand: () => worldLand,
  worldchain: () => worldchain,
  worldchainSepolia: () => worldchainSepolia,
  x1Testnet: () => xLayerTestnet,
  xLayer: () => xLayer,
  xLayerTestnet: () => xLayerTestnet,
  xai: () => xai,
  xaiTestnet: () => xaiTestnet,
  xdc: () => xdc,
  xdcTestnet: () => xdcTestnet,
  xphereMainnet: () => xphereMainnet,
  xphereTestnet: () => xphereTestnet,
  xrOne: () => xrOne,
  xrSepolia: () => xrSepolia,
  xrplevmDevnet: () => xrplevmDevnet,
  xrplevmTestnet: () => xrplevmTestnet,
  yooldoVerse: () => yooldoVerse,
  yooldoVerseTestnet: () => yooldoVerseTestnet,
  zenchainTestnet: () => zenchainTestnet,
  zeniq: () => zeniq,
  zeroG: () => zeroG,
  zeroGGalileoTestnet: () => zeroGGalileoTestnet,
  zeroGMainnet: () => zeroGMainnet,
  zeroNetwork: () => zeroNetwork,
  zetachain: () => zetachain,
  zetachainAthensTestnet: () => zetachainAthensTestnet,
  zhejiang: () => zhejiang,
  zilliqa: () => zilliqa,
  zilliqaTestnet: () => zilliqaTestnet,
  zircuit: () => zircuit,
  zircuitGarfieldTestnet: () => zircuitGarfieldTestnet,
  zircuitTestnet: () => zircuitTestnet,
  zkFair: () => zkFair,
  zkFairTestnet: () => zkFairTestnet,
  zkLinkNova: () => zkLinkNova,
  zkLinkNovaSepoliaTestnet: () => zkLinkNovaSepoliaTestnet,
  zkSync: () => zksync,
  zkSyncInMemoryNode: () => zksyncInMemoryNode,
  zkSyncLocalNode: () => zksyncLocalNode,
  zkSyncSepoliaTestnet: () => zksyncSepoliaTestnet,
  zksync: () => zksync,
  zksyncInMemoryNode: () => zksyncInMemoryNode,
  zksyncLocalCustomHyperchain: () => zksyncLocalCustomHyperchain,
  zksyncLocalHyperchain: () => zksyncLocalHyperchain,
  zksyncLocalHyperchainL1: () => zksyncLocalHyperchainL1,
  zksyncLocalNode: () => zksyncLocalNode,
  zksyncSepoliaTestnet: () => zksyncSepoliaTestnet,
  zora: () => zora,
  zoraSepolia: () => zoraSepolia,
  zoraTestnet: () => zoraTestnet
});

// node_modules/viem/_esm/chains/definitions/0g.js
var zeroG = defineChain({
  id: 16600,
  name: "0G Newton Testnet",
  nativeCurrency: { name: "A0GI", symbol: "A0GI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evmrpc-testnet.0g.ai"]
    }
  },
  blockExplorers: {
    default: {
      name: "0G BlockChain Explorer",
      url: "https://chainscan-newton.0g.ai"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/0gGalileoTestnet.js
var zeroGGalileoTestnet = defineChain({
  id: 16601,
  name: "0G Galileo Testnet",
  nativeCurrency: { name: "A0GI", symbol: "A0GI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evmrpc-testnet.0g.ai"]
    }
  },
  blockExplorers: {
    default: {
      name: "0G BlockChain Explorer",
      url: "https://chainscan-galileo.0g.ai"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/0gMainnet.js
var zeroGMainnet = defineChain({
  id: 16661,
  name: "0G Mainnet",
  nativeCurrency: { name: "0G", symbol: "0G", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evmrpc.0g.ai"]
    }
  },
  blockExplorers: {
    default: {
      name: "0G BlockChain Explorer",
      url: "https://chainscan.0g.ai"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/5ireChain.js
var fireChain = defineChain({
  id: 995,
  name: "5ireChain",
  nativeCurrency: { name: "5ire Token", symbol: "5IRE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.5ire.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "5ireChain Mainnet Explorer",
      url: "https://5irescan.io/"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/abey.js
var abey = defineChain({
  id: 179,
  name: "ABEY Mainnet",
  nativeCurrency: { name: "ABEY", symbol: "ABEY", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.abeychain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Abey Scan",
      url: "https://abeyscan.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/zksync/constants/number.js
var gasPerPubdataDefault = 50000n;
var maxBytecodeSize = maxUint16 * 32n;

// node_modules/viem/_esm/zksync/formatters.js
var formatters = {
  block: defineBlock({
    format(args) {
      const transactions = args.transactions?.map((transaction) => {
        if (typeof transaction === "string")
          return transaction;
        const formatted = formatters.transaction?.format(transaction);
        if (formatted.typeHex === "0x71")
          formatted.type = "eip712";
        else if (formatted.typeHex === "0xff")
          formatted.type = "priority";
        return formatted;
      });
      return {
        l1BatchNumber: args.l1BatchNumber ? hexToBigInt(args.l1BatchNumber) : null,
        l1BatchTimestamp: args.l1BatchTimestamp ? hexToBigInt(args.l1BatchTimestamp) : null,
        transactions
      };
    }
  }),
  transaction: defineTransaction({
    format(args) {
      const transaction = {};
      if (args.type === "0x71")
        transaction.type = "eip712";
      else if (args.type === "0xff")
        transaction.type = "priority";
      return {
        ...transaction,
        l1BatchNumber: args.l1BatchNumber ? hexToBigInt(args.l1BatchNumber) : null,
        l1BatchTxIndex: args.l1BatchTxIndex ? hexToBigInt(args.l1BatchTxIndex) : null
      };
    }
  }),
  transactionReceipt: defineTransactionReceipt({
    format(args) {
      return {
        l1BatchNumber: args.l1BatchNumber ? hexToBigInt(args.l1BatchNumber) : null,
        l1BatchTxIndex: args.l1BatchTxIndex ? hexToBigInt(args.l1BatchTxIndex) : null,
        logs: args.logs.map((log) => {
          return {
            ...formatLog(log),
            l1BatchNumber: log.l1BatchNumber ? hexToBigInt(log.l1BatchNumber) : null,
            transactionLogIndex: hexToNumber(log.transactionLogIndex),
            logType: log.logType
          };
        }),
        l2ToL1Logs: args.l2ToL1Logs.map((l2ToL1Log) => {
          return {
            blockNumber: hexToBigInt(l2ToL1Log.blockHash),
            blockHash: l2ToL1Log.blockHash,
            l1BatchNumber: l2ToL1Log.l1BatchNumber ? hexToBigInt(l2ToL1Log.l1BatchNumber) : null,
            transactionIndex: hexToBigInt(l2ToL1Log.transactionIndex),
            shardId: hexToBigInt(l2ToL1Log.shardId),
            isService: l2ToL1Log.isService,
            sender: l2ToL1Log.sender,
            key: l2ToL1Log.key,
            value: l2ToL1Log.value,
            transactionHash: l2ToL1Log.transactionHash,
            logIndex: hexToBigInt(l2ToL1Log.logIndex)
          };
        })
      };
    }
  }),
  transactionRequest: defineTransactionRequest({
    exclude: [
      "customSignature",
      "factoryDeps",
      "gasPerPubdata",
      "paymaster",
      "paymasterInput"
    ],
    format(args) {
      if (args.gasPerPubdata || args.paymaster && args.paymasterInput || args.factoryDeps || args.customSignature)
        return {
          eip712Meta: {
            ...args.gasPerPubdata ? { gasPerPubdata: toHex(args.gasPerPubdata) } : { gasPerPubdata: toHex(gasPerPubdataDefault) },
            ...args.paymaster && args.paymasterInput ? {
              paymasterParams: {
                paymaster: args.paymaster,
                paymasterInput: Array.from(hexToBytes(args.paymasterInput))
              }
            } : {},
            ...args.factoryDeps ? {
              factoryDeps: args.factoryDeps.map((dep) => Array.from(hexToBytes(dep)))
            } : {},
            ...args.customSignature ? {
              customSignature: Array.from(hexToBytes(args.customSignature))
            } : {}
          },
          type: "0x71"
        };
      return {};
    }
  })
};

// node_modules/viem/_esm/zksync/errors/transaction.js
var InvalidEip712TransactionError = class extends BaseError {
  constructor() {
    super([
      "Transaction is not an EIP712 transaction.",
      "",
      "Transaction must:",
      '  - include `type: "eip712"`',
      "  - include one of the following: `customSignature`, `paymaster`, `paymasterInput`, `gasPerPubdata`, `factoryDeps`"
    ].join("\n"), { name: "InvalidEip712TransactionError" });
  }
};

// node_modules/viem/_esm/zksync/utils/isEip712Transaction.js
function isEIP712Transaction(transaction) {
  if (transaction.type === "eip712")
    return true;
  if ("customSignature" in transaction && transaction.customSignature || "paymaster" in transaction && transaction.paymaster || "paymasterInput" in transaction && transaction.paymasterInput || "gasPerPubdata" in transaction && typeof transaction.gasPerPubdata === "bigint" || "factoryDeps" in transaction && transaction.factoryDeps)
    return true;
  return false;
}

// node_modules/viem/_esm/zksync/utils/assertEip712Transaction.js
function assertEip712Transaction(transaction) {
  const { chainId, to, from, paymaster, paymasterInput } = transaction;
  if (!isEIP712Transaction(transaction))
    throw new InvalidEip712TransactionError();
  if (!chainId || chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (from && !isAddress(from))
    throw new InvalidAddressError({ address: from });
  if (paymaster && !isAddress(paymaster))
    throw new InvalidAddressError({ address: paymaster });
  if (paymaster && !paymasterInput) {
    throw new BaseError("`paymasterInput` must be provided when `paymaster` is defined");
  }
  if (!paymaster && paymasterInput) {
    throw new BaseError("`paymaster` must be provided when `paymasterInput` is defined");
  }
}

// node_modules/viem/_esm/zksync/serializers.js
function serializeTransaction2(transaction, signature) {
  if (isEIP712Transaction(transaction))
    return serializeTransactionEIP712(transaction);
  return serializeTransaction(transaction, signature);
}
var serializers = {
  transaction: serializeTransaction2
};
function serializeTransactionEIP712(transaction) {
  const { chainId, gas, nonce, to, from, value, maxFeePerGas, maxPriorityFeePerGas, customSignature, factoryDeps, paymaster, paymasterInput, gasPerPubdata, data } = transaction;
  assertEip712Transaction(transaction);
  const serializedTransaction = [
    nonce ? toHex(nonce) : "0x",
    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? toHex(maxFeePerGas) : "0x",
    gas ? toHex(gas) : "0x",
    to ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x",
    toHex(chainId),
    toHex(""),
    toHex(""),
    toHex(chainId),
    from ?? "0x",
    gasPerPubdata ? toHex(gasPerPubdata) : toHex(gasPerPubdataDefault),
    factoryDeps ?? [],
    customSignature ?? "0x",
    // EIP712 signature
    paymaster && paymasterInput ? [paymaster, paymasterInput] : []
  ];
  return concatHex([
    "0x71",
    toRlp(serializedTransaction)
  ]);
}

// node_modules/viem/_esm/zksync/errors/bytecode.js
var BytecodeLengthExceedsMaxSizeError = class extends BaseError {
  constructor({ givenLength, maxBytecodeSize: maxBytecodeSize2 }) {
    super(`Bytecode cannot be longer than ${maxBytecodeSize2} bytes. Given length: ${givenLength}`, { name: "BytecodeLengthExceedsMaxSizeError" });
  }
};
var BytecodeLengthInWordsMustBeOddError = class extends BaseError {
  constructor({ givenLengthInWords }) {
    super(`Bytecode length in 32-byte words must be odd. Given length in words: ${givenLengthInWords}`, { name: "BytecodeLengthInWordsMustBeOddError" });
  }
};
var BytecodeLengthMustBeDivisibleBy32Error = class extends BaseError {
  constructor({ givenLength }) {
    super(`The bytecode length in bytes must be divisible by 32. Given length: ${givenLength}`, { name: "BytecodeLengthMustBeDivisibleBy32Error" });
  }
};

// node_modules/viem/_esm/zksync/utils/hashBytecode.js
function hashBytecode(bytecode) {
  const bytecodeBytes = toBytes(bytecode);
  if (bytecodeBytes.length % 32 !== 0)
    throw new BytecodeLengthMustBeDivisibleBy32Error({
      givenLength: bytecodeBytes.length
    });
  if (bytecodeBytes.length > maxBytecodeSize)
    throw new BytecodeLengthExceedsMaxSizeError({
      givenLength: bytecodeBytes.length,
      maxBytecodeSize
    });
  const hashStr = sha256(bytecodeBytes);
  const hash = toBytes(hashStr);
  const bytecodeLengthInWords = bytecodeBytes.length / 32;
  if (bytecodeLengthInWords % 2 === 0) {
    throw new BytecodeLengthInWordsMustBeOddError({
      givenLengthInWords: bytecodeLengthInWords
    });
  }
  const bytecodeLength = toBytes(bytecodeLengthInWords);
  const bytecodeLengthPadded = pad(bytecodeLength, { size: 2 });
  const codeHashVersion = new Uint8Array([1, 0]);
  hash.set(codeHashVersion, 0);
  hash.set(bytecodeLengthPadded, 2);
  return hash;
}

// node_modules/viem/_esm/zksync/utils/getEip712Domain.js
var getEip712Domain = (transaction) => {
  assertEip712Transaction(transaction);
  const message = transactionToMessage(transaction);
  return {
    domain: {
      name: "zkSync",
      version: "2",
      chainId: transaction.chainId
    },
    types: {
      Transaction: [
        { name: "txType", type: "uint256" },
        { name: "from", type: "uint256" },
        { name: "to", type: "uint256" },
        { name: "gasLimit", type: "uint256" },
        { name: "gasPerPubdataByteLimit", type: "uint256" },
        { name: "maxFeePerGas", type: "uint256" },
        { name: "maxPriorityFeePerGas", type: "uint256" },
        { name: "paymaster", type: "uint256" },
        { name: "nonce", type: "uint256" },
        { name: "value", type: "uint256" },
        { name: "data", type: "bytes" },
        { name: "factoryDeps", type: "bytes32[]" },
        { name: "paymasterInput", type: "bytes" }
      ]
    },
    primaryType: "Transaction",
    message
  };
};
function transactionToMessage(transaction) {
  const { gas, nonce, to, from, value, maxFeePerGas, maxPriorityFeePerGas, factoryDeps, paymaster, paymasterInput, gasPerPubdata, data } = transaction;
  return {
    txType: 113n,
    from: BigInt(from),
    to: to ? BigInt(to) : 0n,
    gasLimit: gas ?? 0n,
    gasPerPubdataByteLimit: gasPerPubdata ?? gasPerPubdataDefault,
    maxFeePerGas: maxFeePerGas ?? 0n,
    maxPriorityFeePerGas: maxPriorityFeePerGas ?? 0n,
    paymaster: paymaster ? BigInt(paymaster) : 0n,
    nonce: nonce ? BigInt(nonce) : 0n,
    value: value ?? 0n,
    data: data ?? "0x",
    factoryDeps: factoryDeps?.map((dep) => toHex(hashBytecode(dep))) ?? [],
    paymasterInput: paymasterInput ? paymasterInput : "0x"
  };
}

// node_modules/viem/_esm/zksync/chainConfig.js
var chainConfig = {
  blockTime: 1e3,
  formatters,
  serializers,
  custom: {
    getEip712Domain
  }
};

// node_modules/viem/_esm/chains/definitions/abstract.js
var abstract = defineChain({
  ...chainConfig,
  id: 2741,
  name: "Abstract",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://api.mainnet.abs.xyz"],
      webSocket: ["wss://api.mainnet.abs.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://abscan.org"
    },
    native: {
      name: "Abstract Explorer",
      url: "https://explorer.mainnet.abs.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xAa4De41dba0Ca5dCBb288b7cC6b708F3aaC759E7",
      blockCreated: 5288
    },
    erc6492Verifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 5263
    }
  }
});

// node_modules/viem/_esm/chains/definitions/abstractTestnet.js
var abstractTestnet = defineChain({
  ...chainConfig,
  id: 11124,
  name: "Abstract Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://api.testnet.abs.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.abscan.org"
    },
    native: {
      name: "Abstract Explorer",
      url: "https://explorer.testnet.abs.xyz"
    }
  },
  testnet: true,
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963",
      blockCreated: 358349
    },
    erc6492Verifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 431682
    }
  }
});

// node_modules/viem/_esm/chains/definitions/acala.js
var acala = defineChain({
  id: 787,
  name: "Acala",
  network: "acala",
  nativeCurrency: {
    name: "Acala",
    symbol: "ACA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-acala.aca-api.network"],
      webSocket: ["wss://eth-rpc-acala.aca-api.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Acala Blockscout",
      url: "https://blockscout.acala.network",
      apiUrl: "https://blockscout.acala.network/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/acria.js
var acria = defineChain({
  id: 47,
  name: "Acria IntelliChain",
  nativeCurrency: {
    decimals: 18,
    name: "ACRIA",
    symbol: "ACRIA"
  },
  rpcUrls: {
    default: {
      http: ["https://aic.acria.ai"]
    }
  },
  blockExplorers: {
    default: {
      name: "Acria Explorer",
      url: "https://explorer.acria.ai"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/adf.js
var adf = defineChain({
  id: 1215,
  name: "ADF Chain",
  nativeCurrency: { name: "ADDFILL", symbol: "ADF", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.adftechnology.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "ADF Mainnet Explorer",
      url: "https://explorer.adftechnology.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/agungTestnet.js
var agungTestnet = defineChain({
  id: 9990,
  name: "Agung Network",
  nativeCurrency: {
    decimals: 18,
    name: "Agung",
    symbol: "AGNG"
  },
  rpcUrls: {
    default: {
      http: ["https://wss-async.agung.peaq.network"],
      webSocket: ["wss://wss-async.agung.peaq.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Subscan",
      url: "https://agung-testnet.subscan.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/aioz.js
var aioz = defineChain({
  id: 168,
  name: "AIOZ Network",
  nativeCurrency: {
    decimals: 18,
    name: "AIOZ",
    symbol: "AIOZ"
  },
  rpcUrls: {
    default: {
      http: ["https://eth-dataseed.aioz.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "AIOZ Explorer",
      url: "https://explorer.aioz.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/alephZero.js
var alephZero = defineChain({
  id: 41455,
  name: "Aleph Zero",
  nativeCurrency: { name: "Aleph Zero", symbol: "AZERO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.alephzero.raas.gelato.cloud"]
    }
  },
  blockExplorers: {
    default: {
      name: "Aleph Zero EVM Explorer",
      url: "https://evm-explorer.alephzero.org",
      apiUrl: "https://evm-explorer.alephzero.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4603377
    }
  }
});

// node_modules/viem/_esm/chains/definitions/alephZeroTestnet.js
var alephZeroTestnet = defineChain({
  id: 2039,
  name: "Aleph Zero Testnet",
  nativeCurrency: { name: "TZERO", symbol: "TZERO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.alephzero-testnet.gelato.digital"],
      webSocket: ["wss://ws.alephzero-testnet.gelato.digital"]
    }
  },
  blockExplorers: {
    default: {
      name: "Aleph Zero EVM Testnet explorer",
      url: "https://evm-explorer-testnet.alephzero.org",
      apiUrl: "https://evm-explorer-testnet.alephzero.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2861745
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/alienX.js
var alienx = defineChain({
  id: 10241024,
  name: "AlienX Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.alienxchain.io/http"] }
  },
  blockExplorers: {
    default: {
      name: "AlienX Explorer",
      url: "https://explorer.alienxchain.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/alienXHalTestnet.js
var alienxHalTestnet = defineChain({
  id: 10241025,
  name: "ALIENX Hal Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://hal-rpc.alienxchain.io/http"] }
  },
  blockExplorers: {
    default: {
      name: "AlienX Explorer",
      url: "https://hal-explorer.alienxchain.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/op-stack/contracts.js
var contracts = {
  gasPriceOracle: { address: "0x420000000000000000000000000000000000000F" },
  l1Block: { address: "0x4200000000000000000000000000000000000015" },
  l2CrossDomainMessenger: {
    address: "0x4200000000000000000000000000000000000007"
  },
  l2Erc721Bridge: { address: "0x4200000000000000000000000000000000000014" },
  l2StandardBridge: { address: "0x4200000000000000000000000000000000000010" },
  l2ToL1MessagePasser: {
    address: "0x4200000000000000000000000000000000000016"
  }
};

// node_modules/viem/_esm/op-stack/formatters.js
var formatters2 = {
  block: defineBlock({
    format(args) {
      const transactions = args.transactions?.map((transaction) => {
        if (typeof transaction === "string")
          return transaction;
        const formatted = formatTransaction(transaction);
        if (formatted.typeHex === "0x7e") {
          formatted.isSystemTx = transaction.isSystemTx;
          formatted.mint = transaction.mint ? hexToBigInt(transaction.mint) : void 0;
          formatted.sourceHash = transaction.sourceHash;
          formatted.type = "deposit";
        }
        return formatted;
      });
      return {
        transactions,
        stateRoot: args.stateRoot
      };
    }
  }),
  transaction: defineTransaction({
    format(args) {
      const transaction = {};
      if (args.type === "0x7e") {
        transaction.isSystemTx = args.isSystemTx;
        transaction.mint = args.mint ? hexToBigInt(args.mint) : void 0;
        transaction.sourceHash = args.sourceHash;
        transaction.type = "deposit";
      }
      return transaction;
    }
  }),
  transactionReceipt: defineTransactionReceipt({
    format(args) {
      return {
        l1GasPrice: args.l1GasPrice ? hexToBigInt(args.l1GasPrice) : null,
        l1GasUsed: args.l1GasUsed ? hexToBigInt(args.l1GasUsed) : null,
        l1Fee: args.l1Fee ? hexToBigInt(args.l1Fee) : null,
        l1FeeScalar: args.l1FeeScalar ? Number(args.l1FeeScalar) : null
      };
    }
  })
};

// node_modules/viem/_esm/op-stack/serializers.js
function serializeTransaction3(transaction, signature) {
  if (isDeposit(transaction))
    return serializeTransactionDeposit(transaction);
  return serializeTransaction(transaction, signature);
}
var serializers2 = {
  transaction: serializeTransaction3
};
function serializeTransactionDeposit(transaction) {
  assertTransactionDeposit(transaction);
  const { sourceHash, data, from, gas, isSystemTx, mint: mint2, to, value } = transaction;
  const serializedTransaction = [
    sourceHash,
    from,
    to ?? "0x",
    mint2 ? toHex(mint2) : "0x",
    value ? toHex(value) : "0x",
    gas ? toHex(gas) : "0x",
    isSystemTx ? "0x1" : "0x",
    data ?? "0x"
  ];
  return concatHex([
    "0x7e",
    toRlp(serializedTransaction)
  ]);
}
function isDeposit(transaction) {
  if (transaction.type === "deposit")
    return true;
  if (typeof transaction.sourceHash !== "undefined")
    return true;
  return false;
}
function assertTransactionDeposit(transaction) {
  const { from, to } = transaction;
  if (from && !isAddress(from))
    throw new InvalidAddressError({ address: from });
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
}

// node_modules/viem/_esm/op-stack/chainConfig.js
var chainConfig2 = {
  blockTime: 2e3,
  contracts,
  formatters: formatters2,
  serializers: serializers2
};

// node_modules/viem/_esm/chains/definitions/ancient8.js
var sourceId = 1;
var ancient8 = defineChain({
  ...chainConfig2,
  id: 888888888,
  name: "Ancient8",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.ancient8.gg"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ancient8 explorer",
      url: "https://scan.ancient8.gg",
      apiUrl: "https://scan.ancient8.gg/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId]: {
        address: "0xB09DC08428C8b4EFB4ff9C0827386CDF34277996"
      }
    },
    portal: {
      [sourceId]: {
        address: "0x639F2AECE398Aa76b07e59eF6abe2cFe32bacb68",
        blockCreated: 19070571
      }
    },
    l1StandardBridge: {
      [sourceId]: {
        address: "0xd5e3eDf5b68135D559D572E26bF863FBC1950033",
        blockCreated: 19070571
      }
    }
  },
  sourceId
});

// node_modules/viem/_esm/chains/definitions/ancient8Sepolia.js
var sourceId2 = 11155111;
var ancient8Sepolia = defineChain({
  ...chainConfig2,
  id: 28122024,
  name: "Ancient8 Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpcv2-testnet.ancient8.gg"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ancient8 Celestia Testnet explorer",
      url: "https://scanv2-testnet.ancient8.gg",
      apiUrl: "https://scanv2-testnet.ancient8.gg/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId2]: {
        address: "0x942fD5017c0F60575930D8574Eaca13BEcD6e1bB"
      }
    },
    portal: {
      [sourceId2]: {
        address: "0xfa1d9E26A6aCD7b22115D27572c1221B9803c960",
        blockCreated: 4972908
      }
    },
    l1StandardBridge: {
      [sourceId2]: {
        address: "0xF6Bc0146d3c74D48306e79Ae134A260E418C9335",
        blockCreated: 4972908
      }
    }
  },
  sourceId: sourceId2
});

// node_modules/viem/_esm/chains/definitions/anvil.js
var anvil = defineChain({
  id: 31337,
  name: "Anvil",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["http://127.0.0.1:8545"],
      webSocket: ["ws://127.0.0.1:8545"]
    }
  }
});

// node_modules/viem/_esm/chains/definitions/apeChain.js
var sourceId3 = 42161;
var apeChain = defineChain({
  id: 33139,
  name: "Ape Chain",
  nativeCurrency: {
    name: "ApeCoin",
    symbol: "APE",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.apechain.com/http"],
      webSocket: ["wss://rpc.apechain.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Apescan",
      url: "https://apescan.io",
      apiUrl: "https://api.apescan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 20889
    }
  },
  sourceId: sourceId3
});

// node_modules/viem/_esm/chains/definitions/apexTestnet.js
var apexTestnet = defineChain({
  id: 3993,
  name: "APEX Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.apexlayer.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp-testnet.apexlayer.xyz",
      apiUrl: "https://exp-testnet.apexlayer.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xf7642be33a6b18D16a995657adb5a68CD0438aE2",
      blockCreated: 283775
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/arbitrum.js
var arbitrum = defineChain({
  id: 42161,
  name: "Arbitrum One",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  blockTime: 250,
  rpcUrls: {
    default: {
      http: ["https://arb1.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://arbiscan.io",
      apiUrl: "https://api.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7654707
    }
  }
});

// node_modules/viem/_esm/chains/definitions/arbitrumGoerli.js
var arbitrumGoerli = defineChain({
  id: 421613,
  name: "Arbitrum Goerli",
  nativeCurrency: {
    name: "Arbitrum Goerli Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://goerli-rollup.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://goerli.arbiscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 88114
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/arbitrumNova.js
var arbitrumNova = defineChain({
  id: 42170,
  name: "Arbitrum Nova",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://nova.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://nova.arbiscan.io",
      apiUrl: "https://api-nova.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1746963
    }
  }
});

// node_modules/viem/_esm/chains/definitions/arbitrumSepolia.js
var arbitrumSepolia = defineChain({
  id: 421614,
  name: "Arbitrum Sepolia",
  blockTime: 250,
  nativeCurrency: {
    name: "Arbitrum Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rollup.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://sepolia.arbiscan.io",
      apiUrl: "https://api-sepolia.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 81930
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/arenaz.js
var arenaz = defineChain({
  id: 7897,
  name: "Arena-Z",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.arena-z.gg"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arena-Z Explorer",
      url: "https://explorer.arena-z.gg",
      apiUrl: "https://explorer.arena-z.gg"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/areonNetwork.js
var areonNetwork = defineChain({
  id: 463,
  name: "Areon Network",
  nativeCurrency: { decimals: 18, name: "AREA", symbol: "AREA" },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.areon.network"],
      webSocket: ["wss://mainnet-ws.areon.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Areonscan",
      url: "https://areonscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 353286
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/areonNetworkTestnet.js
var areonNetworkTestnet = defineChain({
  id: 462,
  name: "Areon Network Testnet",
  nativeCurrency: { decimals: 18, name: "TAREA", symbol: "TAREA" },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.areon.network"],
      webSocket: ["wss://testnet-ws.areon.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Areonscan",
      url: "https://areonscan.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/areum.js
var areum = defineChain({
  id: 463,
  name: "Areum",
  nativeCurrency: { decimals: 18, name: "AREA", symbol: "AREA" },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.areum.network"],
      webSocket: ["wss://mainnet-ws.areum.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Areum Explorer",
      url: "https://explorer.areum.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 353286
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/artelaTestnet.js
var artelaTestnet = defineChain({
  id: 11822,
  name: "Artela Testnet",
  nativeCurrency: { name: "ART", symbol: "ART", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://betanet-rpc1.artela.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Artela",
      url: "https://betanet-scan.artela.network",
      apiUrl: "https://betanet-scan.artela.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xd07c8635f76e8745Ee7092fbb6e8fbc5FeF09DD7",
      blockCreated: 7001871
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/arthera.js
var arthera = defineChain({
  id: 10242,
  name: "Arthera",
  nativeCurrency: { name: "Arthera", symbol: "AA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.arthera.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arthera EVM Explorer",
      url: "https://explorer.arthera.net",
      apiUrl: "https://explorer.arthera.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4502791
    }
  }
});

// node_modules/viem/_esm/chains/definitions/artheraTestnet.js
var artheraTestnet = defineChain({
  id: 10243,
  name: "Arthera Testnet",
  nativeCurrency: { name: "Arthera", symbol: "AA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-test.arthera.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arthera EVM Explorer",
      url: "https://explorer-test.arthera.net",
      apiUrl: "https://explorer-test.arthera.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 22051
    }
  }
});

// node_modules/viem/_esm/chains/definitions/assetChain.js
var assetChain = defineChain({
  id: 42420,
  name: "AssetChain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Real World Asset",
    symbol: "RWA"
  },
  rpcUrls: {
    default: { http: ["https://mainnet-rpc.assetchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "Asset Chain Explorer",
      url: "https://scan.assetchain.org",
      apiUrl: "https://scan.assetchain.org/api"
    }
  },
  testnet: false,
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/assetChainTestnet.js
var assetChainTestnet = defineChain({
  id: 42421,
  name: "AssetChain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Real World Asset",
    symbol: "RWA"
  },
  rpcUrls: {
    default: { http: ["https://enugu-rpc.assetchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "Asset Chain Testnet Explorer",
      url: "https://scan-testnet.assetchain.org",
      apiUrl: "https://scan-testnet.assetchain.org/api"
    }
  },
  testnet: true,
  contracts: {
    multicall3: {
      address: "0x989F832D35988cb5e3eB001Fa2Fe789469EC31Ea",
      blockCreated: 17177
    }
  }
});

// node_modules/viem/_esm/chains/definitions/astar.js
var astar = defineChain({
  id: 592,
  name: "Astar",
  network: "astar-mainnet",
  nativeCurrency: {
    name: "Astar",
    symbol: "ASTR",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://astar.api.onfinality.io/public"] }
  },
  blockExplorers: {
    default: {
      name: "Astar Subscan",
      url: "https://astar.subscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 761794
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/astarZkEVM.js
var astarZkEVM = defineChain({
  id: 3776,
  name: "Astar zkEVM",
  network: "AstarZkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-zkevm.astar.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Astar zkEVM Explorer",
      url: "https://astar-zkevm.explorer.startale.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 93528
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/astarZkyoto.js
var astarZkyoto = defineChain({
  id: 6038361,
  name: "Astar zkEVM Testnet zKyoto",
  network: "zKyoto",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.startale.com/zkyoto"]
    }
  },
  blockExplorers: {
    default: {
      name: "zKyoto Explorer",
      url: "https://zkyoto.explorer.startale.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 196153
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/atletaOlympia.js
var atletaOlympia = defineChain({
  id: 2340,
  name: "Atleta Olympia",
  nativeCurrency: { decimals: 18, name: "Atla", symbol: "ATLA" },
  rpcUrls: {
    default: {
      http: [
        "https://testnet-rpc.atleta.network:9944",
        "https://testnet-rpc.atleta.network"
      ],
      ws: ["wss://testnet-rpc.atleta.network:9944"]
    }
  },
  blockExplorers: {
    default: {
      name: "Atleta Olympia Explorer",
      url: "https://blockscout.atleta.network",
      apiUrl: "https://blockscout.atleta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x1472ec6392180fb84F345d2455bCC75B26577115",
      blockCreated: 1076473
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/aurora.js
var aurora = defineChain({
  id: 1313161554,
  name: "Aurora",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.aurora.dev"] }
  },
  blockExplorers: {
    default: {
      name: "Aurorascan",
      url: "https://aurorascan.dev",
      apiUrl: "https://aurorascan.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 62907816
    }
  }
});

// node_modules/viem/_esm/chains/definitions/auroraTestnet.js
var auroraTestnet = defineChain({
  id: 1313161555,
  name: "Aurora Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://testnet.aurora.dev"] }
  },
  blockExplorers: {
    default: {
      name: "Aurorascan",
      url: "https://testnet.aurorascan.dev",
      apiUrl: "https://testnet.aurorascan.dev/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/auroria.js
var auroria = defineChain({
  id: 205205,
  name: "Auroria Testnet",
  network: "auroria",
  nativeCurrency: {
    name: "Auroria Stratis",
    symbol: "tSTRAX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://auroria.rpc.stratisevm.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Auroria Testnet Explorer",
      url: "https://auroria.explorer.stratisevm.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/autheoTestnet.js
var autheoTestnet = defineChain({
  id: 785,
  name: "Autheo Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Autheo",
    symbol: "THEO"
  },
  rpcUrls: {
    default: {
      http: [
        "https://testnet-rpc1.autheo.com",
        "https://testnet-rpc2.autheo.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Autheo Testnet Block Explorer",
      url: "https://testnet-explorer.autheo.com/"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/avalanche.js
var avalanche = defineChain({
  id: 43114,
  name: "Avalanche",
  blockTime: 1700,
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "SnowTrace",
      url: "https://snowtrace.io",
      apiUrl: "https://api.snowtrace.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11907934
    }
  }
});

// node_modules/viem/_esm/chains/definitions/avalancheFuji.js
var avalancheFuji = defineChain({
  id: 43113,
  name: "Avalanche Fuji",
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche Fuji",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax-test.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "SnowTrace",
      url: "https://testnet.snowtrace.io",
      apiUrl: "https://api-testnet.snowtrace.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7096959
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/b3.js
var sourceId4 = 8453;
var b3 = defineChain({
  id: 8333,
  name: "B3",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.b3.fun/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.b3.fun"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  },
  sourceId: sourceId4
});

// node_modules/viem/_esm/chains/definitions/b3Sepolia.js
var sourceId5 = 168587773;
var b3Sepolia = defineChain({
  id: 1993,
  name: "B3 Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.b3.fun/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepolia.explorer.b3.fun"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  },
  testnet: true,
  sourceId: sourceId5
});

// node_modules/viem/_esm/chains/definitions/bahamut.js
var bahamut = defineChain({
  id: 5165,
  network: "bahamut",
  name: "Bahamut",
  nativeCurrency: { name: "Fasttoken", symbol: "FTN", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc1.bahamut.io",
        "https://bahamut-rpc.publicnode.com",
        "https://rpc2.bahamut.io"
      ],
      webSocket: [
        "wss://ws1.sahara.bahamutchain.com",
        "wss://bahamut-rpc.publicnode.com",
        "wss://ws2.sahara.bahamutchain.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Ftnscan",
      url: "https://www.ftnscan.com",
      apiUrl: "https://www.ftnscan.com/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/base.js
var sourceId6 = 1;
var base = defineChain({
  ...chainConfig2,
  id: 8453,
  name: "Base",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://basescan.org",
      apiUrl: "https://api.basescan.org/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId6]: {
        address: "0x43edB88C4B80fDD2AdFF2412A7BebF9dF42cB40e"
      }
    },
    l2OutputOracle: {
      [sourceId6]: {
        address: "0x56315b90c40730925ec5485cf004d835058518A0"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 5022
    },
    portal: {
      [sourceId6]: {
        address: "0x49048044D57e1C92A77f79988d21Fa8fAF74E97e",
        blockCreated: 17482143
      }
    },
    l1StandardBridge: {
      [sourceId6]: {
        address: "0x3154Cf16ccdb4C6d922629664174b904d80F2C35",
        blockCreated: 17482143
      }
    }
  },
  sourceId: sourceId6
});
var basePreconf = defineChain({
  ...base,
  experimental_preconfirmationTime: 200,
  rpcUrls: {
    default: {
      http: ["https://mainnet-preconf.base.org"]
    }
  }
});

// node_modules/viem/_esm/chains/definitions/basecampTestnet.js
var basecampTestnet = defineChain({
  id: 123420001114,
  name: "Basecamp Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Camp",
    symbol: "CAMP"
  },
  rpcUrls: {
    default: { http: ["https://rpc.basecamp.t.raas.gelato.cloud"] }
  },
  blockExplorers: {
    default: {
      name: "basecamp",
      url: "https://basecamp.cloud.blockscout.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/baseGoerli.js
var sourceId7 = 5;
var baseGoerli = defineChain({
  ...chainConfig2,
  id: 84531,
  name: "Base Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://goerli.base.org"] }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://goerli.basescan.org",
      apiUrl: "https://goerli.basescan.org/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId7]: {
        address: "0x2A35891ff30313CcFa6CE88dcf3858bb075A2298"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1376988
    },
    portal: {
      [sourceId7]: {
        address: "0xe93c8cD0D409341205A592f8c4Ac1A5fe5585cfA"
      }
    },
    l1StandardBridge: {
      [sourceId7]: {
        address: "0xfA6D8Ee5BE770F84FC001D098C4bD604Fe01284a"
      }
    }
  },
  testnet: true,
  sourceId: sourceId7
});

// node_modules/viem/_esm/chains/definitions/baseSepolia.js
var sourceId8 = 11155111;
var baseSepolia = defineChain({
  ...chainConfig2,
  id: 84532,
  network: "base-sepolia",
  name: "Base Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://sepolia.basescan.org",
      apiUrl: "https://api-sepolia.basescan.org/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId8]: {
        address: "0xd6E6dBf4F7EA0ac412fD8b65ED297e64BB7a06E1"
      }
    },
    l2OutputOracle: {
      [sourceId8]: {
        address: "0x84457ca9D0163FbC4bbfe4Dfbb20ba46e48DF254"
      }
    },
    portal: {
      [sourceId8]: {
        address: "0x49f53e41452c74589e85ca1677426ba426459e85",
        blockCreated: 4446677
      }
    },
    l1StandardBridge: {
      [sourceId8]: {
        address: "0xfd0Bf71F60660E2f608ed56e1659C450eB113120",
        blockCreated: 4446677
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1059647
    }
  },
  testnet: true,
  sourceId: sourceId8
});
var baseSepoliaPreconf = defineChain({
  ...baseSepolia,
  experimental_preconfirmationTime: 200,
  rpcUrls: {
    default: {
      http: ["https://sepolia-preconf.base.org"]
    }
  }
});

// node_modules/viem/_esm/chains/definitions/beam.js
var beam = defineChain({
  id: 4337,
  name: "Beam",
  network: "beam",
  nativeCurrency: {
    decimals: 18,
    name: "Beam",
    symbol: "BEAM"
  },
  rpcUrls: {
    default: {
      http: ["https://build.onbeam.com/rpc"],
      webSocket: ["wss://build.onbeam.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Beam Explorer",
      url: "https://subnets.avax.network/beam"
    }
  },
  contracts: {
    multicall3: {
      address: "0x4956f15efdc3dc16645e90cc356eafa65ffc65ec",
      blockCreated: 1
    }
  }
});

// node_modules/viem/_esm/chains/definitions/beamTestnet.js
var beamTestnet = defineChain({
  id: 13337,
  name: "Beam Testnet",
  network: "beam",
  nativeCurrency: {
    decimals: 18,
    name: "Beam",
    symbol: "BEAM"
  },
  rpcUrls: {
    default: {
      http: ["https://build.onbeam.com/rpc/testnet"],
      webSocket: ["wss://build.onbeam.com/ws/testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "Beam Explorer",
      url: "https://subnets-test.avax.network/beam"
    }
  },
  contracts: {
    multicall3: {
      address: "0x9bf49b704ee2a095b95c1f2d4eb9010510c41c9e",
      blockCreated: 3
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bearNetworkChainMainnet.js
var bearNetworkChainMainnet = defineChain({
  id: 641230,
  name: "Bear Network Chain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "BearNetworkChain",
    symbol: "BRNKC"
  },
  rpcUrls: {
    default: { http: ["https://brnkc-mainnet.bearnetwork.net"] }
  },
  blockExplorers: {
    default: {
      name: "BrnkScan",
      url: "https://brnkscan.bearnetwork.net",
      apiUrl: "https://brnkscan.bearnetwork.net/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bearNetworkChainTestnet.js
var bearNetworkChainTestnet = defineChain({
  id: 751230,
  name: "Bear Network Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "tBRNKC",
    symbol: "tBRNKC"
  },
  rpcUrls: {
    default: { http: ["https://brnkc-test.bearnetwork.net"] }
  },
  blockExplorers: {
    default: {
      name: "BrnkTestScan",
      url: "https://brnktest-scan.bearnetwork.net",
      apiUrl: "https://brnktest-scan.bearnetwork.net/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/berachain.js
var berachain = defineChain({
  id: 80094,
  name: "Berachain",
  blockTime: 2e3,
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    ensRegistry: {
      address: "0x5b22280886a2f5e09a49bea7e320eab0e5320e28",
      blockCreated: 877007
    },
    ensUniversalResolver: {
      address: "0x4D41762915F83c76EcaF6776d9b08076aA32b492",
      blockCreated: 9310021
    }
  },
  rpcUrls: {
    default: { http: ["https://rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berascan",
      url: "https://berascan.com"
    }
  },
  ensTlds: [".bera"],
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/berachainBepolia.js
var berachainBepolia = defineChain({
  id: 80069,
  blockTime: 2e3,
  name: "Berachain Bepolia",
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  },
  rpcUrls: {
    default: { http: ["https://bepolia.rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berascan",
      url: "https://bepolia.beratrail.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/berachainTestnet.js
var berachainTestnet = defineChain({
  id: 80085,
  name: "Berachain Artio",
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  rpcUrls: {
    default: { http: ["https://artio.rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berachain",
      url: "https://artio.beratrail.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 866924
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/berachainTestnetbArtio.js
var berachainTestnetbArtio = defineChain({
  id: 80084,
  name: "Berachain bArtio",
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 109269
    },
    ensRegistry: {
      address: "0xB0eef18971290b333450586D33dcA6cE122651D2",
      blockCreated: 7736794
    },
    ensUniversalResolver: {
      address: "0x41692Ef1EA0C79E6b73077E4A67572D2BDbD7057",
      blockCreated: 7736795
    }
  },
  ensTlds: [".bera"],
  rpcUrls: {
    default: { http: ["https://bartio.rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berachain bArtio Beratrail",
      url: "https://bartio.beratrail.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bevmMainnet.js
var bevmMainnet = defineChain({
  id: 11501,
  name: "BEVM Mainnet",
  nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-mainnet-1.bevm.io"] }
  },
  blockExplorers: {
    default: {
      name: "Bevmscan",
      url: "https://scan-mainnet.bevm.io",
      apiUrl: "https://scan-mainnet-api.bevm.io/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bifrost.js
var bifrost = defineChain({
  id: 3068,
  name: "Bifrost Mainnet",
  nativeCurrency: { name: "BFC", symbol: "BFC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://public-01.mainnet.bifrostnetwork.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bifrost Blockscout",
      url: "https://explorer.mainnet.bifrostnetwork.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/birdlayer.js
var birdlayer = defineChain({
  id: 53456,
  name: "BirdLayer",
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rpc.birdlayer.xyz", "https://rpc1.birdlayer.xyz"],
      webSocket: ["wss://rpc.birdlayer.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "BirdLayer Explorer",
      url: "https://scan.birdlayer.xyz"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bitgert.js
var bitgert = defineChain({
  id: 32520,
  name: "Bitgert Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Brise",
    symbol: "Brise"
  },
  rpcUrls: {
    default: { http: ["https://rpc-bitgert.icecreamswap.com"] }
  },
  blockExplorers: {
    default: {
      name: "Bitgert Scan",
      url: "https://brisescan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2118034
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/bitkub.js
var bitkub = defineChain({
  id: 96,
  name: "KUB Mainnet",
  nativeCurrency: { name: "KUB Coin", symbol: "KUB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.bitkubchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "KUB Chain Mainnet Explorer",
      url: "https://www.bkcscan.com",
      apiUrl: "https://www.bkcscan.com/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bitkubTestnet.js
var bitkubTestnet = defineChain({
  id: 25925,
  name: "Bitkub Testnet",
  network: "Bitkub Testnet",
  nativeCurrency: { name: "Bitkub Test", symbol: "tKUB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.bitkubchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitkub Chain Testnet Explorer",
      url: "https://testnet.bkcscan.com",
      apiUrl: "https://testnet.bkcscan.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bitlayer.js
var bitlayer = defineChain({
  id: 200901,
  name: "Bitlayer Mainnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.bitlayer.org"],
      webSocket: ["wss://ws.bitlayer.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "bitlayer mainnet scan",
      url: "https://www.btrscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x5B256fE9e993902eCe49D138a5b1162cBb529474",
      blockCreated: 2421963
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bitlayerTestnet.js
var bitlayerTestnet = defineChain({
  id: 200810,
  name: "Bitlayer Testnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.bitlayer.org"],
      webSocket: ["wss://testnet-ws.bitlayer.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "bitlayer testnet scan",
      url: "https://testnet.btrscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x5B256fE9e993902eCe49D138a5b1162cBb529474",
      blockCreated: 4135671
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bitrock.js
var bitrock = defineChain({
  id: 7171,
  name: "Bitrock Mainnet",
  nativeCurrency: { name: "BROCK", symbol: "BROCK", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://brockrpc.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitrock Explorer",
      url: "https://explorer.bit-rock.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/bitTorrent.js
var bitTorrent = defineChain({
  id: 199,
  name: "BitTorrent",
  network: "bittorrent-chain-mainnet",
  nativeCurrency: { name: "BitTorrent", symbol: "BTT", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.bittorrentchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Bttcscan",
      url: "https://bttcscan.com",
      apiUrl: "https://api.bttcscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 31078552
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bitTorrentTestnet.js
var bitTorrentTestnet = defineChain({
  id: 1028,
  name: "BitTorrent Chain Testnet",
  network: "bittorrent-chain-testnet",
  nativeCurrency: { name: "BitTorrent", symbol: "BTT", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://testrpc.bittorrentchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Bttcscan",
      url: "https://testnet.bttcscan.com",
      apiUrl: "https://testnet.bttcscan.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/blast.js
var sourceId9 = 1;
var blast = defineChain({
  ...chainConfig2,
  id: 81457,
  name: "Blast",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.blast.io"] }
  },
  blockExplorers: {
    default: {
      name: "Blastscan",
      url: "https://blastscan.io",
      apiUrl: "https://api.blastscan.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 212929
    },
    l2OutputOracle: {
      [sourceId9]: {
        address: "0x826D1B0D4111Ad9146Eb8941D7Ca2B6a44215c76",
        blockCreated: 19300358
      }
    },
    portal: {
      [sourceId9]: {
        address: "0x0Ec68c5B10F21EFFb74f2A5C61DFe6b08C0Db6Cb",
        blockCreated: 19300357
      }
    },
    l1StandardBridge: {
      [sourceId9]: {
        address: "0x697402166Fbf2F22E970df8a6486Ef171dbfc524",
        blockCreated: 19300360
      }
    }
  },
  sourceId: sourceId9
});

// node_modules/viem/_esm/chains/definitions/blastSepolia.js
var sourceId10 = 11155111;
var blastSepolia = defineChain({
  id: 168587773,
  name: "Blast Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.blast.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blastscan",
      url: "https://sepolia.blastscan.io",
      apiUrl: "https://api-sepolia.blastscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 756690
    }
  },
  testnet: true,
  sourceId: sourceId10
});

// node_modules/viem/_esm/chains/definitions/bob.js
var sourceId11 = 1;
var bob = defineChain({
  ...chainConfig2,
  id: 60808,
  name: "BOB",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.gobob.xyz"],
      webSocket: ["wss://rpc.gobob.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "BOB Explorer",
      url: "https://explorer.gobob.xyz"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 23131
    },
    l2OutputOracle: {
      [sourceId11]: {
        address: "0xdDa53E23f8a32640b04D7256e651C1db98dB11C1",
        blockCreated: 4462615
      }
    },
    portal: {
      [sourceId11]: {
        address: "0x8AdeE124447435fE03e3CD24dF3f4cAE32E65a3E",
        blockCreated: 4462615
      }
    }
  },
  sourceId: sourceId11
});

// node_modules/viem/_esm/chains/definitions/boba.js
var boba = defineChain({
  id: 288,
  name: "Boba Network",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.boba.network"] }
  },
  blockExplorers: {
    default: {
      name: "BOBAScan",
      url: "https://bobascan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 446859
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bobaSepolia.js
var bobaSepolia = defineChain({
  id: 28882,
  name: "Boba Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://sepolia.boba.network"] }
  },
  blockExplorers: {
    default: {
      name: "BOBAScan",
      url: "https://testnet.bobascan.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bobSepolia.js
var sourceId12 = 11155111;
var bobSepolia = defineChain({
  ...chainConfig2,
  id: 808813,
  name: "BOB Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://bob-sepolia.rpc.gobob.xyz"],
      webSocket: ["wss://bob-sepolia.rpc.gobob.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "BOB Sepolia Explorer",
      url: "https://bob-sepolia.explorer.gobob.xyz"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 35677
    },
    l2OutputOracle: {
      [sourceId12]: {
        address: "0x14D0069452b4AE2b250B395b8adAb771E4267d2f",
        blockCreated: 4462615
      }
    },
    portal: {
      [sourceId12]: {
        address: "0x867B1Aa872b9C8cB5E9F7755feDC45BB24Ad0ae4",
        blockCreated: 4462615
      }
    }
  },
  testnet: true,
  sourceId: sourceId12
});

// node_modules/viem/_esm/chains/definitions/boolBetaMainnet.js
var boolBetaMainnet = defineChain({
  id: 11100,
  name: "Bool Beta Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "BOL",
    symbol: "BOL"
  },
  rpcUrls: {
    default: { http: ["https://beta-rpc-node-http.bool.network"] }
  },
  blockExplorers: {
    default: {
      name: "BoolScan",
      url: "https://beta-mainnet.boolscan.com/"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/botanix.js
var botanix = defineChain({
  id: 3637,
  name: "Botanix",
  nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.botanixlabs.com"],
      webSocket: ["wss://rpc.botanixlabs.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Botanixscan",
      url: "https://botanixscan.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/botanixTestnet.js
var botanixTestnet = defineChain({
  id: 3636,
  name: "Botanix Testnet",
  nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://node.botanixlabs.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Botanix Testnet Explorer",
      url: "https://testnet.botanixscan.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bounceBit.js
var bounceBit = defineChain({
  id: 6001,
  name: "BounceBit Mainnet",
  nativeCurrency: { name: "BounceBit", symbol: "BB", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://fullnode-mainnet.bouncebitapi.com"] }
  },
  blockExplorers: {
    default: {
      name: "BB Scan",
      url: "https://bbscan.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/bounceBitTestnet.js
var bounceBitTestnet = defineChain({
  id: 6e3,
  name: "BounceBit Testnet",
  nativeCurrency: { name: "BounceBit", symbol: "BB", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://fullnode-testnet.bouncebitapi.com"] }
  },
  blockExplorers: {
    default: {
      name: "BB Scan",
      url: "https://testnet.bbscan.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bronos.js
var bronos = defineChain({
  id: 1039,
  name: "Bronos",
  nativeCurrency: {
    decimals: 18,
    name: "BRO",
    symbol: "BRO"
  },
  rpcUrls: {
    default: { http: ["https://evm.bronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "BronoScan",
      url: "https://broscan.bronos.org"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bronosTestnet.js
var bronosTestnet = defineChain({
  id: 1038,
  name: "Bronos Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Bronos Coin",
    symbol: "tBRO"
  },
  rpcUrls: {
    default: { http: ["https://evm-testnet.bronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "BronoScan",
      url: "https://tbroscan.bronos.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bsc.js
var bsc = defineChain({
  id: 56,
  name: "BNB Smart Chain",
  blockTime: 750,
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "BNB"
  },
  rpcUrls: {
    default: { http: ["https://56.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "BscScan",
      url: "https://bscscan.com",
      apiUrl: "https://api.bscscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15921452
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bscGreenfield.js
var bscGreenfield = defineChain({
  id: 1017,
  name: "BNB Greenfield Chain",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "BNB"
  },
  rpcUrls: {
    default: { http: ["https://greenfield-chain.bnbchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "BNB Greenfield Mainnet Scan",
      url: "https://greenfieldscan.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/bscTestnet.js
var bscTestnet = defineChain({
  id: 97,
  name: "BNB Smart Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "tBNB"
  },
  rpcUrls: {
    default: { http: ["https://data-seed-prebsc-1-s1.bnbchain.org:8545"] }
  },
  blockExplorers: {
    default: {
      name: "BscScan",
      url: "https://testnet.bscscan.com",
      apiUrl: "https://api-testnet.bscscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 17422483
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bsquared.js
var bsquared = defineChain({
  id: 223,
  name: "B2",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.bsquared.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.bsquared.network"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bsquaredTestnet.js
var bsquaredTestnet = defineChain({
  id: 1123,
  name: "B2 Testnet",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.bsquared.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://testnet-explorer.bsquared.network"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/btr.js
var btr = defineChain({
  id: 200901,
  name: "Bitlayer",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.bitlayer.org", "https://rpc.bitlayer-rpc.com"],
      webSocket: ["wss://ws.bitlayer.org", "wss://ws.bitlayer-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitlayer(BTR) Scan",
      url: "https://www.btrscan.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/btrTestnet.js
var btrTestnet = defineChain({
  id: 200810,
  name: "Bitlayer Testnet",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.bitlayer.org"],
      webSocket: [
        "wss://testnet-ws.bitlayer.org",
        "wss://testnet-ws.bitlayer-rpc.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitlayer(BTR) Scan",
      url: "https://testnet.btrscan.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bxn.js
var bxn = defineChain({
  id: 4999,
  name: "BlackFort Exchange Network",
  nativeCurrency: { name: "BlackFort Token", symbol: "BXN", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.blackfort.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.blackfort.network",
      apiUrl: "https://explorer.blackfort.network/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bxnTestnet.js
var bxnTestnet = defineChain({
  id: 4777,
  name: "BlackFort Exchange Network Testnet",
  nativeCurrency: {
    name: "BlackFort Testnet Token",
    symbol: "TBXN",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.blackfort.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer.blackfort.network",
      apiUrl: "https://testnet-explorer.blackfort.network/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/cannon.js
var cannon = defineChain({
  id: 13370,
  name: "Cannon",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["http://127.0.0.1:8545"] }
  }
});

// node_modules/viem/_esm/chains/definitions/canto.js
var canto = defineChain({
  id: 7700,
  name: "Canto",
  nativeCurrency: {
    decimals: 18,
    name: "Canto",
    symbol: "CANTO"
  },
  rpcUrls: {
    default: { http: ["https://canto.gravitychain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Tuber.Build (Blockscout)",
      url: "https://tuber.build"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2905789
    }
  }
});

// node_modules/viem/_esm/celo/fees.js
var fees = {
  /*
     * Estimates the fees per gas for a transaction.
  
     * If the transaction is to be paid in a token (feeCurrency is present) then the fees
     * are estimated in the value of the token. Otherwise falls back to the default
     * estimation by returning null.
     *
     * @param params fee estimation function parameters
     */
  estimateFeesPerGas: async (params) => {
    if (!params.request?.feeCurrency)
      return null;
    const [gasPrice, maxPriorityFeePerGas] = await Promise.all([
      estimateFeePerGasInFeeCurrency(params.client, params.request.feeCurrency),
      estimateMaxPriorityFeePerGasInFeeCurrency(params.client, params.request.feeCurrency)
    ]);
    const maxFeePerGas = params.multiply(gasPrice - maxPriorityFeePerGas) + maxPriorityFeePerGas;
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  }
};
async function estimateFeePerGasInFeeCurrency(client, feeCurrency) {
  const fee = await client.request({
    method: "eth_gasPrice",
    params: [feeCurrency]
  });
  return BigInt(fee);
}
async function estimateMaxPriorityFeePerGasInFeeCurrency(client, feeCurrency) {
  const feesPerGas = await client.request({
    method: "eth_maxPriorityFeePerGas",
    params: [feeCurrency]
  });
  return BigInt(feesPerGas);
}

// node_modules/viem/_esm/celo/utils.js
function isEmpty(value) {
  return value === 0 || value === 0n || value === void 0 || value === null || value === "0" || value === "" || typeof value === "string" && (trim(value).toLowerCase() === "0x" || trim(value).toLowerCase() === "0x00");
}
function isPresent(value) {
  return !isEmpty(value);
}
function isEIP1559(transaction) {
  return typeof transaction.maxFeePerGas !== "undefined" && typeof transaction.maxPriorityFeePerGas !== "undefined";
}
function isCIP64(transaction) {
  if (transaction.type === "cip64") {
    return true;
  }
  return isEIP1559(transaction) && isPresent(transaction.feeCurrency);
}

// node_modules/viem/_esm/celo/formatters.js
var formatters3 = {
  block: defineBlock({
    format(args) {
      const transactions = args.transactions?.map((transaction) => {
        if (typeof transaction === "string")
          return transaction;
        const formatted = formatTransaction(transaction);
        return {
          ...formatted,
          ...transaction.gatewayFee ? {
            gatewayFee: hexToBigInt(transaction.gatewayFee),
            gatewayFeeRecipient: transaction.gatewayFeeRecipient
          } : {},
          feeCurrency: transaction.feeCurrency
        };
      });
      return {
        transactions
      };
    }
  }),
  transaction: defineTransaction({
    format(args) {
      if (args.type === "0x7e")
        return {
          isSystemTx: args.isSystemTx,
          mint: args.mint ? hexToBigInt(args.mint) : void 0,
          sourceHash: args.sourceHash,
          type: "deposit"
        };
      const transaction = { feeCurrency: args.feeCurrency };
      if (args.type === "0x7b")
        transaction.type = "cip64";
      else {
        if (args.type === "0x7c")
          transaction.type = "cip42";
        transaction.gatewayFee = args.gatewayFee ? hexToBigInt(args.gatewayFee) : null;
        transaction.gatewayFeeRecipient = args.gatewayFeeRecipient;
      }
      return transaction;
    }
  }),
  transactionRequest: defineTransactionRequest({
    format(args) {
      const request = {};
      if (args.feeCurrency)
        request.feeCurrency = args.feeCurrency;
      if (isCIP64(args))
        request.type = "0x7b";
      return request;
    }
  })
};

// node_modules/viem/_esm/celo/serializers.js
function serializeTransaction4(transaction, signature) {
  if (isCIP64(transaction))
    return serializeTransactionCIP64(transaction, signature);
  return serializeTransaction3(transaction, signature);
}
var serializers3 = {
  transaction: serializeTransaction4
};
function serializeTransactionCIP64(transaction, signature) {
  assertTransactionCIP64(transaction);
  const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, feeCurrency, data } = transaction;
  const serializedTransaction = [
    toHex(chainId),
    nonce ? toHex(nonce) : "0x",
    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? toHex(maxFeePerGas) : "0x",
    gas ? toHex(gas) : "0x",
    to ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x",
    serializeAccessList(accessList),
    feeCurrency,
    ...toYParitySignatureArray(transaction, signature)
  ];
  return concatHex([
    "0x7b",
    toRlp(serializedTransaction)
  ]);
}
var MAX_MAX_FEE_PER_GAS = maxUint256;
function assertTransactionCIP64(transaction) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to, feeCurrency } = transaction;
  if (chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (gasPrice)
    throw new BaseError("`gasPrice` is not a valid CIP-64 Transaction attribute.");
  if (isPresent(maxFeePerGas) && maxFeePerGas > MAX_MAX_FEE_PER_GAS)
    throw new FeeCapTooHighError({ maxFeePerGas });
  if (isPresent(maxPriorityFeePerGas) && isPresent(maxFeePerGas) && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
  if (isPresent(feeCurrency) && !isAddress(feeCurrency)) {
    throw new BaseError("`feeCurrency` MUST be a token address for CIP-64 transactions.");
  }
  if (isEmpty(feeCurrency)) {
    throw new BaseError("`feeCurrency` must be provided for CIP-64 transactions.");
  }
}

// node_modules/viem/_esm/celo/chainConfig.js
var chainConfig3 = {
  blockTime: 1e3,
  contracts,
  formatters: formatters3,
  serializers: serializers3,
  fees
};

// node_modules/viem/_esm/chains/definitions/celo.js
var celo = defineChain({
  ...chainConfig3,
  id: 42220,
  name: "Celo",
  nativeCurrency: {
    decimals: 18,
    name: "CELO",
    symbol: "CELO"
  },
  rpcUrls: {
    default: { http: ["https://forno.celo.org"] }
  },
  blockExplorers: {
    default: {
      name: "Celo Explorer",
      url: "https://celoscan.io",
      apiUrl: "https://api.celoscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 13112599
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/celoAlfajores.js
var sourceId13 = 17e3;
var celoAlfajores = defineChain({
  ...chainConfig3,
  id: 44787,
  name: "Alfajores",
  nativeCurrency: {
    decimals: 18,
    name: "CELO",
    symbol: "A-CELO"
  },
  rpcUrls: {
    default: {
      http: ["https://alfajores-forno.celo-testnet.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Celo Alfajores Explorer",
      url: "https://celo-alfajores.blockscout.com",
      apiUrl: "https://celo-alfajores.blockscout.com/api"
    }
  },
  contracts: {
    ...chainConfig3.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 14569001
    },
    portal: {
      [sourceId13]: {
        address: "0x82527353927d8D069b3B452904c942dA149BA381",
        blockCreated: 2411324
      }
    },
    disputeGameFactory: {
      [sourceId13]: {
        address: "0xE28AAdcd9883746c0e5068F58f9ea06027b214cb",
        blockCreated: 2411324
      }
    },
    l2OutputOracle: {
      [sourceId13]: {
        address: "0x4a2635e9e4f6e45817b1D402ac4904c1d1752438",
        blockCreated: 2411324
      }
    },
    l1StandardBridge: {
      [sourceId13]: {
        address: "0xD1B0E0581973c9eB7f886967A606b9441A897037",
        blockCreated: 2411324
      }
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/celoSepolia.js
var sourceId14 = 11155111;
var celoSepolia = defineChain({
  ...chainConfig3,
  id: 11142220,
  name: "Celo Sepolia Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "CELO",
    symbol: "S-CELO"
  },
  rpcUrls: {
    default: {
      http: ["https://forno.celo-sepolia.celo-testnet.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Celo Sepolia Explorer",
      url: "https://celo-sepolia.blockscout.com/",
      apiUrl: "https://celo-sepolia.blockscout.com/api"
    }
  },
  contracts: {
    ...chainConfig3.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    },
    portal: {
      [sourceId14]: {
        address: "0x44ae3d41a335a7d05eb533029917aad35662dcc2",
        blockCreated: 8825790
      }
    },
    disputeGameFactory: {
      [sourceId14]: {
        address: "0x57c45d82d1a995f1e135b8d7edc0a6bb5211cfaa",
        blockCreated: 8825790
      }
    },
    l1StandardBridge: {
      [sourceId14]: {
        address: "0xec18a3c30131a0db4246e785355fbc16e2eaf408",
        blockCreated: 8825790
      }
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/chang.js
var chang = defineChain({
  id: 5858,
  name: "Chang Chain Foundation Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "CTH",
    symbol: "CTH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.cthscan.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chang Chain explorer",
      url: "https://cthscan.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/chiliz.js
var chiliz = defineChain({
  id: 88888,
  name: "Chiliz Chain",
  network: "chiliz-chain",
  nativeCurrency: {
    decimals: 18,
    name: "CHZ",
    symbol: "CHZ"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.chiliz.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chiliz Explorer",
      url: "https://scan.chiliz.com",
      apiUrl: "https://scan.chiliz.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 8080847
    }
  }
});

// node_modules/viem/_esm/chains/definitions/chips.js
var chips = defineChain({
  id: 2882,
  name: "Chips Network",
  network: "CHIPS",
  nativeCurrency: {
    decimals: 18,
    name: "IOTA",
    symbol: "IOTA"
  },
  rpcUrls: {
    default: {
      http: [
        "https://node.chips.ooo/wasp/api/v1/chains/iota1pp3d3mnap3ufmgqnjsnw344sqmf5svjh26y2khnmc89sv6788y3r207a8fn/evm"
      ]
    }
  }
});

// node_modules/viem/_esm/chains/definitions/citreaTestnet.js
var citreaTestnet = defineChain({
  id: 5115,
  name: "Citrea Testnet",
  nativeCurrency: { name: "cBTC", symbol: "cBTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.citrea.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Citrea Explorer",
      url: "https://explorer.testnet.citrea.xyz",
      apiUrl: "https://explorer.testnet.citrea.xyz/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/classic.js
var classic = defineChain({
  id: 61,
  name: "Ethereum Classic",
  nativeCurrency: {
    decimals: 18,
    name: "ETC",
    symbol: "ETC"
  },
  rpcUrls: {
    default: { http: ["https://etc.rivet.link"] }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.com/etc/mainnet"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/coinbit.js
var coinbit = defineChain({
  id: 112,
  name: "Coinbit Mainnet",
  nativeCurrency: { name: "GIDR", symbol: "GIDR", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://coinbit-rpc-mainnet.chain.sbcrypto.app"]
    }
  },
  blockExplorers: {
    default: {
      name: "Coinbit Explorer",
      url: "https://coinbit-explorer.chain.sbcrypto.app"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/coinex.js
var coinex = defineChain({
  id: 52,
  name: "CoinEx Mainnet",
  nativeCurrency: { name: "cet", symbol: "cet", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.coinex.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "CoinEx Explorer",
      url: "https://www.coinex.net"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/confluxESpace.js
var confluxESpace = defineChain({
  id: 1030,
  name: "Conflux eSpace",
  nativeCurrency: { name: "Conflux", symbol: "CFX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm.confluxrpc.com"],
      webSocket: ["wss://evm.confluxrpc.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "ConfluxScan",
      url: "https://evm.confluxscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xEFf0078910f638cd81996cc117bccD3eDf2B072F",
      blockCreated: 68602935
    }
  }
});

// node_modules/viem/_esm/chains/definitions/confluxESpaceTestnet.js
var confluxESpaceTestnet = defineChain({
  id: 71,
  name: "Conflux eSpace Testnet",
  network: "cfx-espace-testnet",
  testnet: true,
  nativeCurrency: { name: "Conflux", symbol: "CFX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evmtestnet.confluxrpc.com"],
      webSocket: ["wss://evmtestnet.confluxrpc.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "ConfluxScan",
      url: "https://evmtestnet.confluxscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xEFf0078910f638cd81996cc117bccD3eDf2B072F",
      blockCreated: 117499050
    }
  }
});

// node_modules/viem/_esm/chains/definitions/coreDao.js
var coreDao = defineChain({
  id: 1116,
  name: "Core Dao",
  nativeCurrency: {
    decimals: 18,
    name: "Core",
    symbol: "CORE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.coredao.org"] }
  },
  blockExplorers: {
    default: {
      name: "CoreDao",
      url: "https://scan.coredao.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 11907934
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/coreTestnet1.js
var coreTestnet1 = defineChain({
  id: 1115,
  name: "Core Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "tCore",
    symbol: "TCORE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.test.btcs.network"] }
  },
  blockExplorers: {
    default: {
      name: "Core Testnet",
      url: "https://scan.test.btcs.network",
      apiUrl: "https://api.test.btcs.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xCcddF20A1932537123C2E48Bd8e00b108B8f7569",
      blockCreated: 29350509
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/coreTestnet2.js
var coreTestnet2 = defineChain({
  id: 1114,
  name: "Core Testnet2",
  nativeCurrency: {
    decimals: 18,
    name: "tCore2",
    symbol: "TCORE2"
  },
  rpcUrls: {
    default: { http: ["https://rpc.test2.btcs.network"] }
  },
  blockExplorers: {
    default: {
      name: "Core Testnet2",
      url: "https://scan.test2.btcs.network",
      apiUrl: "https://api.test2.btcs.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x3CB285ff3Cd5C7C7e570b1E7DE3De17A0f985e56",
      blockCreated: 3838600
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/corn.js
var sourceId15 = 1;
var corn = defineChain({
  id: 21e6,
  name: "Corn",
  nativeCurrency: {
    decimals: 18,
    name: "Bitcorn",
    symbol: "BTCN"
  },
  rpcUrls: {
    default: { http: ["https://21000000.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "Corn Explorer",
      url: "https://cornscan.io",
      apiUrl: "https://api.routescan.io/v2/network/mainnet/evm/21000000/etherscan/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3228
    }
  },
  sourceId: sourceId15
});

// node_modules/viem/_esm/chains/definitions/cornTestnet.js
var sourceId16 = 11155111;
var cornTestnet = defineChain({
  id: 21000001,
  name: "Corn Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Bitcorn",
    symbol: "BTCN"
  },
  rpcUrls: {
    default: { http: ["https://21000001.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "Corn Testnet Explorer",
      url: "https://testnet.cornscan.io",
      apiUrl: "https://api.routescan.io/v2/network/testnet/evm/21000001/etherscan/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4886
    }
  },
  testnet: true,
  sourceId: sourceId16
});

// node_modules/viem/_esm/chains/definitions/crab.js
var crab = defineChain({
  id: 44,
  name: "Crab Network",
  nativeCurrency: {
    decimals: 18,
    name: "Crab Network Native Token",
    symbol: "CRAB"
  },
  rpcUrls: {
    default: {
      http: ["https://crab-rpc.darwinia.network"],
      webSocket: ["wss://crab-rpc.darwinia.network"]
    }
  },
  blockExplorers: {
    default: { name: "Blockscout", url: "https://crab-scan.darwinia.network" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3032593
    }
  }
});

// node_modules/viem/_esm/chains/definitions/creatorTestnet.js
var creatorTestnet = defineChain({
  id: 66665,
  name: "Creator",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.creatorchain.io"]
    }
  },
  blockExplorers: {
    default: { name: "Explorer", url: "https://explorer.creatorchain.io" }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/creditCoin3Devnet.js
var creditCoin3Devnet = defineChain({
  id: 102032,
  name: "Creditcoin Devnet",
  nativeCurrency: { name: "Devnet CTC", symbol: "devCTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.cc3-devnet.creditcoin.network"],
      webSocket: ["wss://rpc.cc3-devnet.creditcoin.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://creditcoin-devnet.blockscout.com",
      apiUrl: "https://creditcoin3-dev.subscan.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/creditCoin3Mainnet.js
var creditCoin3Mainnet = defineChain({
  id: 102030,
  name: "Creditcoin",
  nativeCurrency: { name: "Creditcoin", symbol: "CTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet3.creditcoin.network"],
      webSocket: ["wss://mainnet3.creditcoin.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://creditcoin.blockscout.com",
      apiUrl: "https://creditcoin.blockscout.com/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/creditCoin3Testnet.js
var creditCoin3Testnet = defineChain({
  id: 102031,
  name: "Creditcoin Testnet",
  nativeCurrency: { name: "Creditcoin Testnet", symbol: "tCTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.cc3-testnet.creditcoin.network"],
      webSocket: ["wss://rpc.cc3-testnet.creditcoin.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://creditcoin-testnet.blockscout.com",
      apiUrl: "https://creditcoin-testnet.blockscout.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/cronos.js
var cronos = defineChain({
  id: 25,
  name: "Cronos Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Cronos",
    symbol: "CRO"
  },
  rpcUrls: {
    default: { http: ["https://evm.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos Explorer",
      url: "https://explorer.cronos.org",
      apiUrl: "https://explorer-api.cronos.org/mainnet/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1963112
    }
  }
});

// node_modules/viem/_esm/chains/definitions/cronosTestnet.js
var cronosTestnet = defineChain({
  id: 338,
  name: "Cronos Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "CRO",
    symbol: "tCRO"
  },
  rpcUrls: {
    default: { http: ["https://evm-t3.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos Explorer (Testnet)",
      url: "https://explorer.cronos.org/testnet"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 10191251
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/cronoszkEVM.js
var cronoszkEVM = defineChain({
  id: 388,
  name: "Cronos zkEVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Cronos zkEVM CRO",
    symbol: "zkCRO"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.zkevm.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos zkEVM (Mainnet) Chain Explorer",
      url: "https://explorer.zkevm.cronos.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0x06f4487d7c4a5983d2660db965cc6d2565e4cfaa",
      blockCreated: 72
    }
  }
});

// node_modules/viem/_esm/chains/definitions/cronoszkEVMTestnet.js
var cronoszkEVMTestnet = defineChain({
  id: 282,
  name: "Cronos zkEVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Cronos zkEVM Test Coin",
    symbol: "zkTCRO"
  },
  rpcUrls: {
    default: { http: ["https://testnet.zkevm.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos zkEVM Testnet Explorer",
      url: "https://explorer.zkevm.cronos.org/testnet"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/crossbell.js
var crossbell = defineChain({
  id: 3737,
  name: "Crossbell",
  nativeCurrency: {
    decimals: 18,
    name: "CSB",
    symbol: "CSB"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.crossbell.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "CrossScan",
      url: "https://scan.crossbell.io",
      apiUrl: "https://scan.crossbell.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 38246031
    }
  }
});

// node_modules/viem/_esm/chains/definitions/crossfi.js
var crossfi = defineChain({
  id: 4158,
  name: "CrossFi Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "CrossFi",
    symbol: "XFI"
  },
  rpcUrls: {
    default: { http: ["https://rpc.mainnet.ms"] }
  },
  blockExplorers: {
    default: {
      name: "CrossFi Blockchain Explorer",
      url: "https://xfiscan.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/curtis.js
var curtis = defineChain({
  id: 33111,
  name: "Curtis",
  nativeCurrency: { name: "ApeCoin", symbol: "APE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.curtis.apechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Curtis Explorer",
      url: "https://explorer.curtis.apechain.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/cyber.js
var cyber = defineChain({
  id: 7560,
  name: "Cyber",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://cyber.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://cyberscan.co",
      apiUrl: "https://cyberscan.co/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  }
});

// node_modules/viem/_esm/chains/definitions/cyberTestnet.js
var cyberTestnet = defineChain({
  id: 111557560,
  name: "Cyber Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://cyber-testnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet.cyberscan.co",
      apiUrl: "https://testnet.cyberscan.co/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xffc391F0018269d4758AEA1a144772E8FB99545E",
      blockCreated: 304545
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/dailyNetwork.js
var dailyNetwork = defineChain({
  id: 824,
  name: "Daily Network Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Daily",
    symbol: "DLY"
  },
  rpcUrls: {
    default: { http: ["https://rpc.mainnet.dailycrypto.net"] }
  },
  blockExplorers: {
    default: {
      name: "Daily Mainnet Explorer",
      url: "https://explorer.mainnet.dailycrypto.net"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/dailyNetworkTestnet.js
var dailyNetworkTestnet = defineChain({
  id: 825,
  name: "Daily Network Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Daily",
    symbol: "DLY"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.dailycrypto.net"] }
  },
  blockExplorers: {
    default: {
      name: "Daily Testnet Explorer",
      url: "https://explorer.testnet.dailycrypto.net"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/darwinia.js
var darwinia = defineChain({
  id: 46,
  name: "Darwinia Network",
  nativeCurrency: {
    decimals: 18,
    name: "RING",
    symbol: "RING"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.darwinia.network"],
      webSocket: ["wss://rpc.darwinia.network"]
    }
  },
  blockExplorers: {
    default: { name: "Explorer", url: "https://explorer.darwinia.network" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 69420
    }
  }
});

// node_modules/viem/_esm/chains/definitions/dbkchain.js
var dbkchain = defineChain({
  id: 20240603,
  name: "DBK chain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.dbkchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "DBK Chain Explorer",
      url: "https://scan.dbkchain.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/dchain.js
var dchain = defineChain({
  ...chainConfig2,
  id: 2716446429837e3,
  name: "Dchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dchain-2716446429837000-1.jsonrpc.sagarpc.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Dchain Explorer",
      url: "https://dchain-2716446429837000-1.sagaexplorer.io",
      apiUrl: "https://api-dchain-2716446429837000-1.sagaexplorer.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts
  }
});

// node_modules/viem/_esm/chains/definitions/dchainTestnet.js
var dchainTestnet = defineChain({
  ...chainConfig2,
  id: 2713017997578e3,
  name: "Dchain Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://dchaintestnet-2713017997578000-1.jsonrpc.testnet.sagarpc.io"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Dchain Explorer",
      url: "https://dchaintestnet-2713017997578000-1.testnet.sagaexplorer.io",
      apiUrl: "https://api-dchaintestnet-2713017997578000-1.testnet.sagaexplorer.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts
  }
});

// node_modules/viem/_esm/chains/definitions/defichainEvm.js
var defichainEvm = defineChain({
  id: 1130,
  network: "defichain-evm",
  name: "DeFiChain EVM Mainnet",
  nativeCurrency: {
    name: "DeFiChain",
    symbol: "DFI",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth.mainnet.ocean.jellyfishsdk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DeFiScan",
      url: "https://meta.defiscan.live"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 137852
    }
  }
});

// node_modules/viem/_esm/chains/definitions/defichainEvmTestnet.js
var defichainEvmTestnet = defineChain({
  id: 1131,
  network: "defichain-evm-testnet",
  name: "DeFiChain EVM Testnet",
  nativeCurrency: {
    name: "DeFiChain",
    symbol: "DFI",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth.testnet.ocean.jellyfishsdk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DeFiScan",
      url: "https://meta.defiscan.live/?network=TestNet"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 156462
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/degen.js
var degen = defineChain({
  id: 666666666,
  name: "Degen",
  nativeCurrency: {
    decimals: 18,
    name: "Degen",
    symbol: "DEGEN"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.degen.tips"],
      webSocket: ["wss://rpc.degen.tips"]
    }
  },
  blockExplorers: {
    default: {
      name: "Degen Chain Explorer",
      url: "https://explorer.degen.tips",
      apiUrl: "https://explorer.degen.tips/api/v2"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/dfk.js
var dfk = defineChain({
  id: 53935,
  name: "DFK Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Jewel",
    symbol: "JEWEL"
  },
  rpcUrls: {
    default: {
      http: ["https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "DFKSubnetScan",
      url: "https://subnets.avax.network/defi-kingdoms"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14790551
    }
  }
});

// node_modules/viem/_esm/chains/definitions/diode.js
var diode = defineChain({
  id: 15,
  name: "Diode Prenet",
  nativeCurrency: {
    decimals: 18,
    name: "DIODE",
    symbol: "DIODE"
  },
  rpcUrls: {
    default: {
      http: ["https://prenet.diode.io:8443"],
      webSocket: ["wss://prenet.diode.io:8443/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Diode Explorer",
      url: "https://diode.io/prenet"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/disChain.js
var disChain = defineChain({
  id: 513100,
  name: "DisChain",
  nativeCurrency: {
    decimals: 18,
    name: "DIS",
    symbol: "DIS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.dischain.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "DisChain Explorer",
      url: "https://www.oklink.com/dis"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/dodochainTestnet.js
var dodochainTestnet = defineChain({
  id: 53457,
  name: "DODOchain Testnet",
  nativeCurrency: { decimals: 18, name: "DODO", symbol: "DODO" },
  rpcUrls: {
    default: {
      http: ["https://dodochain-testnet.alt.technology"],
      webSocket: ["wss://dodochain-testnet.alt.technology/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "DODOchain Testnet (Sepolia) Explorer",
      url: "https://testnet-scan.dodochain.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/dogechain.js
var dogechain = defineChain({
  id: 2e3,
  name: "Dogechain",
  nativeCurrency: {
    decimals: 18,
    name: "Wrapped Dogecoin",
    symbol: "WDOGE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.dogechain.dog"] }
  },
  blockExplorers: {
    default: {
      name: "DogeChainExplorer",
      url: "https://explorer.dogechain.dog",
      apiUrl: "https://explorer.dogechain.dog/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x68a8609a60a008EFA633dfdec592c03B030cC508",
      blockCreated: 25384031
    }
  }
});

// node_modules/viem/_esm/chains/definitions/domaTestnet.js
var domaTestnet = defineChain({
  id: 97476,
  name: "Doma Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc-testnet.doma.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Doma Testnet Explorer",
      url: "https://explorer-testnet.doma.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/donatuz.js
var donatuz = defineChain({
  id: 42026,
  name: "Donatuz",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.donatuz.com"] }
  },
  blockExplorers: {
    default: {
      name: "Donatuz Explorer",
      url: "https://explorer.donatuz.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  }
});

// node_modules/viem/_esm/chains/definitions/dosChain.js
var dosChain = defineChain({
  id: 7979,
  name: "DOS Chain",
  nativeCurrency: {
    decimals: 18,
    name: "DOS Chain",
    symbol: "DOS"
  },
  rpcUrls: {
    default: { http: ["https://main.doschain.com"] }
  },
  blockExplorers: {
    default: {
      name: "DOS Chain Explorer",
      url: "https://doscan.io",
      apiUrl: "https://api.doscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 161908
    }
  }
});

// node_modules/viem/_esm/chains/definitions/dosChainTestnet.js
var dosChainTestnet = defineChain({
  id: 3939,
  name: "DOS Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "DOS Chain Testnet",
    symbol: "DOS"
  },
  rpcUrls: {
    default: { http: ["https://test.doschain.com"] }
  },
  blockExplorers: {
    default: {
      name: "DOS Chain Testnet Explorer",
      url: "https://test.doscan.io",
      apiUrl: "https://api-test.doscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 69623
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/dreyerxMainnet.js
var dreyerxMainnet = defineChain({
  id: 23451,
  name: "DreyerX Mainnet",
  nativeCurrency: {
    name: "DreyerX",
    symbol: "DRX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.dreyerx.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DreyerX Scan",
      url: "https://scan.dreyerx.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/dreyerxTestnet.js
var dreyerxTestnet = defineChain({
  id: 23452,
  name: "DreyerX Testnet",
  nativeCurrency: {
    name: "DreyerX",
    symbol: "DRX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["http://testnet-rpc.dreyerx.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DreyerX Testnet Scan",
      url: "https://testnet-scan.dreyerx.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/dustboyIoT.js
var dustboyIoT = defineChain({
  id: 555888,
  name: "DustBoy IoT",
  nativeCurrency: { name: "Ether", symbol: "DST", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dustboy-rpc.jibl2.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://dustboy.jibl2.com",
      apiUrl: "https://dustboy.jibl2.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xFFD34aa2C62B2D52E00A361e466C229788f4eD6a",
      blockCreated: 526569
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/dymension.js
var dymension = defineChain({
  id: 1100,
  name: "Dymension",
  nativeCurrency: {
    name: "DYM",
    symbol: "DYM",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://dymension-evm-rpc.publicnode.com"],
      webSocket: ["wss://dymension-evm-rpc.publicnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Dym FYI",
      url: "https://dym.fyi"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/edexa.js
var edexa = defineChain({
  id: 5424,
  name: "edeXa",
  nativeCurrency: { name: "edeXa", symbol: "EDX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.edexa.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "edeXa Explorer",
      url: "https://explorer.edexa.network",
      apiUrl: "https://explorer.edexa.network/api/v2"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/edexaTestnet.js
var edexaTestnet = defineChain({
  id: 1995,
  name: "edeXa Testnet",
  nativeCurrency: { name: "edeXa", symbol: "tEDX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.edexa.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "edeXa Testnet Explorer",
      url: "https://explorer.testnet.edexa.network",
      apiUrl: "https://explorer.testnet.edexa.network/api/v2"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/edgeless.js
var edgeless = defineChain({
  id: 2026,
  name: "Edgeless Network",
  nativeCurrency: {
    name: "Edgeless Wrapped ETH",
    symbol: "EwETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.edgeless.network/http"],
      webSocket: ["wss://rpc.edgeless.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Edgeless Explorer",
      url: "https://explorer.edgeless.network"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/edgelessTestnet.js
var edgelessTestnet = defineChain({
  id: 202,
  name: "Edgeless Testnet",
  nativeCurrency: {
    name: "Edgeless Wrapped ETH",
    symbol: "EwETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://edgeless-testnet.rpc.caldera.xyz/http"],
      webSocket: ["wss://edgeless-testnet.rpc.caldera.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Edgeless Testnet Explorer",
      url: "https://testnet.explorer.edgeless.network"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/edgeware.js
var edgeware = defineChain({
  id: 2021,
  name: "Edgeware EdgeEVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Edgeware",
    symbol: "EDG"
  },
  rpcUrls: {
    default: { http: ["https://edgeware-evm.jelliedowl.net"] }
  },
  blockExplorers: {
    default: {
      name: "Edgscan by Bharathcoorg",
      url: "https://edgscan.live",
      apiUrl: "https://edgscan.live/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 18117872
    }
  }
});

// node_modules/viem/_esm/chains/definitions/edgewareTestnet.js
var edgewareTestnet = defineChain({
  id: 2022,
  name: "Beresheet BereEVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Testnet EDG",
    symbol: "tEDG"
  },
  rpcUrls: {
    default: { http: ["https://beresheet-evm.jelliedowl.net"] }
  },
  blockExplorers: {
    default: {
      name: "Edgscan by Bharathcoorg",
      url: "https://testnet.edgscan.live",
      apiUrl: "https://testnet.edgscan.live/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/eduChain.js
var eduChain = defineChain({
  id: 41923,
  name: "EDU Chain",
  nativeCurrency: {
    decimals: 18,
    name: "EDU",
    symbol: "EDU"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.edu-chain.raas.gelato.cloud"]
    }
  },
  blockExplorers: {
    default: {
      name: "EDU Chain Explorer",
      url: "https://educhain.blockscout.com/"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/eduChainTestnet.js
var eduChainTestnet = defineChain({
  id: 656476,
  name: "EDU Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "EDU",
    symbol: "EDU"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.open-campus-codex.gelato.digital/"],
      webSocket: ["wss://ws.open-campus-codex.gelato.digital"]
    }
  },
  blockExplorers: {
    default: {
      name: "EDU Chain Testnet Explorer",
      url: "https://opencampus-codex.blockscout.com",
      apiUrl: "https://opencampus-codex.blockscout.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 15514133
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/ekta.js
var ekta = defineChain({
  id: 1994,
  name: "Ekta",
  nativeCurrency: {
    decimals: 18,
    name: "EKTA",
    symbol: "EKTA"
  },
  rpcUrls: {
    default: { http: ["https://main.ekta.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ektascan",
      url: "https://ektascan.io",
      apiUrl: "https://ektascan.io/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/ektaTestnet.js
var ektaTestnet = defineChain({
  id: 1004,
  name: "Ekta Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "EKTA",
    symbol: "EKTA"
  },
  rpcUrls: {
    default: { http: ["https://test.ekta.io:8545"] }
  },
  blockExplorers: {
    default: {
      name: "Test Ektascan",
      url: "https://test.ektascan.io",
      apiUrl: "https://test.ektascan.io/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/elastos.js
var elastos = defineChain({
  id: 20,
  name: "Elastos Smart Chain",
  nativeCurrency: { name: "ELA", symbol: "ELA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api2.elastos.io/eth"]
    }
  },
  blockExplorers: {
    default: {
      name: "Elastos Explorer",
      url: "https://esc.elastos.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/elastosTestnet.js
var elastosTestnet = defineChain({
  id: 21,
  name: "Elastos Smart Chain Testnet",
  nativeCurrency: { name: "tELA", symbol: "tELA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api-testnet.elastos.io/eth"]
    }
  },
  blockExplorers: {
    default: {
      name: "Elastos Explorer",
      url: "https://esc-testnet.elastos.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/electroneum.js
var electroneum = defineChain({
  id: 52014,
  name: "Electroneum Mainnet",
  nativeCurrency: {
    name: "ETN",
    symbol: "ETN",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.electroneum.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Electroneum Block Explorer",
      url: "https://blockexplorer.electroneum.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/electroneumTestnet.js
var electroneumTestnet = defineChain({
  id: 5201420,
  name: "Electroneum Testnet",
  nativeCurrency: {
    name: "ETN",
    symbol: "ETN",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.electroneum.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Electroneum Block Explorer",
      url: "https://blockexplorer.thesecurityteam.rocks"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/elysiumTestnet.js
var elysiumTestnet = defineChain({
  ...chainConfig2,
  id: 1338,
  name: "Elysium Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "LAVA",
    symbol: "LAVA"
  },
  rpcUrls: {
    default: {
      http: ["https://elysium-test-rpc.vulcanforged.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Elysium testnet explorer",
      url: "https://elysium-explorer.vulcanforged.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/energy.js
var energy = defineChain({
  id: 246,
  name: "Energy Mainnet",
  nativeCurrency: { name: "EWT", symbol: "EWT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.energyweb.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "EnergyWeb Explorer",
      url: "https://explorer.energyweb.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/eni.js
var eni = defineChain({
  id: 173,
  name: "ENI Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "ENI",
    symbol: "ENI"
  },
  rpcUrls: {
    default: { http: ["https://rpc.eniac.network"] }
  },
  blockExplorers: {
    default: {
      name: "ENI Explorer",
      url: "https://scan.eniac.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/eniTestnet.js
var eniTestnet = defineChain({
  id: 6912115,
  name: "ENI Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ENI Testnet Token",
    symbol: "ENI"
  },
  rpcUrls: {
    default: { http: ["https://rpc-testnet.eniac.network"] }
  },
  blockExplorers: {
    default: {
      name: "ENI Testnet Explorer",
      url: "https://scan-testnet.eniac.network"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/enuls.js
var enuls = defineChain({
  id: 119,
  name: "ENULS Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "NULS",
    symbol: "NULS"
  },
  rpcUrls: {
    default: { http: ["https://evmapi2.nuls.io"] }
  },
  blockExplorers: {
    default: {
      name: "ENULS Explorer",
      url: "https://evmscan.nuls.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/eon.js
var eon = defineChain({
  id: 7332,
  name: "Horizen EON",
  nativeCurrency: {
    decimals: 18,
    name: "ZEN",
    symbol: "ZEN"
  },
  rpcUrls: {
    default: { http: ["https://eon-rpc.horizenlabs.io/ethv1"] }
  },
  blockExplorers: {
    default: {
      name: "EON Explorer",
      url: "https://eon-explorer.horizenlabs.io"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/eos.js
var eos = defineChain({
  id: 17777,
  name: "EOS EVM",
  nativeCurrency: {
    decimals: 18,
    name: "EOS",
    symbol: "EOS"
  },
  rpcUrls: {
    default: { http: ["https://api.evm.eosnetwork.com"] }
  },
  blockExplorers: {
    default: {
      name: "EOS EVM Explorer",
      url: "https://explorer.evm.eosnetwork.com",
      apiUrl: "https://explorer.evm.eosnetwork.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7943933
    }
  }
});

// node_modules/viem/_esm/chains/definitions/eosTestnet.js
var eosTestnet = defineChain({
  id: 15557,
  name: "EOS EVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "EOS",
    symbol: "EOS"
  },
  rpcUrls: {
    default: { http: ["https://api.testnet.evm.eosnetwork.com"] }
  },
  blockExplorers: {
    default: {
      name: "EOS EVM Testnet Explorer",
      url: "https://explorer.testnet.evm.eosnetwork.com",
      apiUrl: "https://explorer.testnet.evm.eosnetwork.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 9067940
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/eteria.js
var eteria = defineChain({
  id: 140,
  name: "Eteria",
  nativeCurrency: { name: "Eteria", symbol: "ERA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.eteria.io/v1"]
    }
  },
  blockExplorers: {
    default: {
      name: "Eteria Explorer",
      url: "https://explorer.eteria.io",
      apiUrl: "https://explorer.eteria.io/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/etherlink.js
var etherlink = defineChain({
  id: 42793,
  name: "Etherlink",
  blockTime: 4830,
  nativeCurrency: {
    decimals: 18,
    name: "Tez",
    symbol: "XTZ"
  },
  rpcUrls: {
    default: { http: ["https://node.mainnet.etherlink.com"] }
  },
  blockExplorers: {
    default: {
      name: "Etherlink",
      url: "https://explorer.etherlink.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 33899
    }
  }
});

// node_modules/viem/_esm/chains/definitions/etherlinkTestnet.js
var etherlinkTestnet = defineChain({
  id: 128123,
  name: "Etherlink Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Tez",
    symbol: "XTZ"
  },
  rpcUrls: {
    default: { http: ["https://node.ghostnet.etherlink.com"] }
  },
  blockExplorers: {
    default: {
      name: "Etherlink Testnet",
      url: "https://testnet.explorer.etherlink.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/ethernity.js
var ethernity = defineChain({
  id: 183,
  name: "Ethernity",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.ethernitychain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ethernity Explorer",
      url: "https://ernscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/etp.js
var etp = defineChain({
  id: 20256789,
  name: "ETP Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETP Chain Native Token",
    symbol: "ETP"
  },
  rpcUrls: {
    default: { http: ["https://rpc.etpscan.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "ETP Scan",
      url: "https://etpscan.xyz"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/evmos.js
var evmos = defineChain({
  id: 9001,
  name: "Evmos",
  nativeCurrency: {
    decimals: 18,
    name: "Evmos",
    symbol: "EVMOS"
  },
  rpcUrls: {
    default: { http: ["https://eth.bd.evmos.org:8545"] }
  },
  blockExplorers: {
    default: {
      name: "Evmos Block Explorer",
      url: "https://escan.live"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/evmosTestnet.js
var evmosTestnet = defineChain({
  id: 9e3,
  name: "Evmos Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Evmos",
    symbol: "EVMOS"
  },
  rpcUrls: {
    default: { http: ["https://eth.bd.evmos.dev:8545"] }
  },
  blockExplorers: {
    default: {
      name: "Evmos Testnet Block Explorer",
      url: "https://evm.evmos.dev/"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/excelonMainnet.js
var excelonMainnet = defineChain({
  id: 22052002,
  name: "Excelon Mainnet",
  network: "XLON",
  nativeCurrency: {
    decimals: 18,
    name: "Excelon",
    symbol: "xlon"
  },
  rpcUrls: {
    default: {
      http: ["https://edgewallet1.xlon.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Excelon explorer",
      url: "https://explorer.excelon.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/expanse.js
var expanse = defineChain({
  id: 2,
  name: "Expanse Network",
  nativeCurrency: {
    decimals: 18,
    name: "EXP",
    symbol: "EXP"
  },
  rpcUrls: {
    default: { http: ["https://node.expanse.tech"] }
  },
  blockExplorers: {
    default: {
      name: "Expanse Explorer",
      url: "https://explorer.expanse.tech"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/exSat.js
var exsat = defineChain({
  id: 7200,
  name: "exSat Network",
  nativeCurrency: {
    decimals: 18,
    name: "BTC",
    symbol: "BTC"
  },
  rpcUrls: {
    default: { http: ["https://evm.exsat.network"] }
  },
  blockExplorers: {
    default: {
      name: "exSat Explorer",
      url: "https://scan.exsat.network",
      apiUrl: "https://scan.exsat.network/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/exSatTestnet.js
var exsatTestnet = defineChain({
  id: 839999,
  name: "exSat Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "BTC",
    symbol: "BTC"
  },
  rpcUrls: {
    default: { http: ["https://evm-tst3.exsat.network"] }
  },
  blockExplorers: {
    default: {
      name: "exSat Explorer",
      url: "https://scan-testnet.exsat.network",
      apiUrl: "https://scan-testnet.exsat.network/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/fantom.js
var fantom = defineChain({
  id: 250,
  name: "Fantom",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://250.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "FTMScan",
      url: "https://ftmscan.com",
      apiUrl: "https://api.ftmscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 33001987
    }
  }
});

// node_modules/viem/_esm/chains/definitions/fantomSonicTestnet.js
var fantomSonicTestnet = defineChain({
  id: 64240,
  name: "Fantom Sonic Open Testnet",
  network: "fantom-sonic-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://rpcapi.sonic.fantom.network"] }
  },
  blockExplorers: {
    default: {
      name: "Fantom Sonic Open Testnet Explorer",
      url: "https://public-sonic.fantom.network"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/fantomTestnet.js
var fantomTestnet = defineChain({
  id: 4002,
  name: "Fantom Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.fantom.network"] }
  },
  blockExplorers: {
    default: {
      name: "FTMScan",
      url: "https://testnet.ftmscan.com",
      apiUrl: "https://testnet.ftmscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 8328688
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/fibo.js
var fibo = defineChain({
  id: 12306,
  name: "Fibo Chain",
  nativeCurrency: {
    decimals: 18,
    name: "fibo",
    symbol: "FIBO"
  },
  rpcUrls: {
    default: { http: ["https://network.hzroc.art"] }
  },
  blockExplorers: {
    default: {
      name: "FiboScan",
      url: "https://scan.fibochain.org"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/filecoin.js
var filecoin = defineChain({
  id: 314,
  name: "Filecoin Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "filecoin",
    symbol: "FIL"
  },
  rpcUrls: {
    default: { http: ["https://api.node.glif.io/rpc/v1"] }
  },
  blockExplorers: {
    default: {
      name: "Filfox",
      url: "https://filfox.info/en"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3328594
    }
  }
});

// node_modules/viem/_esm/chains/definitions/filecoinCalibration.js
var filecoinCalibration = defineChain({
  id: 314159,
  name: "Filecoin Calibration",
  nativeCurrency: {
    decimals: 18,
    name: "testnet filecoin",
    symbol: "tFIL"
  },
  rpcUrls: {
    default: { http: ["https://api.calibration.node.glif.io/rpc/v1"] }
  },
  blockExplorers: {
    default: {
      name: "Filscan",
      url: "https://calibration.filscan.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/filecoinHyperspace.js
var filecoinHyperspace = defineChain({
  id: 3141,
  name: "Filecoin Hyperspace",
  nativeCurrency: {
    decimals: 18,
    name: "testnet filecoin",
    symbol: "tFIL"
  },
  rpcUrls: {
    default: { http: ["https://api.hyperspace.node.glif.io/rpc/v1"] }
  },
  blockExplorers: {
    default: {
      name: "Filfox",
      url: "https://hyperspace.filfox.info/en"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/flame.js
var flame = defineChain({
  id: 253368190,
  name: "Flame",
  network: "flame",
  nativeCurrency: {
    symbol: "TIA",
    name: "TIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.flame.astria.org"],
      webSocket: ["wss://ws.flame.astria.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Flame Explorer",
      url: "https://explorer.flame.astria.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 6829148
    }
  }
});

// node_modules/viem/_esm/chains/definitions/flare.js
var flare = defineChain({
  id: 14,
  name: "Flare Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flare",
    symbol: "FLR"
  },
  rpcUrls: {
    default: { http: ["https://flare-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Flare Explorer",
      url: "https://flare-explorer.flare.network",
      apiUrl: "https://flare-explorer.flare.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3002461
    }
  }
});

// node_modules/viem/_esm/chains/definitions/flareTestnet.js
var flareTestnet = defineChain({
  id: 114,
  name: "Flare Testnet Coston2",
  nativeCurrency: {
    decimals: 18,
    name: "Coston2 Flare",
    symbol: "C2FLR"
  },
  rpcUrls: {
    default: { http: ["https://coston2-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Coston2 Explorer",
      url: "https://coston2-explorer.flare.network",
      apiUrl: "https://coston2-explorer.flare.network/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/flowMainnet.js
var flowMainnet = defineChain({
  id: 747,
  name: "Flow EVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flow",
    symbol: "FLOW"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.evm.nodes.onflow.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mainnet Explorer",
      url: "https://evm.flowscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6205
    }
  },
  blockTime: 800
});

// node_modules/viem/_esm/chains/definitions/flowPreviewnet.js
var flowPreviewnet = defineChain({
  id: 646,
  name: "Flow EVM Previewnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flow",
    symbol: "FLOW"
  },
  rpcUrls: {
    default: {
      http: ["https://previewnet.evm.nodes.onflow.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Previewnet Explorer",
      url: "https://previewnet.flowdiver.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6205
    }
  }
});

// node_modules/viem/_esm/chains/definitions/flowTestnet.js
var flowTestnet = defineChain({
  id: 545,
  name: "Flow EVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flow",
    symbol: "FLOW"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.evm.nodes.onflow.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Flow Diver",
      url: "https://evm-testnet.flowscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 137518
    }
  },
  testnet: true,
  blockTime: 800
});

// node_modules/viem/_esm/chains/definitions/fluence.js
var fluence = defineChain({
  id: 9999999,
  name: "Fluence",
  nativeCurrency: { name: "FLT", symbol: "FLT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.fluence.dev"],
      webSocket: ["wss://ws.mainnet.fluence.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.mainnet.fluence.dev",
      apiUrl: "https://blockscout.mainnet.fluence.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 207583
    }
  }
});

// node_modules/viem/_esm/chains/definitions/fluenceStage.js
var fluenceStage = defineChain({
  id: 123420000220,
  name: "Fluence Stage",
  nativeCurrency: { name: "tFLT", symbol: "tFLT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.stage.fluence.dev"],
      webSocket: ["wss://ws.stage.fluence.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.stage.fluence.dev",
      apiUrl: "https://blockscout.stage.fluence.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 83227
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/fluenceTestnet.js
var fluenceTestnet = defineChain({
  id: 52164803,
  name: "Fluence Testnet",
  nativeCurrency: { name: "tFLT", symbol: "tFLT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.fluence.dev"],
      webSocket: ["wss://ws.testnet.fluence.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.testnet.fluence.dev",
      apiUrl: "https://blockscout.testnet.fluence.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 96424
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/fluentTestnet.js
var fluentTestnet = defineChain({
  id: 20993,
  name: "Fluent Testnet",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.dev.gblend.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Fluent Explorer",
      url: "https://blockscout.dev.gblend.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/form.js
var sourceId17 = 1;
var form = defineChain({
  id: 478,
  name: "Form Network",
  nativeCurrency: {
    decimals: 18,
    name: "Ethereum",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.form.network/http"],
      webSocket: ["wss://rpc.form.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Form Explorer",
      url: "https://explorer.form.network"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    addressManager: {
      [sourceId17]: {
        address: "0x15c249E46A2F924C2dB3A1560CF86729bAD1f07B"
      }
    },
    l1CrossDomainMessenger: {
      [sourceId17]: {
        address: "0xF333158DCCad1dF6C3F0a3aEe8BC31fA94d9eD5c"
      }
    },
    l2OutputOracle: {
      [sourceId17]: {
        address: "0x4ccAAF69F41c5810cA875183648B577CaCf1F67E"
      }
    },
    portal: {
      [sourceId17]: {
        address: "0x4E259Ee5F4136408908160dD32295A5031Fa426F"
      }
    },
    l1StandardBridge: {
      [sourceId17]: {
        address: "0xdc20aA63D3DE59574E065957190D8f24e0F7B8Ba"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  sourceId: sourceId17
});

// node_modules/viem/_esm/chains/definitions/forma.js
var forma = defineChain({
  id: 984122,
  name: "Forma",
  network: "forma",
  nativeCurrency: {
    symbol: "TIA",
    name: "TIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.forma.art"],
      webSocket: ["wss://ws.forma.art"]
    }
  },
  blockExplorers: {
    default: {
      name: "Forma Explorer",
      url: "https://explorer.forma.art"
    }
  },
  contracts: {
    multicall3: {
      address: "0xd53C6FFB123F7349A32980F87faeD8FfDc9ef079",
      blockCreated: 252705
    }
  }
});

// node_modules/viem/_esm/chains/definitions/formTestnet.js
var sourceId18 = 11155111;
var formTestnet = defineChain({
  id: 132902,
  name: "Form Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ethereum",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.form.network/http"],
      webSocket: ["wss://sepolia-rpc.form.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Form Testnet Explorer",
      url: "https://sepolia-explorer.form.network"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    addressManager: {
      [sourceId18]: {
        address: "0xd5C38fa934f7fd7477D4800F4f38a1c5BFdF1373"
      }
    },
    l1CrossDomainMessenger: {
      [sourceId18]: {
        address: "0x37A68565c4BE9700b3E3Ec60cC4416cAC3052FAa"
      }
    },
    l2OutputOracle: {
      [sourceId18]: {
        address: "0x9eA2239E65a59EC9C7F1ED4C116dD58Da71Fc1e2"
      }
    },
    portal: {
      [sourceId18]: {
        address: "0x60377e3cE15dF4CCA24c4beF076b60314240b032"
      }
    },
    l1StandardBridge: {
      [sourceId18]: {
        address: "0xD4531f633942b2725896F47cD2aFd260b44Ab1F7"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  testnet: true,
  sourceId: sourceId18
});

// node_modules/viem/_esm/chains/definitions/forta.js
var forta = defineChain({
  id: 80931,
  name: "Forta Chain",
  nativeCurrency: {
    symbol: "FORT",
    name: "FORT",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc-forta-chain-8gj1qndmfc.t.conduit.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Forta Explorer",
      url: "https://explorer.forta.org"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/foundry.js
var foundry = defineChain({
  id: 31337,
  name: "Foundry",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["http://127.0.0.1:8545"],
      webSocket: ["ws://127.0.0.1:8545"]
    }
  }
});

// node_modules/viem/_esm/chains/definitions/fraxtal.js
var sourceId19 = 1;
var fraxtal = defineChain({
  ...chainConfig2,
  id: 252,
  name: "Fraxtal",
  nativeCurrency: { name: "Frax", symbol: "FRAX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.frax.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "fraxscan",
      url: "https://fraxscan.com",
      apiUrl: "https://api.fraxscan.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId19]: {
        address: "0x66CC916Ed5C6C2FA97014f7D1cD141528Ae171e4"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId19]: {
        address: "0x36cb65c1967A0Fb0EEE11569C51C2f2aA1Ca6f6D",
        blockCreated: 19135323
      }
    },
    l1StandardBridge: {
      [sourceId19]: {
        address: "0x34C0bD5877A5Ee7099D0f5688D65F4bB9158BDE2",
        blockCreated: 19135323
      }
    }
  },
  sourceId: sourceId19
});

// node_modules/viem/_esm/chains/definitions/fraxtalTestnet.js
var sourceId20 = 17e3;
var fraxtalTestnet = defineChain({
  ...chainConfig2,
  id: 2522,
  name: "Fraxtal Testnet",
  nativeCurrency: { name: "Frax", symbol: "FRAX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.frax.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "fraxscan testnet",
      url: "https://holesky.fraxscan.com",
      apiUrl: "https://api-holesky.fraxscan.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId20]: {
        address: "0x715EA64DA13F4d0831ece4Ad3E8c1aa013167F32"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId20]: {
        address: "0xB9c64BfA498d5b9a8398Ed6f46eb76d90dE5505d",
        blockCreated: 318416
      }
    },
    l1StandardBridge: {
      [sourceId20]: {
        address: "0x0BaafC217162f64930909aD9f2B27125121d6332",
        blockCreated: 318416
      }
    }
  },
  sourceId: sourceId20
});

// node_modules/viem/_esm/chains/definitions/funkiMainnet.js
var sourceId21 = 1;
var funkiMainnet = defineChain({
  ...chainConfig2,
  id: 33979,
  name: "Funki",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-mainnet.funkichain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Funki Mainnet Explorer",
      url: "https://funkiscan.io"
    }
  },
  contracts: {
    ...chainConfig2.contracts
  },
  sourceId: sourceId21
});

// node_modules/viem/_esm/chains/definitions/funkiSepolia.js
var sourceId22 = 11155111;
var funkiSepolia = defineChain({
  ...chainConfig2,
  id: 3397901,
  network: "funkiSepolia",
  name: "Funki Sepolia Sandbox",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://funki-testnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Funki Sepolia Sandbox Explorer",
      url: "https://sepolia-sandbox.funkichain.com/"
    }
  },
  testnet: true,
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1620204
    }
  },
  sourceId: sourceId22
});

// node_modules/viem/_esm/chains/definitions/fuse.js
var fuse = defineChain({
  id: 122,
  name: "Fuse",
  nativeCurrency: { name: "Fuse", symbol: "FUSE", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.fuse.io"] }
  },
  blockExplorers: {
    default: {
      name: "Fuse Explorer",
      url: "https://explorer.fuse.io",
      apiUrl: "https://explorer.fuse.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 16146628
    }
  }
});

// node_modules/viem/_esm/chains/definitions/fuseSparknet.js
var fuseSparknet = defineChain({
  id: 123,
  name: "Fuse Sparknet",
  nativeCurrency: { name: "Spark", symbol: "SPARK", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.fusespark.io"] }
  },
  blockExplorers: {
    default: {
      name: "Sparkent Explorer",
      url: "https://explorer.fusespark.io",
      apiUrl: "https://explorer.fusespark.io/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/fusion.js
var fusion = defineChain({
  id: 32659,
  name: "Fusion Mainnet",
  nativeCurrency: { name: "Fusion", symbol: "FSN", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.fusionnetwork.io"],
      webSocket: ["wss://mainnet.fusionnetwork.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "FSNscan",
      url: "https://fsnscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 10441605
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/fusionTestnet.js
var fusionTestnet = defineChain({
  id: 46688,
  name: "Fusion Testnet",
  nativeCurrency: { name: "Fusion", symbol: "FSN", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.fusionnetwork.io"],
      webSocket: ["wss://testnet.fusionnetwork.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "FSNscan",
      url: "https://testnet.fsnscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 10428309
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/garnet.js
var sourceId23 = 17e3;
var garnet = defineChain({
  ...chainConfig2,
  name: "Garnet Testnet",
  testnet: true,
  id: 17069,
  sourceId: sourceId23,
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.garnetchain.com"],
      webSocket: ["wss://rpc.garnetchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.garnetchain.com"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId23]: {
        address: "0x57ee40586fbE286AfC75E67cb69511A6D9aF5909",
        blockCreated: 1274684
      }
    },
    l2OutputOracle: {
      [sourceId23]: {
        address: "0xCb8E7AC561b8EF04F2a15865e9fbc0766FEF569B",
        blockCreated: 1274684
      }
    },
    l1StandardBridge: {
      [sourceId23]: {
        address: "0x09bcDd311FE398F80a78BE37E489f5D440DB95DE",
        blockCreated: 1274684
      }
    }
  }
});

// node_modules/viem/_esm/chains/definitions/gatechain.js
var gatechain = defineChain({
  id: 86,
  name: "GateChain Mainnet",
  nativeCurrency: { name: "GateChainToken", symbol: "GT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm.nodeinfo.cc"],
      webSocket: ["wss://evm-ws.gatenode.cc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Gate Scan",
      url: "https://www.gatescan.org",
      apiUrl: "https://gatescan.org/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/geist.js
var geist = defineChain({
  id: 63157,
  name: "Geist Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Aavegotchi GHST Token",
    symbol: "GHST"
  },
  rpcUrls: {
    default: {
      http: ["https://geist-mainnet.g.alchemy.com/public"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://geist-mainnet.explorer.alchemy.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 660735
    }
  }
});

// node_modules/viem/_esm/chains/definitions/genesys.js
var genesys = defineChain({
  id: 16507,
  name: "Genesys Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "GSYS",
    symbol: "GSYS"
  },
  rpcUrls: {
    default: { http: ["https://rpc.genesys.network"] }
  },
  blockExplorers: {
    default: {
      name: "Genesys Explorer",
      url: "https://gchainexplorer.genesys.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/giwaSepolia.js
var sourceId24 = 11155111;
var giwaSepolia = defineChain({
  ...chainConfig2,
  id: 91342,
  network: "giwa-sepolia",
  name: "GIWA Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  blockTime: 1e3,
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.giwa.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepolia-explorer.giwa.io",
      apiUrl: "https://sepolia-explorer.giwa.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [sourceId24]: {
        address: "0x37347caB2afaa49B776372279143D71ad1f354F6"
      }
    },
    portal: {
      [sourceId24]: {
        address: "0x956962C34687A954e611A83619ABaA37Ce6bC78A"
      }
    },
    l1StandardBridge: {
      [sourceId24]: {
        address: "0x77b2ffc0F57598cAe1DB76cb398059cF5d10A7E7"
      }
    }
  },
  testnet: true,
  sourceId: sourceId24
});

// node_modules/viem/_esm/chains/definitions/glideL1Protocol.js
var glideL1Protocol = defineChain({
  id: 251,
  name: "Glide L1 Protocol XP",
  nativeCurrency: { name: "GLXP", symbol: "GLXP", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-api.glideprotocol.xyz/l1-rpc"],
      webSocket: ["wss://rpc-api.glideprotocol.xyz/l1-rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Glide Protocol Explore",
      url: "https://blockchain-explorer.glideprotocol.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/glideL2Protocol.js
var glideL2Protocol = defineChain({
  id: 253,
  name: "Glide L2 Protocol XP",
  nativeCurrency: { name: "GLXP", symbol: "GLXP", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-api.glideprotocol.xyz/l2-rpc"],
      webSocket: ["wss://rpc-api.glideprotocol.xyz/l2-rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Glide Protocol Explore",
      url: "https://blockchain-explorer.glideprotocol.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/gnosis.js
var gnosis = defineChain({
  id: 100,
  name: "Gnosis",
  nativeCurrency: {
    decimals: 18,
    name: "xDAI",
    symbol: "XDAI"
  },
  blockTime: 5e3,
  rpcUrls: {
    default: {
      http: ["https://rpc.gnosischain.com"],
      webSocket: ["wss://rpc.gnosischain.com/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "Gnosisscan",
      url: "https://gnosisscan.io",
      apiUrl: "https://api.gnosisscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 21022491
    }
  }
});

// node_modules/viem/_esm/chains/definitions/gnosisChiado.js
var gnosisChiado = defineChain({
  id: 10200,
  name: "Gnosis Chiado",
  nativeCurrency: {
    decimals: 18,
    name: "Gnosis",
    symbol: "xDAI"
  },
  blockTime: 5e3,
  rpcUrls: {
    default: {
      http: ["https://rpc.chiadochain.net"],
      webSocket: ["wss://rpc.chiadochain.net/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.chiadochain.net",
      apiUrl: "https://blockscout.chiadochain.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4967313
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/goat.js
var goat = defineChain({
  id: 2345,
  name: "GOAT",
  nativeCurrency: {
    decimals: 18,
    name: "Bitcoin",
    symbol: "BTC"
  },
  rpcUrls: {
    default: { http: ["https://rpc.goat.network"] }
  },
  blockExplorers: {
    default: {
      name: "Goat Explorer",
      url: "https://explorer.goat.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  }
});

// node_modules/viem/_esm/chains/definitions/gobi.js
var gobi = defineChain({
  id: 1663,
  name: "Horizen Gobi Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Test ZEN",
    symbol: "tZEN"
  },
  rpcUrls: {
    default: { http: ["https://gobi-testnet.horizenlabs.io/ethv1"] }
  },
  blockExplorers: {
    default: {
      name: "Gobi Explorer",
      url: "https://gobi-explorer.horizen.io"
    }
  },
  contracts: {},
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/goChain.js
var goChain = defineChain({
  id: 60,
  name: "GoChain",
  nativeCurrency: {
    decimals: 18,
    name: "GO",
    symbol: "GO"
  },
  rpcUrls: {
    default: { http: ["https://rpc.gochain.io"] }
  },
  blockExplorers: {
    default: {
      name: "GoChain Explorer",
      url: "https://explorer.gochain.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/godwoken.js
var godwoken = defineChain({
  id: 71402,
  name: "Godwoken Mainnet",
  nativeCurrency: { decimals: 18, name: "pCKB", symbol: "pCKB" },
  rpcUrls: {
    default: {
      http: ["https://v1.mainnet.godwoken.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "GW Scan",
      url: "https://v1.gwscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 15034
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/goerli.js
var goerli = defineChain({
  id: 5,
  name: "Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://5.rpc.thirdweb.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli.etherscan.io",
      apiUrl: "https://api-goerli.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xfc4AC75C46C914aF5892d6d3eFFcebD7917293F1",
      blockCreated: 10339206
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6507670
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/graphite.js
var graphite = defineChain({
  id: 440017,
  name: "Graphite Network",
  nativeCurrency: { name: "Graphite", symbol: "@G", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://anon-entrypoint-1.atgraphite.com"],
      webSocket: ["wss://ws-anon-entrypoint-1.atgraphite.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Graphite Spectre",
      url: "https://main.atgraphite.com",
      apiUrl: "https://api.main.atgraphite.com/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/graphiteTestnet.js
var graphiteTestnet = defineChain({
  id: 54170,
  name: "Graphite Network Testnet",
  nativeCurrency: { name: "Graphite", symbol: "@G", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://anon-entrypoint-test-1.atgraphite.com"],
      webSocket: ["wss://ws-anon-entrypoint-test-1.atgraphite.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Graphite Testnet Spectre",
      url: "https://test.atgraphite.com",
      apiUrl: "https://api.test.atgraphite.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/gravity.js
var gravity = defineChain({
  id: 1625,
  name: "Gravity Alpha Mainnet",
  nativeCurrency: { name: "G", symbol: "G", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.gravity.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Gravity Explorer",
      url: "https://explorer.gravity.xyz",
      apiUrl: "https://explorer.gravity.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xf8ac4BEB2F75d2cFFb588c63251347fdD629B92c",
      blockCreated: 16851
    }
  }
});

// node_modules/viem/_esm/chains/definitions/gunz.js
var gunz = defineChain({
  id: 43419,
  name: "Gunz Mainnet",
  nativeCurrency: { name: "GUN", symbol: "GUN", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc.gunzchain.io/ext/bc/2M47TxWHGnhNtq6pM5zPXdATBtuqubxn5EPFgFmEawCQr9WFML/rpc"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Gunz Explorer",
      url: "https://gunzscan.io/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 70502
    }
  }
});

// node_modules/viem/_esm/chains/definitions/guruNetwork.js
var guruNetwork = defineChain({
  id: 260,
  name: "Guru Network Mainnet",
  nativeCurrency: {
    name: "GURU Token",
    symbol: "GURU",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-main.gurunetwork.ai",
        "https://rpc.gurunetwork.ai/archive/260"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Guruscan",
      url: "https://scan.gurunetwork.ai"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 271691
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/guruTestnet.js
var guruTestnet = defineChain({
  id: 261,
  name: "Guru Network Testnet",
  nativeCurrency: {
    name: "tGURU Token",
    symbol: "tGURU",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-test.gurunetwork.ai",
        "https://rpc.gurunetwork.ai/archive/261"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Guruscan",
      url: "https://sepolia.gurunetwork.ai"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/ham.js
var ham = defineChain({
  id: 5112,
  name: "Ham",
  nativeCurrency: {
    decimals: 18,
    name: "Ham",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.ham.fun"],
      webSocket: ["wss://rpc.ham.fun"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ham Chain Explorer",
      url: "https://explorer.ham.fun",
      apiUrl: "https://explorer.ham.fun/api/v2"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/happychainTestnet.js
var happychainTestnet = defineChain({
  id: 216,
  name: "Happychain Testnet",
  nativeCurrency: {
    symbol: "HAPPY",
    name: "HAPPY",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.happy.tech/http"],
      webSocket: ["wss://rpc.testnet.happy.tech/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Happy Chain Testnet Explorer",
      url: "https://explorer.testnet.happy.tech"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/haqqMainnet.js
var haqqMainnet = defineChain({
  id: 11235,
  name: "HAQQ Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Islamic Coin",
    symbol: "ISLM"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.eth.haqq.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "HAQQ Explorer",
      url: "https://explorer.haqq.network",
      apiUrl: "https://explorer.haqq.network/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/haqqTestedge2.js
var haqqTestedge2 = defineChain({
  id: 54211,
  name: "HAQQ Testedge 2",
  nativeCurrency: {
    decimals: 18,
    name: "Islamic Coin",
    symbol: "ISLMT"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.eth.testedge2.haqq.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "HAQQ Explorer",
      url: "https://explorer.testedge2.haqq.network",
      apiUrl: "https://explorer.testedge2.haqq.network/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/hardhat.js
var hardhat = defineChain({
  id: 31337,
  name: "Hardhat",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["http://127.0.0.1:8545"] }
  }
});

// node_modules/viem/_esm/chains/definitions/harmonyOne.js
var harmonyOne = defineChain({
  id: 16666e5,
  name: "Harmony One",
  nativeCurrency: {
    name: "Harmony",
    symbol: "ONE",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://1666600000.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "Harmony Explorer",
      url: "https://explorer.harmony.one"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 24185753
    }
  }
});

// node_modules/viem/_esm/chains/definitions/hashKeyChain.js
var hashkey = defineChain({
  id: 177,
  name: "HashKey Chain",
  nativeCurrency: {
    decimals: 18,
    name: "HashKey EcoPoints",
    symbol: "HSK"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.hsk.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "HashKey Chain Explorer",
      url: "https://hashkey.blockscout.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  }
});

// node_modules/viem/_esm/chains/definitions/hashkeyChainTestnet.js
var hashkeyTestnet = defineChain({
  id: 133,
  name: "HashKey Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "HashKey EcoPoints",
    symbol: "HSK"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.hsk.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "HashKey Chain Testnet explorer",
      url: "https://testnet-explorer.hsk.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/haustTestnet.js
var haustTestnet = defineChain({
  id: 1523903251,
  name: "Haust Network Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "HAUST",
    symbol: "HAUST"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.haust.app"]
    }
  },
  blockExplorers: {
    default: {
      name: "Haust Network Testnet Explorer",
      url: "https://explorer-testnet.haust.app"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/hedera.js
var hedera = defineChain({
  id: 295,
  name: "Hedera Mainnet",
  network: "hedera-mainnet",
  nativeCurrency: {
    symbol: "HBAR",
    name: "HBAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.hashio.io/api"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hashscan",
      url: "https://hashscan.io/mainnet"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/hederaPreviewnet.js
var hederaPreviewnet = defineChain({
  id: 297,
  name: "Hedera Previewnet",
  network: "hedera-previewnet",
  nativeCurrency: {
    symbol: "HBAR",
    name: "HBAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://previewnet.hashio.io/api"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hashscan",
      url: "https://hashscan.io/previewnet"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/hederaTestnet.js
var hederaTestnet = defineChain({
  id: 296,
  name: "Hedera Testnet",
  network: "hedera-testnet",
  nativeCurrency: {
    symbol: "HBAR",
    name: "HBAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.hashio.io/api"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hashscan",
      url: "https://hashscan.io/testnet"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/hela.js
var hela = defineChain({
  id: 8668,
  name: "Hela Mainnet",
  nativeCurrency: {
    name: "HLUSD",
    symbol: "HLUSD",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.helachain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hela explorer",
      url: "https://mainnet-blockexplorer.helachain.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/hemi.js
var hemi = defineChain({
  id: 43111,
  name: "Hemi",
  network: "Hemi",
  blockTime: 12e3,
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.hemi.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.hemi.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/hemiSepolia.js
var hemiSepolia = defineChain({
  id: 743111,
  name: "Hemi Sepolia",
  network: "Hemi Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.rpc.hemi.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hemi Sepolia explorer",
      url: "https://testnet.explorer.hemi.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/holesky.js
var holesky = defineChain({
  id: 17e3,
  name: "Holesky",
  nativeCurrency: { name: "Holesky Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://ethereum-holesky-rpc.publicnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://holesky.etherscan.io",
      apiUrl: "https://api-holesky.etherscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 77
    },
    ensUniversalResolver: {
      address: "0xeeeeeeee14d718c2b47d9923deab1335e144eeee",
      blockCreated: 4295055
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/hoodi.js
var hoodi = defineChain({
  id: 560048,
  name: "Hoodi",
  nativeCurrency: { name: "Hoodi Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.hoodi.ethpandaops.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://hoodi.etherscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2589
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/hpb.js
var hpb = defineChain({
  id: 269,
  name: "High Performance Blockchain",
  nativeCurrency: { name: "HPB", symbol: "HPB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://hpbnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "hpbScan",
      url: "https://hscan.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/huddle01Mainnet.js
var sourceId25 = 42161;
var huddle01Mainnet = defineChain({
  id: 12323,
  name: "Huddle01 dRTC Chain",
  nativeCurrency: {
    name: "Ethereum",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://huddle01.calderachain.xyz/http"],
      webSocket: ["wss://huddle01.calderachain.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Huddle01 Caldera Explorer",
      url: "https://huddle01.calderaexplorer.xyz",
      apiUrl: "https://huddle01.calderaexplorer.xyz/api"
    }
  },
  sourceId: sourceId25
});

// node_modules/viem/_esm/chains/definitions/huddle01Testnet.js
var sourceId26 = 421614;
var huddle01Testnet = defineChain({
  id: 2524852,
  name: "Huddle01 dRTC Chain Testnet",
  nativeCurrency: {
    name: "Ethereum",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://huddle-testnet.rpc.caldera.xyz/http"],
      webSocket: ["wss://huddle-testnet.rpc.caldera.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Huddle01 Caldera Explorer",
      url: "https://huddle-testnet.explorer.caldera.xyz",
      apiUrl: "https://huddle-testnet.explorer.caldera.xyz/api"
    }
  },
  sourceId: sourceId26
});

// node_modules/viem/_esm/chains/definitions/humanity.js
var humanity = defineChain({
  id: 6985385,
  name: "Humanity",
  nativeCurrency: {
    name: "H",
    symbol: "H",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://humanity-mainnet.g.alchemy.com/public"]
    }
  },
  blockExplorers: {
    default: {
      name: "Humanity Mainnet Explorer",
      url: "https://humanity-mainnet.explorer.alchemy.com",
      apiUrl: "https://humanity-mainnet.explorer.alchemy.com/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/humanityTestnet.js
var humanityTestnet = defineChain({
  id: 7080969,
  name: "Humanity Testnet",
  nativeCurrency: {
    name: "tHP",
    symbol: "tHP",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.humanity.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Humanity Testnet Explorer",
      url: "https://humanity-testnet.explorer.alchemy.com",
      apiUrl: "https://humanity-testnet.explorer.alchemy.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/humanode.js
var humanode = defineChain({
  id: 5234,
  name: "Humanode",
  nativeCurrency: { name: "HMND", symbol: "HMND", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://explorer-rpc-http.mainnet.stages.humanode.io"],
      webSocket: ["wss://explorer-rpc-ws.mainnet.stages.humanode.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Subscan",
      url: "https://humanode.subscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4413097
    }
  }
});

// node_modules/viem/_esm/chains/definitions/humanodeTestnet5.js
var humanodeTestnet5 = defineChain({
  id: 14853,
  name: "Humanode Testnet 5",
  nativeCurrency: { name: "HMND", symbol: "HMND", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://explorer-rpc-http.testnet5.stages.humanode.io"],
      webSocket: ["wss://explorer-rpc-ws.testnet5.stages.humanode.io"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/hychain.js
var hychain = defineChain({
  id: 2911,
  name: "HYCHAIN",
  nativeCurrency: { name: "HYTOPIA", symbol: "TOPIA", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.hychain.com/http"] }
  },
  blockExplorers: {
    default: {
      name: "HYCHAIN Explorer",
      url: "https://explorer.hychain.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/hychainTestnet.js
var hychainTestnet = defineChain({
  id: 29112,
  name: "HYCHAIN Testnet",
  nativeCurrency: { name: "HYTOPIA", symbol: "TOPIA", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.hychain.com/http"] }
  },
  blockExplorers: {
    default: {
      name: "HYCHAIN Explorer",
      url: "https://testnet-rpc.hychain.com/http"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/hyperliquidEvmTestnet.js
var hyperliquidEvmTestnet = defineChain({
  id: 998,
  name: "Hyperliquid EVM Testnet",
  nativeCurrency: { name: "HYPE", symbol: "HYPE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.hyperliquid-testnet.xyz/evm"]
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/icbNetwork.js
var icbNetwork = defineChain({
  id: 73115,
  name: "ICB Network",
  nativeCurrency: {
    decimals: 18,
    name: "ICB Native Token",
    symbol: "ICBX"
  },
  rpcUrls: {
    default: { http: ["https://rpc1-mainnet.icbnetwork.info"] }
  },
  blockExplorers: {
    default: {
      name: "ICB Explorer",
      url: "https://icbscan.io",
      apiUrl: "https://icbscan.io/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/idchain.js
var idchain = defineChain({
  id: 74,
  name: "IDChain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "EIDI",
    symbol: "EIDI"
  },
  rpcUrls: {
    default: {
      http: ["https://idchain.one/rpc"],
      webSocket: ["wss://idchain.one/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "IDChain Explorer",
      url: "https://explorer.idchain.one"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/immutableZkEvm.js
var immutableZkEvm = defineChain({
  id: 13371,
  name: "Immutable zkEVM",
  nativeCurrency: {
    decimals: 18,
    name: "Immutable Coin",
    symbol: "IMX"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.immutable.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Immutable Explorer",
      url: "https://explorer.immutable.com",
      apiUrl: "https://explorer.immutable.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x236bdA4589e44e6850f5aC6a74BfCa398a86c6c0",
      blockCreated: 4335972
    }
  }
});

// node_modules/viem/_esm/chains/definitions/immutableZkEvmTestnet.js
var immutableZkEvmTestnet = defineChain({
  id: 13473,
  name: "Immutable zkEVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Immutable Coin",
    symbol: "IMX"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.immutable.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Immutable Testnet Explorer",
      url: "https://explorer.testnet.immutable.com/"
    }
  },
  contracts: {
    multicall3: {
      address: "0x2CC787Ed364600B0222361C4188308Fa8E68bA60",
      blockCreated: 5977391
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/inEVM.js
var inEVM = defineChain({
  id: 2525,
  name: "inEVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Injective",
    symbol: "INJ"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.rpc.inevm.com/http"] }
  },
  blockExplorers: {
    default: {
      name: "inEVM Explorer",
      url: "https://inevm.calderaexplorer.xyz",
      apiUrl: "https://inevm.calderaexplorer.xyz/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 118606
    }
  }
});

// node_modules/viem/_esm/chains/definitions/initVerse.js
var initVerse = defineChain({
  id: 7233,
  name: "InitVerse Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "InitVerse",
    symbol: "INI"
  },
  rpcUrls: {
    default: { http: ["https://rpc-mainnet.inichain.com"] }
  },
  blockExplorers: {
    default: {
      name: "InitVerseScan",
      url: "https://www.iniscan.com",
      apiUrl: "https://explorer-api.inichain.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x83466BE48A067115FFF91f7b892Ed1726d032e47",
      blockCreated: 2318
    }
  }
});

// node_modules/viem/_esm/chains/definitions/initVerseGenesis.js
var initVerseGenesis = defineChain({
  id: 7234,
  name: "InitVerse Genesis Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "InitVerse",
    symbol: "INI"
  },
  rpcUrls: {
    default: { http: ["https://rpc-testnet.inichain.com"] }
  },
  blockExplorers: {
    default: {
      name: "InitVerseGenesisScan",
      url: "https://genesis-testnet.iniscan.com",
      apiUrl: "https://explorer-testnet-api.inichain.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0cF32CBDd6c437331EA4f85ed2d881A5379B5a6F",
      blockCreated: 16361
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/injective.js
var injective = defineChain({
  id: 1776,
  name: "Injective",
  nativeCurrency: {
    decimals: 18,
    name: "Injective",
    symbol: "INJ"
  },
  rpcUrls: {
    default: {
      http: ["https://sentry.evm-rpc.injective.network"],
      webSocket: ["wss://sentry.evm-ws.injective.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Injective Explorer",
      url: "https://blockscout.injective.network",
      apiUrl: "https://blockscout.injective.network/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/injectiveTestnet.js
var injectiveTestnet = defineChain({
  id: 1439,
  name: "Injective Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Injective",
    symbol: "INJ"
  },
  rpcUrls: {
    default: {
      http: ["https://k8s.testnet.json-rpc.injective.network"],
      webSocket: ["wss://k8s.testnet.ws.injective.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Injective Explorer",
      url: "https://testnet.blockscout.injective.network",
      apiUrl: "https://testnet.blockscout.injective.network/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/ink.js
var sourceId27 = 1;
var ink = defineChain({
  ...chainConfig2,
  id: 57073,
  name: "Ink",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-gel.inkonchain.com",
        "https://rpc-qnd.inkonchain.com"
      ],
      webSocket: [
        "wss://rpc-gel.inkonchain.com",
        "wss://rpc-qnd.inkonchain.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.inkonchain.com",
      apiUrl: "https://explorer.inkonchain.com/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId27]: {
        address: "0x10d7b35078d3baabb96dd45a9143b94be65b12cd"
      }
    },
    portal: {
      [sourceId27]: {
        address: "0x5d66c1782664115999c47c9fa5cd031f495d3e4f"
      }
    },
    l1StandardBridge: {
      [sourceId27]: {
        address: "0x88ff1e5b602916615391f55854588efcbb7663f0"
      }
    }
  },
  testnet: false,
  sourceId: sourceId27
});

// node_modules/viem/_esm/chains/definitions/inkSepolia.js
var sourceId28 = 11155111;
var inkSepolia = defineChain({
  ...chainConfig2,
  id: 763373,
  name: "Ink Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-gel-sepolia.inkonchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer-sepolia.inkonchain.com/",
      apiUrl: "https://explorer-sepolia.inkonchain.com/api/v2"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [sourceId28]: {
        address: "0x860e626c700af381133d9f4af31412a2d1db3d5d"
      }
    },
    portal: {
      [sourceId28]: {
        address: "0x5c1d29c6c9c8b0800692acc95d700bcb4966a1d7"
      }
    },
    l1StandardBridge: {
      [sourceId28]: {
        address: "0x33f60714bbd74d62b66d79213c348614de51901c"
      }
    }
  },
  testnet: true,
  sourceId: sourceId28
});

// node_modules/viem/_esm/chains/definitions/iota.js
var iota = defineChain({
  id: 8822,
  name: "IOTA EVM",
  network: "iotaevm",
  nativeCurrency: {
    decimals: 18,
    name: "IOTA",
    symbol: "IOTA"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.iotaledger.net"],
      webSocket: ["wss://ws.json-rpc.evm.iotaledger.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.evm.iota.org",
      apiUrl: "https://explorer.evm.iota.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 25022
    }
  }
});

// node_modules/viem/_esm/chains/definitions/iotaTestnet.js
var iotaTestnet = defineChain({
  id: 1075,
  name: "IOTA EVM Testnet",
  network: "iotaevm-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "IOTA",
    symbol: "IOTA"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.testnet.iotaledger.net"],
      webSocket: ["wss://ws.json-rpc.evm.testnet.iotaledger.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.evm.testnet.iotaledger.net",
      apiUrl: "https://explorer.evm.testnet.iotaledger.net/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/iotex.js
var iotex = defineChain({
  id: 4689,
  name: "IoTeX",
  nativeCurrency: {
    decimals: 18,
    name: "IoTeX",
    symbol: "IOTX"
  },
  rpcUrls: {
    default: {
      http: ["https://babel-api.mainnet.iotex.io"],
      webSocket: ["wss://babel-api.mainnet.iotex.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "IoTeXScan",
      url: "https://iotexscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 22163670
    }
  }
});

// node_modules/viem/_esm/chains/definitions/iotexTestnet.js
var iotexTestnet = defineChain({
  id: 4690,
  name: "IoTeX Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "IoTeX",
    symbol: "IOTX"
  },
  rpcUrls: {
    default: {
      http: ["https://babel-api.testnet.iotex.io"],
      webSocket: ["wss://babel-api.testnet.iotex.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "IoTeXScan",
      url: "https://testnet.iotexscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xb5cecD6894c6f473Ec726A176f1512399A2e355d",
      blockCreated: 24347592
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/iSunCoin.js
var iSunCoin = defineChain({
  id: 8017,
  name: "iSunCoin Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "ISC",
    symbol: "ISC"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.isuncoin.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "iSunCoin Explorer",
      url: "https://baifa.io/app/chains/8017"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/jbc.js
var jbc = defineChain({
  id: 8899,
  name: "JB Chain",
  network: "jbc",
  nativeCurrency: { name: "JBC", symbol: "JBC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-l1.jibchain.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp-l1.jibchain.net",
      apiUrl: "https://exp-l1.jibchain.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xc0C8C486D1466C57Efe13C2bf000d4c56F47CBdC",
      blockCreated: 2299048
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/jbcTestnet.js
var jbcTestnet = defineChain({
  id: 88991,
  name: "Jibchain Testnet",
  nativeCurrency: { name: "tJBC", symbol: "tJBC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.jibchain.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp.testnet.jibchain.net",
      apiUrl: "https://exp.testnet.jibchain.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xa1a858ad9041B4741e620355a3F96B3c78e70ecE",
      blockCreated: 32848
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/jocMainnet.js
var jocMainnet = defineChain({
  id: 81,
  name: "Japan Open Chain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Japan Open Chain Token",
    symbol: "JOC"
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-1.japanopenchain.org:8545",
        "https://rpc-2.japanopenchain.org:8545",
        "https://rpc-3.japanopenchain.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Block Explorer",
      url: "https://explorer.japanopenchain.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/jocTestnet.js
var jocTestnet = defineChain({
  id: 10081,
  name: "Japan Open Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Japan Open Chain Testnet Token",
    symbol: "JOCT"
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-1.testnet.japanopenchain.org:8545",
        "https://rpc-2.testnet.japanopenchain.org:8545",
        "https://rpc-3.testnet.japanopenchain.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Testnet Block Explorer",
      url: "https://explorer.testnet.japanopenchain.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/jovay.js
var jovay = defineChain({
  id: 5734951,
  name: "Jovay Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://api.zan.top/public/jovay-mainnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "Jovay Explorer",
      url: "https://explorer.jovay.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/jovaySepolia.js
var jovaySepolia = defineChain({
  id: 2019775,
  name: "Jovay Sepolia Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://api.zan.top/public/jovay-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "Jovay Testnet Explorer",
      url: "https://sepolia-explorer.jovay.io/l2"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/juneo.js
var juneo = defineChain({
  id: 45003,
  name: "Juneo JUNE-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "JUNE-Chain",
    symbol: "JUNE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/JUNE/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/2",
      apiUrl: "https://juneoscan.io/chain/2/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoBCH1Chain.js
var juneoBCH1Chain = defineChain({
  id: 45013,
  name: "Juneo BCH1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo BCH1-Chain",
    symbol: "BCH1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/BCH1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/12",
      apiUrl: "https://juneoscan.io/chain/12/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoDAI1Chain.js
var juneoDAI1Chain = defineChain({
  id: 45004,
  name: "Juneo DAI1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo DAI1-Chain",
    symbol: "DAI1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/DAI1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/5",
      apiUrl: "https://juneoscan.io/chain/5/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoDOGE1Chain.js
var juneoDOGE1Chain = defineChain({
  id: 45010,
  name: "Juneo DOGE1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo DOGE1-Chain",
    symbol: "DOGE1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/DOGE1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/10",
      apiUrl: "https://juneoscan.io/chain/10/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoEUR1Chain.js
var juneoEUR1Chain = defineChain({
  id: 45011,
  name: "Juneo EUR1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo EUR1-Chain",
    symbol: "EUR1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/EUR1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/6",
      apiUrl: "https://juneoscan.io/chain/6/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoGLD1Chain.js
var juneoGLD1Chain = defineChain({
  id: 45008,
  name: "Juneo GLD1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo GLD1-Chain",
    symbol: "GLD1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/GLD1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/8",
      apiUrl: "https://juneoscan.io/chain/8/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoLINK1Chain.js
var juneoLINK1Chain = defineChain({
  id: 45014,
  name: "Juneo LINK1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo LINK1-Chain",
    symbol: "LINK1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/LINK1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/13",
      apiUrl: "https://juneoscan.io/chain/13/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoLTC1Chain.js
var juneoLTC1Chain = defineChain({
  id: 45009,
  name: "Juneo LTC1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo LTC1-Chain",
    symbol: "LTC1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/LTC1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/11",
      apiUrl: "https://juneoscan.io/chain/11/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneomBTC1Chain.js
var juneomBTC1Chain = defineChain({
  id: 45007,
  name: "Juneo mBTC1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo mBTC1-Chain",
    symbol: "mBTC1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/mBTC1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/9",
      apiUrl: "https://juneoscan.io/chain/9/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoSGD1Chain.js
var juneoSGD1Chain = defineChain({
  id: 45012,
  name: "Juneo SGD1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo SGD1-Chain",
    symbol: "SGD1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/SGD1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/7",
      apiUrl: "https://juneoscan.io/chain/7/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoSocotraTestnet.js
var juneoSocotraTestnet = defineChain({
  id: 101003,
  name: "Socotra JUNE-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Socotra JUNE-Chain",
    symbol: "JUNE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.socotra-testnet.network/ext/bc/JUNE/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://socotra.juneoscan.io/chain/2",
      apiUrl: "https://socotra.juneoscan.io/chain/2/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/juneoUSD1Chain.js
var juneoUSD1Chain = defineChain({
  id: 45006,
  name: "Juneo USD1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo USD1-Chain",
    symbol: "USD1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/USD1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/4",
      apiUrl: "https://juneoscan.io/chain/4/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoUSDT1Chain.js
var juneoUSDT1Chain = defineChain({
  id: 45005,
  name: "Juneo USDT1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo USDT1-Chain",
    symbol: "USDT1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/USDT1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/3",
      apiUrl: "https://juneoscan.io/chain/3/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/kaia.js
var kaia = defineChain({
  id: 8217,
  name: "Kaia",
  nativeCurrency: {
    decimals: 18,
    name: "Kaia",
    symbol: "KAIA"
  },
  rpcUrls: {
    default: { http: ["https://public-en.node.kaia.io"] }
  },
  blockExplorers: {
    default: {
      name: "KaiaScan",
      url: "https://kaiascan.io",
      apiUrl: "https://api-cypress.klaytnscope.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 96002415
    }
  }
});

// node_modules/viem/_esm/chains/definitions/kairos.js
var kairos = defineChain({
  id: 1001,
  name: "Kairos Testnet",
  network: "kairos",
  nativeCurrency: {
    decimals: 18,
    name: "Kairos KAIA",
    symbol: "KAIA"
  },
  rpcUrls: {
    default: { http: ["https://public-en-kairos.node.kaia.io"] }
  },
  blockExplorers: {
    default: {
      name: "KaiaScan",
      url: "https://kairos.kaiascan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 123390593
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/kakarotSepolia.js
var kakarotSepolia = defineChain({
  id: 1802203764,
  name: "Kakarot Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.kakarot.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kakarot Scan",
      url: "https://sepolia.kakarotscan.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/kakarotStarknetSepolia.js
var kakarotStarknetSepolia = defineChain({
  id: 920637907288165,
  name: "Kakarot Starknet Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.kakarot.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kakarot Scan",
      url: "https://sepolia.kakarotscan.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/kardiaChain.js
var kardiaChain = defineChain({
  id: 24,
  name: "KardiaChain Mainnet",
  nativeCurrency: { name: "KAI", symbol: "KAI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.kardiachain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "KardiaChain Explorer",
      url: "https://explorer.kardiachain.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/karura.js
var karura = defineChain({
  id: 686,
  name: "Karura",
  network: "karura",
  nativeCurrency: {
    name: "Karura",
    symbol: "KAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-karura.aca-api.network"],
      webSocket: ["wss://eth-rpc-karura.aca-api.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Karura Blockscout",
      url: "https://blockscout.karura.network",
      apiUrl: "https://blockscout.karura.network/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/katana.js
var katana = defineChain({
  id: 747474,
  name: "Katana",
  network: "katana",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.katana.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "katana explorer",
      url: "https://explorer.katanarpc.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/kava.js
var kava = defineChain({
  id: 2222,
  name: "Kava EVM",
  network: "kava-mainnet",
  nativeCurrency: {
    name: "Kava",
    symbol: "KAVA",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://evm.kava.io"] }
  },
  blockExplorers: {
    default: {
      name: "Kava EVM Explorer",
      url: "https://kavascan.com",
      apiUrl: "https://kavascan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3661165
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/kavaTestnet.js
var kavaTestnet = defineChain({
  id: 2221,
  name: "Kava EVM Testnet",
  network: "kava-testnet",
  nativeCurrency: {
    name: "Kava",
    symbol: "KAVA",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://evm.testnet.kava.io"] }
  },
  blockExplorers: {
    default: {
      name: "Kava EVM Testnet Explorer",
      url: "https://testnet.kavascan.com/",
      apiUrl: "https://testnet.kavascan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xDf1D724A7166261eEB015418fe8c7679BBEa7fd6",
      blockCreated: 7242179
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/kcc.js
var kcc = defineChain({
  id: 321,
  name: "KCC Mainnet",
  network: "KCC Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "KCS",
    symbol: "KCS"
  },
  rpcUrls: {
    default: {
      http: ["https://kcc-rpc.com"]
    }
  },
  blockExplorers: {
    default: { name: "KCC Explorer", url: "https://explorer.kcc.io" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11760430
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/kiiTestnet.js
var kiiTestnetOro = defineChain({
  id: 1336,
  name: "Kii Testnet Oro",
  network: "kii-testnet-oro",
  nativeCurrency: {
    name: "Kii",
    symbol: "KII",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.uno.sentry.testnet.v3.kiivalidator.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "KiiExplorer",
      url: "https://explorer.kiichain.io/testnet"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/kinto.js
var kinto = defineChain({
  id: 7887,
  name: "Kinto Mainnet",
  network: "Kinto Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.kinto.xyz/http"] }
  },
  blockExplorers: {
    default: {
      name: "Kinto Explorer",
      url: "https://explorer.kinto.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/klaytn.js
var klaytn = defineChain({
  id: 8217,
  name: "Klaytn",
  nativeCurrency: {
    decimals: 18,
    name: "Klaytn",
    symbol: "KLAY"
  },
  rpcUrls: {
    default: { http: ["https://public-en-cypress.klaytn.net"] }
  },
  blockExplorers: {
    default: {
      name: "KlaytnScope",
      url: "https://scope.klaytn.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 96002415
    }
  }
});

// node_modules/viem/_esm/chains/definitions/klaytnBaobab.js
var klaytnBaobab = defineChain({
  id: 1001,
  name: "Klaytn Baobab Testnet",
  network: "klaytn-baobab",
  nativeCurrency: {
    decimals: 18,
    name: "Baobab Klaytn",
    symbol: "KLAY"
  },
  rpcUrls: {
    default: { http: ["https://public-en-baobab.klaytn.net"] }
  },
  blockExplorers: {
    default: {
      name: "KlaytnScope",
      url: "https://baobab.klaytnscope.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 123390593
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/koi.js
var koi = defineChain({
  id: 701,
  name: "Koi Network",
  nativeCurrency: {
    decimals: 18,
    name: "Koi Network Native Token",
    symbol: "KRING"
  },
  rpcUrls: {
    default: {
      http: ["https://koi-rpc.darwinia.network"],
      webSocket: ["wss://koi-rpc.darwinia.network"]
    }
  },
  blockExplorers: {
    default: { name: "Blockscout", url: "https://koi-scan.darwinia.network" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 180001
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/kroma.js
var kroma = defineChain({
  id: 255,
  name: "Kroma",
  nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.kroma.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kroma Explorer",
      url: "https://blockscout.kroma.network",
      apiUrl: "https://blockscout.kroma.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 16054868
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/kromaSepolia.js
var kromaSepolia = defineChain({
  id: 2358,
  name: "Kroma Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.sepolia.kroma.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kroma Sepolia Explorer",
      url: "https://blockscout.sepolia.kroma.network",
      apiUrl: "https://blockscout.sepolia.kroma.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 8900914
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/l3x.js
var l3x = defineChain({
  id: 12324,
  name: "L3X Protocol",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-mainnet.l3x.com"],
      webSocket: ["wss://rpc-mainnet.l3x.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "L3X Mainnet Explorer",
      url: "https://explorer.l3x.com",
      apiUrl: "https://explorer.l3x.com/api/v2"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/l3xTestnet.js
var l3xTestnet = defineChain({
  id: 12325,
  name: "L3X Protocol Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.l3x.com"],
      webSocket: ["wss://rpc-testnet.l3x.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "L3X Testnet Explorer",
      url: "https://explorer-testnet.l3x.com",
      apiUrl: "https://explorer-testnet.l3x.com/api/v2"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lavita.js
var lavita = defineChain({
  id: 360890,
  name: "LAVITA Mainnet",
  nativeCurrency: { name: "vTFUEL", symbol: "vTFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://tsub360890-eth-rpc.thetatoken.org/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "LAVITA Explorer",
      url: "https://tsub360890-explorer.thetatoken.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/lens.js
var lens = defineChain({
  id: 232,
  name: "Lens",
  nativeCurrency: { name: "GHO", symbol: "GHO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.lens.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lens Block Explorer",
      url: "https://explorer.lens.xyz",
      apiUrl: "https://explorer.lens.xyz/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/lensTestnet.js
var lensTestnet = defineChain({
  id: 37111,
  name: "Lens Testnet",
  nativeCurrency: { name: "GRASS", symbol: "GRASS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.lens.dev"],
      webSocket: ["wss://rpc.testnet.lens.dev/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lens Block Explorer",
      url: "https://block-explorer.testnet.lens.dev",
      apiUrl: "https://block-explorer-api.staging.lens.dev/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lestnet.js
var lestnet = defineChain({
  id: 21363,
  name: "Lestnet",
  nativeCurrency: { name: "Lestnet Ether", symbol: "LETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://service.lestnet.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lestnet Explorer",
      url: "https://explore.lestnet.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lightlinkPegasus.js
var lightlinkPegasus = defineChain({
  id: 1891,
  name: "LightLink Pegasus Testnet",
  network: "lightlink-pegasus",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://replicator.pegasus.lightlink.io/rpc/v1"]
    }
  },
  blockExplorers: {
    default: {
      name: "LightLink Pegasus Explorer",
      url: "https://pegasus.lightlink.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 127188532
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lightlinkPhoenix.js
var lightlinkPhoenix = defineChain({
  id: 1890,
  name: "LightLink Phoenix Mainnet",
  network: "lightlink-phoenix",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://replicator.phoenix.lightlink.io/rpc/v1"]
    }
  },
  blockExplorers: {
    default: {
      name: "LightLink Phoenix Explorer",
      url: "https://phoenix.lightlink.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 125499184
    }
  },
  testnet: false
});

// node_modules/viem/_esm/linea/actions/estimateGas.js
async function estimateGas(client, args) {
  const { account: account_ = client.account } = args;
  if (!account_)
    throw new AccountNotFoundError();
  const account = parseAccount(account_);
  try {
    const { accessList, blockNumber, blockTag, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
    const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : void 0;
    const block = blockNumberHex || blockTag;
    assertRequest(args);
    const chainFormat = client.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || formatTransactionRequest;
    const request = format({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(rest, { format: chainFormat }),
      account,
      accessList,
      data,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    }, "estimateGas");
    const { baseFeePerGas, gasLimit, priorityFeePerGas } = await client.request({
      method: "linea_estimateGas",
      params: block ? [request, block] : [request]
    });
    return {
      baseFeePerGas: BigInt(baseFeePerGas),
      gasLimit: BigInt(gasLimit),
      priorityFeePerGas: BigInt(priorityFeePerGas)
    };
  } catch (err) {
    throw getCallError(err, {
      ...args,
      account,
      chain: client.chain
    });
  }
}

// node_modules/viem/_esm/linea/chainConfig.js
var chainConfig4 = {
  fees: {
    estimateFeesPerGas,
    async maxPriorityFeePerGas({ block, client, request }) {
      const response = await estimateFeesPerGas({
        block,
        client,
        multiply: (x) => x,
        request,
        type: "eip1559"
      });
      if (!response?.maxPriorityFeePerGas)
        return null;
      return response.maxPriorityFeePerGas;
    }
  }
};
async function estimateFeesPerGas({ client, multiply, request, type }) {
  try {
    const response = await estimateGas(client, {
      ...request,
      account: request?.account
    });
    const { priorityFeePerGas: maxPriorityFeePerGas } = response;
    const baseFeePerGas = multiply(BigInt(response.baseFeePerGas));
    const maxFeePerGas = baseFeePerGas + maxPriorityFeePerGas;
    if (type === "legacy")
      return { gasPrice: maxFeePerGas };
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  } catch {
    return null;
  }
}

// node_modules/viem/_esm/chains/definitions/linea.js
var linea = defineChain({
  ...chainConfig4,
  id: 59144,
  name: "Linea Mainnet",
  blockTime: 2e3,
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.linea.build"],
      webSocket: ["wss://rpc.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://lineascan.build",
      apiUrl: "https://api.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 42
    },
    ensRegistry: {
      address: "0x50130b669B28C339991d8676FA73CF122a121267",
      blockCreated: 6682888
    },
    ensUniversalResolver: {
      address: "0x4D41762915F83c76EcaF6776d9b08076aA32b492",
      blockCreated: 22222151
    }
  },
  ensTlds: [".linea.eth"],
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/lineaGoerli.js
var lineaGoerli = defineChain({
  id: 59140,
  name: "Linea Goerli Testnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.goerli.linea.build"],
      webSocket: ["wss://rpc.goerli.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli.lineascan.build",
      apiUrl: "https://api-goerli.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 498623
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lineaSepolia.js
var lineaSepolia = defineChain({
  ...chainConfig4,
  id: 59141,
  name: "Linea Sepolia Testnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.sepolia.linea.build"],
      webSocket: ["wss://rpc.sepolia.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.lineascan.build",
      apiUrl: "https://api-sepolia.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 227427
    },
    ensRegistry: {
      address: "0x5B2636F0f2137B4aE722C01dd5122D7d3e9541f7",
      blockCreated: 2395094
    },
    ensUniversalResolver: {
      address: "0x4D41762915F83c76EcaF6776d9b08076aA32b492",
      blockCreated: 17168484
    }
  },
  ensTlds: [".linea.eth"],
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lineaTestnet.js
var lineaTestnet = defineChain({
  id: 59140,
  name: "Linea Goerli Testnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.goerli.linea.build"],
      webSocket: ["wss://rpc.goerli.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli.lineascan.build",
      apiUrl: "https://goerli.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 498623
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lisk.js
var sourceId29 = 1;
var lisk = defineChain({
  ...chainConfig2,
  id: 1135,
  name: "Lisk",
  network: "lisk",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.api.lisk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.lisk.com",
      apiUrl: "https://blockscout.lisk.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xA9d71E1dd7ca26F26e656E66d6AA81ed7f745bf0"
    },
    l2OutputOracle: {
      [sourceId29]: {
        address: "0x113cB99283AF242Da0A0C54347667edF531Aa7d6"
      }
    },
    portal: {
      [sourceId29]: {
        address: "0x26dB93F8b8b4f7016240af62F7730979d353f9A7"
      }
    },
    l1StandardBridge: {
      [sourceId29]: {
        address: "0x2658723Bf70c7667De6B25F99fcce13A16D25d08"
      }
    }
  },
  sourceId: sourceId29
});

// node_modules/viem/_esm/chains/definitions/liskSepolia.js
var sourceId30 = 11155111;
var liskSepolia = defineChain({
  ...chainConfig2,
  id: 4202,
  network: "lisk-sepolia",
  name: "Lisk Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.sepolia-api.lisk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepolia-blockscout.lisk.com",
      apiUrl: "https://sepolia-blockscout.lisk.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId30]: {
        address: "0xA0E35F56C318DE1bD5D9ca6A94Fe7e37C5663348"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId30]: {
        address: "0xe3d90F21490686Ec7eF37BE788E02dfC12787264"
      }
    },
    l1StandardBridge: {
      [sourceId30]: {
        address: "0x1Fb30e446eA791cd1f011675E5F3f5311b70faF5"
      }
    }
  },
  testnet: true,
  sourceId: sourceId30
});

// node_modules/viem/_esm/chains/definitions/loadAlphanet.js
var loadAlphanet = defineChain({
  id: 9496,
  name: "Load Alphanet",
  nativeCurrency: { name: "Testnet LOAD", symbol: "tLOAD", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://alphanet.load.network"] }
  },
  blockExplorers: {
    default: {
      name: "Load Alphanet Explorer",
      url: "https://explorer.load.network"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/localhost.js
var localhost = defineChain({
  id: 1337,
  name: "Localhost",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["http://127.0.0.1:8545"] }
  }
});

// node_modules/viem/_esm/chains/definitions/loop.js
var loop = defineChain({
  id: 15551,
  name: "LoopNetwork Mainnet",
  nativeCurrency: {
    name: "LOOP",
    symbol: "LOOP",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://api.mainnetloop.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "LoopNetwork Blockchain Explorer",
      url: "https://explorer.mainnetloop.com/"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/lukso.js
var lukso = defineChain({
  id: 42,
  network: "lukso",
  name: "LUKSO",
  nativeCurrency: {
    name: "LUKSO",
    symbol: "LYX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.lukso.network"],
      webSocket: ["wss://ws-rpc.mainnet.lukso.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "LUKSO Mainnet Explorer",
      url: "https://explorer.execution.mainnet.lukso.network",
      apiUrl: "https://api.explorer.execution.mainnet.lukso.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 468183
    }
  }
});

// node_modules/viem/_esm/chains/definitions/luksoTestnet.js
var luksoTestnet = defineChain({
  id: 4201,
  name: "LUKSO Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "LUKSO Testnet",
    symbol: "LYXt"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.lukso.network"],
      webSocket: ["wss://ws-rpc.testnet.lukso.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "LUKSO Testnet Explorer",
      url: "https://explorer.execution.testnet.lukso.network",
      apiUrl: "https://api.explorer.execution.testnet.lukso.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 605348
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lumiaMainnet.js
var lumiaMainnet = defineChain({
  id: 994873017,
  name: "Lumia Mainnet",
  network: "LumiaMainnet",
  nativeCurrency: { name: "Lumia", symbol: "LUMIA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.lumia.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumia Explorer",
      url: "https://explorer.lumia.org/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3975939
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/lumiaTestnet.js
var lumiaTestnet = defineChain({
  id: 1952959480,
  name: "Lumia Testnet",
  network: "LumiaTestnet",
  nativeCurrency: {
    name: "Lumia",
    symbol: "LUMIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.lumia.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumia Testnet Explorer",
      url: "https://testnet-explorer.lumia.org/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2235063
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lumoz.js
var lumoz = defineChain({
  id: 96370,
  name: "Lumoz",
  nativeCurrency: {
    decimals: 18,
    name: "Lumoz Token",
    symbol: "MOZ"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.lumoz.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumoz Scan",
      url: "https://scan.lumoz.info"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/lumozTestnet.js
var lumozTestnet = defineChain({
  id: 105363,
  name: "Lumoz Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Lumoz Testnet Token",
    symbol: "MOZ"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.lumoz.org"]
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lycan.js
var lycan = defineChain({
  id: 721,
  name: "Lycan",
  nativeCurrency: {
    decimals: 18,
    name: "Lycan",
    symbol: "LYC"
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc.lycanchain.com",
        "https://us-east.lycanchain.com",
        "https://us-west.lycanchain.com",
        "https://eu-north.lycanchain.com",
        "https://eu-west.lycanchain.com",
        "https://asia-southeast.lycanchain.com"
      ],
      webSocket: [
        "wss://rpc.lycanchain.com",
        "wss://us-east.lycanchain.com",
        "wss://us-west.lycanchain.com",
        "wss://eu-north.lycanchain.com",
        "wss://eu-west.lycanchain.com",
        "wss://asia-southeast.lycanchain.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Lycan Explorer",
      url: "https://explorer.lycanchain.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/lyra.js
var lyra = defineChain({
  id: 957,
  name: "Lyra Chain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.lyra.finance"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lyra Explorer",
      url: "https://explorer.lyra.finance",
      apiUrl: "https://explorer.lyra.finance/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1935198
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mainnet.js
var mainnet = defineChain({
  id: 1,
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  blockTime: 12e3,
  rpcUrls: {
    default: {
      http: ["https://eth.merkle.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://etherscan.io",
      apiUrl: "https://api.etherscan.io/api"
    }
  },
  contracts: {
    ensUniversalResolver: {
      address: "0xeeeeeeee14d718c2b47d9923deab1335e144eeee",
      blockCreated: 23085558
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mandala.js
var mandala = defineChain({
  id: 595,
  name: "Mandala TC9",
  network: "mandala",
  nativeCurrency: {
    name: "Mandala",
    symbol: "mACA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-tc9.aca-staging.network"],
      webSocket: ["wss://eth-rpc-tc9.aca-staging.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mandala Blockscout",
      url: "https://blockscout.mandala.aca-staging.network",
      apiUrl: "https://blockscout.mandala.aca-staging.network/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/manta.js
var manta = defineChain({
  id: 169,
  name: "Manta Pacific Mainnet",
  network: "manta",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://pacific-rpc.manta.network/http"] }
  },
  blockExplorers: {
    default: {
      name: "Manta Explorer",
      url: "https://pacific-explorer.manta.network",
      apiUrl: "https://pacific-explorer.manta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 332890
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mantaSepoliaTestnet.js
var mantaSepoliaTestnet = defineChain({
  id: 3441006,
  name: "Manta Pacific Sepolia Testnet",
  network: "manta-sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://pacific-rpc.sepolia-testnet.manta.network/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Manta Sepolia Testnet Explorer",
      url: "https://pacific-explorer.sepolia-testnet.manta.network",
      apiUrl: "https://pacific-explorer.sepolia-testnet.manta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca54918f7B525C8df894668846506767412b53E3",
      blockCreated: 479584
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mantaTestnet.js
var mantaTestnet = defineChain({
  id: 3441005,
  name: "Manta Pacific Testnet",
  network: "manta-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://manta-testnet.calderachain.xyz/http"] }
  },
  blockExplorers: {
    default: {
      name: "Manta Testnet Explorer",
      url: "https://pacific-explorer.testnet.manta.network",
      apiUrl: "https://pacific-explorer.testnet.manta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x211B1643b95Fe76f11eD8880EE810ABD9A4cf56C",
      blockCreated: 419915
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mantle.js
var mantle = defineChain({
  id: 5e3,
  name: "Mantle",
  nativeCurrency: {
    decimals: 18,
    name: "MNT",
    symbol: "MNT"
  },
  rpcUrls: {
    default: { http: ["https://rpc.mantle.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Mantle Explorer",
      url: "https://mantlescan.xyz/",
      apiUrl: "https://api.mantlescan.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 304717
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mantleSepoliaTestnet.js
var mantleSepoliaTestnet = defineChain({
  id: 5003,
  name: "Mantle Sepolia Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MNT",
    symbol: "MNT"
  },
  rpcUrls: {
    default: { http: ["https://rpc.sepolia.mantle.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Mantle Testnet Explorer",
      url: "https://explorer.sepolia.mantle.xyz/",
      apiUrl: "https://explorer.sepolia.mantle.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4584012
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mantleTestnet.js
var mantleTestnet = defineChain({
  id: 5001,
  name: "Mantle Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MNT",
    symbol: "MNT"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.mantle.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Mantle Testnet Explorer",
      url: "https://explorer.testnet.mantle.xyz",
      apiUrl: "https://explorer.testnet.mantle.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 561333
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mantraDuKongEVMTestnet.js
var mantraDuKongEVMTestnet = defineChain({
  id: 5887,
  name: "MANTRA DuKong EVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "OM",
    symbol: "OM"
  },
  rpcUrls: {
    default: { http: ["https://evm.dukong.mantrachain.io"] }
  },
  blockExplorers: {
    default: {
      name: "MANTRAScan",
      url: "https://mantrascan.io/dukong"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mantraEVM.js
var mantraEVM = defineChain({
  id: 5888,
  name: "MANTRA EVM",
  nativeCurrency: {
    decimals: 18,
    name: "OM",
    symbol: "OM"
  },
  rpcUrls: {
    default: {
      http: ["https://evm.mantrachain.io"],
      webSocket: ["https://evm.mantrachain.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "MANTRA Scan",
      url: "https://mantrascan.io/mainnet"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mapProtocol.js
var mapProtocol = defineChain({
  id: 22776,
  name: "MAP Protocol",
  nativeCurrency: {
    decimals: 18,
    name: "MAPO",
    symbol: "MAPO"
  },
  rpcUrls: {
    default: { http: ["https://rpc.maplabs.io"] }
  },
  blockExplorers: {
    default: {
      name: "MAPO Scan",
      url: "https://maposcan.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/matchain.js
var matchain = defineChain({
  id: 698,
  name: "Matchain",
  nativeCurrency: {
    name: "BNB",
    symbol: "BNB",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.matchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Matchain Scan",
      url: "https://matchscan.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/matchainTestnet.js
var matchainTestnet = defineChain({
  id: 699,
  name: "Matchain Testnet",
  nativeCurrency: {
    name: "BNB",
    symbol: "BNB",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://testnet-rpc.matchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Matchain Scan",
      url: "https://testnet.matchscan.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mchVerse.js
var mchVerse = defineChain({
  id: 29548,
  name: "MCH Verse",
  nativeCurrency: { name: "Oasys", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.oasys.mycryptoheroes.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "MCH Verse Explorer",
      url: "https://explorer.oasys.mycryptoheroes.net",
      apiUrl: "https://explorer.oasys.mycryptoheroes.net/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/megaethTestnet.js
var megaethTestnet = defineChain({
  id: 6342,
  blockTime: 1e3,
  name: "MegaETH Testnet",
  nativeCurrency: {
    name: "MegaETH Testnet Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://carrot.megaeth.com/rpc"],
      webSocket: ["wss://carrot.megaeth.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "MegaETH Testnet Explorer",
      url: "https://www.megaexplorer.xyz/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mekong.js
var mekong = defineChain({
  id: 7078815900,
  name: "Mekong Pectra Devnet",
  nativeCurrency: { name: "eth", symbol: "eth", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mekong.ethpandaops.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Block Explorer",
      url: "https://explorer.mekong.ethpandaops.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/meld.js
var meld = defineChain({
  id: 333000333,
  name: "Meld",
  nativeCurrency: {
    decimals: 18,
    name: "Meld",
    symbol: "MELD"
  },
  rpcUrls: {
    default: { http: ["https://rpc-1.meld.com"] }
  },
  blockExplorers: {
    default: { name: "MELDscan", url: "https://meldscan.io" }
  },
  contracts: {
    multicall3: {
      address: "0x769ee5a8e82c15c1b6e358f62ac8eb6e3abe8dc5",
      blockCreated: 360069
    }
  }
});

// node_modules/viem/_esm/chains/definitions/memecore.js
var memecore = defineChain({
  id: 4352,
  name: "MemeCore",
  nativeCurrency: {
    decimals: 18,
    name: "M",
    symbol: "M"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.memecore.net"],
      webSocket: ["wss://ws.memecore.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "MemeCore Explorer",
      url: "https://memecorescan.io",
      apiUrl: "https://api.memecorescan.io/api"
    },
    okx: {
      name: "MemeCore Explorer",
      url: "https://web3.okx.com/explorer/memecore"
    },
    memecore: {
      name: "MemeCore Explorer",
      url: "https://blockscout.memecore.com",
      apiUrl: "https://blockscout.memecore.com/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/memecoreFormicariumTestnet.js
var formicarium = defineChain({
  id: 43521,
  name: "Formicarium",
  nativeCurrency: {
    decimals: 18,
    name: "M",
    symbol: "M"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.formicarium.memecore.net"],
      webSocket: ["wss://ws.formicarium.memecore.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "MemeCore Testnet Explorer",
      url: "https://formicarium.memecorescan.io"
    },
    okx: {
      name: "MemeCore Testnet Explorer",
      url: "https://web3.okx.com/explorer/formicarium-testnet"
    },
    memecore: {
      name: "MemeCore Testnet Explorer",
      url: "https://formicarium.blockscout.memecore.com",
      apiUrl: "https://formicarium.blockscout.memecore.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/merlin.js
var merlin = defineChain({
  id: 4200,
  name: "Merlin",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.merlinchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://scan.merlinchain.io",
      apiUrl: "https://scan.merlinchain.io/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/merlinErigonTestnet.js
var merlinErigonTestnet = defineChain({
  id: 4203,
  name: "Merlin Erigon Testnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://testnet-erigon-rpc.merlinchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://testnet-erigon-scan.merlinchain.io",
      apiUrl: "https://testnet-erigon-scan.merlinchain.io/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/metachain.js
var metachain = defineChain({
  id: 571,
  name: "MetaChain Mainnet",
  nativeCurrency: { name: "Metatime Coin", symbol: "MTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.metatime.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "MetaExplorer",
      url: "https://explorer.metatime.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0000000000000000000000000000000000003001",
      blockCreated: 0
    }
  }
});

// node_modules/viem/_esm/chains/definitions/metachainIstanbul.js
var metachainIstanbul = defineChain({
  id: 1453,
  name: "MetaChain Istanbul",
  nativeCurrency: { name: "Metatime Coin", symbol: "MTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://istanbul-rpc.metachain.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "MetaExplorer",
      url: "https://istanbul-explorer.metachain.dev"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0000000000000000000000000000000000003001",
      blockCreated: 0
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/metadium.js
var metadium = defineChain({
  id: 11,
  name: "Metadium Network",
  nativeCurrency: {
    decimals: 18,
    name: "META",
    symbol: "META"
  },
  rpcUrls: {
    default: { http: ["https://api.metadium.com/prod"] }
  },
  blockExplorers: {
    default: {
      name: "Metadium Explorer",
      url: "https://explorer.metadium.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/metalL2.js
var sourceId31 = 1;
var metalL2 = defineChain({
  ...chainConfig2,
  id: 1750,
  name: "Metal L2",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.metall2.com"],
      webSocket: ["wss://rpc.metall2.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.metall2.com",
      apiUrl: "https://explorer.metall2.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId31]: {
        address: "0x3B1F7aDa0Fcc26B13515af752Dd07fB1CAc11426"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    portal: {
      [sourceId31]: {
        address: "0x3F37aBdE2C6b5B2ed6F8045787Df1ED1E3753956"
      }
    },
    l1StandardBridge: {
      [sourceId31]: {
        address: "0x6d0f65D59b55B0FEC5d2d15365154DcADC140BF3"
      }
    }
  },
  sourceId: sourceId31
});

// node_modules/viem/_esm/chains/definitions/meter.js
var meter = defineChain({
  id: 82,
  name: "Meter",
  nativeCurrency: {
    decimals: 18,
    name: "MTR",
    symbol: "MTR"
  },
  rpcUrls: {
    default: { http: ["https://rpc.meter.io"] }
  },
  blockExplorers: {
    default: {
      name: "MeterScan",
      url: "https://scan.meter.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/meterTestnet.js
var meterTestnet = defineChain({
  id: 83,
  name: "Meter Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MTR",
    symbol: "MTR"
  },
  rpcUrls: {
    default: { http: ["https://rpctest.meter.io"] }
  },
  blockExplorers: {
    default: {
      name: "MeterTestnetScan",
      url: "https://scan-warringstakes.meter.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/metis.js
var metis = defineChain({
  id: 1088,
  name: "Metis",
  nativeCurrency: {
    decimals: 18,
    name: "Metis",
    symbol: "METIS"
  },
  rpcUrls: {
    default: {
      http: [
        "https://metis.rpc.hypersync.xyz",
        "https://metis-pokt.nodies.app",
        "https://api.blockeden.xyz/metis/67nCBdZQSH9z3YqDDjdm",
        "https://metis-andromeda.rpc.thirdweb.com",
        "https://metis-andromeda.gateway.tenderly.co",
        "https://metis.api.onfinality.io/public",
        "https://andromeda.metis.io/?owner=1088",
        "https://metis-mainnet.public.blastapi.io"
      ],
      webSocket: ["wss://metis-rpc.publicnode.com", "wss://metis.drpc.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Metis Explorer",
      url: "https://explorer.metis.io",
      apiUrl: "https://api.routescan.io/v2/network/mainnet/evm/1088/etherscan/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2338552
    }
  }
});

// node_modules/viem/_esm/chains/definitions/metisGoerli.js
var metisGoerli = defineChain({
  id: 599,
  name: "Metis Goerli",
  nativeCurrency: {
    decimals: 18,
    name: "Metis Goerli",
    symbol: "METIS"
  },
  rpcUrls: {
    default: { http: ["https://goerli.gateway.metisdevops.link"] }
  },
  blockExplorers: {
    default: {
      name: "Metis Goerli Explorer",
      url: "https://goerli.explorer.metisdevops.link",
      apiUrl: "https://goerli.explorer.metisdevops.link/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1006207
    }
  }
});

// node_modules/viem/_esm/chains/definitions/metisSepolia.js
var metisSepolia = defineChain({
  id: 59902,
  name: "Metis Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Test Metis",
    symbol: "tMETIS"
  },
  rpcUrls: {
    default: {
      http: [
        "https://sepolia.metisdevops.link",
        "https://metis-sepolia-rpc.publicnode.com",
        "https://metis-sepolia.gateway.tenderly.co"
      ],
      webSocket: ["wss://metis-sepolia-rpc.publicnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Metis Sepolia Explorer",
      url: "https://sepolia-explorer.metisdevops.link",
      apiUrl: "https://sepolia-explorer.metisdevops.link/api-docs"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 224185
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mev.js
var mev = defineChain({
  id: 7518,
  name: "MEVerse Chain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "MEVerse",
    symbol: "MEV"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.meversemainnet.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://www.meversescan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 86881340
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mevTestnet.js
var mevTestnet = defineChain({
  id: 4759,
  name: "MEVerse Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MEVerse",
    symbol: "MEV"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.meversetestnet.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://testnet.meversescan.io/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 64371115
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mint.js
var mint = defineChain({
  id: 185,
  name: "Mint Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mintchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mintchain explorer",
      url: "https://explorer.mintchain.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/mintSepoliaTestnet.js
var mintSepoliaTestnet = defineChain({
  id: 1686,
  name: "Mint Sepolia Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.mintchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mintchain Testnet explorer",
      url: "https://testnet-explorer.mintchain.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mitosisTestnet.js
var mitosisTestnet = defineChain({
  id: 124832,
  name: "Mitosis Testnet",
  nativeCurrency: { name: "MITO", symbol: "MITO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.mitosis.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mitosis testnet explorer",
      url: "https://testnet.mitosiscan.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mode.js
var sourceId32 = 1;
var mode = defineChain({
  ...chainConfig2,
  id: 34443,
  name: "Mode Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.mode.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Modescan",
      url: "https://modescan.io"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2465882
    },
    l2OutputOracle: {
      [sourceId32]: {
        address: "0x4317ba146D4933D889518a3e5E11Fe7a53199b04"
      }
    },
    portal: {
      [sourceId32]: {
        address: "0x8B34b14c7c7123459Cf3076b8Cb929BE097d0C07"
      }
    },
    l1StandardBridge: {
      [sourceId32]: {
        address: "0x735aDBbE72226BD52e818E7181953f42E3b0FF21"
      }
    }
  },
  sourceId: sourceId32
});

// node_modules/viem/_esm/chains/definitions/modeTestnet.js
var sourceId33 = 11155111;
var modeTestnet = defineChain({
  ...chainConfig2,
  id: 919,
  name: "Mode Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.mode.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepolia.explorer.mode.network",
      apiUrl: "https://sepolia.explorer.mode.network/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId33]: {
        address: "0x2634BD65ba27AB63811c74A63118ACb312701Bfa",
        blockCreated: 3778393
      }
    },
    portal: {
      [sourceId33]: {
        address: "0x320e1580effF37E008F1C92700d1eBa47c1B23fD",
        blockCreated: 3778395
      }
    },
    l1StandardBridge: {
      [sourceId33]: {
        address: "0xbC5C679879B2965296756CD959C3C739769995E2",
        blockCreated: 3778392
      }
    },
    multicall3: {
      address: "0xBAba8373113Fb7a68f195deF18732e01aF8eDfCF",
      blockCreated: 3019007
    }
  },
  testnet: true,
  sourceId: sourceId33
});

// node_modules/viem/_esm/chains/definitions/monadTestnet.js
var monadTestnet = defineChain({
  id: 10143,
  name: "Monad Testnet",
  blockTime: 400,
  nativeCurrency: {
    name: "Testnet MON Token",
    symbol: "MON",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.monad.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Monad Testnet explorer",
      url: "https://testnet.monadexplorer.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 251449
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/moonbaseAlpha.js
var moonbaseAlpha = defineChain({
  id: 1287,
  name: "Moonbase Alpha",
  nativeCurrency: {
    decimals: 18,
    name: "DEV",
    symbol: "DEV"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.api.moonbase.moonbeam.network"],
      webSocket: ["wss://wss.api.moonbase.moonbeam.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Moonscan",
      url: "https://moonbase.moonscan.io",
      apiUrl: "https://moonbase.moonscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1850686
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/moonbeam.js
var moonbeam = defineChain({
  id: 1284,
  name: "Moonbeam",
  nativeCurrency: {
    decimals: 18,
    name: "GLMR",
    symbol: "GLMR"
  },
  rpcUrls: {
    default: {
      http: ["https://moonbeam.public.blastapi.io"],
      webSocket: ["wss://moonbeam.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Moonscan",
      url: "https://moonscan.io",
      apiUrl: "https://api-moonbeam.moonscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 609002
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/moonbeamDev.js
var moonbeamDev = defineChain({
  id: 1281,
  name: "Moonbeam Development Node",
  nativeCurrency: {
    decimals: 18,
    name: "DEV",
    symbol: "DEV"
  },
  rpcUrls: {
    default: {
      http: ["http://127.0.0.1:9944"],
      webSocket: ["wss://127.0.0.1:9944"]
    }
  }
});

// node_modules/viem/_esm/chains/definitions/moonriver.js
var moonriver = defineChain({
  id: 1285,
  name: "Moonriver",
  nativeCurrency: {
    decimals: 18,
    name: "MOVR",
    symbol: "MOVR"
  },
  rpcUrls: {
    default: {
      http: ["https://moonriver.public.blastapi.io"],
      webSocket: ["wss://moonriver.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Moonscan",
      url: "https://moonriver.moonscan.io",
      apiUrl: "https://api-moonriver.moonscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1597904
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/morph.js
var morph = defineChain({
  id: 2818,
  name: "Morph",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.morphl2.io"],
      webSocket: ["wss://rpc.morphl2.io:8443"]
    }
  },
  blockExplorers: {
    default: {
      name: "Morph Explorer",
      url: "https://explorer.morphl2.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3654913
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/morphHolesky.js
var morphHolesky = defineChain({
  id: 2810,
  name: "Morph Holesky",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-quicknode-holesky.morphl2.io"],
      webSocket: ["wss://rpc-quicknode-holesky.morphl2.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Morph Holesky Explorer",
      url: "https://explorer-holesky.morphl2.io",
      apiUrl: "https://explorer-api-holesky.morphl2.io/api?"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/morphSepolia.js
var morphSepolia = defineChain({
  id: 2710,
  name: "Morph Sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.morphl2.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Morph Testnet Explorer",
      url: "https://explorer-testnet.morphl2.io",
      apiUrl: "https://explorer-api-testnet.morphl2.io/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/nahmii.js
var nahmii = defineChain({
  id: 5551,
  name: "Nahmii 2 Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://l2.nahmii.io"] }
  },
  blockExplorers: {
    default: {
      name: "Nahmii 2 Explorer",
      url: "https://explorer.n2.nahmii.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/nautilus.js
var nautilus = defineChain({
  id: 22222,
  name: "Nautilus Mainnet",
  nativeCurrency: { name: "ZBC", symbol: "ZBC", decimals: 9 },
  rpcUrls: {
    default: {
      http: ["https://api.nautilus.nautchain.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "NautScan",
      url: "https://nautscan.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/near.js
var near = defineChain({
  id: 397,
  name: "NEAR Protocol",
  nativeCurrency: {
    decimals: 18,
    name: "NEAR",
    symbol: "NEAR"
  },
  rpcUrls: {
    default: { http: ["https://eth-rpc.mainnet.near.org"] }
  },
  blockExplorers: {
    default: {
      name: "NEAR Explorer",
      url: "https://eth-explorer.near.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/nearTestnet.js
var nearTestnet = defineChain({
  id: 398,
  name: "NEAR Protocol Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "NEAR",
    symbol: "NEAR"
  },
  rpcUrls: {
    default: { http: ["https://eth-rpc.testnet.near.org"] }
  },
  blockExplorers: {
    default: {
      name: "NEAR Explorer",
      url: "https://eth-explorer-testnet.near.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/neonDevnet.js
var neonDevnet = defineChain({
  id: 245022926,
  name: "Neon EVM DevNet",
  nativeCurrency: { name: "NEON", symbol: "NEON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://devnet.neonevm.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Neonscan",
      url: "https://devnet.neonscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 205206112
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/neonMainnet.js
var neonMainnet = defineChain({
  id: 245022934,
  network: "neonMainnet",
  name: "Neon EVM MainNet",
  nativeCurrency: { name: "NEON", symbol: "NEON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://neon-proxy-mainnet.solana.p2p.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Neonscan",
      url: "https://neonscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 206545524
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/neoxMainnet.js
var neoxMainnet = defineChain({
  id: 47763,
  name: "Neo X Mainnet",
  nativeCurrency: { name: "Gas", symbol: "GAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://mainnet-1.rpc.banelabs.org",
        "https://mainnet-2.rpc.banelabs.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Neo X - Explorer",
      url: "https://xexplorer.neo.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/neoxT4.js
var neoxT4 = defineChain({
  id: 12227332,
  name: "Neo X Testnet T4",
  nativeCurrency: { name: "Gas", symbol: "GAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.rpc.banelabs.org/"]
    }
  },
  blockExplorers: {
    default: {
      name: "neox-scan",
      url: "https://xt4scan.ngd.network"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/newton.js
var newton = defineChain({
  id: 1012,
  name: "Newton",
  nativeCurrency: {
    name: "Newton",
    symbol: "NEW",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://global.rpc.mainnet.newtonproject.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "NewFi explorer",
      url: "https://explorer.newtonproject.org/"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/nexi.js
var nexi = defineChain({
  id: 4242,
  name: "Nexi",
  nativeCurrency: { name: "Nexi", symbol: "NEXI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.chain.nexi.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "NexiScan",
      url: "https://www.nexiscan.com",
      apiUrl: "https://www.nexiscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0277A46Cc69A57eE3A6C8c158bA874832F718B8E",
      blockCreated: 25770160
    }
  }
});

// node_modules/viem/_esm/chains/definitions/nexilix.js
var nexilix = defineChain({
  id: 240,
  name: "Nexilix Smart Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Nexilix",
    symbol: "NEXILIX"
  },
  rpcUrls: {
    default: { http: ["https://rpcurl.pos.nexilix.com"] }
  },
  blockExplorers: {
    default: {
      name: "NexilixScan",
      url: "https://scan.nexilix.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x58381c8e2BF9d0C2C4259cA14BdA9Afe02831244",
      blockCreated: 74448
    }
  }
});

// node_modules/viem/_esm/chains/definitions/nibiru.js
var nibiru = defineChain({
  id: 6900,
  name: "Nibiru",
  nativeCurrency: {
    decimals: 18,
    name: "NIBI",
    symbol: "NIBI"
  },
  rpcUrls: {
    default: { http: ["https://evm-rpc.nibiru.fi"] }
  },
  blockExplorers: {
    default: {
      name: "NibiScan",
      url: "https://nibiscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 19587573
    }
  }
});

// node_modules/viem/_esm/chains/definitions/nitrographTestnet.js
var nitrographTestnet = defineChain({
  id: 200024,
  name: "Nitrograph Testnet",
  testnet: true,
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.nitrograph.foundation"]
    }
  },
  nativeCurrency: {
    name: "Nitro",
    symbol: "NOS",
    decimals: 18
  },
  blockExplorers: {
    default: {
      url: "https://explorer-testnet.nitrograph.foundation",
      name: "Nitrograph Explorer"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/oasisTestnet.js
var oasisTestnet = defineChain({
  id: 4090,
  network: "oasis-testnet",
  name: "Oasis Testnet",
  nativeCurrency: { name: "Fasttoken", symbol: "FTN", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc1.oasis.bahamutchain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Ftnscan",
      url: "https://oasis.ftnscan.com",
      apiUrl: "https://oasis.ftnscan.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/oasys.js
var oasys = defineChain({
  id: 248,
  name: "Oasys",
  nativeCurrency: { name: "Oasys", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.oasys.games"]
    }
  },
  blockExplorers: {
    default: {
      name: "OasysScan",
      url: "https://scan.oasys.games",
      apiUrl: "https://scan.oasys.games/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/odysseyTestnet.js
var odysseyTestnet = defineChain({
  id: 911867,
  name: "Odyssey Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://odyssey.ithaca.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Odyssey Explorer",
      url: "https://odyssey-explorer.ithaca.xyz",
      apiUrl: "https://odyssey-explorer.ithaca.xyz/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/okc.js
var okc = defineChain({
  id: 66,
  name: "OKC",
  nativeCurrency: {
    decimals: 18,
    name: "OKT",
    symbol: "OKT"
  },
  rpcUrls: {
    default: { http: ["https://exchainrpc.okex.org"] }
  },
  blockExplorers: {
    default: {
      name: "oklink",
      url: "https://www.oklink.com/okc"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 10364792
    }
  }
});

// node_modules/viem/_esm/chains/definitions/omax.js
var omax = defineChain({
  id: 311,
  name: "Omax Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "OMAX",
    symbol: "OMAX"
  },
  rpcUrls: {
    default: { http: ["https://mainapi.omaxray.com"] }
  },
  blockExplorers: {
    default: {
      name: "Omax Explorer",
      url: "https://omaxscan.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/omni.js
var omni = defineChain({
  id: 166,
  name: "Omni",
  nativeCurrency: { name: "Omni", symbol: "OMNI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.omni.network"],
      webSocket: ["wss://mainnet.omni.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "OmniScan",
      url: "https://omniscan.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/omniOmega.js
var omniOmega = defineChain({
  id: 164,
  name: "Omni Omega",
  nativeCurrency: { name: "Omni", symbol: "OMNI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://omega.omni.network"],
      webSocket: ["wss://omega.omni.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Omega OmniScan",
      url: "https://omega.omniscan.network/"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/oneWorld.js
var oneWorld = defineChain({
  id: 309075,
  name: "One World Chain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "OWCT",
    symbol: "OWCT"
  },
  rpcUrls: {
    default: { http: ["https://mainnet-rpc.oneworldchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "One World Explorer",
      url: "https://mainnet.oneworldchain.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/oortmainnetDev.js
var oortMainnetDev = defineChain({
  id: 9700,
  name: "OORT MainnetDev",
  nativeCurrency: {
    decimals: 18,
    name: "OORT",
    symbol: "OORT"
  },
  rpcUrls: {
    default: { http: ["https://dev-rpc.oortech.com"] }
  },
  blockExplorers: {
    default: {
      name: "OORT MainnetDev Explorer",
      url: "https://dev-scan.oortech.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/opBNB.js
var sourceId34 = 56;
var opBNB = defineChain({
  id: 204,
  name: "opBNB",
  nativeCurrency: {
    name: "BNB",
    symbol: "BNB",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://opbnb-mainnet-rpc.bnbchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "opBNB (BSCScan)",
      url: "https://opbnb.bscscan.com",
      apiUrl: "https://api-opbnb.bscscan.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 512881
    },
    l2OutputOracle: {
      [sourceId34]: {
        address: "0x153CAB79f4767E2ff862C94aa49573294B13D169"
      }
    },
    portal: {
      [sourceId34]: {
        address: "0x1876EA7702C0ad0C6A2ae6036DE7733edfBca519"
      }
    },
    l1StandardBridge: {
      [sourceId34]: {
        address: "0xF05F0e4362859c3331Cb9395CBC201E3Fa6757Ea"
      }
    }
  },
  sourceId: sourceId34
});

// node_modules/viem/_esm/chains/definitions/opBNBTestnet.js
var sourceId35 = 97;
var opBNBTestnet = defineChain({
  id: 5611,
  name: "opBNB Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "tBNB",
    symbol: "tBNB"
  },
  rpcUrls: {
    default: { http: ["https://opbnb-testnet-rpc.bnbchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "opbnbscan",
      url: "https://testnet.opbnbscan.com"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3705108
    },
    l2OutputOracle: {
      [sourceId35]: {
        address: "0xFf2394Bb843012562f4349C6632a0EcB92fC8810"
      }
    },
    portal: {
      [sourceId35]: {
        address: "0x4386C8ABf2009aC0c263462Da568DD9d46e52a31"
      }
    },
    l1StandardBridge: {
      [sourceId35]: {
        address: "0x677311Fd2cCc511Bbc0f581E8d9a07B033D5E840"
      }
    }
  },
  testnet: true,
  sourceId: sourceId35
});

// node_modules/viem/_esm/chains/definitions/openledger.js
var openledger = defineChain({
  id: 1612,
  name: "OpenLedger",
  nativeCurrency: { name: "Open", symbol: "OPEN", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.openledger.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "OpenLedger Explorer",
      url: "https://scan.openledger.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/optimism.js
var sourceId36 = 1;
var optimism = defineChain({
  ...chainConfig2,
  id: 10,
  name: "OP Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Optimism Explorer",
      url: "https://optimistic.etherscan.io",
      apiUrl: "https://api-optimistic.etherscan.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId36]: {
        address: "0xe5965Ab5962eDc7477C8520243A95517CD252fA9"
      }
    },
    l2OutputOracle: {
      [sourceId36]: {
        address: "0xdfe97868233d1aa22e815a266982f2cf17685a27"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4286263
    },
    portal: {
      [sourceId36]: {
        address: "0xbEb5Fc579115071764c7423A4f12eDde41f106Ed"
      }
    },
    l1StandardBridge: {
      [sourceId36]: {
        address: "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1"
      }
    }
  },
  sourceId: sourceId36
});

// node_modules/viem/_esm/chains/definitions/optimismGoerli.js
var sourceId37 = 5;
var optimismGoerli = defineChain({
  ...chainConfig2,
  id: 420,
  name: "Optimism Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://goerli.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli-optimism.etherscan.io",
      apiUrl: "https://goerli-optimism.etherscan.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId37]: {
        address: "0xE6Dfba0953616Bacab0c9A8ecb3a9BBa77FC15c0"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 49461
    },
    portal: {
      [sourceId37]: {
        address: "0x5b47E1A08Ea6d985D6649300584e6722Ec4B1383"
      }
    },
    l1StandardBridge: {
      [sourceId37]: {
        address: "0x636Af16bf2f682dD3109e60102b8E1A089FedAa8"
      }
    }
  },
  testnet: true,
  sourceId: sourceId37
});

// node_modules/viem/_esm/chains/definitions/optimismSepolia.js
var sourceId38 = 11155111;
var optimismSepolia = defineChain({
  ...chainConfig2,
  id: 11155420,
  name: "OP Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://optimism-sepolia.blockscout.com",
      apiUrl: "https://optimism-sepolia.blockscout.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId38]: {
        address: "0x05F9613aDB30026FFd634f38e5C4dFd30a197Fa1"
      }
    },
    l2OutputOracle: {
      [sourceId38]: {
        address: "0x90E9c4f8a994a250F6aEfd61CAFb4F2e895D458F"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1620204
    },
    portal: {
      [sourceId38]: {
        address: "0x16Fc5058F25648194471939df75CF27A2fdC48BC"
      }
    },
    l1StandardBridge: {
      [sourceId38]: {
        address: "0xFBb0621E0B23b5478B630BD55a5f21f67730B0F1"
      }
    }
  },
  testnet: true,
  sourceId: sourceId38
});

// node_modules/viem/_esm/chains/definitions/optopia.js
var optopia = defineChain({
  id: 62050,
  name: "Optopia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-mainnet.optopia.ai"] }
  },
  blockExplorers: {
    default: {
      name: "Optopia Explorer",
      url: "https://scan.optopia.ai"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/optopiaTestnet.js
var optopiaTestnet = defineChain({
  id: 62049,
  name: "Optopia Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-testnet.optopia.ai"] }
  },
  blockExplorers: {
    default: {
      name: "Optopia Explorer",
      url: "https://scan-testnet.optopia.ai"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/orderly.js
var orderly = defineChain({
  id: 291,
  name: "Orderly",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.orderly.network"] }
  },
  blockExplorers: {
    default: {
      name: "Orderly Explorer",
      url: "https://explorer.orderly.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/orderlySepolia.js
var orderlySepolia = defineChain({
  id: 4460,
  name: "Orderly Sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://l2-orderly-l2-4460-sepolia-8tc3sd7dvy.t.conduit.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Orderly Explorer",
      url: "https://explorerl2new-orderly-l2-4460-sepolia-8tc3sd7dvy.t.conduit.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/otimDevnet.js
var otimDevnet = defineChain({
  id: 41144114,
  name: "Otim Devnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["http://devnet.otim.xyz"]
    }
  },
  contracts: {
    batchInvoker: {
      address: "0x5FbDB2315678afecb367f032d93F642f64180aa3"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/palm.js
var palm = defineChain({
  id: 11297108109,
  name: "Palm",
  nativeCurrency: {
    decimals: 18,
    name: "PALM",
    symbol: "PALM"
  },
  rpcUrls: {
    default: {
      http: ["https://palm-mainnet.public.blastapi.io"],
      webSocket: ["wss://palm-mainnet.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chainlens",
      url: "https://palm.chainlens.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15429248
    }
  }
});

// node_modules/viem/_esm/chains/definitions/palmTestnet.js
var palmTestnet = defineChain({
  id: 11297108099,
  name: "Palm Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "PALM",
    symbol: "PALM"
  },
  rpcUrls: {
    default: {
      http: ["https://palm-mainnet.public.blastapi.io"],
      webSocket: ["wss://palm-mainnet.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chainlens",
      url: "https://palm.chainlens.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15429248
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/peaq.js
var peaq = defineChain({
  id: 3338,
  name: "Peaq",
  nativeCurrency: {
    decimals: 18,
    name: "peaq",
    symbol: "PEAQ"
  },
  rpcUrls: {
    default: {
      http: [
        "https://quicknode1.peaq.xyz",
        "https://quicknode2.peaq.xyz",
        "https://quicknode3.peaq.xyz"
      ],
      webSocket: [
        "wss://quicknode1.peaq.xyz",
        "wss://quicknode2.peaq.xyz",
        "wss://quicknode3.peaq.xyz"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Subscan",
      url: "https://peaq.subscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3566354
    }
  }
});

// node_modules/viem/_esm/chains/definitions/pgn.js
var sourceId39 = 1;
var pgn = defineChain({
  id: 424,
  network: "pgn",
  name: "PGN",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.publicgoods.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "PGN Explorer",
      url: "https://explorer.publicgoods.network",
      apiUrl: "https://explorer.publicgoods.network/api"
    }
  },
  contracts: {
    l2OutputOracle: {
      [sourceId39]: {
        address: "0x9E6204F750cD866b299594e2aC9eA824E2e5f95c"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3380209
    },
    portal: {
      [sourceId39]: {
        address: "0xb26Fd985c5959bBB382BAFdD0b879E149e48116c"
      }
    },
    l1StandardBridge: {
      [sourceId39]: {
        address: "0xD0204B9527C1bA7bD765Fa5CCD9355d38338272b"
      }
    }
  },
  formatters: formatters2,
  sourceId: sourceId39
});

// node_modules/viem/_esm/chains/definitions/pgnTestnet.js
var sourceId40 = 11155111;
var pgnTestnet = defineChain({
  id: 58008,
  network: "pgn-testnet",
  name: "PGN ",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.publicgoods.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "PGN Testnet Explorer",
      url: "https://explorer.sepolia.publicgoods.network",
      apiUrl: "https://explorer.sepolia.publicgoods.network/api"
    }
  },
  contracts: {
    l2OutputOracle: {
      [sourceId40]: {
        address: "0xD5bAc3152ffC25318F848B3DD5dA6C85171BaEEe"
      }
    },
    portal: {
      [sourceId40]: {
        address: "0xF04BdD5353Bb0EFF6CA60CfcC78594278eBfE179"
      }
    },
    l1StandardBridge: {
      [sourceId40]: {
        address: "0xFaE6abCAF30D23e233AC7faF747F2fC3a5a6Bfa3"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3754925
    }
  },
  formatters: formatters2,
  sourceId: sourceId40,
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/phoenix.js
var phoenix = defineChain({
  id: 13381,
  name: "Phoenix Blockchain",
  nativeCurrency: { name: "Phoenix", symbol: "PHX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.phoenixplorer.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Phoenixplorer",
      url: "https://phoenixplorer.com",
      apiUrl: "https://phoenixplorer.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x498cF757a575cFF2c2Ed9f532f56Efa797f86442",
      blockCreated: 5620192
    }
  }
});

// node_modules/viem/_esm/chains/definitions/planq.js
var planq = defineChain({
  id: 7070,
  name: "Planq Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "PLQ",
    symbol: "PLQ"
  },
  rpcUrls: {
    default: {
      http: [
        "https://planq-rpc.nodies.app",
        "https://evm-rpc.planq.network",
        "https://jsonrpc.planq.nodestake.top"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Planq Explorer",
      url: "https://evm.planq.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 8470015
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/plasma.js
var plasma = defineChain({
  id: 9745,
  name: "Plasma",
  blockTime: 1e3,
  nativeCurrency: {
    name: "Plasma",
    symbol: "XPL",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.plasma.to"]
    }
  },
  blockExplorers: {
    default: {
      name: "PlasmaScan",
      url: "https://plasmascan.to"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  }
});

// node_modules/viem/_esm/chains/definitions/plasmaDevnet.js
var plasmaDevnet = defineChain({
  id: 9747,
  name: "Plasma Devnet",
  nativeCurrency: {
    name: "Devnet Plasma",
    symbol: "XPL",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://devnet-rpc.plasma.to"]
    }
  },
  testnet: true,
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  }
});

// node_modules/viem/_esm/chains/definitions/plasmaTestnet.js
var plasmaTestnet = defineChain({
  id: 9746,
  name: "Plasma Testnet",
  nativeCurrency: {
    name: "Testnet Plasma",
    symbol: "XPL",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.plasma.to"]
    }
  },
  blockExplorers: {
    default: {
      name: "RouteScan",
      url: "https://testnet.plasmascan.to"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/playfiAlbireo.js
var playfiAlbireo = defineChain({
  ...chainConfig,
  id: 1612127,
  name: "PlayFi Albireo Testnet",
  network: "albireo",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://albireo-rpc.playfi.ai"],
      webSocket: ["wss://albireo-rpc-ws.playfi.ai/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "PlayFi Albireo Explorer",
      url: "https://albireo-explorer.playfi.ai"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/plinga.js
var plinga = defineChain({
  id: 242,
  name: "Plinga",
  nativeCurrency: { name: "Plinga", symbol: "PLINGA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpcurl.mainnet.plgchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Plgscan",
      url: "https://www.plgscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0989576160f2e7092908BB9479631b901060b6e4",
      blockCreated: 204489
    }
  }
});

// node_modules/viem/_esm/chains/definitions/plume.js
var sourceId41 = 1;
var plume = defineChain({
  id: 98865,
  name: "Plume (Legacy)",
  nativeCurrency: {
    name: "Plume Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.plumenetwork.xyz"],
      webSocket: ["wss://rpc.plumenetwork.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.plumenetwork.xyz",
      apiUrl: "https://explorer.plumenetwork.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 48577
    }
  },
  sourceId: sourceId41
});

// node_modules/viem/_esm/chains/definitions/plumeDevnet.js
var sourceId42 = 11155111;
var plumeDevnet = defineChain({
  id: 98864,
  name: "Plume Devnet (Legacy)",
  nativeCurrency: {
    name: "Plume Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://test-rpc.plumenetwork.xyz"],
      webSocket: ["wss://test-rpc.plumenetwork.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://test-explorer.plumenetwork.xyz",
      apiUrl: "https://test-explorer.plumenetwork.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 481948
    }
  },
  testnet: true,
  sourceId: sourceId42
});

// node_modules/viem/_esm/chains/definitions/plumeMainnet.js
var sourceId43 = 1;
var plumeMainnet = defineChain({
  id: 98866,
  name: "Plume",
  nativeCurrency: {
    name: "Plume",
    symbol: "PLUME",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.plume.org"],
      webSocket: ["wss://rpc.plume.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.plume.org",
      apiUrl: "https://explorer.plume.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 39679
    }
  },
  sourceId: sourceId43
});

// node_modules/viem/_esm/chains/definitions/plumeSepolia.js
var sourceId44 = 11155111;
var plumeSepolia = defineChain({
  id: 98867,
  name: "Plume Testnet",
  nativeCurrency: {
    name: "Plume",
    symbol: "PLUME",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.plume.org"],
      webSocket: ["wss://testnet-rpc.plume.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer.plume.org",
      apiUrl: "https://testnet-explorer.plume.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 199712
    }
  },
  testnet: true,
  sourceId: sourceId44
});

// node_modules/viem/_esm/chains/definitions/plumeTestnet.js
var sourceId45 = 11155111;
var plumeTestnet = defineChain({
  id: 161221135,
  name: "Plume Testnet (Legacy)",
  nativeCurrency: {
    name: "Plume Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.plumenetwork.xyz/http"],
      webSocket: ["wss://testnet-rpc.plumenetwork.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer.plumenetwork.xyz",
      apiUrl: "https://testnet-explorer.plumenetwork.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 6022332
    }
  },
  testnet: true,
  sourceId: sourceId45
});

// node_modules/viem/_esm/chains/definitions/polterTestnet.js
var polterTestnet = defineChain({
  id: 631571,
  name: "Polter Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Polter GHST",
    symbol: "GHST"
  },
  rpcUrls: {
    default: {
      http: ["https://geist-polter.g.alchemy.com/public"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://polter-testnet.explorer.alchemy.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11245
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/polygon.js
var polygon = defineChain({
  id: 137,
  name: "Polygon",
  blockTime: 2e3,
  nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://polygon-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://polygonscan.com",
      apiUrl: "https://api.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  }
});

// node_modules/viem/_esm/chains/definitions/polygonAmoy.js
var polygonAmoy = defineChain({
  id: 80002,
  name: "Polygon Amoy",
  nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-amoy.polygon.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://amoy.polygonscan.com",
      apiUrl: "https://api-amoy.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3127388
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/polygonMumbai.js
var polygonMumbai = defineChain({
  id: 80001,
  name: "Polygon Mumbai",
  nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://80001.rpc.thirdweb.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://mumbai.polygonscan.com",
      apiUrl: "https://api-testnet.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/polygonZkEvm.js
var polygonZkEvm = defineChain({
  id: 1101,
  name: "Polygon zkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://zkevm-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://zkevm.polygonscan.com",
      apiUrl: "https://api-zkevm.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 57746
    }
  }
});

// node_modules/viem/_esm/chains/definitions/polygonZkEvmCardona.js
var polygonZkEvmCardona = defineChain({
  id: 2442,
  name: "Polygon zkEVM Cardona",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.cardona.zkevm-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://cardona-zkevm.polygonscan.com",
      apiUrl: "https://cardona-zkevm.polygonscan.com/api"
    }
  },
  testnet: true,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 114091
    }
  }
});

// node_modules/viem/_esm/chains/definitions/polygonZkEvmTestnet.js
var polygonZkEvmTestnet = defineChain({
  id: 1442,
  name: "Polygon zkEVM Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.public.zkevm-test.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://testnet-zkevm.polygonscan.com",
      apiUrl: "https://testnet-zkevm.polygonscan.com/api"
    }
  },
  testnet: true,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 525686
    }
  }
});

// node_modules/viem/_esm/chains/definitions/polynomial.js
var polynomial = defineChain({
  id: 8008,
  name: "Polynomial",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.polynomial.fi"]
    }
  },
  blockExplorers: {
    default: {
      name: "Polynomial Scan",
      url: "https://polynomialscan.io"
    }
  },
  testnet: false,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/polynomialSepolia.js
var polynomialSepolia = defineChain({
  id: 80008,
  name: "Polynomia Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.sepolia.polynomial.fi"]
    }
  },
  blockExplorers: {
    default: {
      name: "Polynomial Scan",
      url: "https://sepolia.polynomialscan.io"
    }
  },
  testnet: true,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/premiumBlock.js
var premiumBlockTestnet = defineChain({
  id: 23023,
  name: "PremiumBlock Testnet",
  nativeCurrency: { name: "Premium Block", symbol: "PBLK", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.premiumblock.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "PremiumBlocks Explorer",
      url: "https://scan.premiumblock.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/pulsechain.js
var pulsechain = defineChain({
  id: 369,
  name: "PulseChain",
  nativeCurrency: { name: "Pulse", symbol: "PLS", decimals: 18 },
  testnet: false,
  blockTime: 1e4,
  rpcUrls: {
    default: {
      http: ["https://rpc.pulsechain.com"],
      webSocket: ["wss://ws.pulsechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PulseScan",
      url: "https://ipfs.scan.pulsechain.com",
      apiUrl: "https://api.scan.pulsechain.com/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
});

// node_modules/viem/_esm/chains/definitions/pulsechainV4.js
var pulsechainV4 = defineChain({
  id: 943,
  name: "PulseChain V4",
  testnet: true,
  nativeCurrency: { name: "V4 Pulse", symbol: "v4PLS", decimals: 18 },
  blockTime: 1e4,
  rpcUrls: {
    default: {
      http: ["https://rpc.v4.testnet.pulsechain.com"],
      webSocket: ["wss://ws.v4.testnet.pulsechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PulseScan",
      url: "https://scan.v4.testnet.pulsechain.com",
      apiUrl: "https://scan.v4.testnet.pulsechain.com/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
});

// node_modules/viem/_esm/chains/definitions/pumpfiTestnet.js
var pumpfiTestnet = defineChain({
  id: 490092,
  name: "Pumpfi Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "PMPT",
    symbol: "PMPT"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc1testnet.pumpfi.me"]
    }
  },
  blockExplorers: {
    default: {
      name: "Pumpfi Testnet Scan",
      url: "https://testnetscan.pumpfi.me"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/pyrope.js
var sourceId46 = 11155111;
var pyrope = defineChain({
  ...chainConfig2,
  name: "Pyrope Testnet",
  testnet: true,
  id: 695569,
  sourceId: sourceId46,
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.pyropechain.com"],
      webSocket: ["wss://rpc.pyropechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://pyrope.blockscout.com"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l1StandardBridge: {
      [sourceId46]: {
        address: "0xC24932c31D9621aE9e792576152B7ef010cFC2F8"
      }
    }
  }
});

// node_modules/viem/_esm/chains/definitions/ql1.js
var ql1 = defineChain({
  id: 766,
  name: "QL1",
  nativeCurrency: {
    decimals: 18,
    name: "QOM",
    symbol: "QOM"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.qom.one"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ql1 Explorer",
      url: "https://scan.qom.one"
    }
  },
  contracts: {
    multicall3: {
      address: "0x7A52370716ea730585884F5BDB0f6E60C39b8C64"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/qMainnet.js
var qMainnet = defineChain({
  id: 35441,
  name: "Q Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Q",
    symbol: "Q"
  },
  rpcUrls: {
    default: { http: ["https://rpc.q.org"] }
  },
  blockExplorers: {
    default: {
      name: "Q Mainnet Explorer",
      url: "https://explorer.q.org",
      apiUrl: "https://explorer.q.org/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/qTestnet.js
var qTestnet = defineChain({
  id: 35443,
  name: "Q Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Q",
    symbol: "Q"
  },
  rpcUrls: {
    default: { http: ["https://rpc.qtestnet.org"] }
  },
  blockExplorers: {
    default: {
      name: "Q Testnet Explorer",
      url: "https://explorer.qtestnet.org",
      apiUrl: "https://explorer.qtestnet.org/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/quai.js
var quai = defineChain({
  id: 9,
  name: "Quai Network Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Quai",
    symbol: "QUAI"
  },
  rpcUrls: {
    default: { http: ["https://rpc.quai.network/cyprus1"] }
  },
  blockExplorers: {
    default: {
      name: "Quaiscan",
      url: "https://quaiscan.io",
      apiUrl: "https://quaiscan.io/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/quaiTestnet.js
var quaiTestnet = defineChain({
  id: 15e3,
  name: "Quai Network Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Quai",
    symbol: "QUAI"
  },
  rpcUrls: {
    default: { http: ["https://orchard.rpc.quai.network/cyprus1"] }
  },
  blockExplorers: {
    default: {
      name: "Orchard Quaiscan",
      url: "https://orchard.quaiscan.io",
      apiUrl: "https://orchard.quaiscan.io/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/real.js
var real = defineChain({
  id: 111188,
  name: "re.al",
  nativeCurrency: {
    name: "reETH",
    decimals: 18,
    symbol: "reETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.realforreal.gelato.digital"] }
  },
  blockExplorers: {
    default: {
      name: "re.al Explorer",
      url: "https://explorer.re.al",
      apiUrl: "https://explorer.re.al/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 695
    }
  }
});

// node_modules/viem/_esm/chains/definitions/redbellyMainnet.js
var redbellyMainnet = defineChain({
  id: 151,
  name: "Redbelly Network Mainnet",
  nativeCurrency: {
    name: "Redbelly Native Coin",
    symbol: "RBNT",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://governors.mainnet.redbelly.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Routescan",
      url: "https://redbelly.routescan.io",
      apiUrl: "https://api.routescan.io/v2/network/mainnet/evm/151/etherscan/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/redbellyTestnet.js
var redbellyTestnet = defineChain({
  id: 153,
  name: "Redbelly Network Testnet",
  nativeCurrency: {
    name: "Redbelly Native Coin",
    symbol: "RBNT",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://governors.testnet.redbelly.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Routescan",
      url: "https://redbelly.testnet.routescan.io",
      apiUrl: "https://api.routescan.io/v2/network/testnet/evm/153_2/etherscan/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/reddio.js
var reddio = defineChain({
  id: 50342,
  name: "Reddio",
  nativeCurrency: { name: "Reddio", symbol: "RED", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.reddio.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://reddio.cloud.blockscout.com",
      apiUrl: "https://reddio.cloud.blockscout.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 848849
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/reddioSepolia.js
var reddioSepolia = defineChain({
  id: 50341,
  name: "Reddio Sepolia",
  nativeCurrency: { name: "Reddio", symbol: "RED", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://reddio-dev.reddio.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Reddioscan",
      url: "https://reddio-devnet.l2scan.co",
      apiUrl: "https://reddio-devnet.l2scan.co/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/redstone.js
var sourceId47 = 1;
var redstone = defineChain({
  ...chainConfig2,
  name: "Redstone",
  id: 690,
  sourceId: sourceId47,
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rpc.redstonechain.com"],
      webSocket: ["wss://rpc.redstonechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.redstone.xyz"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId47]: {
        address: "0xC7bCb0e8839a28A1cFadd1CF716de9016CdA51ae",
        blockCreated: 19578329
      }
    },
    l2OutputOracle: {
      [sourceId47]: {
        address: "0xa426A052f657AEEefc298b3B5c35a470e4739d69",
        blockCreated: 19578337
      }
    },
    l1StandardBridge: {
      [sourceId47]: {
        address: "0xc473ca7E02af24c129c2eEf51F2aDf0411c1Df69",
        blockCreated: 19578331
      }
    }
  }
});

// node_modules/viem/_esm/chains/definitions/rei.js
var rei = defineChain({
  id: 47805,
  name: "REI Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "REI",
    symbol: "REI"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.rei.network"],
      webSocket: ["wss://rpc.rei.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "REI Scan",
      url: "https://scan.rei.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/reyaNetwork.js
var reyaNetwork = defineChain({
  id: 1729,
  name: "Reya Network",
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rpc.reya.network"],
      webSocket: ["wss://ws.reya.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Reya Network Explorer",
      url: "https://explorer.reya.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/riseTestnet.js
var riseTestnet = defineChain({
  id: 11155931,
  name: "RISE Testnet",
  nativeCurrency: { name: "RISE Testnet Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.riselabs.xyz"],
      webSocket: ["wss://testnet.riselabs.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.testnet.riselabs.xyz/",
      apiUrl: "https://explorer.testnet.riselabs.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/rivalz.js
var rivalz = defineChain({
  id: 753,
  name: "Rivalz",
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rivalz.calderachain.xyz/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Rivalz Caldera Explorer",
      url: "https://rivalz.calderaexplorer.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/rollux.js
var rollux = defineChain({
  id: 570,
  name: "Rollux Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.rollux.com"],
      webSocket: ["wss://rpc.rollux.com/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "RolluxExplorer",
      url: "https://explorer.rollux.com",
      apiUrl: "https://explorer.rollux.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 119222
    }
  }
});

// node_modules/viem/_esm/chains/definitions/rolluxTestnet.js
var rolluxTestnet = defineChain({
  id: 57e3,
  name: "Rollux Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc-tanenbaum.rollux.com/"],
      webSocket: ["wss://rpc-tanenbaum.rollux.com/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "RolluxTestnetExplorer",
      url: "https://rollux.tanenbaum.io",
      apiUrl: "https://rollux.tanenbaum.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1813675
    }
  }
});

// node_modules/viem/_esm/chains/definitions/ronin.js
var ronin = defineChain({
  id: 2020,
  name: "Ronin",
  nativeCurrency: { name: "RON", symbol: "RON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.roninchain.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ronin Explorer",
      url: "https://app.roninchain.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 26023535
    }
  }
});

// node_modules/viem/_esm/chains/definitions/root.js
var root = defineChain({
  id: 7668,
  name: "The Root Network",
  nativeCurrency: {
    decimals: 18,
    name: "XRP",
    symbol: "XRP"
  },
  rpcUrls: {
    default: {
      http: ["https://root.rootnet.live/archive"],
      webSocket: ["wss://root.rootnet.live/archive/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Rootscan",
      url: "https://rootscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xc9C2E2429AeC354916c476B30d729deDdC94988d",
      blockCreated: 9218338
    }
  }
});

// node_modules/viem/_esm/chains/definitions/rootPorcini.js
var rootPorcini = defineChain({
  id: 7672,
  name: "The Root Network - Porcini",
  nativeCurrency: {
    decimals: 18,
    name: "XRP",
    symbol: "XRP"
  },
  rpcUrls: {
    default: {
      http: ["https://porcini.rootnet.app/archive"],
      webSocket: ["wss://porcini.rootnet.app/archive/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Rootscan",
      url: "https://porcini.rootscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xc9C2E2429AeC354916c476B30d729deDdC94988d",
      blockCreated: 10555692
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/rootstock.js
var rootstock = defineChain({
  id: 30,
  name: "Rootstock Mainnet",
  network: "rootstock",
  nativeCurrency: {
    decimals: 18,
    name: "Rootstock Bitcoin",
    symbol: "RBTC"
  },
  rpcUrls: {
    default: { http: ["https://public-node.rsk.co"] }
  },
  blockExplorers: {
    default: {
      name: "RSK Explorer",
      url: "https://explorer.rsk.co"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4249540
    }
  }
});

// node_modules/viem/_esm/chains/definitions/rootstockTestnet.js
var rootstockTestnet = defineChain({
  id: 31,
  name: "Rootstock Testnet",
  network: "rootstock",
  nativeCurrency: {
    decimals: 18,
    name: "Rootstock Bitcoin",
    symbol: "tRBTC"
  },
  rpcUrls: {
    default: { http: ["https://public-node.testnet.rsk.co"] }
  },
  blockExplorers: {
    default: {
      name: "RSK Explorer",
      url: "https://explorer.testnet.rootstock.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2771150
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/rss3.js
var sourceId48 = 1;
var rss3 = defineChain({
  ...chainConfig2,
  id: 12553,
  name: "RSS3 VSL Mainnet",
  nativeCurrency: { name: "RSS3", symbol: "RSS3", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.rss3.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "RSS3 VSL Mainnet Scan",
      url: "https://scan.rss3.io",
      apiUrl: "https://scan.rss3.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId48]: {
        address: "0xE6f24d2C32B3109B18ed33cF08eFb490b1e09C10"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14193
    },
    portal: {
      [sourceId48]: {
        address: "0x6A12432491bbbE8d3babf75F759766774C778Db4",
        blockCreated: 19387057
      }
    },
    l1StandardBridge: {
      [sourceId48]: {
        address: "0x4cbab69108Aa72151EDa5A3c164eA86845f18438"
      }
    }
  },
  sourceId: sourceId48
});

// node_modules/viem/_esm/chains/definitions/rss3Sepolia.js
var sourceId49 = 11155111;
var rss3Sepolia = defineChain({
  ...chainConfig2,
  id: 2331,
  name: "RSS3 VSL Sepolia Testnet",
  nativeCurrency: { name: "RSS3", symbol: "RSS3", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.rss3.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "RSS3 VSL Sepolia Testnet Scan",
      url: "https://scan.testnet.rss3.io",
      apiUrl: "https://scan.testnet.rss3.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId49]: {
        address: "0xDb5c46C3Eaa6Ed6aE8b2379785DF7dd029C0dC81"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 55697
    },
    portal: {
      [sourceId49]: {
        address: "0xcBD77E8E1E7F06B25baDe67142cdE82652Da7b57",
        blockCreated: 5345035
      }
    },
    l1StandardBridge: {
      [sourceId49]: {
        address: "0xdDD29bb63B0839FB1cE0eE439Ff027738595D07B"
      }
    }
  },
  testnet: true,
  sourceId: sourceId49
});

// node_modules/viem/_esm/chains/definitions/saakuru.js
var saakuru = defineChain({
  id: 7225878,
  name: "Saakuru Mainnet",
  nativeCurrency: { name: "OAS", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.saakuru.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Saakuru Explorer",
      url: "https://explorer.saakuru.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/saga.js
var saga = defineChain({
  id: 5464,
  name: "Saga",
  network: "saga",
  nativeCurrency: {
    decimals: 18,
    name: "gas",
    symbol: "GAS"
  },
  rpcUrls: {
    default: { http: ["https://sagaevm.jsonrpc.sagarpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Saga Explorer",
      url: "https://sagaevm.sagaexplorer.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0x864DDc9B50B9A0dF676d826c9B9EDe9F8913a160",
      blockCreated: 467530
    }
  }
});

// node_modules/viem/_esm/chains/definitions/saigon.js
var saigon = defineChain({
  id: 2021,
  name: "Saigon Testnet",
  nativeCurrency: { name: "RON", symbol: "RON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://saigon-testnet.roninchain.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Saigon Explorer",
      url: "https://saigon-app.roninchain.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 18736871
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sanko.js
var sanko = defineChain({
  id: 1996,
  name: "Sanko",
  nativeCurrency: { name: "DMT", symbol: "DMT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.sanko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sanko Explorer",
      url: "https://explorer.sanko.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 37
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/sapphire.js
var sapphire = defineChain({
  id: 23294,
  name: "Oasis Sapphire",
  network: "sapphire",
  nativeCurrency: { name: "Sapphire Rose", symbol: "ROSE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sapphire.oasis.io"],
      webSocket: ["wss://sapphire.oasis.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Oasis Explorer",
      url: "https://explorer.oasis.io/mainnet/sapphire"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 734531
    }
  }
});

// node_modules/viem/_esm/chains/definitions/sapphireTestnet.js
var sapphireTestnet = defineChain({
  id: 23295,
  name: "Oasis Sapphire Testnet",
  network: "sapphire-testnet",
  nativeCurrency: { name: "Sapphire Test Rose", symbol: "TEST", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.sapphire.oasis.dev"],
      webSocket: ["wss://testnet.sapphire.oasis.dev/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Oasis Explorer",
      url: "https://explorer.oasis.io/testnet/sapphire"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/satoshivm.js
var satoshiVM = defineChain({
  id: 3109,
  name: "SatoshiVM Alpha Mainnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://alpha-rpc-node-http.svmscan.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://svmscan.io",
      apiUrl: "https://svmscan.io/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/satoshivmTestnet.js
var satoshiVMTestnet = defineChain({
  id: 3110,
  name: "SatoshiVM Testnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://test-rpc-node-http.svmscan.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://testnet.svmscan.io",
      apiUrl: "https://testnet.svmscan.io/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/scroll.js
var scroll = defineChain({
  id: 534352,
  name: "Scroll",
  blockTime: 3e3,
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.scroll.io"],
      webSocket: ["wss://wss-rpc.scroll.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Scrollscan",
      url: "https://scrollscan.com",
      apiUrl: "https://api.scrollscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/scrollSepolia.js
var scrollSepolia = defineChain({
  id: 534351,
  name: "Scroll Sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.scroll.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Scrollscan",
      url: "https://sepolia.scrollscan.com",
      apiUrl: "https://api-sepolia.scrollscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 9473
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sei.js
var sei = defineChain({
  id: 1329,
  name: "Sei Network",
  nativeCurrency: { name: "Sei", symbol: "SEI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm-rpc.sei-apis.com/"],
      webSocket: ["wss://evm-ws.sei-apis.com/"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seitrace",
      url: "https://seitrace.com",
      apiUrl: "https://seitrace.com/pacific-1/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/seiDevnet.js
var seiDevnet = defineChain({
  id: 713715,
  name: "Sei Devnet",
  nativeCurrency: { name: "Sei", symbol: "SEI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm-rpc-arctic-1.sei-apis.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seitrace",
      url: "https://seitrace.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/seismicDevnet.js
var seismicDevnet = defineChain({
  id: 5124,
  name: "Seismic Devnet",
  nativeCurrency: { name: "Seismic Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://node-2.seismicdev.net/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seismic Devnet Explorer",
      url: "https://explorer-2.seismicdev.net"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/seiTestnet.js
var seiTestnet = defineChain({
  id: 1328,
  name: "Sei Testnet",
  nativeCurrency: { name: "Sei", symbol: "SEI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm-rpc-testnet.sei-apis.com"],
      webSocket: ["wss://evm-ws-testnet.sei-apis.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seitrace",
      url: "https://seitrace.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 98697651
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sepolia.js
var sepolia = defineChain({
  id: 11155111,
  name: "Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://11155111.rpc.thirdweb.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.etherscan.io",
      apiUrl: "https://api-sepolia.etherscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 751532
    },
    ensUniversalResolver: {
      address: "0xeeeeeeee14d718c2b47d9923deab1335e144eeee",
      blockCreated: 8928790
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/shape.js
var sourceId50 = 1;
var shape = defineChain({
  ...chainConfig2,
  id: 360,
  name: "Shape",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.shape.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "shapescan",
      url: "https://shapescan.xyz",
      apiUrl: "https://shapescan.xyz/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId50]: {
        address: "0x6Ef8c69CfE4635d866e3E02732068022c06e724D",
        blockCreated: 20369940
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1
    },
    portal: {
      [sourceId50]: {
        address: "0xEB06fFa16011B5628BaB98E29776361c83741dd3",
        blockCreated: 20369933
      }
    },
    l1StandardBridge: {
      [sourceId50]: {
        address: "0x62Edd5f4930Ea92dCa3fB81689bDD9b9d076b57B",
        blockCreated: 20369935
      }
    }
  },
  sourceId: sourceId50
});

// node_modules/viem/_esm/chains/definitions/shapeSepolia.js
var sourceId51 = 11155111;
var shapeSepolia = defineChain({
  ...chainConfig2,
  id: 11011,
  name: "Shape Sepolia Testnet",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.shape.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer-sepolia.shape.network/",
      apiUrl: "https://explorer-sepolia.shape.network/api/v2"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1
    }
  },
  testnet: true,
  sourceId: sourceId51
});

// node_modules/viem/_esm/chains/definitions/shardeum.js
var shardeum = defineChain({
  id: 8118,
  name: "Shardeum",
  nativeCurrency: { name: "Shardeum", symbol: "SHM", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.shardeum.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shardeum Explorer",
      url: "https://explorer.shardeum.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/shardeumSphinx.js
var shardeumSphinx = defineChain({
  id: 8082,
  name: "Shardeum Sphinx",
  nativeCurrency: { name: "SHARDEUM", symbol: "SHM", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sphinx.shardeum.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shardeum Explorer",
      url: "https://explorer-sphinx.shardeum.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/shibarium.js
var shibarium = defineChain({
  id: 109,
  name: "Shibarium",
  network: "shibarium",
  nativeCurrency: { name: "Bone", symbol: "BONE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.shibrpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://shibariumscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0x864Bf681ADD6052395188A89101A1B37d3B4C961",
      blockCreated: 265900
    }
  }
});

// node_modules/viem/_esm/chains/definitions/shibariumTestnet.js
var shibariumTestnet = defineChain({
  id: 157,
  name: "Puppynet Shibarium",
  nativeCurrency: {
    decimals: 18,
    name: "Bone",
    symbol: "BONE"
  },
  rpcUrls: {
    default: { http: ["https://puppynet.shibrpc.com"] }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://puppyscan.shib.io",
      apiUrl: "https://puppyscan.shib.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xA4029b74FBA366c926eDFA7Dd10B21C621170a4c",
      blockCreated: 3035769
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/shiden.js
var shiden = defineChain({
  id: 336,
  name: "Shiden",
  nativeCurrency: {
    decimals: 18,
    name: "SDN",
    symbol: "SDN"
  },
  rpcUrls: {
    default: {
      http: ["https://shiden.public.blastapi.io"],
      webSocket: ["wss://shiden-rpc.dwellir.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shiden Scan",
      url: "https://shiden.subscan.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/shimmer.js
var shimmer = defineChain({
  id: 148,
  name: "Shimmer",
  network: "shimmer",
  nativeCurrency: {
    decimals: 18,
    name: "Shimmer",
    symbol: "SMR"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.shimmer.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shimmer Network Explorer",
      url: "https://explorer.evm.shimmer.network",
      apiUrl: "https://explorer.evm.shimmer.network/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/shimmerTestnet.js
var shimmerTestnet = defineChain({
  id: 1073,
  name: "Shimmer Testnet",
  network: "shimmer-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Shimmer",
    symbol: "SMR"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.testnet.shimmer.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shimmer Network Explorer",
      url: "https://explorer.evm.testnet.shimmer.network",
      apiUrl: "https://explorer.evm.testnet.shimmer.network/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sidra.js
var sidraChain = defineChain({
  id: 97453,
  name: "Sidra Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Sidra Digital Asset",
    symbol: "SDA"
  },
  rpcUrls: {
    default: {
      http: ["https://node.sidrachain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sidra Chain Explorer",
      url: "https://ledger.sidrachain.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/silicon.js
var silicon = defineChain({
  id: 2355,
  name: "Silicon zkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc.silicon.network",
        "https://silicon-mainnet.nodeinfra.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SiliconScope",
      url: "https://scope.silicon.network"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/siliconSepolia.js
var siliconSepolia = defineChain({
  id: 1722641160,
  name: "Silicon Sepolia zkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-sepolia.silicon.network",
        "https://silicon-testnet.nodeinfra.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SiliconSepoliaScope",
      url: "https://scope-sepolia.silicon.network"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sixProtocol.js
var sixProtocol = defineChain({
  id: 98,
  name: "Six Protocol",
  nativeCurrency: {
    decimals: 18,
    name: "SIX",
    symbol: "SIX"
  },
  rpcUrls: {
    default: {
      http: ["https://sixnet-rpc-evm.sixprotocol.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Six Protocol Scan",
      url: "https://sixscan.io/sixnet"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/skale/brawl.js
var skaleBlockBrawlers = defineChain({
  id: 391845894,
  name: "SKALE | Block Brawlers",
  nativeCurrency: { name: "BRAWL", symbol: "BRAWL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/frayed-decent-antares"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/frayed-decent-antares"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://frayed-decent-antares.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/skale/calypso.js
var skaleCalypso = defineChain({
  id: 1564830818,
  name: "SKALE Calypso Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/honorable-steel-rasalhague"],
      webSocket: [
        "wss://mainnet.skalenodes.com/v1/ws/honorable-steel-rasalhague"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://honorable-steel-rasalhague.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3107626
    }
  }
});

// node_modules/viem/_esm/chains/definitions/skale/calypsoTestnet.js
var skaleCalypsoTestnet = defineChain({
  id: 974399131,
  name: "SKALE Calypso Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/giant-half-dual-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/giant-half-dual-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://giant-half-dual-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 103220
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/skale/cryptoBlades.js
var skaleCryptoBlades = defineChain({
  id: 1026062157,
  name: "SKALE | CryptoBlades",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/affectionate-immediate-pollux"],
      webSocket: [
        "wss://mainnet.skalenodes.com/v1/ws/affectionate-immediate-pollux"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://affectionate-immediate-pollux.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/skale/cryptoColosseum.js
var skaleCryptoColosseum = defineChain({
  id: 1032942172,
  name: "SKALE | Crypto Colosseum",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/haunting-devoted-deneb"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/haunting-devoted-deneb"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://haunting-devoted-deneb.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/skale/europa.js
var skaleEuropa = defineChain({
  id: 2046399126,
  name: "SKALE Europa Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/elated-tan-skat"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/elated-tan-skat"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://elated-tan-skat.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3113495
    }
  }
});

// node_modules/viem/_esm/chains/definitions/skale/europaTestnet.js
var skaleEuropaTestnet = defineChain({
  id: 1444673419,
  name: "SKALE Europa Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/juicy-low-small-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/juicy-low-small-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://juicy-low-small-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 110858
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/skale/exorde.js
var skaleExorde = defineChain({
  id: 2139927552,
  name: "Exorde Network",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/light-vast-diphda"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/light-vast-diphda"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://light-vast-diphda.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/skale/humanProtocol.js
var skaleHumanProtocol = defineChain({
  id: 1273227453,
  name: "SKALE | Human Protocol",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/wan-red-ain"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/wan-red-ain"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://wan-red-ain.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/skale/nebula.js
var skaleNebula = defineChain({
  id: 1482601649,
  name: "SKALE Nebula Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/green-giddy-denebola"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/green-giddy-denebola"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2372986
    }
  }
});

// node_modules/viem/_esm/chains/definitions/skale/nebulaTestnet.js
var skaleNebulaTestnet = defineChain({
  id: 37084624,
  name: "SKALE Nebula Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/lanky-ill-funny-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/lanky-ill-funny-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://lanky-ill-funny-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 105141
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/skale/razor.js
var skaleRazor = defineChain({
  id: 278611351,
  name: "SKALE | Razor Network",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/turbulent-unique-scheat"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/turbulent-unique-scheat"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://turbulent-unique-scheat.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/skale/titan.js
var skaleTitan = defineChain({
  id: 1350216234,
  name: "SKALE Titan Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/parallel-stormy-spica"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/parallel-stormy-spica"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://parallel-stormy-spica.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2076458
    }
  }
});

// node_modules/viem/_esm/chains/definitions/skale/titanTestnet.js
var skaleTitanTestnet = defineChain({
  id: 1020352220,
  name: "SKALE Titan Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/aware-fake-trim-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/aware-fake-trim-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://aware-fake-trim-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 104072
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sketchpad.js
var sketchpad = defineChain({
  id: 984123,
  name: "Forma Sketchpad",
  network: "sketchpad",
  nativeCurrency: {
    symbol: "TIA",
    name: "TIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.sketchpad-1.forma.art"],
      webSocket: ["wss://ws.sketchpad-1.forma.art"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sketchpad Explorer",
      url: "https://explorer.sketchpad-1.forma.art"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/snax.js
var sourceId52 = 1;
var snax = defineChain({
  ...chainConfig2,
  id: 2192,
  network: "snaxchain-mainnet",
  name: "SnaxChain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.snaxchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Snax Explorer",
      url: "https://explorer.snaxchain.io",
      apiUrl: "https://explorer.snaxchain.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId52]: {
        address: "0x472562Fcf26D6b2793f8E0b0fB660ba0E5e08A46"
      }
    },
    l2OutputOracle: {
      [sourceId52]: {
        address: "0x2172e492Fc807F5d5645D0E3543f139ECF539294"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId52]: {
        address: "0x79f446D024d74D0Bb6E699C131c703463c5D65E9"
      }
    },
    l1StandardBridge: {
      [sourceId52]: {
        address: "0x6534Bdb6b5c060d3e6aa833433333135eFE8E0aA"
      }
    }
  },
  sourceId: sourceId52
});

// node_modules/viem/_esm/chains/definitions/snaxTestnet.js
var sourceId53 = 11155111;
var snaxTestnet = defineChain({
  ...chainConfig2,
  id: 13001,
  network: "snaxchain-testnet",
  name: "SnaxChain Testnet",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.snaxchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Snax Explorer",
      url: "https://testnet-explorer.snaxchain.io",
      apiUrl: "https://testnet-explorer.snaxchain.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId53]: {
        address: "0x206a75d89d45F146C54020F132FF93bEDD09f55E"
      }
    },
    l2OutputOracle: {
      [sourceId53]: {
        address: "0x60e3A368a4cdCEf85ffB964e372726F56A46221e"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId53]: {
        address: "0xb5afdd0E8dDF081Ef90e8A3e0c7b5798e66E954E"
      }
    },
    l1StandardBridge: {
      [sourceId53]: {
        address: "0xbd37E1a59D4C00C9A46F75018dffd84061bC5f74"
      }
    }
  },
  testnet: true,
  sourceId: sourceId53
});

// node_modules/viem/_esm/chains/definitions/somniaTestnet.js
var somniaTestnet = defineChain({
  id: 50312,
  name: "Somnia Testnet",
  nativeCurrency: { name: "STT", symbol: "STT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dream-rpc.somnia.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Somnia Testnet Explorer",
      url: "https://shannon-explorer.somnia.network/",
      apiUrl: "https://shannon-explorer.somnia.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x841b8199E6d3Db3C6f264f6C2bd8848b3cA64223",
      blockCreated: 71314235
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/soneium.js
var sourceId54 = 1;
var soneium = defineChain({
  ...chainConfig2,
  id: 1868,
  name: "Soneium Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.soneium.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://soneium.blockscout.com",
      apiUrl: "https://soneium.blockscout.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId54]: {
        address: "0x512a3d2c7a43bd9261d2b8e8c9c70d4bd4d503c0"
      }
    },
    l2OutputOracle: {
      [sourceId54]: {
        address: "0x0000000000000000000000000000000000000000"
      }
    },
    portal: {
      [sourceId54]: {
        address: "0x88e529a6ccd302c948689cd5156c83d4614fae92",
        blockCreated: 7061266
      }
    },
    l1StandardBridge: {
      [sourceId54]: {
        address: "0xeb9bf100225c214efc3e7c651ebbadcf85177607",
        blockCreated: 7061266
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  },
  sourceId: sourceId54
});

// node_modules/viem/_esm/chains/definitions/soneiumMinato.js
var sourceId55 = 11155111;
var soneiumMinato = defineChain({
  ...chainConfig2,
  id: 1946,
  name: "Soneium Minato Testnet",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.minato.soneium.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://soneium-minato.blockscout.com",
      apiUrl: "https://soneium-minato.blockscout.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId55]: {
        address: "0xB3Ad2c38E6e0640d7ce6aA952AB3A60E81bf7a01"
      }
    },
    l2OutputOracle: {
      [sourceId55]: {
        address: "0x710e5286C746eC38beeB7538d0146f60D27be343"
      }
    },
    portal: {
      [sourceId55]: {
        address: "0x65ea1489741A5D72fFdD8e6485B216bBdcC15Af3",
        blockCreated: 6466136
      }
    },
    l1StandardBridge: {
      [sourceId55]: {
        address: "0x5f5a404A5edabcDD80DB05E8e54A78c9EBF000C2",
        blockCreated: 6466136
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  },
  testnet: true,
  sourceId: sourceId55
});

// node_modules/viem/_esm/chains/definitions/songbird.js
var songbird = defineChain({
  id: 19,
  name: "Songbird Canary-Network",
  nativeCurrency: {
    decimals: 18,
    name: "Songbird",
    symbol: "SGB"
  },
  rpcUrls: {
    default: { http: ["https://songbird-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Songbird Explorer",
      url: "https://songbird-explorer.flare.network",
      apiUrl: "https://songbird-explorer.flare.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 13382504
    }
  }
});

// node_modules/viem/_esm/chains/definitions/songbirdTestnet.js
var songbirdTestnet = defineChain({
  id: 16,
  name: "Songbird Testnet Coston",
  nativeCurrency: {
    decimals: 18,
    name: "Coston Flare",
    symbol: "CFLR"
  },
  rpcUrls: {
    default: { http: ["https://coston-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Coston Explorer",
      url: "https://coston-explorer.flare.network",
      apiUrl: "https://coston-explorer.flare.network/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sonic.js
var sonic = defineChain({
  id: 146,
  name: "Sonic",
  blockTime: 630,
  nativeCurrency: {
    decimals: 18,
    name: "Sonic",
    symbol: "S"
  },
  rpcUrls: {
    default: { http: ["https://rpc.soniclabs.com"] }
  },
  blockExplorers: {
    default: {
      name: "Sonic Explorer",
      url: "https://sonicscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 60
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/sonicBlazeTestnet.js
var sonicBlazeTestnet = defineChain({
  id: 57054,
  name: "Sonic Blaze Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Sonic",
    symbol: "S"
  },
  rpcUrls: {
    default: { http: ["https://rpc.blaze.soniclabs.com"] }
  },
  blockExplorers: {
    default: {
      name: "Sonic Blaze Testnet Explorer",
      url: "https://testnet.sonicscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1100
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sonicTestnet.js
var sonicTestnet = defineChain({
  id: 64165,
  name: "Sonic Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Sonic",
    symbol: "S"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.soniclabs.com"] }
  },
  blockExplorers: {
    default: {
      name: "Sonic Testnet Explorer",
      url: "https://testnet.soniclabs.com/"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sophon.js
var sophon = defineChain({
  ...chainConfig,
  id: 50104,
  name: "Sophon",
  nativeCurrency: {
    decimals: 18,
    name: "Sophon",
    symbol: "SOPH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.sophon.xyz"],
      webSocket: ["wss://rpc.sophon.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sophon Block Explorer",
      url: "https://explorer.sophon.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0x5f4867441d2416cA88B1b3fd38f21811680CD2C8",
      blockCreated: 116
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/sophonTestnet.js
var sophonTestnet = defineChain({
  ...chainConfig,
  id: 531050104,
  name: "Sophon Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Sophon",
    symbol: "SOPH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.sophon.xyz"],
      webSocket: ["wss://rpc.testnet.sophon.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sophon Block Explorer",
      url: "https://explorer.testnet.sophon.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0x83c04d112adedA2C6D9037bb6ecb42E7f0b108Af",
      blockCreated: 15642
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sova.js
var sova = defineChain({
  id: 100021,
  name: "Sova",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.sova.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sova Block Explorer",
      url: "hhttps://explorer.sova.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/sovaSepolia.js
var sovaSepolia = defineChain({
  id: 120893,
  name: "Sova Network Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Sepolia Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.sova.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sova Sepolia Explorer",
      url: "https://explorer.testnet.sova.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/spicy.js
var spicy = defineChain({
  id: 88882,
  name: "Chiliz Spicy Testnet",
  network: "chiliz-spicy-Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "CHZ",
    symbol: "CHZ"
  },
  rpcUrls: {
    default: {
      http: [
        "https://spicy-rpc.chiliz.com",
        "https://chiliz-spicy-rpc.publicnode.com"
      ],
      webSocket: [
        "wss://spicy-rpc-ws.chiliz.com",
        "wss://chiliz-spicy-rpc.publicnode.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Chiliz Explorer",
      url: "http://spicy-explorer.chiliz.com",
      apiUrl: "http://spicy-explorer.chiliz.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/statusNetworkSepolia.js
var statusSepolia = defineChain({
  ...chainConfig4,
  id: 1660990954,
  name: "Status Network Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://public.sepolia.rpc.status.network"],
      webSocket: ["wss://public.sepolia.rpc.status.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepoliascan.status.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1578364
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/step.js
var step = defineChain({
  id: 1234,
  name: "Step Network",
  nativeCurrency: { name: "FITFI", symbol: "FITFI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.step.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Step Scan",
      url: "https://stepscan.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/story.js
var story = defineChain({
  id: 1514,
  name: "Story",
  nativeCurrency: {
    decimals: 18,
    name: "IP Token",
    symbol: "IP"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 340998
    },
    ensRegistry: {
      address: "0x5dc881dda4e4a8d312be3544ad13118d1a04cb17",
      blockCreated: 648924
    },
    ensUniversalResolver: {
      address: "0xddfb18888a9466688235887dec2a10c4f5effee9",
      blockCreated: 649114
    }
  },
  rpcUrls: {
    default: { http: ["https://mainnet.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story explorer",
      url: "https://storyscan.io",
      apiUrl: "https://storyscan.io/api/v2"
    }
  },
  ensTlds: [".ip"],
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/storyAeneid.js
var storyAeneid = defineChain({
  id: 1315,
  name: "Story Aeneid",
  network: "story-aeneid",
  nativeCurrency: {
    decimals: 18,
    name: "IP",
    symbol: "IP"
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1792
    },
    ensRegistry: {
      address: "0x5dC881dDA4e4a8d312be3544AD13118D1a04Cb17",
      blockCreated: 1322033
    },
    ensUniversalResolver: {
      address: "0x6D3B3F99177FB2A5de7F9E928a9BD807bF7b5BAD",
      blockCreated: 1322097
    }
  },
  rpcUrls: {
    default: { http: ["https://aeneid.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story Aeneid Explorer",
      url: "https://aeneid.storyscan.io",
      apiUrl: "https://aeneid.storyscan.io/api/v2"
    }
  },
  ensTlds: [".ip"],
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/storyOdyssey.js
var storyOdyssey = defineChain({
  id: 1516,
  name: "Story Odyssey",
  nativeCurrency: {
    decimals: 18,
    name: "IP",
    symbol: "IP"
  },
  rpcUrls: {
    default: { http: ["https://rpc.odyssey.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story Odyssey Explorer",
      url: "https://odyssey.storyscan.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/storyTestnet.js
var storyTestnet = defineChain({
  id: 1513,
  name: "Story Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "IP",
    symbol: "IP"
  },
  rpcUrls: {
    default: { http: ["https://testnet.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story Testnet Explorer",
      url: "https://testnet.storyscan.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/stratis.js
var stratis = defineChain({
  id: 105105,
  name: "Stratis Mainnet",
  network: "stratis",
  nativeCurrency: {
    name: "Stratis",
    symbol: "STRAX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.stratisevm.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Stratis Explorer",
      url: "https://explorer.stratisevm.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/superlumio.js
var superlumio = defineChain({
  id: 8866,
  name: "SuperLumio",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.lumio.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumio explorer",
      url: "https://explorer.lumio.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/superposition.js
var superposition = defineChain({
  id: 55244,
  name: "Superposition",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.superposition.so"] }
  },
  blockExplorers: {
    default: {
      name: "Superposition Explorer",
      url: "https://explorer.superposition.so"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 39
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/superseed.js
var sourceId56 = 1;
var superseed = defineChain({
  ...chainConfig2,
  id: 5330,
  name: "Superseed",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.superseed.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Superseed Explorer",
      url: "https://explorer.superseed.xyz",
      apiUrl: "https://explorer.superseed.xyz/api/v2"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId56]: {
        address: "0x8b097CF1f9BbD9cbFD0DD561858a1FCbC8857Be0",
        blockCreated: 20737481
      }
    },
    l2OutputOracle: {
      [sourceId56]: {
        address: "0x693A0F8854F458D282DE3C5b69E8eE5EEE8aA949",
        blockCreated: 20737481
      }
    },
    portal: {
      [sourceId56]: {
        address: "0x2c2150aa5c75A24fB93d4fD2F2a895D618054f07",
        blockCreated: 20737481
      }
    },
    l1StandardBridge: {
      [sourceId56]: {
        address: "0x8b0576E39F1233679109F9b40cFcC2a7E0901Ede",
        blockCreated: 20737481
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  sourceId: sourceId56
});

// node_modules/viem/_esm/chains/definitions/superseedSepolia.js
var sourceId57 = 11155111;
var superseedSepolia = defineChain({
  ...chainConfig2,
  id: 53302,
  name: "Superseed Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.superseed.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Superseed Sepolia Explorer",
      url: "https://sepolia-explorer.superseed.xyz",
      apiUrl: "https://sepolia-explorer.superseed.xyz/api/v2"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    },
    portal: {
      [sourceId57]: {
        address: "0x7A0db8C51432d2C3eb4e8f360a2EeB26FF2809fB",
        blockCreated: 5523438
      }
    },
    l1StandardBridge: {
      [sourceId57]: {
        address: "0x2B227A603fAAdB3De0ED050b63ADD232B5f2c28C",
        blockCreated: 5523442
      }
    }
  },
  testnet: true,
  sourceId: sourceId57
});

// node_modules/viem/_esm/chains/definitions/surgeTestnet.js
var surgeTestnet = defineChain({
  id: 763375,
  name: "Surge Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://l2-rpc.hoodi.surge.wtf"],
      webSocket: ["wss://l2-ws.hoodi.surge.wtf"]
    }
  },
  blockExplorers: {
    default: {
      name: "Surge Testnet Blockscout",
      url: "https://explorer.hoodi.surge.wtf"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/swan.js
var swan = defineChain({
  id: 254,
  name: "Swan Chain Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://mainnet-rpc.swanchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "Swan Explorer",
      url: "https://swanscan.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/swanProximaTestnet.js
var swanProximaTestnet = defineChain({
  id: 20241133,
  name: "Swan Proxima Testnet",
  nativeCurrency: { name: "Swan Ether", symbol: "sETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-proxima.swanchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Swan Explorer",
      url: "https://proxima-explorer.swanchain.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/swanSaturnTestnet.js
var swanSaturnTestnet = defineChain({
  id: 2024,
  name: "Swan Saturn Testnet",
  nativeCurrency: { name: "Swan Ether", symbol: "sETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://saturn-rpc.swanchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Swan Explorer",
      url: "https://saturn-explorer.swanchain.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/swellchain.js
var swellchain = defineChain({
  ...chainConfig2,
  id: 1923,
  name: "Swellchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://swell-mainnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Swell Explorer",
      url: "https://explorer.swellnetwork.io",
      apiUrl: "https://explorer.swellnetwork.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  }
});

// node_modules/viem/_esm/chains/definitions/swellchainTestnet.js
var swellchainTestnet = defineChain({
  ...chainConfig2,
  id: 1924,
  name: "Swellchain Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://swell-testnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Swellchain Testnet Explorer",
      url: "https://swell-testnet-explorer.alt.technology",
      apiUrl: "https://swell-testnet-explorer.alt.technology/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  }
});

// node_modules/viem/_esm/chains/definitions/swissdlt.js
var swissdlt = defineChain({
  id: 94,
  name: "SwissDLT Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "BCTS",
    symbol: "BCTS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.swissdlt.ch"]
    }
  },
  blockExplorers: {
    default: {
      name: "SwissDLT Explorer",
      url: "https://explorer.swissdlt.ch"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/syscoin.js
var syscoin = defineChain({
  id: 57,
  name: "Syscoin Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.syscoin.org"],
      webSocket: ["wss://rpc.syscoin.org/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "SyscoinExplorer",
      url: "https://explorer.syscoin.org",
      apiUrl: "https://explorer.syscoin.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 287139
    }
  }
});

// node_modules/viem/_esm/chains/definitions/syscoinTestnet.js
var syscoinTestnet = defineChain({
  id: 5700,
  name: "Syscoin Tanenbaum Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.tanenbaum.io"],
      webSocket: ["wss://rpc.tanenbaum.io/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "SyscoinTestnetExplorer",
      url: "https://tanenbaum.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 271288
    }
  }
});

// node_modules/viem/_esm/chains/definitions/tac.js
var tac = defineChain({
  id: 239,
  name: "TAC",
  nativeCurrency: { name: "TAC", symbol: "TAC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.ankr.com/tac"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://tac.blockscout.com",
      apiUrl: "https://tac.blockscout.com/api"
    },
    native: {
      name: "TAC Explorer",
      url: "https://explorer.tac.build",
      apiUrl: "https://explorer.tac.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  }
});

// node_modules/viem/_esm/chains/definitions/tacSPB.js
var tacSPB = defineChain({
  id: 2391,
  name: "TAC SPB Testnet",
  nativeCurrency: {
    name: "TAC",
    symbol: "TAC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://spb.rpc.tac.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "TAC",
      url: "https://spb.explorer.tac.build",
      apiUrl: "https://spb.explorer.tac.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 471429
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/taiko.js
var taiko = defineChain({
  id: 167e3,
  name: "Taiko Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.taiko.xyz"],
      webSocket: ["wss://ws.mainnet.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taikoscan",
      url: "https://taikoscan.io",
      apiUrl: "https://api.taikoscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcb2436774C3e191c85056d248EF4260ce5f27A9D"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/taikoHekla.js
var taikoHekla = defineChain({
  id: 167009,
  name: "Taiko Hekla L2",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.hekla.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taikoscan",
      url: "https://hekla.taikoscan.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 59757
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/taikoJolnir.js
var taikoJolnir = defineChain({
  id: 167007,
  name: "Taiko Jolnir (Alpha-5 Testnet)",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.jolnir.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.jolnir.taiko.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 732706
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/taikoKatla.js
var taikoKatla = defineChain({
  id: 167008,
  name: "Taiko Katla (Alpha-6 Testnet)",
  network: "tko-katla",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.katla.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.katla.taiko.xyz"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/taikoTestnetSepolia.js
var taikoTestnetSepolia = defineChain({
  id: 167005,
  name: "Taiko (Alpha-3 Testnet)",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.test.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.test.taiko.xyz"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/taraxa.js
var taraxa = defineChain({
  id: 841,
  name: "Taraxa Mainnet",
  nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.taraxa.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taraxa Explorer",
      url: "https://explorer.mainnet.taraxa.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/taraxaTestnet.js
var taraxaTestnet = defineChain({
  id: 842,
  name: "Taraxa Testnet",
  nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.taraxa.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taraxa Explorer",
      url: "https://explorer.testnet.taraxa.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/teaSepolia.js
var teaSepolia = defineChain({
  id: 10218,
  name: "Tea Sepolia",
  nativeCurrency: { name: "Sepolia Tea", symbol: "TEA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://tea-sepolia.g.alchemy.com/public"]
    }
  },
  blockExplorers: {
    default: {
      name: "Tea Sepolia Explorer",
      url: "https://sepolia.tea.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/telcoinTestnet.js
var telcoinTestnet = defineChain({
  id: 2017,
  name: "Telcoin Adiri Testnet",
  nativeCurrency: { name: "Telcoin", symbol: "TEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.telcoin.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "telscan",
      url: "https://telscan.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/telos.js
var telos = defineChain({
  id: 40,
  name: "Telos",
  nativeCurrency: {
    decimals: 18,
    name: "Telos",
    symbol: "TLOS"
  },
  rpcUrls: {
    default: { http: ["https://rpc.telos.net"] }
  },
  blockExplorers: {
    default: {
      name: "Teloscan",
      url: "https://www.teloscan.io/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 246530709
    }
  }
});

// node_modules/viem/_esm/chains/definitions/telosTestnet.js
var telosTestnet = defineChain({
  id: 41,
  name: "Telos",
  nativeCurrency: {
    decimals: 18,
    name: "Telos",
    symbol: "TLOS"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.telos.net"] }
  },
  blockExplorers: {
    default: {
      name: "Teloscan (testnet)",
      url: "https://testnet.teloscan.io/"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/tenet.js
var tenet = defineChain({
  id: 1559,
  name: "Tenet",
  network: "tenet-mainnet",
  nativeCurrency: {
    name: "TENET",
    symbol: "TENET",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.tenet.org"] }
  },
  blockExplorers: {
    default: {
      name: "TenetScan Mainnet",
      url: "https://tenetscan.io",
      apiUrl: "https://tenetscan.io/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/ternoa.js
var ternoa = defineChain({
  id: 752025,
  name: "Ternoa",
  nativeCurrency: { name: "Capsule Coin", symbol: "CAPS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-mainnet.zkevm.ternoa.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ternoa Explorer",
      url: "https://explorer-mainnet.zkevm.ternoa.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/thaiChain.js
var thaiChain = defineChain({
  id: 7,
  name: "ThaiChain",
  nativeCurrency: { name: "TCH", symbol: "TCH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.thaichain.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp.thaichain.org",
      apiUrl: "https://exp.thaichain.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0DaD6130e832c21719C5CE3bae93454E16A84826",
      blockCreated: 4806386
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/that.js
var that = defineChain({
  id: 8428,
  name: "THAT Mainnet",
  nativeCurrency: { name: "THAT", symbol: "THAT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.thatchain.io/mainnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://that.blockscout.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/theta.js
var theta = defineChain({
  id: 361,
  name: "Theta Mainnet",
  nativeCurrency: { name: "TFUEL", symbol: "TFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-api.thetatoken.org/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Theta Explorer",
      url: "https://explorer.thetatoken.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/thetaTestnet.js
var thetaTestnet = defineChain({
  id: 365,
  name: "Theta Testnet",
  nativeCurrency: { name: "TFUEL", symbol: "TFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-api-testnet.thetatoken.org/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Theta Explorer",
      url: "https://testnet-explorer.thetatoken.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/thunderCore.js
var thunderCore = defineChain({
  id: 108,
  name: "ThunderCore Mainnet",
  nativeCurrency: { name: "TT", symbol: "TT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.thundercore.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "ThunderCore Explorer",
      url: "https://explorer-mainnet.thundercore.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/thunderTestnet.js
var thunderTestnet = defineChain({
  id: 997,
  name: "5ireChain Thunder Testnet",
  nativeCurrency: { name: "5ire Token", symbol: "5IRE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.5ire.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "5ireChain Thunder Explorer",
      url: "https://testnet.5irescan.io/"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/tiktrixTestnet.js
var tiktrixTestnet = defineChain({
  id: 62092,
  name: "TikTrix Testnet",
  nativeCurrency: {
    name: "tTTX",
    symbol: "tTTX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://tiktrix-rpc.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "TikTrix Testnet Explorer",
      url: "https://tiktrix.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/tomb.js
var tomb = defineChain({
  id: 6969,
  name: "Tomb Mainnet",
  nativeCurrency: { name: "TOMB", symbol: "TOMB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.tombchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Tomb Explorer",
      url: "https://tombscout.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/treasure.js
var treasure = defineChain({
  ...chainConfig,
  id: 61166,
  name: "Treasure",
  nativeCurrency: {
    decimals: 18,
    name: "MAGIC",
    symbol: "MAGIC"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.treasure.lol"],
      webSocket: ["wss://rpc.treasure.lol/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Treasure Block Explorer",
      url: "https://treasurescan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0x2e29fe39496a56856D8698bD43e1dF4D0CE6266a",
      blockCreated: 101
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/treasureTopaz.js
var treasureTopaz = defineChain({
  ...chainConfig,
  id: 978658,
  name: "Treasure Topaz Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MAGIC",
    symbol: "MAGIC"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.topaz.treasure.lol"],
      webSocket: ["wss://rpc.topaz.treasure.lol/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Treasure Topaz Block Explorer",
      url: "https://topaz.treasurescan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963",
      blockCreated: 108112
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/tron.js
var tron = defineChain({
  id: 728126428,
  name: "Tron",
  nativeCurrency: { name: "TRON", symbol: "TRX", decimals: 6 },
  rpcUrls: {
    default: {
      http: ["https://api.trongrid.io/jsonrpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Tronscan",
      url: "https://tronscan.org",
      apiUrl: "https://apilist.tronscanapi.com/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/tronNile.js
var tronNile = defineChain({
  id: 3448148188,
  name: "Tron Nile",
  nativeCurrency: { name: "TRON", symbol: "TRX", decimals: 6 },
  rpcUrls: {
    default: {
      http: ["https://nile.trongrid.io/jsonrpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Tronscan",
      url: "https://nile.tronscan.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/tronShasta.js
var tronShasta = defineChain({
  id: 2494104990,
  name: "Tron Shasta",
  nativeCurrency: { name: "TRON", symbol: "TRX", decimals: 6 },
  rpcUrls: {
    default: {
      http: ["https://api.shasta.trongrid.io/jsonrpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Tronscan",
      url: "https://shasta.tronscan.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/ubiq.js
var ubiq = defineChain({
  id: 8,
  name: "Ubiq Mainnet",
  nativeCurrency: { name: "UBQ", symbol: "UBQ", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://pyrus2.ubiqscan.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ubiq Scan",
      url: "https://ubiqscan.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/ultra.js
var ultra = defineChain({
  id: 19991,
  name: "Ultra EVM",
  nativeCurrency: {
    decimals: 18,
    name: "Ultra Token",
    symbol: "UOS"
  },
  rpcUrls: {
    default: { http: ["https://evm.ultra.eosusa.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ultra EVM Explorer",
      url: "https://evmexplorer.ultra.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/ultraTestnet.js
var ultraTestnet = defineChain({
  id: 18881,
  name: "Ultra EVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ultra Token",
    symbol: "UOS"
  },
  rpcUrls: {
    default: { http: ["https://evm.test.ultra.eosusa.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ultra EVM Testnet Explorer",
      url: "https://evmexplorer.testnet.ultra.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/ultron.js
var ultron = defineChain({
  id: 1231,
  name: "Ultron Mainnet",
  nativeCurrency: { name: "ULX", symbol: "ULX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://ultron-rpc.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ultron Scan",
      url: "https://ulxscan.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/ultronTestnet.js
var ultronTestnet = defineChain({
  id: 1230,
  name: "Ultron Testnet",
  nativeCurrency: { name: "ULX", symbol: "ULX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://ultron-dev.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ultron Scan",
      url: "https://explorer.ultron-dev.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/unichain.js
var sourceId58 = 1;
var unichain = defineChain({
  ...chainConfig2,
  id: 130,
  name: "Unichain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  blockTime: 1e3,
  rpcUrls: {
    default: {
      http: ["https://mainnet.unichain.org/"]
    }
  },
  blockExplorers: {
    default: {
      name: "Uniscan",
      url: "https://uniscan.xyz",
      apiUrl: "https://api.uniscan.xyz/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [sourceId58]: {
        address: "0x2F12d621a16e2d3285929C9996f478508951dFe4"
      }
    },
    portal: {
      [sourceId58]: {
        address: "0x0bd48f6B86a26D3a217d0Fa6FfE2B491B956A7a2"
      }
    },
    l1StandardBridge: {
      [sourceId58]: {
        address: "0x81014F44b0a345033bB2b3B21C7a1A308B35fEeA"
      }
    }
  },
  sourceId: sourceId58
});

// node_modules/viem/_esm/chains/definitions/unichainSepolia.js
var sourceId59 = 11155111;
var unichainSepolia = defineChain({
  ...chainConfig2,
  id: 1301,
  name: "Unichain Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  blockTime: 1e3,
  rpcUrls: {
    default: {
      http: ["https://sepolia.unichain.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Uniscan",
      url: "https://sepolia.uniscan.xyz",
      apiUrl: "https://api-sepolia.uniscan.xyz/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    portal: {
      [sourceId59]: {
        address: "0x0d83dab629f0e0F9d36c0Cbc89B69a489f0751bD"
      }
    },
    l1StandardBridge: {
      [sourceId59]: {
        address: "0xea58fcA6849d79EAd1f26608855c2D6407d54Ce2"
      }
    },
    disputeGameFactory: {
      [sourceId59]: {
        address: "0xeff73e5aa3B9AEC32c659Aa3E00444d20a84394b"
      }
    }
  },
  testnet: true,
  sourceId: sourceId59
});

// node_modules/viem/_esm/chains/definitions/unique.js
var unique = defineChain({
  id: 8880,
  name: "Unique Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "UNQ",
    symbol: "UNQ"
  },
  rpcUrls: {
    default: { http: ["https://rpc.unique.network"] }
  },
  blockExplorers: {
    default: {
      name: "Unique Subscan",
      url: "https://unique.subscan.io/"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/uniqueOpal.js
var uniqueOpal = defineChain({
  id: 8882,
  name: "Opal Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "OPL",
    symbol: "OPL"
  },
  rpcUrls: {
    default: { http: ["https://rpc-opal.unique.network"] }
  },
  blockExplorers: {
    default: {
      name: "Opal Subscan",
      url: "https://opal.subscan.io/"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/uniqueQuartz.js
var uniqueQuartz = defineChain({
  id: 8881,
  name: "Quartz Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "QTZ",
    symbol: "QTZ"
  },
  rpcUrls: {
    default: { http: ["https://rpc-quartz.unique.network"] }
  },
  blockExplorers: {
    default: {
      name: "Quartz Subscan",
      url: "https://quartz.subscan.io/"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/unreal.js
var unreal = defineChain({
  id: 18233,
  name: "Unreal",
  nativeCurrency: {
    name: "reETH",
    decimals: 18,
    symbol: "reETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.unreal-orbit.gelato.digital"] }
  },
  blockExplorers: {
    default: {
      name: "Unreal Explorer",
      url: "https://unreal.blockscout.com",
      apiUrl: "https://unreal.blockscout.com/api/v2"
    }
  },
  testnet: true,
  contracts: {
    multicall3: {
      address: "0x8b6B0e60D8CD84898Ea8b981065A12F876eA5677",
      blockCreated: 1745
    }
  }
});

// node_modules/viem/_esm/chains/definitions/vana.js
var vana = defineChain({
  id: 1480,
  name: "Vana",
  blockTime: 6e3,
  nativeCurrency: {
    decimals: 18,
    name: "Vana",
    symbol: "VANA"
  },
  rpcUrls: {
    default: { http: ["https://rpc.vana.org/"] }
  },
  blockExplorers: {
    default: {
      name: "Vana Block Explorer",
      url: "https://vanascan.io",
      apiUrl: "https://vanascan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xD8d2dFca27E8797fd779F8547166A2d3B29d360E",
      blockCreated: 716763
    }
  }
});

// node_modules/viem/_esm/chains/definitions/vanaMoksha.js
var vanaMoksha = defineChain({
  id: 14800,
  name: "Vana Moksha Testnet",
  blockTime: 6e3,
  nativeCurrency: {
    decimals: 18,
    name: "Vana",
    symbol: "VANA"
  },
  rpcUrls: {
    default: { http: ["https://rpc.moksha.vana.org"] }
  },
  blockExplorers: {
    default: {
      name: "Vana Moksha Testnet",
      url: "https://moksha.vanascan.io",
      apiUrl: "https://moksha.vanascan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xD8d2dFca27E8797fd779F8547166A2d3B29d360E",
      blockCreated: 732283
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/vanar.js
var vanar = defineChain({
  id: 2040,
  name: "Vanar Mainnet",
  nativeCurrency: { name: "VANRY", symbol: "VANRY", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.vanarchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vanar Mainnet Explorer",
      url: "https://explorer.vanarchain.com/"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/vechain.js
var vechain = defineChain({
  id: 100009,
  name: "Vechain",
  nativeCurrency: { name: "VeChain", symbol: "VET", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.vechain.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vechain Explorer",
      url: "https://explore.vechain.org"
    },
    vechainStats: {
      name: "Vechain Stats",
      url: "https://vechainstats.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/velas.js
var velas = defineChain({
  id: 106,
  name: "Velas EVM Mainnet",
  nativeCurrency: { name: "VLX", symbol: "VLX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evmexplorer.velas.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Velas Explorer",
      url: "https://evmexplorer.velas.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 55883577
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/viction.js
var viction = defineChain({
  id: 88,
  name: "Viction",
  nativeCurrency: { name: "Viction", symbol: "VIC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.viction.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "VIC Scan",
      url: "https://vicscan.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/victionTestnet.js
var victionTestnet = defineChain({
  id: 89,
  name: "Viction Testnet",
  nativeCurrency: { name: "Viction", symbol: "VIC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.viction.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "VIC Scan",
      url: "https://testnet.vicscan.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 12170179
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/vision.js
var vision = defineChain({
  id: 888888,
  name: "Vision",
  nativeCurrency: { name: "VISION", symbol: "VS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://infragrid.v.network/ethereum/compatible"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vision Scan",
      url: "https://visionscan.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/visionTestnet.js
var visionTestnet = defineChain({
  id: 666666,
  name: "Vision Testnet",
  nativeCurrency: { name: "VISION", symbol: "VS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://vpioneer.infragrid.v.network/ethereum/compatible"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vision Scan",
      url: "https://visionscan.org/?chain=vpioneer"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/wanchain.js
var wanchain = defineChain({
  id: 888,
  name: "Wanchain",
  nativeCurrency: { name: "WANCHAIN", symbol: "WAN", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://gwan-ssl.wandevs.org:56891",
        "https://gwan2-ssl.wandevs.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "WanScan",
      url: "https://wanscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcDF6A1566e78EB4594c86Fe73Fcdc82429e97fbB",
      blockCreated: 25312390
    }
  }
});

// node_modules/viem/_esm/chains/definitions/wanchainTestnet.js
var wanchainTestnet = defineChain({
  id: 999,
  name: "Wanchain Testnet",
  nativeCurrency: { name: "WANCHAIN", symbol: "WANt", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://gwan-ssl.wandevs.org:46891"]
    }
  },
  blockExplorers: {
    default: {
      name: "WanScanTest",
      url: "https://wanscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0x11c89bF4496c39FB80535Ffb4c92715839CC5324",
      blockCreated: 24743448
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/weavevmAlphanet.js
var weaveVMAlphanet = defineChain({
  id: 9496,
  name: "WeaveVM Alphanet",
  nativeCurrency: { name: "Testnet WeaveVM", symbol: "tWVM", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://testnet-rpc.wvm.dev"] }
  },
  blockExplorers: {
    default: {
      name: "WeaveVM Alphanet Explorer",
      url: "https://explorer.wvm.dev"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/wemix.js
var wemix = defineChain({
  id: 1111,
  name: "WEMIX",
  network: "wemix-mainnet",
  nativeCurrency: { name: "WEMIX", symbol: "WEMIX", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://api.wemix.com"] }
  },
  blockExplorers: {
    default: {
      name: "wemixExplorer",
      url: "https://explorer.wemix.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/wemixTestnet.js
var wemixTestnet = defineChain({
  id: 1112,
  name: "WEMIX Testnet",
  network: "wemix-testnet",
  nativeCurrency: { name: "WEMIX", symbol: "tWEMIX", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://api.test.wemix.com"] }
  },
  blockExplorers: {
    default: {
      name: "wemixExplorer",
      url: "https://testnet.wemixscan.com",
      apiUrl: "https://testnet.wemixscan.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/westendAssetHub.js
var westendAssetHub = defineChain({
  id: 420420421,
  name: "Westend Asset Hub",
  nativeCurrency: {
    decimals: 18,
    name: "Westies",
    symbol: "WND"
  },
  rpcUrls: {
    default: { http: ["https://westend-asset-hub-eth-rpc.polkadot.io"] }
  },
  blockExplorers: {
    default: {
      name: "subscan",
      url: "https://westend-asset-hub-eth-explorer.parity.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/whitechain.js
var whitechain = defineChain({
  testnet: false,
  name: "Whitechain",
  blockExplorers: {
    default: {
      name: "Whitechain Explorer",
      url: "https://explorer.whitechain.io"
    }
  },
  id: 1875,
  rpcUrls: {
    default: {
      http: ["https://rpc.whitechain.io"]
    }
  },
  nativeCurrency: {
    decimals: 18,
    name: "WhiteBIT Coin",
    symbol: "WBT"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 25212237
    }
  }
});

// node_modules/viem/_esm/chains/definitions/whitechainTestnet.js
var whitechainTestnet = defineChain({
  testnet: true,
  name: "Whitechain Testnet",
  blockExplorers: {
    default: {
      name: "Whitechain Explorer",
      url: "https://testnet.whitechain.io"
    }
  },
  id: 2625,
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.whitechain.io"]
    }
  },
  nativeCurrency: {
    decimals: 18,
    name: "WhiteBIT Coin",
    symbol: "WBT"
  }
});

// node_modules/viem/_esm/chains/definitions/wmcTestnet.js
var wmcTestnet = defineChain({
  id: 42070,
  name: "WMC Testnet",
  nativeCurrency: { name: "WMTx", symbol: "WMTx", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet-base.worldmobile.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "WMC Explorer",
      url: "https://explorer2-base-testnet.worldmobile.net"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/worldchain.js
var sourceId60 = 1;
var worldchain = defineChain({
  ...chainConfig2,
  id: 480,
  name: "World Chain",
  network: "worldchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://worldchain-mainnet.g.alchemy.com/public"] }
  },
  blockExplorers: {
    default: {
      name: "Worldscan",
      url: "https://worldscan.org",
      apiUrl: "https://api.worldscan.org/api"
    },
    blockscout: {
      name: "Blockscout",
      url: "https://worldchain-mainnet.explorer.alchemy.com",
      apiUrl: "https://worldchain-mainnet.explorer.alchemy.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [sourceId60]: {
        address: "0x069c4c579671f8c120b1327a73217D01Ea2EC5ea"
      }
    },
    l2OutputOracle: {
      [sourceId60]: {
        address: "0x19A6d1E9034596196295CF148509796978343c5D"
      }
    },
    portal: {
      [sourceId60]: {
        address: "0xd5ec14a83B7d95BE1E2Ac12523e2dEE12Cbeea6C"
      }
    },
    l1StandardBridge: {
      [sourceId60]: {
        address: "0x470458C91978D2d929704489Ad730DC3E3001113"
      }
    }
  },
  testnet: false,
  sourceId: sourceId60
});

// node_modules/viem/_esm/chains/definitions/worldchainSepolia.js
var sourceId61 = 11155111;
var worldchainSepolia = defineChain({
  ...chainConfig2,
  id: 4801,
  name: "World Chain Sepolia",
  network: "worldchain-sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://worldchain-sepolia.g.alchemy.com/public"] }
  },
  blockExplorers: {
    default: {
      name: "Worldscan Sepolia",
      url: "https://sepolia.worldscan.org",
      apiUrl: "https://api-sepolia.worldscan.org/api"
    },
    blockscout: {
      name: "Blockscout",
      url: "https://worldchain-sepolia.explorer.alchemy.com",
      apiUrl: "https://worldchain-sepolia.explorer.alchemy.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [sourceId61]: {
        address: "0x8Ec1111f67Dad6b6A93B3F42DfBC92D81c98449A"
      }
    },
    l2OutputOracle: {
      [sourceId61]: {
        address: "0xc8886f8BAb6Eaeb215aDB5f1c686BF699248300e"
      }
    },
    portal: {
      [sourceId61]: {
        address: "0xFf6EBa109271fe6d4237EeeD4bAb1dD9A77dD1A4"
      }
    },
    l1StandardBridge: {
      [sourceId61]: {
        address: "0xd7DF54b3989855eb66497301a4aAEc33Dbb3F8DE"
      }
    }
  },
  testnet: true,
  sourceId: sourceId61
});

// node_modules/viem/_esm/chains/definitions/worldLand.js
var worldLand = defineChain({
  id: 103,
  name: "WorldLand Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "WLC",
    symbol: "WLC"
  },
  rpcUrls: {
    default: {
      http: ["https://seoul.worldland.foundation"]
    }
  },
  blockExplorers: {
    default: {
      name: "WorldLand Scan",
      url: "https://scan.worldland.foundation"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/xai.js
var xai = defineChain({
  id: 660279,
  name: "Xai Mainnet",
  nativeCurrency: { name: "Xai", symbol: "XAI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://xai-chain.net/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.xai-chain.net"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 222549
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/xaiTestnet.js
var xaiTestnet = defineChain({
  id: 37714555429,
  name: "Xai Testnet",
  nativeCurrency: { name: "sXai", symbol: "sXAI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet-v2.xai-chain.net/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer-v2.xai-chain.net"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/xdc.js
var xdc = defineChain({
  id: 50,
  name: "XDC Network",
  nativeCurrency: {
    decimals: 18,
    name: "XDC",
    symbol: "XDC"
  },
  rpcUrls: {
    default: { http: ["https://rpc.xdcrpc.com"] }
  },
  blockExplorers: {
    default: {
      name: "XDCScan",
      url: "https://xdcscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0B1795ccA8E4eC4df02346a082df54D437F8D9aF",
      blockCreated: 75884020
    }
  }
});

// node_modules/viem/_esm/chains/definitions/xdcTestnet.js
var xdcTestnet = defineChain({
  id: 51,
  name: "Apothem Network",
  nativeCurrency: {
    decimals: 18,
    name: "TXDC",
    symbol: "TXDC"
  },
  rpcUrls: {
    default: { http: ["https://erpc.apothem.network"] }
  },
  blockExplorers: {
    default: {
      name: "XDCScan",
      url: "https://testnet.xdcscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 59765389
    }
  }
});

// node_modules/viem/_esm/chains/definitions/xLayer.js
var xLayer = defineChain({
  id: 196,
  name: "X Layer Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "OKB",
    symbol: "OKB"
  },
  rpcUrls: {
    default: { http: ["https://rpc.xlayer.tech"] }
  },
  blockExplorers: {
    default: {
      name: "OKLink",
      url: "https://www.oklink.com/xlayer",
      apiUrl: "https://www.oklink.com/api/v5/explorer/xlayer/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 47416
    }
  }
});

// node_modules/viem/_esm/chains/definitions/xLayerTestnet.js
var xLayerTestnet = defineChain({
  id: 195,
  name: "X1 Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "OKB",
    symbol: "OKB"
  },
  rpcUrls: {
    default: { http: ["https://xlayertestrpc.okx.com"] }
  },
  blockExplorers: {
    default: {
      name: "OKLink",
      url: "https://www.oklink.com/xlayer-test"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 624344
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/xphereMainnet.js
var xphereMainnet = defineChain({
  id: 20250217,
  name: "Xphere Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "XP",
    symbol: "XP"
  },
  rpcUrls: {
    default: {
      http: ["https://en-bkk.x-phere.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Xphere Tamsa Explorer",
      url: "https://xp.tamsa.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/xphereTestnet.js
var xphereTestnet = defineChain({
  id: 1998991,
  name: "Xphere Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "XPT",
    symbol: "XPT"
  },
  rpcUrls: {
    default: {
      http: ["http://testnet.x-phere.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Xphere Tamsa Explorer",
      url: "https://xpt.tamsa.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/xrOne.js
var xrOne = defineChain({
  id: 273,
  name: "XR One",
  nativeCurrency: {
    decimals: 18,
    name: "XR1",
    symbol: "XR1"
  },
  rpcUrls: {
    default: {
      http: ["https://xr1.calderachain.xyz/http"],
      webSocket: ["wss://xr1.calderachain.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://xr1.calderaexplorer.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/xrplevmDevnet.js
var xrplevmDevnet = defineChain({
  id: 1440002,
  name: "XRPL EVM Devnet",
  nativeCurrency: {
    name: "XRP",
    symbol: "XRP",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.xrplevm.org/"]
    },
    public: {
      http: ["https://rpc.xrplevm.org/"]
    }
  },
  blockExplorers: {
    default: {
      name: "XRPLEVM Devnet Explorer",
      url: "https://explorer.xrplevm.org/"
    }
  },
  contracts: {
    multicall3: {
      address: "0x82Cc144D7d0AD4B1c27cb41420e82b82Ad6e9B31",
      blockCreated: 15237286
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/xrplevmTestnet.js
var xrplevmTestnet = defineChain({
  id: 1449e3,
  name: "XRPL EVM Testnet",
  nativeCurrency: {
    name: "XRP",
    symbol: "XRP",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.xrplevm.org"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.testnet.xrplevm.org",
      apiUrl: "https://explorer.testnet.xrplevm.org/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0x82Cc144D7d0AD4B1c27cb41420e82b82Ad6e9B31",
      blockCreated: 492302
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/xrSepolia.js
var xrSepolia = defineChain({
  id: 2730,
  name: "XR Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "tXR",
    symbol: "tXR"
  },
  rpcUrls: {
    default: { http: ["https://xr-sepolia-testnet.rpc.caldera.xyz/http"] }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://xr-sepolia-testnet.explorer.caldera.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/yooldoVerse.js
var yooldoVerse = defineChain({
  id: 50005,
  name: "Yooldo Verse",
  nativeCurrency: { name: "OAS", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.yooldo-verse.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Yooldo Verse Explorer",
      url: "https://explorer.yooldo-verse.xyz"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/yooldoVerseTestnet.js
var yooldoVerseTestnet = defineChain({
  id: 50006,
  name: "Yooldo Verse Testnet",
  nativeCurrency: { name: "OAS", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.yooldo-verse.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Yooldo Verse Testnet Explorer",
      url: "https://explorer.testnet.yooldo-verse.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zenchainTestnet.js
var zenchainTestnet = defineChain({
  id: 8408,
  name: "ZenChain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ZTC",
    symbol: "ZTC"
  },
  rpcUrls: {
    default: {
      http: ["https://zenchain-testnet.api.onfinality.io/public"],
      webSocket: ["wss://zenchain-testnet.api.onfinality.io/public-ws"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 230019
    }
  },
  blockExplorers: {
    default: {
      name: "Zentrace",
      url: "https://zentrace.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zeniq.js
var zeniq = defineChain({
  id: 383414847825,
  name: "Zeniq Mainnet",
  nativeCurrency: { name: "ZENIQ", symbol: "ZENIQ", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.zeniq.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zeniq Explorer",
      url: "https://zeniqscan.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/zeroNetwork.js
var zeroNetwork = defineChain({
  id: 543210,
  name: "Zero Network",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.zerion.io/v1/zero"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zero Network Explorer",
      url: "https://explorer.zero.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/zetachain.js
var zetachain = defineChain({
  id: 7e3,
  name: "ZetaChain",
  nativeCurrency: {
    decimals: 18,
    name: "Zeta",
    symbol: "ZETA"
  },
  rpcUrls: {
    default: {
      http: ["https://zetachain-evm.blockpi.network/v1/rpc/public"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1632781
    }
  },
  blockExplorers: {
    default: {
      name: "ZetaScan",
      url: "https://zetascan.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/zetachainAthensTestnet.js
var zetachainAthensTestnet = defineChain({
  id: 7001,
  name: "ZetaChain Athens Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Zeta",
    symbol: "aZETA"
  },
  rpcUrls: {
    default: {
      http: ["https://zetachain-athens-evm.blockpi.network/v1/rpc/public"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2715217
    }
  },
  blockExplorers: {
    default: {
      name: "ZetaScan",
      url: "https://testnet.zetascan.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zhejiang.js
var zhejiang = defineChain({
  id: 1337803,
  name: "Zhejiang",
  nativeCurrency: { name: "Zhejiang Ether", symbol: "ZhejETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.zhejiang.ethpandaops.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Beaconchain",
      url: "https://zhejiang.beaconcha.in"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zilliqa.js
var zilliqa = defineChain({
  id: 32769,
  name: "Zilliqa",
  network: "zilliqa",
  nativeCurrency: { name: "Zilliqa", symbol: "ZIL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.zilliqa.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ethernal",
      url: "https://evmx.zilliqa.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/zilliqaTestnet.js
var zilliqaTestnet = defineChain({
  id: 33101,
  name: "Zilliqa Testnet",
  network: "zilliqa-testnet",
  nativeCurrency: { name: "Zilliqa", symbol: "ZIL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dev-api.zilliqa.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ethernal",
      url: "https://evmx.testnet.zilliqa.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zircuit.js
var sourceId62 = 1;
var zircuit = defineChain({
  ...chainConfig2,
  id: 48900,
  name: "Zircuit Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: [
        "https://mainnet.zircuit.com",
        "https://zircuit1-mainnet.liquify.com",
        "https://zircuit1-mainnet.p2pify.com",
        "https://zircuit-mainnet.drpc.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Zircuit Explorer",
      url: "https://explorer.zircuit.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    },
    l2OutputOracle: {
      [sourceId62]: {
        address: "0x92Ef6Af472b39F1b363da45E35530c24619245A4"
      }
    },
    portal: {
      [sourceId62]: {
        address: "0x17bfAfA932d2e23Bd9B909Fd5B4D2e2a27043fb1"
      }
    },
    l1StandardBridge: {
      [sourceId62]: {
        address: "0x386B76D9cA5F5Fb150B6BFB35CF5379B22B26dd8"
      }
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/zircuitGarfieldTestnet.js
var sourceId63 = 11155111;
var zircuitGarfieldTestnet = defineChain({
  ...chainConfig2,
  id: 48898,
  name: "Zircuit Garfield Testnet",
  nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://garfield-testnet.zircuit.com/"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zircuit Garfield Testnet Explorer",
      url: "https://explorer.garfield-testnet.zircuit.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    },
    l2OutputOracle: {
      [sourceId63]: {
        address: "0xd69D3AC5CA686cCF94b258291772bc520FEAf211"
      }
    },
    portal: {
      [sourceId63]: {
        address: "0x4E21A71Ac3F7607Da5c06153A17B1DD20E702c21"
      }
    },
    l1StandardBridge: {
      [sourceId63]: {
        address: "0x87a7E2bCA9E35BA49282E832a28A6023904460D8"
      }
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zircuitTestnet.js
var sourceId64 = 11155111;
var zircuitTestnet = defineChain({
  ...chainConfig2,
  id: 48899,
  name: "Zircuit Testnet",
  nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://testnet.zircuit.com",
        "https://zircuit1-testnet.p2pify.com",
        "https://zircuit1-testnet.liquify.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Zircuit Testnet Explorer",
      url: "https://explorer.testnet.zircuit.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 6040287
    },
    l2OutputOracle: {
      [sourceId64]: {
        address: "0x740C2dac453aEf7140809F80b72bf0e647af8148"
      }
    },
    portal: {
      [sourceId64]: {
        address: "0x787f1C8c5924178689E0560a43D848bF8E54b23e"
      }
    },
    l1StandardBridge: {
      [sourceId64]: {
        address: "0x0545c5fe980098C16fcD0eCB5E79753afa6d9af9"
      }
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zkFair.js
var zkFair = defineChain({
  id: 42766,
  name: "ZKFair Mainnet",
  network: "zkfair-mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "USD Coin",
    symbol: "USDC"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.zkfair.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "zkFair Explorer",
      url: "https://scan.zkfair.io",
      apiUrl: "https://scan.zkfair.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6090959
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/zkFairTestnet.js
var zkFairTestnet = defineChain({
  id: 43851,
  name: "ZKFair Testnet",
  network: "zkfair-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "USD Coin",
    symbol: "USDC"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.zkfair.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "zkFair Explorer",
      url: "https://testnet-scan.zkfair.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zkLinkNova.js
var zkLinkNova = defineChain({
  id: 810180,
  name: "zkLink Nova",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.zklink.io"] }
  },
  blockExplorers: {
    default: {
      name: "zkLink Nova Block Explorer",
      url: "https://explorer.zklink.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/zkLinkNovaSepoliaTestnet.js
var zkLinkNovaSepoliaTestnet = defineChain({
  id: 810181,
  name: "zkLink Nova Sepolia Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://sepolia.rpc.zklink.io"] }
  },
  blockExplorers: {
    default: {
      name: "zkLink Nova Block Explorer",
      url: "https://sepolia.explorer.zklink.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/zksync.js
var zksync = defineChain({
  ...chainConfig,
  id: 324,
  name: "ZKsync Era",
  network: "zksync-era",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.era.zksync.io"],
      webSocket: ["wss://mainnet.era.zksync.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://era.zksync.network/",
      apiUrl: "https://api-era.zksync.network/api"
    },
    native: {
      name: "ZKsync Explorer",
      url: "https://explorer.zksync.io/",
      apiUrl: "https://block-explorer-api.mainnet.zksync.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
    },
    erc6492Verifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 45659388
    }
  }
});

// node_modules/viem/_esm/chains/definitions/zksyncInMemoryNode.js
var zksyncInMemoryNode = defineChain({
  ...chainConfig,
  id: 260,
  name: "ZKsync InMemory Node",
  network: "zksync-in-memory-node",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:8011"]
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zksyncLocalCustomHyperchain.js
var zksyncLocalCustomHyperchain = defineChain({
  ...chainConfig,
  id: 272,
  name: "ZKsync CLI Local Custom Hyperchain",
  nativeCurrency: { name: "BAT", symbol: "BAT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:15200"],
      webSocket: ["ws://localhost:15201"]
    }
  },
  blockExplorers: {
    default: {
      name: "ZKsync explorer",
      url: "http://localhost:15005/",
      apiUrl: "http://localhost:15005/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zksyncLocalHyperchain.js
var zksyncLocalHyperchain = defineChain({
  ...chainConfig,
  id: 270,
  name: "ZKsync CLI Local Hyperchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:15100"],
      webSocket: ["ws://localhost:15101"]
    }
  },
  blockExplorers: {
    default: {
      name: "ZKsync explorer",
      url: "http://localhost:15005/",
      apiUrl: "http://localhost:15005/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zksyncLocalHyperchainL1.js
var zksyncLocalHyperchainL1 = defineChain({
  id: 9,
  name: "ZKsync CLI Local Hyperchain L1",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:15045"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "http://localhost:15001/",
      apiUrl: "http://localhost:15001/api/v2"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zksyncLocalNode.js
var zksyncLocalNode = defineChain({
  ...chainConfig,
  id: 270,
  name: "ZKsync CLI Local Node",
  network: "zksync-cli-local-node",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:3050"]
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zksyncSepoliaTestnet.js
var zksyncSepoliaTestnet = defineChain({
  ...chainConfig,
  id: 300,
  name: "ZKsync Sepolia Testnet",
  network: "zksync-sepolia-testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.era.zksync.dev"],
      webSocket: ["wss://sepolia.era.zksync.dev/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia-era.zksync.network/",
      apiUrl: "https://api-sepolia-era.zksync.network/api"
    },
    native: {
      name: "ZKsync Explorer",
      url: "https://sepolia.explorer.zksync.io/",
      blockExplorerApi: "https://block-explorer-api.sepolia.zksync.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
    },
    erc6492Verifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 3855712
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zora.js
var sourceId65 = 1;
var zora = defineChain({
  ...chainConfig2,
  id: 7777777,
  name: "Zora",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.zora.energy"],
      webSocket: ["wss://rpc.zora.energy"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.zora.energy",
      apiUrl: "https://explorer.zora.energy/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId65]: {
        address: "0x9E6204F750cD866b299594e2aC9eA824E2e5f95c"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 5882
    },
    portal: {
      [sourceId65]: {
        address: "0x1a0ad011913A150f69f6A19DF447A0CfD9551054"
      }
    },
    l1StandardBridge: {
      [sourceId65]: {
        address: "0x3e2Ea9B92B7E48A52296fD261dc26fd995284631"
      }
    }
  },
  sourceId: sourceId65
});

// node_modules/viem/_esm/chains/definitions/zoraSepolia.js
var sourceId66 = 11155111;
var zoraSepolia = defineChain({
  ...chainConfig2,
  id: 999999999,
  name: "Zora Sepolia",
  network: "zora-sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Zora Sepolia",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.rpc.zora.energy"],
      webSocket: ["wss://sepolia.rpc.zora.energy"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zora Sepolia Explorer",
      url: "https://sepolia.explorer.zora.energy/",
      apiUrl: "https://sepolia.explorer.zora.energy/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId66]: {
        address: "0x2615B481Bd3E5A1C0C7Ca3Da1bdc663E8615Ade9"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 83160
    },
    portal: {
      [sourceId66]: {
        address: "0xeffE2C6cA9Ab797D418f0D91eA60807713f3536f"
      }
    },
    l1StandardBridge: {
      [sourceId66]: {
        address: "0x5376f1D543dcbB5BD416c56C189e4cB7399fCcCB"
      }
    }
  },
  sourceId: sourceId66,
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zoraTestnet.js
var sourceId67 = 5;
var zoraTestnet = defineChain({
  ...chainConfig2,
  id: 999,
  name: "Zora Goerli Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Zora Goerli",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.rpc.zora.energy"],
      webSocket: ["wss://testnet.rpc.zora.energy"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://testnet.explorer.zora.energy",
      apiUrl: "https://testnet.explorer.zora.energy/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 189123
    },
    portal: {
      [sourceId67]: {
        address: "0xDb9F51790365e7dc196e7D072728df39Be958ACe"
      }
    }
  },
  sourceId: sourceId67,
  testnet: true
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/governance.js
function createGovernanceTokensConfig(input) {
  return input;
}
var GovernanceTokensConfig = createGovernanceTokensConfig({
  WELL_TESTNET: {
    id: "WELL_TESTNET",
    symbol: "WELL",
    name: "WELL (Testnet)",
    chainIds: [],
    testnet: true
  },
  WELL: {
    id: "WELL",
    symbol: "WELL",
    name: "WELL",
    chainIds: [moonbeam.id, base.id, optimism.id],
    testnet: false
  },
  MFAM: {
    id: "MFAM",
    symbol: "MFAM",
    name: "MFAM",
    chainIds: [moonriver.id],
    testnet: false
  }
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/abis/chainLinkOracleAbi.js
var chainLinkOracleAbi_default = [
  {
    inputs: [
      {
        internalType: "string",
        name: "_nativeToken",
        type: "string"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "feed",
        type: "address"
      },
      {
        indexed: false,
        internalType: "string",
        name: "symbol",
        type: "string"
      }
    ],
    name: "FeedSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldAdmin",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newAdmin",
        type: "address"
      }
    ],
    name: "NewAdmin",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "previousPriceMantissa",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "requestedPriceMantissa",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newPriceMantissa",
        type: "uint256"
      }
    ],
    name: "PricePosted",
    type: "event"
  },
  {
    inputs: [],
    name: "admin",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      }
    ],
    name: "assetPrices",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "symbol",
        type: "string"
      }
    ],
    name: "getFeed",
    outputs: [
      {
        internalType: "contract AggregatorV3Interface",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract MToken",
        name: "mToken",
        type: "address"
      }
    ],
    name: "getUnderlyingPrice",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "isPriceOracle",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "nativeToken",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newAdmin",
        type: "address"
      }
    ],
    name: "setAdmin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "price",
        type: "uint256"
      }
    ],
    name: "setDirectPrice",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "symbol",
        type: "string"
      },
      {
        internalType: "address",
        name: "feed",
        type: "address"
      }
    ],
    name: "setFeed",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract MToken",
        name: "mToken",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "underlyingPriceMantissa",
        type: "uint256"
      }
    ],
    name: "setUnderlyingPrice",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/abis/comptrollerAbi.js
var comptrollerAbi_default = [
  {
    inputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "string",
        name: "action",
        type: "string"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "pauseState",
        type: "bool"
      }
    ],
    name: "ActionPaused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "contract MToken",
        name: "mToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "string",
        name: "action",
        type: "string"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "pauseState",
        type: "bool"
      }
    ],
    name: "ActionPaused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint8",
        name: "rewardToken",
        type: "uint8"
      },
      {
        indexed: true,
        internalType: "contract MToken",
        name: "mToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newBorrowRewardSpeed",
        type: "uint256"
      }
    ],
    name: "BorrowRewardSpeedUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "contributor",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newSpeed",
        type: "uint256"
      }
    ],
    name: "ContributorWellSpeedUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint8",
        name: "tokenType",
        type: "uint8"
      },
      {
        indexed: true,
        internalType: "contract MToken",
        name: "mToken",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "borrower",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "wellDelta",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "wellBorrowIndex",
        type: "uint256"
      }
    ],
    name: "DistributedBorrowerReward",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint8",
        name: "tokenType",
        type: "uint8"
      },
      {
        indexed: true,
        internalType: "contract MToken",
        name: "mToken",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "borrower",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "wellDelta",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "wellBorrowIndex",
        type: "uint256"
      }
    ],
    name: "DistributedSupplierReward",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "error",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "info",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "detail",
        type: "uint256"
      }
    ],
    name: "Failure",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "contract MToken",
        name: "mToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "MarketEntered",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "contract MToken",
        name: "mToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "MarketExited",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "contract MToken",
        name: "mToken",
        type: "address"
      }
    ],
    name: "MarketListed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "contract MToken",
        name: "mToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newBorrowCap",
        type: "uint256"
      }
    ],
    name: "NewBorrowCap",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldBorrowCapGuardian",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newBorrowCapGuardian",
        type: "address"
      }
    ],
    name: "NewBorrowCapGuardian",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldCloseFactorMantissa",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newCloseFactorMantissa",
        type: "uint256"
      }
    ],
    name: "NewCloseFactor",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "contract MToken",
        name: "mToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "oldCollateralFactorMantissa",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newCollateralFactorMantissa",
        type: "uint256"
      }
    ],
    name: "NewCollateralFactor",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldLiquidationIncentiveMantissa",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newLiquidationIncentiveMantissa",
        type: "uint256"
      }
    ],
    name: "NewLiquidationIncentive",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldPauseGuardian",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newPauseGuardian",
        type: "address"
      }
    ],
    name: "NewPauseGuardian",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "contract PriceOracle",
        name: "oldPriceOracle",
        type: "address"
      },
      {
        indexed: false,
        internalType: "contract PriceOracle",
        name: "newPriceOracle",
        type: "address"
      }
    ],
    name: "NewPriceOracle",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint8",
        name: "rewardToken",
        type: "uint8"
      },
      {
        indexed: true,
        internalType: "contract MToken",
        name: "mToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newSupplyRewardSpeed",
        type: "uint256"
      }
    ],
    name: "SupplyRewardSpeedUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "WellGranted",
    type: "event"
  },
  { payable: true, stateMutability: "payable", type: "fallback" },
  {
    constant: false,
    inputs: [
      {
        internalType: "contract Unitroller",
        name: "unitroller",
        type: "address"
      }
    ],
    name: "_become",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "_borrowGuardianPaused",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address payable",
        name: "recipient",
        type: "address"
      },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "_grantWell",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "_mintGuardianPaused",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "newBorrowCapGuardian",
        type: "address"
      }
    ],
    name: "_setBorrowCapGuardian",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "contract MToken",
        name: "mToken",
        type: "address"
      },
      { internalType: "bool", name: "state", type: "bool" }
    ],
    name: "_setBorrowPaused",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "newCloseFactorMantissa",
        type: "uint256"
      }
    ],
    name: "_setCloseFactor",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "contract MToken",
        name: "mToken",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "newCollateralFactorMantissa",
        type: "uint256"
      }
    ],
    name: "_setCollateralFactor",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "newLiquidationIncentiveMantissa",
        type: "uint256"
      }
    ],
    name: "_setLiquidationIncentive",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "contract MToken[]",
        name: "mTokens",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "newBorrowCaps",
        type: "uint256[]"
      }
    ],
    name: "_setMarketBorrowCaps",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "contract MToken",
        name: "mToken",
        type: "address"
      },
      { internalType: "bool", name: "state", type: "bool" }
    ],
    name: "_setMintPaused",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "newPauseGuardian",
        type: "address"
      }
    ],
    name: "_setPauseGuardian",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "contract PriceOracle",
        name: "newOracle",
        type: "address"
      }
    ],
    name: "_setPriceOracle",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "uint8", name: "rewardType", type: "uint8" },
      {
        internalType: "contract MToken",
        name: "mToken",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "supplyRewardSpeed",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "borrowRewardSpeed",
        type: "uint256"
      }
    ],
    name: "_setRewardSpeed",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [{ internalType: "bool", name: "state", type: "bool" }],
    name: "_setSeizePaused",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [{ internalType: "bool", name: "state", type: "bool" }],
    name: "_setTransferPaused",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "contract MToken", name: "mToken", type: "address" }
    ],
    name: "_supportMarket",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "uint256", name: "", type: "uint256" }
    ],
    name: "accountAssets",
    outputs: [{ internalType: "contract MToken", name: "", type: "address" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "admin",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    name: "allMarkets",
    outputs: [{ internalType: "contract MToken", name: "", type: "address" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "address", name: "mToken", type: "address" },
      { internalType: "address", name: "borrower", type: "address" },
      { internalType: "uint256", name: "borrowAmount", type: "uint256" }
    ],
    name: "borrowAllowed",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "borrowCapGuardian",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "borrowCaps",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "borrowGuardianPaused",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      { internalType: "uint8", name: "", type: "uint8" },
      { internalType: "address", name: "", type: "address" }
    ],
    name: "borrowRewardSpeeds",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "address", name: "mToken", type: "address" },
      { internalType: "address", name: "borrower", type: "address" },
      { internalType: "uint256", name: "borrowAmount", type: "uint256" }
    ],
    name: "borrowVerify",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      { internalType: "address", name: "account", type: "address" },
      { internalType: "contract MToken", name: "mToken", type: "address" }
    ],
    name: "checkMembership",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "uint8", name: "rewardType", type: "uint8" },
      { internalType: "address payable", name: "holder", type: "address" }
    ],
    name: "claimReward",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "uint8", name: "rewardType", type: "uint8" },
      {
        internalType: "address payable",
        name: "holder",
        type: "address"
      },
      {
        internalType: "contract MToken[]",
        name: "mTokens",
        type: "address[]"
      }
    ],
    name: "claimReward",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "uint8", name: "rewardType", type: "uint8" },
      {
        internalType: "address payable[]",
        name: "holders",
        type: "address[]"
      },
      {
        internalType: "contract MToken[]",
        name: "mTokens",
        type: "address[]"
      },
      { internalType: "bool", name: "borrowers", type: "bool" },
      { internalType: "bool", name: "suppliers", type: "bool" }
    ],
    name: "claimReward",
    outputs: [],
    payable: true,
    stateMutability: "payable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "closeFactorMantissa",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "comptrollerImplementation",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [{ internalType: "address[]", name: "mTokens", type: "address[]" }],
    name: "enterMarkets",
    outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "address", name: "mTokenAddress", type: "address" }
    ],
    name: "exitMarket",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "getAccountLiquidity",
    outputs: [
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getAllMarkets",
    outputs: [
      { internalType: "contract MToken[]", name: "", type: "address[]" }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "getAssetsIn",
    outputs: [
      { internalType: "contract MToken[]", name: "", type: "address[]" }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getBlockTimestamp",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      { internalType: "address", name: "account", type: "address" },
      { internalType: "address", name: "mTokenModify", type: "address" },
      { internalType: "uint256", name: "redeemTokens", type: "uint256" },
      { internalType: "uint256", name: "borrowAmount", type: "uint256" }
    ],
    name: "getHypotheticalAccountLiquidity",
    outputs: [
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "initialIndexConstant",
    outputs: [{ internalType: "uint224", name: "", type: "uint224" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "isComptroller",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "mTokenBorrowed",
        type: "address"
      },
      {
        internalType: "address",
        name: "mTokenCollateral",
        type: "address"
      },
      { internalType: "address", name: "liquidator", type: "address" },
      { internalType: "address", name: "borrower", type: "address" },
      { internalType: "uint256", name: "repayAmount", type: "uint256" }
    ],
    name: "liquidateBorrowAllowed",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "mTokenBorrowed",
        type: "address"
      },
      {
        internalType: "address",
        name: "mTokenCollateral",
        type: "address"
      },
      { internalType: "address", name: "liquidator", type: "address" },
      { internalType: "address", name: "borrower", type: "address" },
      {
        internalType: "uint256",
        name: "actualRepayAmount",
        type: "uint256"
      },
      { internalType: "uint256", name: "seizeTokens", type: "uint256" }
    ],
    name: "liquidateBorrowVerify",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "mTokenBorrowed",
        type: "address"
      },
      {
        internalType: "address",
        name: "mTokenCollateral",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "actualRepayAmount",
        type: "uint256"
      }
    ],
    name: "liquidateCalculateSeizeTokens",
    outputs: [
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "liquidationIncentiveMantissa",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "markets",
    outputs: [
      { internalType: "bool", name: "isListed", type: "bool" },
      {
        internalType: "uint256",
        name: "collateralFactorMantissa",
        type: "uint256"
      },
      { internalType: "bool", name: "isWelled", type: "bool" }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "maxAssets",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "address", name: "mToken", type: "address" },
      { internalType: "address", name: "minter", type: "address" },
      { internalType: "uint256", name: "mintAmount", type: "uint256" }
    ],
    name: "mintAllowed",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "mintGuardianPaused",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "address", name: "mToken", type: "address" },
      { internalType: "address", name: "minter", type: "address" },
      {
        internalType: "uint256",
        name: "actualMintAmount",
        type: "uint256"
      },
      { internalType: "uint256", name: "mintTokens", type: "uint256" }
    ],
    name: "mintVerify",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "oracle",
    outputs: [
      { internalType: "contract PriceOracle", name: "", type: "address" }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "pauseGuardian",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "pendingAdmin",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "pendingComptrollerImplementation",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "address", name: "mToken", type: "address" },
      { internalType: "address", name: "redeemer", type: "address" },
      { internalType: "uint256", name: "redeemTokens", type: "uint256" }
    ],
    name: "redeemAllowed",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "address", name: "mToken", type: "address" },
      { internalType: "address", name: "redeemer", type: "address" },
      { internalType: "uint256", name: "redeemAmount", type: "uint256" },
      { internalType: "uint256", name: "redeemTokens", type: "uint256" }
    ],
    name: "redeemVerify",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "address", name: "mToken", type: "address" },
      { internalType: "address", name: "payer", type: "address" },
      { internalType: "address", name: "borrower", type: "address" },
      { internalType: "uint256", name: "repayAmount", type: "uint256" }
    ],
    name: "repayBorrowAllowed",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "address", name: "mToken", type: "address" },
      { internalType: "address", name: "payer", type: "address" },
      { internalType: "address", name: "borrower", type: "address" },
      {
        internalType: "uint256",
        name: "actualRepayAmount",
        type: "uint256"
      },
      { internalType: "uint256", name: "borrowerIndex", type: "uint256" }
    ],
    name: "repayBorrowVerify",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      { internalType: "uint8", name: "", type: "uint8" },
      { internalType: "address", name: "", type: "address" }
    ],
    name: "rewardAccrued",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      { internalType: "uint8", name: "", type: "uint8" },
      { internalType: "address", name: "", type: "address" }
    ],
    name: "rewardBorrowState",
    outputs: [
      { internalType: "uint224", name: "index", type: "uint224" },
      { internalType: "uint32", name: "timestamp", type: "uint32" }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      { internalType: "uint8", name: "", type: "uint8" },
      { internalType: "address", name: "", type: "address" },
      { internalType: "address", name: "", type: "address" }
    ],
    name: "rewardBorrowerIndex",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "rewardGlmr",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      { internalType: "uint8", name: "", type: "uint8" },
      { internalType: "address", name: "", type: "address" },
      { internalType: "address", name: "", type: "address" }
    ],
    name: "rewardSupplierIndex",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      { internalType: "uint8", name: "", type: "uint8" },
      { internalType: "address", name: "", type: "address" }
    ],
    name: "rewardSupplyState",
    outputs: [
      { internalType: "uint224", name: "index", type: "uint224" },
      { internalType: "uint32", name: "timestamp", type: "uint32" }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "rewardWell",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "mTokenCollateral",
        type: "address"
      },
      {
        internalType: "address",
        name: "mTokenBorrowed",
        type: "address"
      },
      { internalType: "address", name: "liquidator", type: "address" },
      { internalType: "address", name: "borrower", type: "address" },
      { internalType: "uint256", name: "seizeTokens", type: "uint256" }
    ],
    name: "seizeAllowed",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "seizeGuardianPaused",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "mTokenCollateral",
        type: "address"
      },
      {
        internalType: "address",
        name: "mTokenBorrowed",
        type: "address"
      },
      { internalType: "address", name: "liquidator", type: "address" },
      { internalType: "address", name: "borrower", type: "address" },
      { internalType: "uint256", name: "seizeTokens", type: "uint256" }
    ],
    name: "seizeVerify",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "address", name: "newWellAddress", type: "address" }
    ],
    name: "setWellAddress",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      { internalType: "uint8", name: "", type: "uint8" },
      { internalType: "address", name: "", type: "address" }
    ],
    name: "supplyRewardSpeeds",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "address", name: "mToken", type: "address" },
      { internalType: "address", name: "src", type: "address" },
      { internalType: "address", name: "dst", type: "address" },
      { internalType: "uint256", name: "transferTokens", type: "uint256" }
    ],
    name: "transferAllowed",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "transferGuardianPaused",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "address", name: "mToken", type: "address" },
      { internalType: "address", name: "src", type: "address" },
      { internalType: "address", name: "dst", type: "address" },
      { internalType: "uint256", name: "transferTokens", type: "uint256" }
    ],
    name: "transferVerify",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "wellAddress",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/abis/coreRouterAbi.js
var coreRouterAbi_default = [
  {
    inputs: [
      {
        internalType: "contract WETH9",
        name: "_weth",
        type: "address"
      },
      {
        internalType: "contract MErc20",
        name: "_mToken",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "mToken",
    outputs: [
      {
        internalType: "contract MErc20",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      }
    ],
    name: "mint",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "mTokenRedeemAmount",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      }
    ],
    name: "redeem",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "weth",
    outputs: [
      {
        internalType: "contract WETH9",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    stateMutability: "payable",
    type: "receive"
  }
];

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/abis/coreViewsAbi.js
var coreViewsAbi_default = [
  {
    type: "function",
    name: "comptroller",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "contract Comptroller"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAllMarketsInfo",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple[]",
        internalType: "struct BaseMoonwellViews.Market[]",
        components: [
          {
            name: "market",
            type: "address",
            internalType: "address"
          },
          {
            name: "isListed",
            type: "bool",
            internalType: "bool"
          },
          {
            name: "borrowCap",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "supplyCap",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "mintPaused",
            type: "bool",
            internalType: "bool"
          },
          {
            name: "borrowPaused",
            type: "bool",
            internalType: "bool"
          },
          {
            name: "collateralFactor",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "underlyingPrice",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalSupply",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalBorrows",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalReserves",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "cash",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "exchangeRate",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "borrowIndex",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "reserveFactor",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "borrowRate",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "supplyRate",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "incentives",
            type: "tuple[]",
            internalType: "struct BaseMoonwellViews.MarketIncentives[]",
            components: [
              {
                name: "token",
                type: "address",
                internalType: "address"
              },
              {
                name: "supplyIncentivesPerSec",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "borrowIncentivesPerSec",
                type: "uint256",
                internalType: "uint256"
              }
            ]
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAllVaultsInfo",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "tuple[]",
        internalType: "struct BaseMoonwellViews.MorphoVault[]",
        components: [
          {
            name: "vault",
            type: "address",
            internalType: "address"
          },
          {
            name: "totalSupply",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalAssets",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "underlyingPrice",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "fee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "timelock",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "markets",
            type: "tuple[]",
            internalType: "struct BaseMoonwellViews.MorphoVaultMarketsInfo[]",
            components: [
              {
                name: "marketId",
                type: "bytes32",
                internalType: "Id"
              },
              {
                name: "marketCollateral",
                type: "address",
                internalType: "address"
              },
              {
                name: "marketCollateralName",
                type: "string",
                internalType: "string"
              },
              {
                name: "marketCollateralSymbol",
                type: "string",
                internalType: "string"
              },
              {
                name: "marketLiquidity",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "marketLltv",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "marketApy",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "vaultAllocation",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "vaultSupplied",
                type: "uint256",
                internalType: "uint256"
              }
            ]
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getGovernanceTokenPrice",
    inputs: [],
    outputs: [
      {
        name: "_result",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getMarketIncentives",
    inputs: [
      {
        name: "market",
        type: "address",
        internalType: "contract MToken"
      }
    ],
    outputs: [
      {
        name: "",
        type: "tuple[]",
        internalType: "struct BaseMoonwellViews.MarketIncentives[]",
        components: [
          {
            name: "token",
            type: "address",
            internalType: "address"
          },
          {
            name: "supplyIncentivesPerSec",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "borrowIncentivesPerSec",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getMarketInfo",
    inputs: [
      {
        name: "_mToken",
        type: "address",
        internalType: "contract MToken"
      }
    ],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct BaseMoonwellViews.Market",
        components: [
          {
            name: "market",
            type: "address",
            internalType: "address"
          },
          {
            name: "isListed",
            type: "bool",
            internalType: "bool"
          },
          {
            name: "borrowCap",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "supplyCap",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "mintPaused",
            type: "bool",
            internalType: "bool"
          },
          {
            name: "borrowPaused",
            type: "bool",
            internalType: "bool"
          },
          {
            name: "collateralFactor",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "underlyingPrice",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalSupply",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalBorrows",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalReserves",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "cash",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "exchangeRate",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "borrowIndex",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "reserveFactor",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "borrowRate",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "supplyRate",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "incentives",
            type: "tuple[]",
            internalType: "struct BaseMoonwellViews.MarketIncentives[]",
            components: [
              {
                name: "token",
                type: "address",
                internalType: "address"
              },
              {
                name: "supplyIncentivesPerSec",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "borrowIncentivesPerSec",
                type: "uint256",
                internalType: "uint256"
              }
            ]
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getMarketsInfo",
    inputs: [
      {
        name: "_mTokens",
        type: "address[]",
        internalType: "contract MToken[]"
      }
    ],
    outputs: [
      {
        name: "",
        type: "tuple[]",
        internalType: "struct BaseMoonwellViews.Market[]",
        components: [
          {
            name: "market",
            type: "address",
            internalType: "address"
          },
          {
            name: "isListed",
            type: "bool",
            internalType: "bool"
          },
          {
            name: "borrowCap",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "supplyCap",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "mintPaused",
            type: "bool",
            internalType: "bool"
          },
          {
            name: "borrowPaused",
            type: "bool",
            internalType: "bool"
          },
          {
            name: "collateralFactor",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "underlyingPrice",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalSupply",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalBorrows",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalReserves",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "cash",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "exchangeRate",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "borrowIndex",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "reserveFactor",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "borrowRate",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "supplyRate",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "incentives",
            type: "tuple[]",
            internalType: "struct BaseMoonwellViews.MarketIncentives[]",
            components: [
              {
                name: "token",
                type: "address",
                internalType: "address"
              },
              {
                name: "supplyIncentivesPerSec",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "borrowIncentivesPerSec",
                type: "uint256",
                internalType: "uint256"
              }
            ]
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getNativeTokenPrice",
    inputs: [],
    outputs: [
      {
        name: "_result",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getProtocolInfo",
    inputs: [],
    outputs: [
      {
        name: "_result",
        type: "tuple",
        internalType: "struct BaseMoonwellViews.ProtocolInfo",
        components: [
          {
            name: "seizePaused",
            type: "bool",
            internalType: "bool"
          },
          {
            name: "transferPaused",
            type: "bool",
            internalType: "bool"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getStakingInfo",
    inputs: [],
    outputs: [
      {
        name: "_result",
        type: "tuple",
        internalType: "struct BaseMoonwellViews.StakingInfo",
        components: [
          {
            name: "cooldown",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "unstakeWindow",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "distributionEnd",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalSupply",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "emissionPerSecond",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "lastUpdateTimestamp",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "index",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getTokensBalances",
    inputs: [
      {
        name: "_tokens",
        type: "address[]",
        internalType: "address[]"
      },
      {
        name: "_user",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "tuple[]",
        internalType: "struct BaseMoonwellViews.Balances[]",
        components: [
          {
            name: "amount",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "token",
            type: "address",
            internalType: "address"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getUserBalances",
    inputs: [
      {
        name: "_user",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "tuple[]",
        internalType: "struct BaseMoonwellViews.Balances[]",
        components: [
          {
            name: "amount",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "token",
            type: "address",
            internalType: "address"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getUserBorrowsBalances",
    inputs: [
      {
        name: "_user",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "tuple[]",
        internalType: "struct BaseMoonwellViews.Balances[]",
        components: [
          {
            name: "amount",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "token",
            type: "address",
            internalType: "address"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getUserClaimsVotingPower",
    inputs: [
      {
        name: "_user",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "_result",
        type: "tuple",
        internalType: "struct BaseMoonwellViews.Votes",
        components: [
          {
            name: "delegatedVotingPower",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "votingPower",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "delegates",
            type: "address",
            internalType: "address"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getUserMarketsMemberships",
    inputs: [
      {
        name: "_user",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "tuple[]",
        internalType: "struct BaseMoonwellViews.Memberships[]",
        components: [
          {
            name: "membership",
            type: "bool",
            internalType: "bool"
          },
          {
            name: "token",
            type: "address",
            internalType: "address"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getUserRewards",
    inputs: [
      {
        name: "_user",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "tuple[]",
        internalType: "struct BaseMoonwellViews.Rewards[]",
        components: [
          {
            name: "market",
            type: "address",
            internalType: "address"
          },
          {
            name: "rewardToken",
            type: "address",
            internalType: "address"
          },
          {
            name: "supplyRewardsAmount",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "borrowRewardsAmount",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getUserStakingInfo",
    inputs: [
      {
        name: "_user",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "_result",
        type: "tuple",
        internalType: "struct BaseMoonwellViews.UserStakingInfo",
        components: [
          {
            name: "cooldown",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "pendingRewards",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalStaked",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getUserStakingVotingPower",
    inputs: [
      {
        name: "_user",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "_result",
        type: "tuple",
        internalType: "struct BaseMoonwellViews.Votes",
        components: [
          {
            name: "delegatedVotingPower",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "votingPower",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "delegates",
            type: "address",
            internalType: "address"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getUserTokensVotingPower",
    inputs: [
      {
        name: "_user",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "_result",
        type: "tuple",
        internalType: "struct BaseMoonwellViews.Votes",
        components: [
          {
            name: "delegatedVotingPower",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "votingPower",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "delegates",
            type: "address",
            internalType: "address"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getUserVotingPower",
    inputs: [
      {
        name: "_user",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "_result",
        type: "tuple",
        internalType: "struct BaseMoonwellViews.UserVotes",
        components: [
          {
            name: "claimsVotes",
            type: "tuple",
            internalType: "struct BaseMoonwellViews.Votes",
            components: [
              {
                name: "delegatedVotingPower",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "votingPower",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "delegates",
                type: "address",
                internalType: "address"
              }
            ]
          },
          {
            name: "stakingVotes",
            type: "tuple",
            internalType: "struct BaseMoonwellViews.Votes",
            components: [
              {
                name: "delegatedVotingPower",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "votingPower",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "delegates",
                type: "address",
                internalType: "address"
              }
            ]
          },
          {
            name: "tokenVotes",
            type: "tuple",
            internalType: "struct BaseMoonwellViews.Votes",
            components: [
              {
                name: "delegatedVotingPower",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "votingPower",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "delegates",
                type: "address",
                internalType: "address"
              }
            ]
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getVaultInfo",
    inputs: [
      {
        name: "_vault",
        type: "address",
        internalType: "contract IMetaMorpho"
      }
    ],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct BaseMoonwellViews.MorphoVault",
        components: [
          {
            name: "vault",
            type: "address",
            internalType: "address"
          },
          {
            name: "totalSupply",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalAssets",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "underlyingPrice",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "fee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "timelock",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "markets",
            type: "tuple[]",
            internalType: "struct BaseMoonwellViews.MorphoVaultMarketsInfo[]",
            components: [
              {
                name: "marketId",
                type: "bytes32",
                internalType: "Id"
              },
              {
                name: "marketCollateral",
                type: "address",
                internalType: "address"
              },
              {
                name: "marketCollateralName",
                type: "string",
                internalType: "string"
              },
              {
                name: "marketCollateralSymbol",
                type: "string",
                internalType: "string"
              },
              {
                name: "marketLiquidity",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "marketLltv",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "marketApy",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "vaultAllocation",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "vaultSupplied",
                type: "uint256",
                internalType: "uint256"
              }
            ]
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getVaultMarketInfo",
    inputs: [
      {
        name: "_marketId",
        type: "bytes32",
        internalType: "Id"
      },
      {
        name: "_morpho",
        type: "address",
        internalType: "contract IMorpho"
      },
      {
        name: "_vault",
        type: "address",
        internalType: "contract IMetaMorpho"
      }
    ],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct BaseMoonwellViews.MorphoVaultMarketsInfo",
        components: [
          {
            name: "marketId",
            type: "bytes32",
            internalType: "Id"
          },
          {
            name: "marketCollateral",
            type: "address",
            internalType: "address"
          },
          {
            name: "marketCollateralName",
            type: "string",
            internalType: "string"
          },
          {
            name: "marketCollateralSymbol",
            type: "string",
            internalType: "string"
          },
          {
            name: "marketLiquidity",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "marketLltv",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "marketApy",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "vaultAllocation",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "vaultSupplied",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "governanceToken",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "contract Well"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "initialize",
    inputs: [
      {
        name: "_comptroller",
        type: "address",
        internalType: "address"
      },
      {
        name: "tokenSaleDistributor",
        type: "address",
        internalType: "address"
      },
      {
        name: "_safetyModule",
        type: "address",
        internalType: "address"
      },
      {
        name: "_governanceToken",
        type: "address",
        internalType: "address"
      },
      {
        name: "nativeMarket",
        type: "address",
        internalType: "address"
      },
      {
        name: "governanceTokenLP",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "morphoMarkets",
    inputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "morphoVaults",
    inputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "safetyModule",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "contract SafetyModuleInterfaceV1"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "setVaults",
    inputs: [
      {
        name: "_vaults",
        type: "address[]",
        internalType: "address[]"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "event",
    name: "Initialized",
    inputs: [
      {
        name: "version",
        type: "uint8",
        indexed: false,
        internalType: "uint8"
      }
    ],
    anonymous: false
  }
];

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/abis/governanceTokenAbi.js
var governanceTokenAbi_default = [
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "delegator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "fromDelegate",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "toDelegate",
        type: "address"
      }
    ],
    name: "DelegateChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "delegate",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "previousBalance",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newBalance",
        type: "uint256"
      }
    ],
    name: "DelegateVotesChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "from", type: "address" },
      { indexed: true, internalType: "address", name: "to", type: "address" },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    constant: true,
    inputs: [],
    name: "DELEGATION_TYPEHASH",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "DOMAIN_TYPEHASH",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "PERMIT_TYPEHASH",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      { internalType: "address", name: "account", type: "address" },
      { internalType: "address", name: "spender", type: "address" }
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "rawAmount", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "uint32", name: "", type: "uint32" }
    ],
    name: "checkpoints",
    outputs: [
      { internalType: "uint32", name: "fromBlock", type: "uint32" },
      { internalType: "uint96", name: "votes", type: "uint96" }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [{ internalType: "address", name: "delegatee", type: "address" }],
    name: "delegate",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "address", name: "delegatee", type: "address" },
      { internalType: "uint256", name: "nonce", type: "uint256" },
      { internalType: "uint256", name: "expiry", type: "uint256" },
      { internalType: "uint8", name: "v", type: "uint8" },
      { internalType: "bytes32", name: "r", type: "bytes32" },
      { internalType: "bytes32", name: "s", type: "bytes32" }
    ],
    name: "delegateBySig",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "delegates",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "getCurrentVotes",
    outputs: [{ internalType: "uint96", name: "", type: "uint96" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      { internalType: "address", name: "account", type: "address" },
      { internalType: "uint256", name: "blockNumber", type: "uint256" }
    ],
    name: "getPriorVotes",
    outputs: [{ internalType: "uint96", name: "", type: "uint96" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "nonces",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "numCheckpoints",
    outputs: [{ internalType: "uint32", name: "", type: "uint32" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "rawAmount", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" },
      { internalType: "uint8", name: "v", type: "uint8" },
      { internalType: "bytes32", name: "r", type: "bytes32" },
      { internalType: "bytes32", name: "s", type: "bytes32" }
    ],
    name: "permit",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "address", name: "dst", type: "address" },
      { internalType: "uint256", name: "rawAmount", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "address", name: "src", type: "address" },
      { internalType: "address", name: "dst", type: "address" },
      { internalType: "uint256", name: "rawAmount", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/abis/governorAbi.js
var governorAbi_default = [
  {
    inputs: [
      {
        internalType: "address",
        name: "timelock_",
        type: "address"
      },
      {
        internalType: "address",
        name: "well_",
        type: "address"
      },
      {
        internalType: "address",
        name: "distributor_",
        type: "address"
      },
      {
        internalType: "address",
        name: "safetyModule_",
        type: "address"
      },
      {
        internalType: "address",
        name: "breakGlassGuardian_",
        type: "address"
      },
      {
        internalType: "address",
        name: "governanceReturnAddress_",
        type: "address"
      },
      {
        internalType: "address",
        name: "governanceReturnGuardian_",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "guardianSunset_",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldValue",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newValue",
        type: "address"
      }
    ],
    name: "BreakGlassGuardianChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldValue",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newValue",
        type: "address"
      }
    ],
    name: "GovernanceReturnAddressChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "ProposalCanceled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "proposer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address[]",
        name: "targets",
        type: "address[]"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "values",
        type: "uint256[]"
      },
      {
        indexed: false,
        internalType: "string[]",
        name: "signatures",
        type: "string[]"
      },
      {
        indexed: false,
        internalType: "bytes[]",
        name: "calldatas",
        type: "bytes[]"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "startTimestamp",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "endTimestamp",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "description",
        type: "string"
      }
    ],
    name: "ProposalCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "ProposalExecuted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldValue",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newValue",
        type: "uint256"
      }
    ],
    name: "ProposalMaxOperationsChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "eta",
        type: "uint256"
      }
    ],
    name: "ProposalQueued",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldValue",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newValue",
        type: "uint256"
      }
    ],
    name: "ProposalThresholdChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldValue",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newValue",
        type: "uint256"
      }
    ],
    name: "QuroumVotesChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "startBlock",
        type: "uint256"
      }
    ],
    name: "StartBlockSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "voter",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint8",
        name: "voteValue",
        type: "uint8"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "votes",
        type: "uint256"
      }
    ],
    name: "VoteCast",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldValue",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newValue",
        type: "uint256"
      }
    ],
    name: "VotingDelayChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldValue",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newValue",
        type: "uint256"
      }
    ],
    name: "VotingPeriodChanged",
    type: "event"
  },
  {
    inputs: [],
    name: "BALLOT_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "DOMAIN_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "__acceptAdminOnTimelock",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "addresses",
        type: "address[]"
      }
    ],
    name: "__executeAcceptAdminOnContract",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract ChangeAdminInterface[]",
        name: "addresses",
        type: "address[]"
      }
    ],
    name: "__executeBreakGlassOnChangeAdmin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract CompoundSetPendingAdminInterface[]",
        name: "addresses",
        type: "address[]"
      }
    ],
    name: "__executeBreakGlassOnCompound",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract SetEmissionsManagerInterface[]",
        name: "addresses",
        type: "address[]"
      }
    ],
    name: "__executeBreakGlassOnEmissionsManager",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract OwnableInterface[]",
        name: "addresses",
        type: "address[]"
      }
    ],
    name: "__executeBreakGlassOnOwnable",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract SetAdminInterface[]",
        name: "addresses",
        type: "address[]"
      }
    ],
    name: "__executeBreakGlassOnSetAdmin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract SetPendingAdminInterface[]",
        name: "addresses",
        type: "address[]"
      }
    ],
    name: "__executeBreakGlassOnSetPendingAdmin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "addresses",
        type: "address[]"
      }
    ],
    name: "__executeCompoundAcceptAdminOnContract",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "__removeGuardians",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "governanceReturnAddress_",
        type: "address"
      }
    ],
    name: "__setGovernanceReturnAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "breakGlassGuardian",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    name: "cancel",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "voteValue",
        type: "uint8"
      }
    ],
    name: "castVote",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "voteValue",
        type: "uint8"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "castVoteBySig",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "distributor",
    outputs: [
      {
        internalType: "contract SnapshotInterface",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    name: "execute",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    name: "getActions",
    outputs: [
      {
        internalType: "address[]",
        name: "targets",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "values",
        type: "uint256[]"
      },
      {
        internalType: "string[]",
        name: "signatures",
        type: "string[]"
      },
      {
        internalType: "bytes[]",
        name: "calldatas",
        type: "bytes[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "voter",
        type: "address"
      }
    ],
    name: "getReceipt",
    outputs: [
      {
        components: [
          {
            internalType: "bool",
            name: "hasVoted",
            type: "bool"
          },
          {
            internalType: "uint8",
            name: "voteValue",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "votes",
            type: "uint256"
          }
        ],
        internalType: "struct MoonwellGovernorArtemis.Receipt",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "governanceReturnAddress",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "governanceReturnGuardian",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "guardianSunset",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "latestProposalIds",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "proposalCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "proposalMaxOperations",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "proposalThreshold",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "proposals",
    outputs: [
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "proposer",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "eta",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "startTimestamp",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "endTimestamp",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "startBlock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "forVotes",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "againstVotes",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "abstainVotes",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "totalVotes",
        type: "uint256"
      },
      {
        internalType: "bool",
        name: "canceled",
        type: "bool"
      },
      {
        internalType: "bool",
        name: "executed",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "targets",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "values",
        type: "uint256[]"
      },
      {
        internalType: "string[]",
        name: "signatures",
        type: "string[]"
      },
      {
        internalType: "bytes[]",
        name: "calldatas",
        type: "bytes[]"
      },
      {
        internalType: "string",
        name: "description",
        type: "string"
      }
    ],
    name: "propose",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    name: "queue",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "quorumVotes",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getQuorum",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "safetyModule",
    outputs: [
      {
        internalType: "contract SnapshotInterface",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newGuardian",
        type: "address"
      }
    ],
    name: "setBreakGlassGuardian",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "newValue",
        type: "uint256"
      }
    ],
    name: "setProposalMaxOperations",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "newValue",
        type: "uint256"
      }
    ],
    name: "setProposalThreshold",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "newValue",
        type: "uint256"
      }
    ],
    name: "setQuorumVotes",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "newValue",
        type: "uint256"
      }
    ],
    name: "setVotingDelay",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "newValue",
        type: "uint256"
      }
    ],
    name: "setVotingPeriod",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    name: "state",
    outputs: [
      {
        internalType: "enum MoonwellGovernorArtemis.ProposalState",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "tokenAddress",
        type: "address"
      },
      {
        internalType: "address",
        name: "destinationAddress",
        type: "address"
      }
    ],
    name: "sweepTokens",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "timelock",
    outputs: [
      {
        internalType: "contract TimelockInterface",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "voteValueAbstain",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "voteValueNo",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "voteValueYes",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "votingDelay",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "votingPeriod",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "well",
    outputs: [
      {
        internalType: "contract WellInterface",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/abis/marketTokenAbi.js
var marketTokenAbi_default = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "cashPrior",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "interestAccumulated",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "borrowIndex",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalBorrows",
        type: "uint256"
      }
    ],
    name: "AccrueInterest",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "BadDebtRepayed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "badDebt",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "previousBadDebt",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "reserves",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "previousReserves",
        type: "uint256"
      }
    ],
    name: "BadDebtRepayedWithReserves",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "borrower",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "borrowAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "accountBorrows",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalBorrows",
        type: "uint256"
      }
    ],
    name: "Borrow",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "error",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "info",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "detail",
        type: "uint256"
      }
    ],
    name: "Failure",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "liquidator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "borrower",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "repayAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "mTokenCollateral",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "seizeTokens",
        type: "uint256"
      }
    ],
    name: "LiquidateBorrow",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "minter",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "mintAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "mintTokens",
        type: "uint256"
      }
    ],
    name: "Mint",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldAdmin",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newAdmin",
        type: "address"
      }
    ],
    name: "NewAdmin",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "contract ComptrollerInterface",
        name: "oldComptroller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "contract ComptrollerInterface",
        name: "newComptroller",
        type: "address"
      }
    ],
    name: "NewComptroller",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "contract InterestRateModel",
        name: "oldInterestRateModel",
        type: "address"
      },
      {
        indexed: false,
        internalType: "contract InterestRateModel",
        name: "newInterestRateModel",
        type: "address"
      }
    ],
    name: "NewMarketInterestRateModel",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldPendingAdmin",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newPendingAdmin",
        type: "address"
      }
    ],
    name: "NewPendingAdmin",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldProtocolSeizeShareMantissa",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newProtocolSeizeShareMantissa",
        type: "uint256"
      }
    ],
    name: "NewProtocolSeizeShare",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldReserveFactorMantissa",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newReserveFactorMantissa",
        type: "uint256"
      }
    ],
    name: "NewReserveFactor",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "redeemer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "redeemAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "redeemTokens",
        type: "uint256"
      }
    ],
    name: "Redeem",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "payer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "borrower",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "repayAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "accountBorrows",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalBorrows",
        type: "uint256"
      }
    ],
    name: "RepayBorrow",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "benefactor",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "addAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newTotalReserves",
        type: "uint256"
      }
    ],
    name: "ReservesAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "admin",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "reduceAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newTotalReserves",
        type: "uint256"
      }
    ],
    name: "ReservesReduced",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "UserFixed",
    type: "event"
  },
  {
    constant: false,
    inputs: [],
    name: "_acceptAdmin",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "addAmount",
        type: "uint256"
      }
    ],
    name: "_addReserves",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "_becomeImplementation",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "reduceAmount",
        type: "uint256"
      }
    ],
    name: "_reduceReserves",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "_resignImplementation",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "contract ComptrollerInterface",
        name: "newComptroller",
        type: "address"
      }
    ],
    name: "_setComptroller",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "contract InterestRateModel",
        name: "newInterestRateModel",
        type: "address"
      }
    ],
    name: "_setInterestRateModel",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address payable",
        name: "newPendingAdmin",
        type: "address"
      }
    ],
    name: "_setPendingAdmin",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "newProtocolSeizeShareMantissa",
        type: "uint256"
      }
    ],
    name: "_setProtocolSeizeShare",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "newReserveFactorMantissa",
        type: "uint256"
      }
    ],
    name: "_setReserveFactor",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "accrualBlockTimestamp",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "accrueInterest",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "admin",
    outputs: [
      {
        internalType: "address payable",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "badDebt",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "balanceOfUnderlying",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "borrowAmount",
        type: "uint256"
      }
    ],
    name: "borrow",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "borrowBalanceCurrent",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "borrowBalanceStored",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "borrowIndex",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "borrowRatePerTimestamp",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "comptroller",
    outputs: [
      {
        internalType: "contract ComptrollerInterface",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "exchangeRateCurrent",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "exchangeRateStored",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "liquidator",
        type: "address"
      },
      {
        internalType: "address",
        name: "user",
        type: "address"
      }
    ],
    name: "fixUser",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "getAccountSnapshot",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getCash",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "implementation",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "underlying_",
        type: "address"
      },
      {
        internalType: "contract ComptrollerInterface",
        name: "comptroller_",
        type: "address"
      },
      {
        internalType: "contract InterestRateModel",
        name: "interestRateModel_",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "initialExchangeRateMantissa_",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "name_",
        type: "string"
      },
      {
        internalType: "string",
        name: "symbol_",
        type: "string"
      },
      {
        internalType: "uint8",
        name: "decimals_",
        type: "uint8"
      }
    ],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "contract ComptrollerInterface",
        name: "comptroller_",
        type: "address"
      },
      {
        internalType: "contract InterestRateModel",
        name: "interestRateModel_",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "initialExchangeRateMantissa_",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "name_",
        type: "string"
      },
      {
        internalType: "string",
        name: "symbol_",
        type: "string"
      },
      {
        internalType: "uint8",
        name: "decimals_",
        type: "uint8"
      }
    ],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "interestRateModel",
    outputs: [
      {
        internalType: "contract InterestRateModel",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "isMToken",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "borrower",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "repayAmount",
        type: "uint256"
      },
      {
        internalType: "contract MTokenInterface",
        name: "mTokenCollateral",
        type: "address"
      }
    ],
    name: "liquidateBorrow",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "mintAmount",
        type: "uint256"
      }
    ],
    name: "mint",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "pendingAdmin",
    outputs: [
      {
        internalType: "address payable",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "protocolSeizeShareMantissa",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "redeemTokens",
        type: "uint256"
      }
    ],
    name: "redeem",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "redeemAmount",
        type: "uint256"
      }
    ],
    name: "redeemUnderlying",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "repayBadDebtWithCash",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "repayBadDebtWithReserves",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "repayAmount",
        type: "uint256"
      }
    ],
    name: "repayBorrow",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "borrower",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "repayAmount",
        type: "uint256"
      }
    ],
    name: "repayBorrowBehalf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "reserveFactorMantissa",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "liquidator",
        type: "address"
      },
      {
        internalType: "address",
        name: "borrower",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "seizeTokens",
        type: "uint256"
      }
    ],
    name: "seize",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "supplyRatePerTimestamp",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "contract EIP20NonStandardInterface",
        name: "token",
        type: "address"
      }
    ],
    name: "sweepToken",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "totalBorrows",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "totalBorrowsCurrent",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "totalReserves",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "dst",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "src",
        type: "address"
      },
      {
        internalType: "address",
        name: "dst",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "underlying",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/abis/maximillionAbi.js
var maximillionAbi_default = [
  {
    inputs: [
      {
        internalType: "contract MGlimmer",
        name: "mGlimmer_",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    constant: true,
    inputs: [],
    name: "mGlimmer",
    outputs: [
      {
        internalType: "contract MGlimmer",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "borrower",
        type: "address"
      }
    ],
    name: "repayBehalf",
    outputs: [],
    payable: true,
    stateMutability: "payable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "borrower",
        type: "address"
      },
      {
        internalType: "contract MGlimmer",
        name: "mGlimmer_",
        type: "address"
      }
    ],
    name: "repayBehalfExplicit",
    outputs: [],
    payable: true,
    stateMutability: "payable",
    type: "function"
  }
];

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/abis/morphoBlueAbi.js
var morphoBlueAbi_default = [
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "Id",
        name: "id",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "prevBorrowRate",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "interest",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "feeShares",
        type: "uint256"
      }
    ],
    name: "AccrueInterest",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "Id",
        name: "id",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "onBehalf",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "shares",
        type: "uint256"
      }
    ],
    name: "Borrow",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "Id",
        name: "id",
        type: "bytes32"
      },
      {
        components: [
          {
            internalType: "address",
            name: "loanToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "collateralToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "address",
            name: "irm",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "lltv",
            type: "uint256"
          }
        ],
        indexed: false,
        internalType: "struct MarketParams",
        name: "marketParams",
        type: "tuple"
      }
    ],
    name: "CreateMarket",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "irm",
        type: "address"
      }
    ],
    name: "EnableIrm",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "lltv",
        type: "uint256"
      }
    ],
    name: "EnableLltv",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      }
    ],
    name: "FlashLoan",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "authorizer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "usedNonce",
        type: "uint256"
      }
    ],
    name: "IncrementNonce",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "Id",
        name: "id",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "borrower",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "repaidAssets",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "repaidShares",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "seizedAssets",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "badDebtAssets",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "badDebtShares",
        type: "uint256"
      }
    ],
    name: "Liquidate",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "Id",
        name: "id",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "onBehalf",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "shares",
        type: "uint256"
      }
    ],
    name: "Repay",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "authorizer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "authorized",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "newIsAuthorized",
        type: "bool"
      }
    ],
    name: "SetAuthorization",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "Id",
        name: "id",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newFee",
        type: "uint256"
      }
    ],
    name: "SetFee",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newFeeRecipient",
        type: "address"
      }
    ],
    name: "SetFeeRecipient",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "SetOwner",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "Id",
        name: "id",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "onBehalf",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "shares",
        type: "uint256"
      }
    ],
    name: "Supply",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "Id",
        name: "id",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "onBehalf",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      }
    ],
    name: "SupplyCollateral",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "Id",
        name: "id",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "onBehalf",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "shares",
        type: "uint256"
      }
    ],
    name: "Withdraw",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "Id",
        name: "id",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "onBehalf",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      }
    ],
    name: "WithdrawCollateral",
    type: "event"
  },
  {
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "loanToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "collateralToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "address",
            name: "irm",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "lltv",
            type: "uint256"
          }
        ],
        internalType: "struct MarketParams",
        name: "marketParams",
        type: "tuple"
      }
    ],
    name: "accrueInterest",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "loanToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "collateralToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "address",
            name: "irm",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "lltv",
            type: "uint256"
          }
        ],
        internalType: "struct MarketParams",
        name: "marketParams",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "shares",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "onBehalf",
        type: "address"
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      }
    ],
    name: "borrow",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "loanToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "collateralToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "address",
            name: "irm",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "lltv",
            type: "uint256"
          }
        ],
        internalType: "struct MarketParams",
        name: "marketParams",
        type: "tuple"
      }
    ],
    name: "createMarket",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "irm",
        type: "address"
      }
    ],
    name: "enableIrm",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "lltv",
        type: "uint256"
      }
    ],
    name: "enableLltv",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32[]",
        name: "slots",
        type: "bytes32[]"
      }
    ],
    name: "extSloads",
    outputs: [
      {
        internalType: "bytes32[]",
        name: "res",
        type: "bytes32[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "flashLoan",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "Id",
        name: "",
        type: "bytes32"
      }
    ],
    name: "idToMarketParams",
    outputs: [
      {
        internalType: "address",
        name: "loanToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "collateralToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "oracle",
        type: "address"
      },
      {
        internalType: "address",
        name: "irm",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "lltv",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "isAuthorized",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "isIrmEnabled",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "isLltvEnabled",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "loanToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "collateralToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "address",
            name: "irm",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "lltv",
            type: "uint256"
          }
        ],
        internalType: "struct MarketParams",
        name: "marketParams",
        type: "tuple"
      },
      {
        internalType: "address",
        name: "borrower",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "seizedAssets",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "repaidShares",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "liquidate",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "Id",
        name: "",
        type: "bytes32"
      }
    ],
    name: "market",
    outputs: [
      {
        internalType: "uint128",
        name: "totalSupplyAssets",
        type: "uint128"
      },
      {
        internalType: "uint128",
        name: "totalSupplyShares",
        type: "uint128"
      },
      {
        internalType: "uint128",
        name: "totalBorrowAssets",
        type: "uint128"
      },
      {
        internalType: "uint128",
        name: "totalBorrowShares",
        type: "uint128"
      },
      {
        internalType: "uint128",
        name: "lastUpdate",
        type: "uint128"
      },
      {
        internalType: "uint128",
        name: "fee",
        type: "uint128"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "nonce",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "Id",
        name: "",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "position",
    outputs: [
      {
        internalType: "uint256",
        name: "supplyShares",
        type: "uint256"
      },
      {
        internalType: "uint128",
        name: "borrowShares",
        type: "uint128"
      },
      {
        internalType: "uint128",
        name: "collateral",
        type: "uint128"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "loanToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "collateralToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "address",
            name: "irm",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "lltv",
            type: "uint256"
          }
        ],
        internalType: "struct MarketParams",
        name: "marketParams",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "shares",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "onBehalf",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "repay",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "authorized",
        type: "address"
      },
      {
        internalType: "bool",
        name: "newIsAuthorized",
        type: "bool"
      }
    ],
    name: "setAuthorization",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "authorizer",
            type: "address"
          },
          {
            internalType: "address",
            name: "authorized",
            type: "address"
          },
          {
            internalType: "bool",
            name: "isAuthorized",
            type: "bool"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          }
        ],
        internalType: "struct Authorization",
        name: "authorization",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "uint8",
            name: "v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
          }
        ],
        internalType: "struct Signature",
        name: "signature",
        type: "tuple"
      }
    ],
    name: "setAuthorizationWithSig",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "loanToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "collateralToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "address",
            name: "irm",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "lltv",
            type: "uint256"
          }
        ],
        internalType: "struct MarketParams",
        name: "marketParams",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "newFee",
        type: "uint256"
      }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newFeeRecipient",
        type: "address"
      }
    ],
    name: "setFeeRecipient",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "loanToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "collateralToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "address",
            name: "irm",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "lltv",
            type: "uint256"
          }
        ],
        internalType: "struct MarketParams",
        name: "marketParams",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "shares",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "onBehalf",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "supply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "loanToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "collateralToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "address",
            name: "irm",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "lltv",
            type: "uint256"
          }
        ],
        internalType: "struct MarketParams",
        name: "marketParams",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "onBehalf",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "supplyCollateral",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "loanToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "collateralToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "address",
            name: "irm",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "lltv",
            type: "uint256"
          }
        ],
        internalType: "struct MarketParams",
        name: "marketParams",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "shares",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "onBehalf",
        type: "address"
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      }
    ],
    name: "withdraw",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "loanToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "collateralToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "address",
            name: "irm",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "lltv",
            type: "uint256"
          }
        ],
        internalType: "struct MarketParams",
        name: "marketParams",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "onBehalf",
        type: "address"
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      }
    ],
    name: "withdrawCollateral",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/abis/morphoBundlerAbi.js
var morphoBundlerAbi_default = [
  {
    inputs: [
      {
        internalType: "address",
        name: "morpho",
        type: "address"
      },
      {
        internalType: "address",
        name: "weth",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "UnsafeCast",
    type: "error"
  },
  {
    inputs: [],
    name: "MORPHO",
    outputs: [
      {
        internalType: "contract IMorpho",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "WRAPPED_NATIVE",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            components: [
              {
                internalType: "address",
                name: "token",
                type: "address"
              },
              {
                internalType: "uint160",
                name: "amount",
                type: "uint160"
              },
              {
                internalType: "uint48",
                name: "expiration",
                type: "uint48"
              },
              {
                internalType: "uint48",
                name: "nonce",
                type: "uint48"
              }
            ],
            internalType: "struct IAllowanceTransfer.PermitDetails",
            name: "details",
            type: "tuple"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "sigDeadline",
            type: "uint256"
          }
        ],
        internalType: "struct IAllowanceTransfer.PermitSingle",
        name: "permitSingle",
        type: "tuple"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      },
      {
        internalType: "bool",
        name: "skipRevert",
        type: "bool"
      }
    ],
    name: "approve2",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "erc20Transfer",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "erc20TransferFrom",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "wrapper",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "erc20WrapperDepositFor",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "wrapper",
        type: "address"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "erc20WrapperWithdrawTo",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "vault",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "minShares",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      }
    ],
    name: "erc4626Deposit",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "vault",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "shares",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "maxAssets",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      }
    ],
    name: "erc4626Mint",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "vault",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "shares",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "minAssets",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "erc4626Redeem",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "vault",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "maxShares",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "erc4626Withdraw",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "initiator",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "loanToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "collateralToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "address",
            name: "irm",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "lltv",
            type: "uint256"
          }
        ],
        internalType: "struct MarketParams",
        name: "marketParams",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "shares",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "slippageAmount",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      }
    ],
    name: "morphoBorrow",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "morphoFlashLoan",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "loanToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "collateralToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "address",
            name: "irm",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "lltv",
            type: "uint256"
          }
        ],
        internalType: "struct MarketParams",
        name: "marketParams",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "shares",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "slippageAmount",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "onBehalf",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "morphoRepay",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "authorizer",
            type: "address"
          },
          {
            internalType: "address",
            name: "authorized",
            type: "address"
          },
          {
            internalType: "bool",
            name: "isAuthorized",
            type: "bool"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          }
        ],
        internalType: "struct Authorization",
        name: "authorization",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "uint8",
            name: "v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
          }
        ],
        internalType: "struct Signature",
        name: "signature",
        type: "tuple"
      },
      {
        internalType: "bool",
        name: "skipRevert",
        type: "bool"
      }
    ],
    name: "morphoSetAuthorizationWithSig",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "loanToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "collateralToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "address",
            name: "irm",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "lltv",
            type: "uint256"
          }
        ],
        internalType: "struct MarketParams",
        name: "marketParams",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "shares",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "slippageAmount",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "onBehalf",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "morphoSupply",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "loanToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "collateralToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "address",
            name: "irm",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "lltv",
            type: "uint256"
          }
        ],
        internalType: "struct MarketParams",
        name: "marketParams",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "onBehalf",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "morphoSupplyCollateral",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "loanToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "collateralToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "address",
            name: "irm",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "lltv",
            type: "uint256"
          }
        ],
        internalType: "struct MarketParams",
        name: "marketParams",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "shares",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "slippageAmount",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      }
    ],
    name: "morphoWithdraw",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "loanToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "collateralToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "address",
            name: "irm",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "lltv",
            type: "uint256"
          }
        ],
        internalType: "struct MarketParams",
        name: "marketParams",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      }
    ],
    name: "morphoWithdrawCollateral",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "nativeTransfer",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "onMorphoFlashLoan",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "onMorphoRepay",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "onMorphoSupply",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "onMorphoSupplyCollateral",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      },
      {
        internalType: "bool",
        name: "skipRevert",
        type: "bool"
      }
    ],
    name: "permit",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "publicAllocator",
        type: "address"
      },
      {
        internalType: "address",
        name: "vault",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        components: [
          {
            components: [
              {
                internalType: "address",
                name: "loanToken",
                type: "address"
              },
              {
                internalType: "address",
                name: "collateralToken",
                type: "address"
              },
              {
                internalType: "address",
                name: "oracle",
                type: "address"
              },
              {
                internalType: "address",
                name: "irm",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "lltv",
                type: "uint256"
              }
            ],
            internalType: "struct MarketParams",
            name: "marketParams",
            type: "tuple"
          },
          {
            internalType: "uint128",
            name: "amount",
            type: "uint128"
          }
        ],
        internalType: "struct Withdrawal[]",
        name: "withdrawals",
        type: "tuple[]"
      },
      {
        components: [
          {
            internalType: "address",
            name: "loanToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "collateralToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "address",
            name: "irm",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "lltv",
            type: "uint256"
          }
        ],
        internalType: "struct MarketParams",
        name: "supplyMarketParams",
        type: "tuple"
      }
    ],
    name: "reallocateTo",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transferFrom2",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "unwrapNative",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "distributor",
        type: "address"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "address",
        name: "reward",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "bytes32[]",
        name: "proof",
        type: "bytes32[]"
      },
      {
        internalType: "bool",
        name: "skipRevert",
        type: "bool"
      }
    ],
    name: "urdClaim",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "wrapNative",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    stateMutability: "payable",
    type: "receive"
  }
];

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/abis/morphoPublicAllocatorAbi.js
var morphoPublicAllocatorAbi_default = [
  {
    inputs: [{ internalType: "address", name: "morpho", type: "address" }],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  { inputs: [], name: "AlreadySet", type: "error" },
  { inputs: [], name: "DepositMarketInWithdrawals", type: "error" },
  { inputs: [], name: "EmptyWithdrawals", type: "error" },
  { inputs: [], name: "InconsistentWithdrawals", type: "error" },
  { inputs: [], name: "IncorrectFee", type: "error" },
  {
    inputs: [{ internalType: "Id", name: "id", type: "bytes32" }],
    name: "MarketNotEnabled",
    type: "error"
  },
  {
    inputs: [{ internalType: "Id", name: "id", type: "bytes32" }],
    name: "MaxInflowExceeded",
    type: "error"
  },
  {
    inputs: [{ internalType: "Id", name: "id", type: "bytes32" }],
    name: "MaxOutflowExceeded",
    type: "error"
  },
  { inputs: [], name: "MaxSettableFlowCapExceeded", type: "error" },
  { inputs: [], name: "NotAdminNorVaultOwner", type: "error" },
  {
    inputs: [{ internalType: "Id", name: "id", type: "bytes32" }],
    name: "NotEnoughSupply",
    type: "error"
  },
  {
    inputs: [{ internalType: "Id", name: "id", type: "bytes32" }],
    name: "WithdrawZero",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "vault",
        type: "address"
      },
      {
        indexed: true,
        internalType: "Id",
        name: "supplyMarketId",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "suppliedAssets",
        type: "uint256"
      }
    ],
    name: "PublicReallocateTo",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "vault",
        type: "address"
      },
      { indexed: true, internalType: "Id", name: "id", type: "bytes32" },
      {
        indexed: false,
        internalType: "uint256",
        name: "withdrawnAssets",
        type: "uint256"
      }
    ],
    name: "PublicWithdrawal",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "vault",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "admin",
        type: "address"
      }
    ],
    name: "SetAdmin",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "vault",
        type: "address"
      },
      { indexed: false, internalType: "uint256", name: "fee", type: "uint256" }
    ],
    name: "SetFee",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "vault",
        type: "address"
      },
      {
        components: [
          { internalType: "Id", name: "id", type: "bytes32" },
          {
            components: [
              { internalType: "uint128", name: "maxIn", type: "uint128" },
              { internalType: "uint128", name: "maxOut", type: "uint128" }
            ],
            internalType: "struct FlowCaps",
            name: "caps",
            type: "tuple"
          }
        ],
        indexed: false,
        internalType: "struct FlowCapsConfig[]",
        name: "config",
        type: "tuple[]"
      }
    ],
    name: "SetFlowCaps",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "vault",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "feeRecipient",
        type: "address"
      }
    ],
    name: "TransferFee",
    type: "event"
  },
  {
    inputs: [],
    name: "MORPHO",
    outputs: [{ internalType: "contract IMorpho", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "accruedFee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "admin",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "Id", name: "", type: "bytes32" }
    ],
    name: "flowCaps",
    outputs: [
      { internalType: "uint128", name: "maxIn", type: "uint128" },
      { internalType: "uint128", name: "maxOut", type: "uint128" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "vault", type: "address" },
      {
        components: [
          {
            components: [
              { internalType: "address", name: "loanToken", type: "address" },
              {
                internalType: "address",
                name: "collateralToken",
                type: "address"
              },
              { internalType: "address", name: "oracle", type: "address" },
              { internalType: "address", name: "irm", type: "address" },
              { internalType: "uint256", name: "lltv", type: "uint256" }
            ],
            internalType: "struct MarketParams",
            name: "marketParams",
            type: "tuple"
          },
          { internalType: "uint128", name: "amount", type: "uint128" }
        ],
        internalType: "struct Withdrawal[]",
        name: "withdrawals",
        type: "tuple[]"
      },
      {
        components: [
          { internalType: "address", name: "loanToken", type: "address" },
          { internalType: "address", name: "collateralToken", type: "address" },
          { internalType: "address", name: "oracle", type: "address" },
          { internalType: "address", name: "irm", type: "address" },
          { internalType: "uint256", name: "lltv", type: "uint256" }
        ],
        internalType: "struct MarketParams",
        name: "supplyMarketParams",
        type: "tuple"
      }
    ],
    name: "reallocateTo",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "vault", type: "address" },
      { internalType: "address", name: "newAdmin", type: "address" }
    ],
    name: "setAdmin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "vault", type: "address" },
      { internalType: "uint256", name: "newFee", type: "uint256" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "vault", type: "address" },
      {
        components: [
          { internalType: "Id", name: "id", type: "bytes32" },
          {
            components: [
              { internalType: "uint128", name: "maxIn", type: "uint128" },
              { internalType: "uint128", name: "maxOut", type: "uint128" }
            ],
            internalType: "struct FlowCaps",
            name: "caps",
            type: "tuple"
          }
        ],
        internalType: "struct FlowCapsConfig[]",
        name: "config",
        type: "tuple[]"
      }
    ],
    name: "setFlowCaps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "vault", type: "address" },
      {
        internalType: "address payable",
        name: "feeRecipient",
        type: "address"
      }
    ],
    name: "transferFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/abis/morphoVaultAbi.js
var morphoVaultAbi_default = [
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "morpho",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "initialTimelock",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_asset",
        type: "address"
      },
      {
        internalType: "string",
        name: "_name",
        type: "string"
      },
      {
        internalType: "string",
        name: "_symbol",
        type: "string"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "AboveMaxTimelock",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "AddressEmptyCode",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "AddressInsufficientBalance",
    type: "error"
  },
  {
    inputs: [],
    name: "AllCapsReached",
    type: "error"
  },
  {
    inputs: [],
    name: "AlreadyPending",
    type: "error"
  },
  {
    inputs: [],
    name: "AlreadySet",
    type: "error"
  },
  {
    inputs: [],
    name: "BelowMinTimelock",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "Id",
        name: "id",
        type: "bytes32"
      }
    ],
    name: "DuplicateMarket",
    type: "error"
  },
  {
    inputs: [],
    name: "ECDSAInvalidSignature",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "length",
        type: "uint256"
      }
    ],
    name: "ECDSAInvalidSignatureLength",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "ECDSAInvalidSignatureS",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "allowance",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "needed",
        type: "uint256"
      }
    ],
    name: "ERC20InsufficientAllowance",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "balance",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "needed",
        type: "uint256"
      }
    ],
    name: "ERC20InsufficientBalance",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "approver",
        type: "address"
      }
    ],
    name: "ERC20InvalidApprover",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      }
    ],
    name: "ERC20InvalidReceiver",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "ERC20InvalidSender",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "ERC20InvalidSpender",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      }
    ],
    name: "ERC2612ExpiredSignature",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      },
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "ERC2612InvalidSigner",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "max",
        type: "uint256"
      }
    ],
    name: "ERC4626ExceededMaxDeposit",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "shares",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "max",
        type: "uint256"
      }
    ],
    name: "ERC4626ExceededMaxMint",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "shares",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "max",
        type: "uint256"
      }
    ],
    name: "ERC4626ExceededMaxRedeem",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "max",
        type: "uint256"
      }
    ],
    name: "ERC4626ExceededMaxWithdraw",
    type: "error"
  },
  {
    inputs: [],
    name: "FailedInnerCall",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "Id",
        name: "id",
        type: "bytes32"
      }
    ],
    name: "InconsistentAsset",
    type: "error"
  },
  {
    inputs: [],
    name: "InconsistentReallocation",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "currentNonce",
        type: "uint256"
      }
    ],
    name: "InvalidAccountNonce",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "Id",
        name: "id",
        type: "bytes32"
      }
    ],
    name: "InvalidMarketRemovalNonZeroCap",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "Id",
        name: "id",
        type: "bytes32"
      }
    ],
    name: "InvalidMarketRemovalNonZeroSupply",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "Id",
        name: "id",
        type: "bytes32"
      }
    ],
    name: "InvalidMarketRemovalTimelockNotElapsed",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidShortString",
    type: "error"
  },
  {
    inputs: [],
    name: "MarketNotCreated",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "Id",
        name: "id",
        type: "bytes32"
      }
    ],
    name: "MarketNotEnabled",
    type: "error"
  },
  {
    inputs: [],
    name: "MathOverflowedMulDiv",
    type: "error"
  },
  {
    inputs: [],
    name: "MaxFeeExceeded",
    type: "error"
  },
  {
    inputs: [],
    name: "MaxQueueLengthExceeded",
    type: "error"
  },
  {
    inputs: [],
    name: "NoPendingValue",
    type: "error"
  },
  {
    inputs: [],
    name: "NonZeroCap",
    type: "error"
  },
  {
    inputs: [],
    name: "NotAllocatorRole",
    type: "error"
  },
  {
    inputs: [],
    name: "NotCuratorNorGuardianRole",
    type: "error"
  },
  {
    inputs: [],
    name: "NotCuratorRole",
    type: "error"
  },
  {
    inputs: [],
    name: "NotEnoughLiquidity",
    type: "error"
  },
  {
    inputs: [],
    name: "NotGuardianRole",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "OwnableInvalidOwner",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "OwnableUnauthorizedAccount",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "Id",
        name: "id",
        type: "bytes32"
      }
    ],
    name: "PendingCap",
    type: "error"
  },
  {
    inputs: [],
    name: "PendingRemoval",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint8",
        name: "bits",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "SafeCastOverflowedUintDowncast",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      }
    ],
    name: "SafeERC20FailedOperation",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "str",
        type: "string"
      }
    ],
    name: "StringTooLong",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "Id",
        name: "id",
        type: "bytes32"
      }
    ],
    name: "SupplyCapExceeded",
    type: "error"
  },
  {
    inputs: [],
    name: "TimelockNotElapsed",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "Id",
        name: "id",
        type: "bytes32"
      }
    ],
    name: "UnauthorizedMarket",
    type: "error"
  },
  {
    inputs: [],
    name: "ZeroAddress",
    type: "error"
  },
  {
    inputs: [],
    name: "ZeroFeeRecipient",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "newTotalAssets",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "feeShares",
        type: "uint256"
      }
    ],
    name: "AccrueInterest",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "shares",
        type: "uint256"
      }
    ],
    name: "Deposit",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [],
    name: "EIP712DomainChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferStarted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: true,
        internalType: "Id",
        name: "id",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "suppliedAssets",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "suppliedShares",
        type: "uint256"
      }
    ],
    name: "ReallocateSupply",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: true,
        internalType: "Id",
        name: "id",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "withdrawnAssets",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "withdrawnShares",
        type: "uint256"
      }
    ],
    name: "ReallocateWithdraw",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: true,
        internalType: "Id",
        name: "id",
        type: "bytes32"
      }
    ],
    name: "RevokePendingCap",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      }
    ],
    name: "RevokePendingGuardian",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: true,
        internalType: "Id",
        name: "id",
        type: "bytes32"
      }
    ],
    name: "RevokePendingMarketRemoval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      }
    ],
    name: "RevokePendingTimelock",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: true,
        internalType: "Id",
        name: "id",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "cap",
        type: "uint256"
      }
    ],
    name: "SetCap",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newCurator",
        type: "address"
      }
    ],
    name: "SetCurator",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newFee",
        type: "uint256"
      }
    ],
    name: "SetFee",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newFeeRecipient",
        type: "address"
      }
    ],
    name: "SetFeeRecipient",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "SetGuardian",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "allocator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "isAllocator",
        type: "bool"
      }
    ],
    name: "SetIsAllocator",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newSkimRecipient",
        type: "address"
      }
    ],
    name: "SetSkimRecipient",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "Id[]",
        name: "newSupplyQueue",
        type: "bytes32[]"
      }
    ],
    name: "SetSupplyQueue",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newTimelock",
        type: "uint256"
      }
    ],
    name: "SetTimelock",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: false,
        internalType: "Id[]",
        name: "newWithdrawQueue",
        type: "bytes32[]"
      }
    ],
    name: "SetWithdrawQueue",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Skim",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: true,
        internalType: "Id",
        name: "id",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "cap",
        type: "uint256"
      }
    ],
    name: "SubmitCap",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newGuardian",
        type: "address"
      }
    ],
    name: "SubmitGuardian",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      },
      {
        indexed: true,
        internalType: "Id",
        name: "id",
        type: "bytes32"
      }
    ],
    name: "SubmitMarketRemoval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "newTimelock",
        type: "uint256"
      }
    ],
    name: "SubmitTimelock",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "updatedTotalAssets",
        type: "uint256"
      }
    ],
    name: "UpdateLastTotalAssets",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "shares",
        type: "uint256"
      }
    ],
    name: "Withdraw",
    type: "event"
  },
  {
    inputs: [],
    name: "DECIMALS_OFFSET",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "MORPHO",
    outputs: [
      {
        internalType: "contract IMorpho",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "loanToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "collateralToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "address",
            name: "irm",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "lltv",
            type: "uint256"
          }
        ],
        internalType: "struct MarketParams",
        name: "marketParams",
        type: "tuple"
      }
    ],
    name: "acceptCap",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "acceptGuardian",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "acceptTimelock",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "asset",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "Id",
        name: "",
        type: "bytes32"
      }
    ],
    name: "config",
    outputs: [
      {
        internalType: "uint184",
        name: "cap",
        type: "uint184"
      },
      {
        internalType: "bool",
        name: "enabled",
        type: "bool"
      },
      {
        internalType: "uint64",
        name: "removableAt",
        type: "uint64"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "shares",
        type: "uint256"
      }
    ],
    name: "convertToAssets",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      }
    ],
    name: "convertToShares",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "curator",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      }
    ],
    name: "deposit",
    outputs: [
      {
        internalType: "uint256",
        name: "shares",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      {
        internalType: "bytes1",
        name: "fields",
        type: "bytes1"
      },
      {
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        internalType: "string",
        name: "version",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "verifyingContract",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "salt",
        type: "bytes32"
      },
      {
        internalType: "uint256[]",
        name: "extensions",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [
      {
        internalType: "uint96",
        name: "",
        type: "uint96"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "guardian",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "isAllocator",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "lastTotalAssets",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "maxDeposit",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "maxMint",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "maxRedeem",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "maxWithdraw",
    outputs: [
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "shares",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      }
    ],
    name: "mint",
    outputs: [
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "nonces",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "Id",
        name: "",
        type: "bytes32"
      }
    ],
    name: "pendingCap",
    outputs: [
      {
        internalType: "uint192",
        name: "value",
        type: "uint192"
      },
      {
        internalType: "uint64",
        name: "validAt",
        type: "uint64"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pendingGuardian",
    outputs: [
      {
        internalType: "address",
        name: "value",
        type: "address"
      },
      {
        internalType: "uint64",
        name: "validAt",
        type: "uint64"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pendingOwner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pendingTimelock",
    outputs: [
      {
        internalType: "uint192",
        name: "value",
        type: "uint192"
      },
      {
        internalType: "uint64",
        name: "validAt",
        type: "uint64"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "permit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      }
    ],
    name: "previewDeposit",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "shares",
        type: "uint256"
      }
    ],
    name: "previewMint",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "shares",
        type: "uint256"
      }
    ],
    name: "previewRedeem",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      }
    ],
    name: "previewWithdraw",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            components: [
              {
                internalType: "address",
                name: "loanToken",
                type: "address"
              },
              {
                internalType: "address",
                name: "collateralToken",
                type: "address"
              },
              {
                internalType: "address",
                name: "oracle",
                type: "address"
              },
              {
                internalType: "address",
                name: "irm",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "lltv",
                type: "uint256"
              }
            ],
            internalType: "struct MarketParams",
            name: "marketParams",
            type: "tuple"
          },
          {
            internalType: "uint256",
            name: "assets",
            type: "uint256"
          }
        ],
        internalType: "struct MarketAllocation[]",
        name: "allocations",
        type: "tuple[]"
      }
    ],
    name: "reallocate",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "shares",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "redeem",
    outputs: [
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "Id",
        name: "id",
        type: "bytes32"
      }
    ],
    name: "revokePendingCap",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "revokePendingGuardian",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "Id",
        name: "id",
        type: "bytes32"
      }
    ],
    name: "revokePendingMarketRemoval",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "revokePendingTimelock",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newCurator",
        type: "address"
      }
    ],
    name: "setCurator",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "newFee",
        type: "uint256"
      }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newFeeRecipient",
        type: "address"
      }
    ],
    name: "setFeeRecipient",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newAllocator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "newIsAllocator",
        type: "bool"
      }
    ],
    name: "setIsAllocator",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newSkimRecipient",
        type: "address"
      }
    ],
    name: "setSkimRecipient",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "Id[]",
        name: "newSupplyQueue",
        type: "bytes32[]"
      }
    ],
    name: "setSupplyQueue",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address"
      }
    ],
    name: "skim",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "skimRecipient",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "loanToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "collateralToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "address",
            name: "irm",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "lltv",
            type: "uint256"
          }
        ],
        internalType: "struct MarketParams",
        name: "marketParams",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "newSupplyCap",
        type: "uint256"
      }
    ],
    name: "submitCap",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newGuardian",
        type: "address"
      }
    ],
    name: "submitGuardian",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "loanToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "collateralToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "address",
            name: "irm",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "lltv",
            type: "uint256"
          }
        ],
        internalType: "struct MarketParams",
        name: "marketParams",
        type: "tuple"
      }
    ],
    name: "submitMarketRemoval",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "newTimelock",
        type: "uint256"
      }
    ],
    name: "submitTimelock",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "supplyQueue",
    outputs: [
      {
        internalType: "Id",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "supplyQueueLength",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "timelock",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalAssets",
    outputs: [
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256[]",
        name: "indexes",
        type: "uint256[]"
      }
    ],
    name: "updateWithdrawQueue",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "assets",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "withdraw",
    outputs: [
      {
        internalType: "uint256",
        name: "shares",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "withdrawQueue",
    outputs: [
      {
        internalType: "Id",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "withdrawQueueLength",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/abis/morphoViewsAbi.js
var morphoViewsAbi_default = [
  {
    type: "constructor",
    inputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "comptroller",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "contract Comptroller"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getMorphoBlueMarketInfo",
    inputs: [
      {
        name: "_marketId",
        type: "bytes32",
        internalType: "Id"
      }
    ],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct MorphoViews.MorphoBlueMarket",
        components: [
          {
            name: "marketId",
            type: "bytes32",
            internalType: "Id"
          },
          {
            name: "collateralToken",
            type: "address",
            internalType: "address"
          },
          {
            name: "collateralName",
            type: "string",
            internalType: "string"
          },
          {
            name: "collateralSymbol",
            type: "string",
            internalType: "string"
          },
          {
            name: "collateralDecimals",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "collateralPrice",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "loanToken",
            type: "address",
            internalType: "address"
          },
          {
            name: "loanName",
            type: "string",
            internalType: "string"
          },
          {
            name: "loanSymbol",
            type: "string",
            internalType: "string"
          },
          {
            name: "loanDecimals",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "loanPrice",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalSupplyAssets",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalBorrowAssets",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalLiquidity",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "lltv",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "supplyApy",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "borrowApy",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "fee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "oracle",
            type: "address",
            internalType: "address"
          },
          {
            name: "oraclePrice",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "irm",
            type: "address",
            internalType: "address"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getMorphoBlueMarketsInfo",
    inputs: [
      {
        name: "_marketIds",
        type: "bytes32[]",
        internalType: "Id[]"
      }
    ],
    outputs: [
      {
        name: "",
        type: "tuple[]",
        internalType: "struct MorphoViews.MorphoBlueMarket[]",
        components: [
          {
            name: "marketId",
            type: "bytes32",
            internalType: "Id"
          },
          {
            name: "collateralToken",
            type: "address",
            internalType: "address"
          },
          {
            name: "collateralName",
            type: "string",
            internalType: "string"
          },
          {
            name: "collateralSymbol",
            type: "string",
            internalType: "string"
          },
          {
            name: "collateralDecimals",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "collateralPrice",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "loanToken",
            type: "address",
            internalType: "address"
          },
          {
            name: "loanName",
            type: "string",
            internalType: "string"
          },
          {
            name: "loanSymbol",
            type: "string",
            internalType: "string"
          },
          {
            name: "loanDecimals",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "loanPrice",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalSupplyAssets",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalBorrowAssets",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalLiquidity",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "lltv",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "supplyApy",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "borrowApy",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "fee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "oracle",
            type: "address",
            internalType: "address"
          },
          {
            name: "oraclePrice",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "irm",
            type: "address",
            internalType: "address"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getMorphoBlueUserBalance",
    inputs: [
      {
        name: "_marketId",
        type: "bytes32",
        internalType: "Id"
      },
      {
        name: "user",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct MorphoViews.UserMarketBalance",
        components: [
          {
            name: "marketId",
            type: "bytes32",
            internalType: "Id"
          },
          {
            name: "collateralToken",
            type: "address",
            internalType: "address"
          },
          {
            name: "collateralAssets",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "loanToken",
            type: "address",
            internalType: "address"
          },
          {
            name: "loanAssets",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "loanShares",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getMorphoBlueUserBalances",
    inputs: [
      {
        name: "_marketIds",
        type: "bytes32[]",
        internalType: "Id[]"
      },
      {
        name: "user",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "tuple[]",
        internalType: "struct MorphoViews.UserMarketBalance[]",
        components: [
          {
            name: "marketId",
            type: "bytes32",
            internalType: "Id"
          },
          {
            name: "collateralToken",
            type: "address",
            internalType: "address"
          },
          {
            name: "collateralAssets",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "loanToken",
            type: "address",
            internalType: "address"
          },
          {
            name: "loanAssets",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "loanShares",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getVaultInfo",
    inputs: [
      {
        name: "_vault",
        type: "address",
        internalType: "contract IMetaMorpho"
      }
    ],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct MorphoViews.MorphoVault",
        components: [
          {
            name: "vault",
            type: "address",
            internalType: "address"
          },
          {
            name: "totalSupply",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalAssets",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "underlyingPrice",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "fee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "timelock",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "markets",
            type: "tuple[]",
            internalType: "struct MorphoViews.MorphoVaultMarketsInfo[]",
            components: [
              {
                name: "marketId",
                type: "bytes32",
                internalType: "Id"
              },
              {
                name: "marketCollateral",
                type: "address",
                internalType: "address"
              },
              {
                name: "marketCollateralName",
                type: "string",
                internalType: "string"
              },
              {
                name: "marketCollateralSymbol",
                type: "string",
                internalType: "string"
              },
              {
                name: "marketLiquidity",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "marketLltv",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "marketApy",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "vaultAllocation",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "vaultSupplied",
                type: "uint256",
                internalType: "uint256"
              }
            ]
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getVaultMarketInfo",
    inputs: [
      {
        name: "_marketId",
        type: "bytes32",
        internalType: "Id"
      },
      {
        name: "_morpho",
        type: "address",
        internalType: "contract IMorpho"
      },
      {
        name: "_vault",
        type: "address",
        internalType: "contract IMetaMorpho"
      }
    ],
    outputs: [
      {
        name: "",
        type: "tuple",
        internalType: "struct MorphoViews.MorphoVaultMarketsInfo",
        components: [
          {
            name: "marketId",
            type: "bytes32",
            internalType: "Id"
          },
          {
            name: "marketCollateral",
            type: "address",
            internalType: "address"
          },
          {
            name: "marketCollateralName",
            type: "string",
            internalType: "string"
          },
          {
            name: "marketCollateralSymbol",
            type: "string",
            internalType: "string"
          },
          {
            name: "marketLiquidity",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "marketLltv",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "marketApy",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "vaultAllocation",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "vaultSupplied",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getVaultsInfo",
    inputs: [
      {
        name: "morphoVaults",
        type: "address[]",
        internalType: "address[]"
      }
    ],
    outputs: [
      {
        name: "",
        type: "tuple[]",
        internalType: "struct MorphoViews.MorphoVault[]",
        components: [
          {
            name: "vault",
            type: "address",
            internalType: "address"
          },
          {
            name: "totalSupply",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalAssets",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "underlyingPrice",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "fee",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "timelock",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "markets",
            type: "tuple[]",
            internalType: "struct MorphoViews.MorphoVaultMarketsInfo[]",
            components: [
              {
                name: "marketId",
                type: "bytes32",
                internalType: "Id"
              },
              {
                name: "marketCollateral",
                type: "address",
                internalType: "address"
              },
              {
                name: "marketCollateralName",
                type: "string",
                internalType: "string"
              },
              {
                name: "marketCollateralSymbol",
                type: "string",
                internalType: "string"
              },
              {
                name: "marketLiquidity",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "marketLltv",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "marketApy",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "vaultAllocation",
                type: "uint256",
                internalType: "uint256"
              },
              {
                name: "vaultSupplied",
                type: "uint256",
                internalType: "uint256"
              }
            ]
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "initialize",
    inputs: [
      {
        name: "_comptroller",
        type: "address",
        internalType: "address"
      },
      {
        name: "_morpho",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "morpho",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "contract IMorpho"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "morphoBlueBorrowAPY",
    inputs: [
      {
        name: "marketParams",
        type: "tuple",
        internalType: "struct MarketParams",
        components: [
          {
            name: "loanToken",
            type: "address",
            internalType: "address"
          },
          {
            name: "collateralToken",
            type: "address",
            internalType: "address"
          },
          {
            name: "oracle",
            type: "address",
            internalType: "address"
          },
          {
            name: "irm",
            type: "address",
            internalType: "address"
          },
          {
            name: "lltv",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      },
      {
        name: "market",
        type: "tuple",
        internalType: "struct Market",
        components: [
          {
            name: "totalSupplyAssets",
            type: "uint128",
            internalType: "uint128"
          },
          {
            name: "totalSupplyShares",
            type: "uint128",
            internalType: "uint128"
          },
          {
            name: "totalBorrowAssets",
            type: "uint128",
            internalType: "uint128"
          },
          {
            name: "totalBorrowShares",
            type: "uint128",
            internalType: "uint128"
          },
          {
            name: "lastUpdate",
            type: "uint128",
            internalType: "uint128"
          },
          {
            name: "fee",
            type: "uint128",
            internalType: "uint128"
          }
        ]
      }
    ],
    outputs: [
      {
        name: "borrowApy",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "morphoBlueSupplyAPY",
    inputs: [
      {
        name: "marketParams",
        type: "tuple",
        internalType: "struct MarketParams",
        components: [
          {
            name: "loanToken",
            type: "address",
            internalType: "address"
          },
          {
            name: "collateralToken",
            type: "address",
            internalType: "address"
          },
          {
            name: "oracle",
            type: "address",
            internalType: "address"
          },
          {
            name: "irm",
            type: "address",
            internalType: "address"
          },
          {
            name: "lltv",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      },
      {
        name: "market",
        type: "tuple",
        internalType: "struct Market",
        components: [
          {
            name: "totalSupplyAssets",
            type: "uint128",
            internalType: "uint128"
          },
          {
            name: "totalSupplyShares",
            type: "uint128",
            internalType: "uint128"
          },
          {
            name: "totalBorrowAssets",
            type: "uint128",
            internalType: "uint128"
          },
          {
            name: "totalBorrowShares",
            type: "uint128",
            internalType: "uint128"
          },
          {
            name: "lastUpdate",
            type: "uint128",
            internalType: "uint128"
          },
          {
            name: "fee",
            type: "uint128",
            internalType: "uint128"
          }
        ]
      }
    ],
    outputs: [
      {
        name: "supplyApy",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "event",
    name: "Initialized",
    inputs: [
      {
        name: "version",
        type: "uint8",
        indexed: false,
        internalType: "uint8"
      }
    ],
    anonymous: false
  }
];

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/abis/multiRewardDistributorAbi.js
var multiRewardDistributorAbi_default = [
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "contract MToken",
        name: "mToken",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "borrower",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "emissionToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalAccrued",
        type: "uint256"
      }
    ],
    name: "DisbursedBorrowerRewards",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "contract MToken",
        name: "mToken",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "supplier",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "emissionToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalAccrued",
        type: "uint256"
      }
    ],
    name: "DisbursedSupplierRewards",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "FundsRescued",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "contract MToken",
        name: "mToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "emissionToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newIndex",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "newTimestamp",
        type: "uint32"
      }
    ],
    name: "GlobalBorrowIndexUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "contract MToken",
        name: "mToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "emissionToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newSupplyIndex",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "newSupplyGlobalTimestamp",
        type: "uint32"
      }
    ],
    name: "GlobalSupplyIndexUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint8",
        name: "version",
        type: "uint8"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address payable",
        name: "user",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "rewardToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "InsufficientTokensToEmit",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "contract MToken",
        name: "mToken",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "emissionToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "oldRewardSpeed",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newRewardSpeed",
        type: "uint256"
      }
    ],
    name: "NewBorrowRewardSpeed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "contract MToken",
        name: "mToken",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "emissionToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "supplySpeed",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "borrowSpeed",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "endTime",
        type: "uint256"
      }
    ],
    name: "NewConfigCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldEmissionCap",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newEmissionCap",
        type: "uint256"
      }
    ],
    name: "NewEmissionCap",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "contract MToken",
        name: "mToken",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "emissionToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "currentOwner",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "NewEmissionConfigOwner",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldPauseGuardian",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newPauseGuardian",
        type: "address"
      }
    ],
    name: "NewPauseGuardian",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "contract MToken",
        name: "mToken",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "emissionToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "currentEndTime",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newEndTime",
        type: "uint256"
      }
    ],
    name: "NewRewardEndTime",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "contract MToken",
        name: "mToken",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "emissionToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "oldRewardSpeed",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newRewardSpeed",
        type: "uint256"
      }
    ],
    name: "NewSupplyRewardSpeed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Paused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [],
    name: "RewardsPaused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [],
    name: "RewardsUnpaused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Unpaused",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "contract MToken",
        name: "_mToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "_emissionToken",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_supplyEmissionPerSec",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_borrowEmissionsPerSec",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_endTime",
        type: "uint256"
      }
    ],
    name: "_addEmissionConfig",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "_pauseRewards",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_tokenAddress",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_amount",
        type: "uint256"
      }
    ],
    name: "_rescueFunds",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_newEmissionCap",
        type: "uint256"
      }
    ],
    name: "_setEmissionCap",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_newPauseGuardian",
        type: "address"
      }
    ],
    name: "_setPauseGuardian",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "_unpauseRewards",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract MToken",
        name: "_mToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "_emissionToken",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_newBorrowSpeed",
        type: "uint256"
      }
    ],
    name: "_updateBorrowSpeed",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract MToken",
        name: "_mToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "_emissionToken",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_newEndTime",
        type: "uint256"
      }
    ],
    name: "_updateEndTime",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract MToken",
        name: "_mToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "_emissionToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "_newOwner",
        type: "address"
      }
    ],
    name: "_updateOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract MToken",
        name: "_mToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "_emissionToken",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_newSupplySpeed",
        type: "uint256"
      }
    ],
    name: "_updateSupplySpeed",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "comptroller",
    outputs: [
      {
        internalType: "contract Comptroller",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract MToken",
        name: "_mToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "_borrower",
        type: "address"
      },
      {
        internalType: "bool",
        name: "_sendTokens",
        type: "bool"
      }
    ],
    name: "disburseBorrowerRewards",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract MToken",
        name: "_mToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "_supplier",
        type: "address"
      },
      {
        internalType: "bool",
        name: "_sendTokens",
        type: "bool"
      }
    ],
    name: "disburseSupplierRewards",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "emissionCap",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract MToken",
        name: "_mToken",
        type: "address"
      }
    ],
    name: "getAllMarketConfigs",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "emissionToken",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "endTime",
            type: "uint256"
          },
          {
            internalType: "uint224",
            name: "supplyGlobalIndex",
            type: "uint224"
          },
          {
            internalType: "uint32",
            name: "supplyGlobalTimestamp",
            type: "uint32"
          },
          {
            internalType: "uint224",
            name: "borrowGlobalIndex",
            type: "uint224"
          },
          {
            internalType: "uint32",
            name: "borrowGlobalTimestamp",
            type: "uint32"
          },
          {
            internalType: "uint256",
            name: "supplyEmissionsPerSec",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "borrowEmissionsPerSec",
            type: "uint256"
          }
        ],
        internalType: "struct MultiRewardDistributorCommon.MarketConfig[]",
        name: "",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract MToken",
        name: "_mToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "_emissionToken",
        type: "address"
      }
    ],
    name: "getConfigForMarket",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "emissionToken",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "endTime",
            type: "uint256"
          },
          {
            internalType: "uint224",
            name: "supplyGlobalIndex",
            type: "uint224"
          },
          {
            internalType: "uint32",
            name: "supplyGlobalTimestamp",
            type: "uint32"
          },
          {
            internalType: "uint224",
            name: "borrowGlobalIndex",
            type: "uint224"
          },
          {
            internalType: "uint32",
            name: "borrowGlobalTimestamp",
            type: "uint32"
          },
          {
            internalType: "uint256",
            name: "supplyEmissionsPerSec",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "borrowEmissionsPerSec",
            type: "uint256"
          }
        ],
        internalType: "struct MultiRewardDistributorCommon.MarketConfig",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCurrentEmissionCap",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract MToken",
        name: "_mToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "_emissionToken",
        type: "address"
      }
    ],
    name: "getCurrentOwner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "mToken",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "getGlobalBorrowIndex",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "mToken",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "getGlobalSupplyIndex",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract MToken",
        name: "_mToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "_user",
        type: "address"
      }
    ],
    name: "getOutstandingRewardsForUser",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "emissionToken",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "totalAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplySide",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "borrowSide",
            type: "uint256"
          }
        ],
        internalType: "struct MultiRewardDistributorCommon.RewardInfo[]",
        name: "",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_user",
        type: "address"
      }
    ],
    name: "getOutstandingRewardsForUser",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "mToken",
            type: "address"
          },
          {
            components: [
              {
                internalType: "address",
                name: "emissionToken",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "totalAmount",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "supplySide",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "borrowSide",
                type: "uint256"
              }
            ],
            internalType: "struct MultiRewardDistributorCommon.RewardInfo[]",
            name: "rewards",
            type: "tuple[]"
          }
        ],
        internalType: "struct MultiRewardDistributorCommon.RewardWithMToken[]",
        name: "",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "initialIndexConstant",
    outputs: [
      {
        internalType: "uint224",
        name: "",
        type: "uint224"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_comptroller",
        type: "address"
      },
      {
        internalType: "address",
        name: "_pauseGuardian",
        type: "address"
      }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "marketConfigs",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "emissionToken",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "endTime",
            type: "uint256"
          },
          {
            internalType: "uint224",
            name: "supplyGlobalIndex",
            type: "uint224"
          },
          {
            internalType: "uint32",
            name: "supplyGlobalTimestamp",
            type: "uint32"
          },
          {
            internalType: "uint224",
            name: "borrowGlobalIndex",
            type: "uint224"
          },
          {
            internalType: "uint32",
            name: "borrowGlobalTimestamp",
            type: "uint32"
          },
          {
            internalType: "uint256",
            name: "supplyEmissionsPerSec",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "borrowEmissionsPerSec",
            type: "uint256"
          }
        ],
        internalType: "struct MultiRewardDistributorCommon.MarketConfig",
        name: "config",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pauseGuardian",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "paused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract MToken",
        name: "_mToken",
        type: "address"
      }
    ],
    name: "updateMarketBorrowIndex",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract MToken",
        name: "_mToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "_borrower",
        type: "address"
      },
      {
        internalType: "bool",
        name: "_sendTokens",
        type: "bool"
      }
    ],
    name: "updateMarketBorrowIndexAndDisburseBorrowerRewards",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract MToken",
        name: "_mToken",
        type: "address"
      }
    ],
    name: "updateMarketSupplyIndex",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract MToken",
        name: "_mToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "_supplier",
        type: "address"
      },
      {
        internalType: "bool",
        name: "_sendTokens",
        type: "bool"
      }
    ],
    name: "updateMarketSupplyIndexAndDisburseSupplierRewards",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/abis/multichainGovernorAbi.js
var multichainGovernorAbi_default = [
  {
    type: "constructor",
    inputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "addExternalChainConfigs",
    inputs: [
      {
        name: "_trustedSenders",
        type: "tuple[]",
        internalType: "struct WormholeTrustedSender.TrustedSender[]",
        components: [
          {
            name: "chainId",
            type: "uint16",
            internalType: "uint16"
          },
          {
            name: "addr",
            type: "address",
            internalType: "address"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "breakGlassGuardian",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "bridgeCost",
    inputs: [
      {
        name: "dstWormholeChainId",
        type: "uint16",
        internalType: "uint16"
      }
    ],
    outputs: [
      {
        name: "gasCost",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "bridgeCostAll",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "cancel",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "castVote",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "voteValue",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "chainAddressVotes",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "wormholeChainId",
        type: "uint16",
        internalType: "uint16"
      }
    ],
    outputs: [
      {
        name: "forVotes",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "againstVotes",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "abstainVotes",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "chainVoteCollectorVotes",
    inputs: [
      {
        name: "wormholeChainId",
        type: "uint16",
        internalType: "uint16"
      },
      {
        name: "proposalId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "forVotes",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "againstVotes",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "abstainVotes",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "crossChainVoteCollectionPeriod",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "currentUserLiveProposals",
    inputs: [
      {
        name: "user",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "distributor",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "contract SnapshotInterface"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "execute",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "executeBreakGlass",
    inputs: [
      {
        name: "targets",
        type: "address[]",
        internalType: "address[]"
      },
      {
        name: "calldatas",
        type: "bytes[]",
        internalType: "bytes[]"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "fromWormholeFormat",
    inputs: [
      {
        name: "whFormatAddress",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "gasLimit",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint96",
        internalType: "uint96"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAllTargetChains",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint16[]",
        internalType: "uint16[]"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAllTargetChainsLength",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getCurrentVotes",
    inputs: [
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getNumLiveProposals",
    inputs: [],
    outputs: [
      {
        name: "count",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getProposalData",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "targets",
        type: "address[]",
        internalType: "address[]"
      },
      {
        name: "values",
        type: "uint256[]",
        internalType: "uint256[]"
      },
      {
        name: "calldatas",
        type: "bytes[]",
        internalType: "bytes[]"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getReceipt",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "voter",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "hasVoted",
        type: "bool",
        internalType: "bool"
      },
      {
        name: "voteValue",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "votes",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getUserLiveProposals",
    inputs: [
      {
        name: "user",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getVotes",
    inputs: [
      {
        name: "account",
        type: "address",
        internalType: "address"
      },
      {
        name: "timestamp",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "blockNumber",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "initialize",
    inputs: [
      {
        name: "initData",
        type: "tuple",
        internalType: "struct MultichainGovernor.InitializeData",
        components: [
          {
            name: "well",
            type: "address",
            internalType: "address"
          },
          {
            name: "xWell",
            type: "address",
            internalType: "address"
          },
          {
            name: "stkWell",
            type: "address",
            internalType: "address"
          },
          {
            name: "distributor",
            type: "address",
            internalType: "address"
          },
          {
            name: "proposalThreshold",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "votingPeriodSeconds",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "crossChainVoteCollectionPeriod",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "quorum",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "maxUserLiveProposals",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "pauseDuration",
            type: "uint128",
            internalType: "uint128"
          },
          {
            name: "pauseGuardian",
            type: "address",
            internalType: "address"
          },
          {
            name: "breakGlassGuardian",
            type: "address",
            internalType: "address"
          },
          {
            name: "wormholeRelayer",
            type: "address",
            internalType: "address"
          }
        ]
      },
      {
        name: "trustedSenders",
        type: "tuple[]",
        internalType: "struct WormholeTrustedSender.TrustedSender[]",
        components: [
          {
            name: "chainId",
            type: "uint16",
            internalType: "uint16"
          },
          {
            name: "addr",
            type: "address",
            internalType: "address"
          }
        ]
      },
      {
        name: "calldatas",
        type: "bytes[]",
        internalType: "bytes[]"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "isTrustedSender",
    inputs: [
      {
        name: "chainId",
        type: "uint16",
        internalType: "uint16"
      },
      {
        name: "addr",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isTrustedSender",
    inputs: [
      {
        name: "chainId",
        type: "uint16",
        internalType: "uint16"
      },
      {
        name: "addr",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "kickGuardian",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "liveProposals",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "maxUserLiveProposals",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "pause",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "pauseDuration",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint128",
        internalType: "uint128"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "pauseGuardian",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "pauseStartTime",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint128",
        internalType: "uint128"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "pauseUsed",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "paused",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "processedNonces",
    inputs: [
      {
        name: "nonce",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "processed",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "proposalActive",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "proposalCount",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "proposalInformation",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "proposer",
        type: "address",
        internalType: "address"
      },
      {
        name: "voteSnapshotTimestamp",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "votingStartTime",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "endTimestamp",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "crossChainVoteCollectionEndTimestamp",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "totalVotes",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "forVotes",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "againstVotes",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "abstainVotes",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "proposalThreshold",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "proposalVotes",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "totalVotes",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "forVotes",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "againstVotes",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "abstainVotes",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "proposals",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "proposer",
        type: "address",
        internalType: "address"
      },
      {
        name: "voteSnapshotTimestamp",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "votingStartTime",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "votingEndTime",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "crossChainVoteCollectionEndTimestamp",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "voteSnapshotBlock",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "forVotes",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "againstVotes",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "abstainVotes",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "totalVotes",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "canceled",
        type: "bool",
        internalType: "bool"
      },
      {
        name: "executed",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "propose",
    inputs: [
      {
        name: "targets",
        type: "address[]",
        internalType: "address[]"
      },
      {
        name: "values",
        type: "uint256[]",
        internalType: "uint256[]"
      },
      {
        name: "calldatas",
        type: "bytes[]",
        internalType: "bytes[]"
      },
      {
        name: "description",
        type: "string",
        internalType: "string"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "quorum",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "rebroadcastProposal",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "receiveWormholeMessages",
    inputs: [
      {
        name: "payload",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "",
        type: "bytes[]",
        internalType: "bytes[]"
      },
      {
        name: "senderAddress",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "sourceChain",
        type: "uint16",
        internalType: "uint16"
      },
      {
        name: "nonce",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "removeExternalChainConfigs",
    inputs: [
      {
        name: "_trustedSenders",
        type: "tuple[]",
        internalType: "struct WormholeTrustedSender.TrustedSender[]",
        components: [
          {
            name: "chainId",
            type: "uint16",
            internalType: "uint16"
          },
          {
            name: "addr",
            type: "address",
            internalType: "address"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setBreakGlassGuardian",
    inputs: [
      {
        name: "newGuardian",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setGasLimit",
    inputs: [
      {
        name: "newGasLimit",
        type: "uint96",
        internalType: "uint96"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setNewStakedWell",
    inputs: [
      {
        name: "newStakedWell",
        type: "address",
        internalType: "address"
      },
      {
        name: "toUseTimestamps",
        type: "bool",
        internalType: "bool"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "state",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint8",
        internalType: "enum IMultichainGovernor.ProposalState"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "stkWell",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "contract SnapshotInterface"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "targetAddress",
    inputs: [
      {
        name: "chainId",
        type: "uint16",
        internalType: "uint16"
      }
    ],
    outputs: [
      {
        name: "target",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "unpause",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "updateApprovedCalldata",
    inputs: [
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "approved",
        type: "bool",
        internalType: "bool"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "updateCrossChainVoteCollectionPeriod",
    inputs: [
      {
        name: "newCrossChainVoteCollectionPeriod",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "updateMaxUserLiveProposals",
    inputs: [
      {
        name: "newMaxLiveProposals",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "updateProposalThreshold",
    inputs: [
      {
        name: "newProposalThreshold",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "updateQuorum",
    inputs: [
      {
        name: "newQuorum",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "updateVotingPeriod",
    inputs: [
      {
        name: "newVotingPeriod",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "useTimestamps",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "votingPeriod",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "well",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "contract SnapshotInterface"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "whitelistedCalldatas",
    inputs: [
      {
        name: "whitelistedCalldata",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "wormholeRelayer",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "contract IWormholeRelayer"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "xWell",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "contract xWELL"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "event",
    name: "BreakGlassExecuted",
    inputs: [
      {
        name: "breakGlassGuardian",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "targets",
        type: "address[]",
        indexed: false,
        internalType: "address[]"
      },
      {
        name: "calldatas",
        type: "bytes[]",
        indexed: false,
        internalType: "bytes[]"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "BreakGlassGuardianChanged",
    inputs: [
      {
        name: "oldValue",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "newValue",
        type: "address",
        indexed: false,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "BridgeOutFailed",
    inputs: [
      {
        name: "dstChainId",
        type: "uint16",
        indexed: false,
        internalType: "uint16"
      },
      {
        name: "payload",
        type: "bytes",
        indexed: false,
        internalType: "bytes"
      },
      {
        name: "refundAmount",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "BridgeOutSuccess",
    inputs: [
      {
        name: "dstWormholeChainId",
        type: "uint16",
        indexed: false,
        internalType: "uint16"
      },
      {
        name: "cost",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "dst",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "payload",
        type: "bytes",
        indexed: false,
        internalType: "bytes"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "CalldataApprovalUpdated",
    inputs: [
      {
        name: "data",
        type: "bytes",
        indexed: false,
        internalType: "bytes"
      },
      {
        name: "approved",
        type: "bool",
        indexed: false,
        internalType: "bool"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "CrossChainVoteCollected",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "sourceChain",
        type: "uint16",
        indexed: false,
        internalType: "uint16"
      },
      {
        name: "forVotes",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "againstVotes",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "abstainVotes",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "CrossChainVoteCollectionPeriodChanged",
    inputs: [
      {
        name: "oldValue",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "newValue",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "GasLimitUpdated",
    inputs: [
      {
        name: "oldGasLimit",
        type: "uint96",
        indexed: false,
        internalType: "uint96"
      },
      {
        name: "newGasLimit",
        type: "uint96",
        indexed: false,
        internalType: "uint96"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "GovernanceReturnAddressChanged",
    inputs: [
      {
        name: "oldValue",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "newValue",
        type: "address",
        indexed: false,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "Initialized",
    inputs: [
      {
        name: "version",
        type: "uint8",
        indexed: false,
        internalType: "uint8"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "NewStakedWellSet",
    inputs: [
      {
        name: "newStakedWell",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "toUseTimestamps",
        type: "bool",
        indexed: false,
        internalType: "bool"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "PauseDurationUpdated",
    inputs: [
      {
        name: "oldPauseDuration",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "newPauseDuration",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "PauseGuardianUpdated",
    inputs: [
      {
        name: "oldPauseGuardian",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "newPauseGuardian",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "PauseTimeUpdated",
    inputs: [
      {
        name: "newPauseStartTime",
        type: "uint256",
        indexed: true,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "Paused",
    inputs: [
      {
        name: "account",
        type: "address",
        indexed: false,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "ProposalCanceled",
    inputs: [
      {
        name: "id",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "ProposalCreated",
    inputs: [
      {
        name: "id",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "proposer",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "targets",
        type: "address[]",
        indexed: false,
        internalType: "address[]"
      },
      {
        name: "values",
        type: "uint256[]",
        indexed: false,
        internalType: "uint256[]"
      },
      {
        name: "calldatas",
        type: "bytes[]",
        indexed: false,
        internalType: "bytes[]"
      },
      {
        name: "votingStartTime",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "votingEndTime",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "description",
        type: "string",
        indexed: false,
        internalType: "string"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "ProposalExecuted",
    inputs: [
      {
        name: "id",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "ProposalQueued",
    inputs: [
      {
        name: "id",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "eta",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "ProposalRebroadcasted",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "data",
        type: "bytes",
        indexed: false,
        internalType: "bytes"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "ProposalThresholdChanged",
    inputs: [
      {
        name: "oldValue",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "newValue",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "QuroumVotesChanged",
    inputs: [
      {
        name: "oldValue",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "newValue",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "StartBlockSet",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "startBlock",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "TargetAddressUpdated",
    inputs: [
      {
        name: "dstChainId",
        type: "uint16",
        indexed: true,
        internalType: "uint16"
      },
      {
        name: "target",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "Unpaused",
    inputs: [
      {
        name: "account",
        type: "address",
        indexed: false,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "UserMaxProposalsChanged",
    inputs: [
      {
        name: "oldValue",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "newValue",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "VoteCast",
    inputs: [
      {
        name: "voter",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "proposalId",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "voteValue",
        type: "uint8",
        indexed: false,
        internalType: "uint8"
      },
      {
        name: "votes",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "VotingPeriodChanged",
    inputs: [
      {
        name: "oldValue",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "newValue",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  }
];

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/abis/stakingTokenAbi.js
var stakingTokenAbi_default = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "emission",
        type: "uint256"
      }
    ],
    name: "AssetConfigUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "AssetIndexUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "user", type: "address" }
    ],
    name: "Cooldown",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "newCooldownSeconds",
        type: "uint256"
      }
    ],
    name: "CooldownSecondsUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "from", type: "address" },
      { indexed: true, internalType: "address", name: "to", type: "address" },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Redeem",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "RewardsAccrued",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "from", type: "address" },
      { indexed: true, internalType: "address", name: "to", type: "address" },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "RewardsClaimed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint128",
        name: "oldValue",
        type: "uint128"
      },
      {
        indexed: false,
        internalType: "uint128",
        name: "newValue",
        type: "uint128"
      }
    ],
    name: "SnapshotDone",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "from", type: "address" },
      {
        indexed: true,
        internalType: "address",
        name: "onBehalfOf",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Staked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "from", type: "address" },
      { indexed: true, internalType: "address", name: "to", type: "address" },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "newUnstakeWindow",
        type: "uint256"
      }
    ],
    name: "UnstakeWindowUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "user", type: "address" },
      {
        indexed: true,
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "UserIndexUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "COOLDOWN_SECONDS",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "DISTRIBUTION_END",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "EMISSION_MANAGER",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "PRECISION",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "REWARDS_VAULT",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "REWARD_TOKEN",
    outputs: [{ internalType: "contract IERC20", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "STAKED_TOKEN",
    outputs: [{ internalType: "contract IERC20", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "UNSTAKE_WINDOW",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "_countsSnapshots",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "_governance",
    outputs: [
      { internalType: "contract ITransferHook", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "uint256", name: "", type: "uint256" }
    ],
    name: "_snapshots",
    outputs: [
      { internalType: "uint128", name: "blockTimestamp", type: "uint128" },
      { internalType: "uint128", name: "value", type: "uint128" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" }
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "assets",
    outputs: [
      { internalType: "uint128", name: "emissionPerSecond", type: "uint128" },
      { internalType: "uint128", name: "lastUpdateTimestamp", type: "uint128" },
      { internalType: "uint256", name: "index", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "claimRewards",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint128", name: "emissionsPerSecond", type: "uint128" },
      {
        internalType: "contract IERC20",
        name: "underlyingAsset",
        type: "address"
      }
    ],
    name: "configureAsset",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint128[]",
        name: "emissionPerSecond",
        type: "uint128[]"
      },
      { internalType: "uint256[]", name: "totalStaked", type: "uint256[]" },
      { internalType: "address[]", name: "underlyingAsset", type: "address[]" }
    ],
    name: "configureAssets",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "cooldown",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "subtractedValue", type: "uint256" }
    ],
    name: "decreaseAllowance",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "getCurrentVotes",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "account", type: "address" },
      { internalType: "uint256", name: "blockTimestamp", type: "uint256" }
    ],
    name: "getPriorVotes",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "staker", type: "address" }],
    name: "getTotalRewardsBalance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "user", type: "address" },
      { internalType: "address", name: "asset", type: "address" }
    ],
    name: "getUserAssetData",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "addedValue", type: "uint256" }
    ],
    name: "increaseAllowance",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "contract IERC20", name: "stakedToken", type: "address" },
      { internalType: "contract IERC20", name: "rewardToken", type: "address" },
      { internalType: "uint256", name: "cooldownSeconds", type: "uint256" },
      { internalType: "uint256", name: "unstakeWindow", type: "uint256" },
      { internalType: "address", name: "rewardsVault", type: "address" },
      { internalType: "address", name: "emissionManager", type: "address" },
      {
        internalType: "uint128",
        name: "distributionDuration",
        type: "uint128"
      },
      { internalType: "address", name: "governance", type: "address" }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "redeem",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "cooldownSeconds", type: "uint256" }
    ],
    name: "setCoolDownSeconds",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "newEmissionsManager", type: "address" }
    ],
    name: "setEmissionsManager",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "unstakeWindow", type: "uint256" }
    ],
    name: "setUnstakeWindow",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "onBehalfOf", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "stake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "stakerRewardsToClaim",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "stakersCooldowns",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "recipient", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "sender", type: "address" },
      { internalType: "address", name: "recipient", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/abis/temporalGovernorAbi.js
var temporalGovernorAbi_default = [
  {
    inputs: [
      {
        internalType: "address",
        name: "wormholeCore",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_proposalDelay",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_permissionlessUnpauseTime",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint16",
            name: "chainId",
            type: "uint16"
          },
          {
            internalType: "address",
            name: "addr",
            type: "address"
          }
        ],
        internalType: "struct ITemporalGovernor.TrustedSender[]",
        name: "_trustedSenders",
        type: "tuple[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "ExecutedTransaction",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "timestamp",
        type: "uint256"
      }
    ],
    name: "GuardianPauseGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "guardian",
        type: "address"
      }
    ],
    name: "GuardianRevoked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Paused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "timestamp",
        type: "uint256"
      }
    ],
    name: "PermissionlessUnpaused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "intendedRecipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address[]",
        name: "targets",
        type: "address[]"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "values",
        type: "uint256[]"
      },
      {
        indexed: false,
        internalType: "bytes[]",
        name: "calldatas",
        type: "bytes[]"
      }
    ],
    name: "QueuedTransaction",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint16",
        name: "chainId",
        type: "uint16"
      },
      {
        indexed: false,
        internalType: "address",
        name: "addr",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "added",
        type: "bool"
      }
    ],
    name: "TrustedSenderUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Unpaused",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "addr",
        type: "address"
      }
    ],
    name: "addressToBytes",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint16",
        name: "chainId",
        type: "uint16"
      }
    ],
    name: "allTrustedSenders",
    outputs: [
      {
        internalType: "bytes32[]",
        name: "",
        type: "bytes32[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "VAA",
        type: "bytes"
      }
    ],
    name: "executeProposal",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "VAA",
        type: "bytes"
      }
    ],
    name: "fastTrackProposalExecution",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "grantGuardiansPause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "guardianPauseAllowed",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint16",
        name: "chainId",
        type: "uint16"
      },
      {
        internalType: "address",
        name: "addr",
        type: "address"
      }
    ],
    name: "isTrustedSender",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint16",
        name: "chainId",
        type: "uint16"
      },
      {
        internalType: "bytes32",
        name: "addr",
        type: "bytes32"
      }
    ],
    name: "isTrustedSender",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "lastPauseTime",
    outputs: [
      {
        internalType: "uint248",
        name: "",
        type: "uint248"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "paused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "permissionlessUnpause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "permissionlessUnpauseTime",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "proposalDelay",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "VAA",
        type: "bytes"
      }
    ],
    name: "queueProposal",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    name: "queuedTransactions",
    outputs: [
      {
        internalType: "bool",
        name: "executed",
        type: "bool"
      },
      {
        internalType: "uint248",
        name: "queueTime",
        type: "uint248"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "revokeGuardian",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint16",
            name: "chainId",
            type: "uint16"
          },
          {
            internalType: "address",
            name: "addr",
            type: "address"
          }
        ],
        internalType: "struct ITemporalGovernor.TrustedSender[]",
        name: "_trustedSenders",
        type: "tuple[]"
      }
    ],
    name: "setTrustedSenders",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "togglePause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint16",
            name: "chainId",
            type: "uint16"
          },
          {
            internalType: "address",
            name: "addr",
            type: "address"
          }
        ],
        internalType: "struct ITemporalGovernor.TrustedSender[]",
        name: "_trustedSenders",
        type: "tuple[]"
      }
    ],
    name: "unSetTrustedSenders",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "wormholeBridge",
    outputs: [
      {
        internalType: "contract IWormhole",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/abis/tokenAbi.js
var tokenAbi_default = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  { inputs: [], name: "IXERC20_INVALID_0_VALUE", type: "error" },
  { inputs: [], name: "IXERC20_NotFactory", type: "error" },
  { inputs: [], name: "IXERC20_NotHighEnoughLimits", type: "error" },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "_mintingLimit",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "_burningLimit",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "_bridge",
        type: "address"
      }
    ],
    name: "BridgeLimitsSet",
    type: "event"
  },
  { anonymous: false, inputs: [], name: "EIP712DomainChanged", type: "event" },
  {
    anonymous: false,
    inputs: [
      { indexed: false, internalType: "uint8", name: "version", type: "uint8" }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "_lockbox",
        type: "address"
      }
    ],
    name: "LockboxSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "from", type: "address" },
      { indexed: true, internalType: "address", name: "to", type: "address" },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "FACTORY",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" }
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "bridges",
    outputs: [
      {
        components: [
          { internalType: "uint256", name: "timestamp", type: "uint256" },
          { internalType: "uint256", name: "ratePerSecond", type: "uint256" },
          { internalType: "uint256", name: "maxLimit", type: "uint256" },
          { internalType: "uint256", name: "currentLimit", type: "uint256" }
        ],
        internalType: "struct IXERC20.BridgeParameters",
        name: "minterParams",
        type: "tuple"
      },
      {
        components: [
          { internalType: "uint256", name: "timestamp", type: "uint256" },
          { internalType: "uint256", name: "ratePerSecond", type: "uint256" },
          { internalType: "uint256", name: "maxLimit", type: "uint256" },
          { internalType: "uint256", name: "currentLimit", type: "uint256" }
        ],
        internalType: "struct IXERC20.BridgeParameters",
        name: "burnerParams",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "_user", type: "address" },
      { internalType: "uint256", name: "_amount", type: "uint256" }
    ],
    name: "burn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "_bridge", type: "address" }],
    name: "burningCurrentLimitOf",
    outputs: [{ internalType: "uint256", name: "_limit", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "_bridge", type: "address" }],
    name: "burningMaxLimitOf",
    outputs: [{ internalType: "uint256", name: "_limit", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "subtractedValue", type: "uint256" }
    ],
    name: "decreaseAllowance",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      { internalType: "bytes1", name: "fields", type: "bytes1" },
      { internalType: "string", name: "name", type: "string" },
      { internalType: "string", name: "version", type: "string" },
      { internalType: "uint256", name: "chainId", type: "uint256" },
      { internalType: "address", name: "verifyingContract", type: "address" },
      { internalType: "bytes32", name: "salt", type: "bytes32" },
      { internalType: "uint256[]", name: "extensions", type: "uint256[]" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "addedValue", type: "uint256" }
    ],
    name: "increaseAllowance",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "string", name: "_name", type: "string" },
      { internalType: "string", name: "_symbol", type: "string" },
      { internalType: "address", name: "_factory", type: "address" }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "lockbox",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "_user", type: "address" },
      { internalType: "uint256", name: "_amount", type: "uint256" }
    ],
    name: "mint",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "_bridge", type: "address" }],
    name: "mintingCurrentLimitOf",
    outputs: [{ internalType: "uint256", name: "_limit", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "_bridge", type: "address" }],
    name: "mintingMaxLimitOf",
    outputs: [{ internalType: "uint256", name: "_limit", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "owner", type: "address" }],
    name: "nonces",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" },
      { internalType: "uint8", name: "v", type: "uint8" },
      { internalType: "bytes32", name: "r", type: "bytes32" },
      { internalType: "bytes32", name: "s", type: "bytes32" }
    ],
    name: "permit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "_bridge", type: "address" },
      { internalType: "uint256", name: "_mintingLimit", type: "uint256" },
      { internalType: "uint256", name: "_burningLimit", type: "uint256" }
    ],
    name: "setLimits",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "_lockbox", type: "address" }],
    name: "setLockbox",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/abis/voteCollectorAbi.js
var voteCollectorAbi_default = [
  {
    type: "constructor",
    inputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "acceptOwnership",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "bridgeCost",
    inputs: [
      {
        name: "dstWormholeChainId",
        type: "uint16",
        internalType: "uint16"
      }
    ],
    outputs: [
      {
        name: "gasCost",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "bridgeCostAll",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "castVote",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "voteValue",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "emitVotes",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "fromWormholeFormat",
    inputs: [
      {
        name: "whFormatAddress",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "gasLimit",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint96",
        internalType: "uint96"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAllTargetChains",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint16[]",
        internalType: "uint16[]"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAllTargetChainsLength",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getReceipt",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "voter",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "hasVoted",
        type: "bool",
        internalType: "bool"
      },
      {
        name: "voteValue",
        type: "uint8",
        internalType: "uint8"
      },
      {
        name: "votes",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getVotes",
    inputs: [
      {
        name: "account",
        type: "address",
        internalType: "address"
      },
      {
        name: "timestamp",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "initialize",
    inputs: [
      {
        name: "_xWell",
        type: "address",
        internalType: "address"
      },
      {
        name: "_stkWell",
        type: "address",
        internalType: "address"
      },
      {
        name: "_moonbeamGovernor",
        type: "address",
        internalType: "address"
      },
      {
        name: "_wormholeRelayer",
        type: "address",
        internalType: "address"
      },
      {
        name: "_moonbeamWormholeChainId",
        type: "uint16",
        internalType: "uint16"
      },
      {
        name: "_owner",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "isTrustedSender",
    inputs: [
      {
        name: "chainId",
        type: "uint16",
        internalType: "uint16"
      },
      {
        name: "addr",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isTrustedSender",
    inputs: [
      {
        name: "chainId",
        type: "uint16",
        internalType: "uint16"
      },
      {
        name: "addr",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "owner",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "pendingOwner",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "processedNonces",
    inputs: [
      {
        name: "nonce",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "processed",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "proposalInformation",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "voteSnapshotTimestamp",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "votingStartTime",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "votingEndTime",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "crossChainVoteCollectionEndTimestamp",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "totalVotes",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "forVotes",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "againstVotes",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "abstainVotes",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "proposalVotes",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "totalVotes",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "forVotes",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "againstVotes",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "abstainVotes",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "proposals",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "votingStartTime",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "voteSnapshotTimestamp",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "votingEndTime",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "crossChainVoteCollectionEndTimestamp",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "votes",
        type: "tuple",
        internalType: "struct IMultichainVoteCollection.MultichainVotes",
        components: [
          {
            name: "forVotes",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "againstVotes",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "abstainVotes",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "totalVotes",
            type: "uint256",
            internalType: "uint256"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "receiveWormholeMessages",
    inputs: [
      {
        name: "payload",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "",
        type: "bytes[]",
        internalType: "bytes[]"
      },
      {
        name: "senderAddress",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "sourceChain",
        type: "uint16",
        internalType: "uint16"
      },
      {
        name: "nonce",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "renounceOwnership",
    inputs: [],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setGasLimit",
    inputs: [
      {
        name: "newGasLimit",
        type: "uint96",
        internalType: "uint96"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setNewStakedWell",
    inputs: [
      {
        name: "newStakedWell",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "stkWell",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "contract SnapshotInterface"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "targetAddress",
    inputs: [
      {
        name: "chainId",
        type: "uint16",
        internalType: "uint16"
      }
    ],
    outputs: [
      {
        name: "target",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "transferOwnership",
    inputs: [
      {
        name: "newOwner",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "wormholeRelayer",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "contract IWormholeRelayer"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "xWell",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "contract xWELL"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "event",
    name: "BridgeOutFailed",
    inputs: [
      {
        name: "dstChainId",
        type: "uint16",
        indexed: false,
        internalType: "uint16"
      },
      {
        name: "payload",
        type: "bytes",
        indexed: false,
        internalType: "bytes"
      },
      {
        name: "refundAmount",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "BridgeOutSuccess",
    inputs: [
      {
        name: "dstWormholeChainId",
        type: "uint16",
        indexed: false,
        internalType: "uint16"
      },
      {
        name: "cost",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "dst",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "payload",
        type: "bytes",
        indexed: false,
        internalType: "bytes"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "GasLimitUpdated",
    inputs: [
      {
        name: "oldGasLimit",
        type: "uint96",
        indexed: false,
        internalType: "uint96"
      },
      {
        name: "newGasLimit",
        type: "uint96",
        indexed: false,
        internalType: "uint96"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "Initialized",
    inputs: [
      {
        name: "version",
        type: "uint8",
        indexed: false,
        internalType: "uint8"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "NewStakedWellSet",
    inputs: [
      {
        name: "newStakedWell",
        type: "address",
        indexed: false,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "OwnershipTransferStarted",
    inputs: [
      {
        name: "previousOwner",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "newOwner",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "OwnershipTransferred",
    inputs: [
      {
        name: "previousOwner",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "newOwner",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "ProposalCreated",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "votingStartTime",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "votingEndTime",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "votingCollectionEndTime",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "TargetAddressUpdated",
    inputs: [
      {
        name: "dstChainId",
        type: "uint16",
        indexed: true,
        internalType: "uint16"
      },
      {
        name: "target",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "VoteCast",
    inputs: [
      {
        name: "voter",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "proposalId",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "voteValue",
        type: "uint8",
        indexed: false,
        internalType: "uint8"
      },
      {
        name: "votes",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "VotesEmitted",
    inputs: [
      {
        name: "proposalId",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "forVotes",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "againstVotes",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "abstainVotes",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  }
];

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/abis/wrappedNativeTokenAbi.js
var wrappedNativeTokenAbi_default = [
  {
    constant: true,
    inputs: [],
    name: "name",
    outputs: [{ name: "", type: "string" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { name: "guy", type: "address" },
      { name: "wad", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ name: "", type: "bool" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "totalSupply",
    outputs: [{ name: "", type: "uint256" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { name: "src", type: "address" },
      { name: "dst", type: "address" },
      { name: "wad", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ name: "", type: "bool" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [{ name: "wad", type: "uint256" }],
    name: "withdraw",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "decimals",
    outputs: [{ name: "", type: "uint8" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [{ name: "", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "", type: "uint256" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "symbol",
    outputs: [{ name: "", type: "string" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { name: "dst", type: "address" },
      { name: "wad", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ name: "", type: "bool" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "deposit",
    outputs: [],
    payable: true,
    stateMutability: "payable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      { name: "", type: "address" },
      { name: "", type: "address" }
    ],
    name: "allowance",
    outputs: [{ name: "", type: "uint256" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  { payable: true, stateMutability: "payable", type: "fallback" },
  {
    anonymous: false,
    inputs: [
      { indexed: true, name: "src", type: "address" },
      { indexed: true, name: "guy", type: "address" },
      { indexed: false, name: "wad", type: "uint256" }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, name: "src", type: "address" },
      { indexed: true, name: "dst", type: "address" },
      { indexed: false, name: "wad", type: "uint256" }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, name: "dst", type: "address" },
      { indexed: false, name: "wad", type: "uint256" }
    ],
    name: "Deposit",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, name: "src", type: "address" },
      { indexed: false, name: "wad", type: "uint256" }
    ],
    name: "Withdrawal",
    type: "event"
  }
];

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/types/config.js
var createTokenConfig = (tokens9) => tokens9;
var createVaultConfig = (config) => config.vaults;
var createMarketConfig = (config) => config.markets;
var createMorphoMarketConfig = (config) => config.markets;
var createContractsConfig = (config) => {
  return config.contracts;
};
var createCustomConfig = (custom6) => {
  return custom6;
};
var createEnvironmentConfig = (config) => {
  const publicClient = createPublicClient({
    chain: config.chain,
    batch: {
      multicall: {
        wait: 100
      }
    },
    cacheTime: 5e3,
    transport: config.transport
  });
  const createContract = (address, abi23) => {
    return getContract({
      address,
      abi: abi23,
      client: publicClient
    });
  };
  const getTokenContract = (key, abi23) => {
    if (key) {
      const token = config.tokens[key];
      return getContract({
        address: token.address,
        abi: abi23,
        client: publicClient
      });
    } else {
      return void 0;
    }
  };
  const tokenContracts = Object.keys(config.tokens).reduce((prev, curr) => {
    return {
      ...prev,
      [curr]: getTokenContract(curr, tokenAbi_default)
    };
  }, {});
  const marketContracts = Object.keys(config.markets).reduce((prev, curr) => {
    const market = config.markets[curr];
    return {
      ...prev,
      [curr]: getTokenContract(market.marketToken, marketTokenAbi_default)
    };
  }, {});
  const vaultsContracts = Object.keys(config.vaults || {}).reduce((prev, curr) => {
    return {
      ...prev,
      [curr]: getTokenContract(curr, morphoVaultAbi_default)
    };
  }, {});
  const contracts6 = Object.keys(config.contracts).reduce((prev, curr) => {
    const key = curr;
    let contractAddress = config.contracts[key];
    let abi23 = tokenAbi_default;
    switch (key) {
      case "comptroller":
        abi23 = comptrollerAbi_default;
        break;
      case "maximillion":
        abi23 = maximillionAbi_default;
        break;
      case "views":
        abi23 = coreViewsAbi_default;
        break;
      case "morphoViews":
        abi23 = morphoViewsAbi_default;
        break;
      case "multiRewardDistributor":
        abi23 = multiRewardDistributorAbi_default;
        break;
      case "temporalGovernor":
        abi23 = temporalGovernorAbi_default;
        break;
      case "voteCollector":
        abi23 = voteCollectorAbi_default;
        break;
      case "governor":
        abi23 = governorAbi_default;
        break;
      case "multichainGovernor":
        abi23 = multichainGovernorAbi_default;
        break;
      case "oracle":
        abi23 = chainLinkOracleAbi_default;
        break;
      case "router":
        abi23 = coreRouterAbi_default;
        break;
      case "morphoBlue":
        abi23 = morphoBlueAbi_default;
        break;
      case "morphoBundler":
        abi23 = morphoBundlerAbi_default;
        break;
      case "morphoPublicAllocator":
        abi23 = morphoPublicAllocatorAbi_default;
        break;
      case "stakingToken":
        contractAddress = config.tokens[contractAddress].address;
        abi23 = stakingTokenAbi_default;
        break;
      case "governanceToken":
        contractAddress = config.tokens[contractAddress].address;
        abi23 = governanceTokenAbi_default;
        break;
      case "wrappedNativeToken":
        contractAddress = config.tokens[contractAddress].address;
        abi23 = wrappedNativeTokenAbi_default;
        break;
    }
    return {
      ...prev,
      [curr]: createContract(contractAddress, abi23)
    };
  }, {});
  return {
    key: config.key,
    name: config.name,
    chainId: config.chain.id,
    chain: config.chain,
    indexerUrl: config.indexerUrl,
    governanceIndexerUrl: config.governanceIndexerUrl,
    tokens: tokenContracts,
    markets: marketContracts,
    vaults: vaultsContracts,
    contracts: contracts6,
    custom: config.custom,
    config: {
      tokens: config.tokens,
      vaults: config.vaults,
      markets: config.markets,
      morphoMarkets: config.morphoMarkets,
      contracts: config.contracts
    },
    publicClient
  };
};

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/base/tokens.js
var tokens = createTokenConfig({
  ETH: {
    address: zeroAddress,
    decimals: 18,
    name: "Ethereum",
    symbol: "ETH"
  },
  WETH: {
    address: "0x4200000000000000000000000000000000000006",
    decimals: 18,
    name: "Wrapped Ethereum",
    symbol: "WETH"
  },
  USDC: {
    address: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
    decimals: 6,
    name: "USD Coin",
    symbol: "USDC"
  },
  MOONWELL_USDC: {
    address: "0xEdc817A28E8B93B03976FBd4a3dDBc9f7D176c22",
    decimals: 8,
    name: "Moonwell USDC",
    symbol: "mUSDC"
  },
  MOONWELL_ETH: {
    address: "0x628ff693426583D9a7FB391E54366292F509D457",
    decimals: 8,
    name: "Moonwell ETH",
    symbol: "mWETH"
  },
  cbETH: {
    address: "0x2Ae3F1Ec7F1F5012CFEab0185bfc7aa3cf0DEc22",
    decimals: 18,
    name: "Coinbase Staked Ethereum",
    symbol: "cbETH"
  },
  MOONWELL_cbETH: {
    address: "0x3bf93770f2d4a794c3d9EBEfBAeBAE2a8f09A5E5",
    decimals: 8,
    name: "Moonwell cbETH",
    symbol: "mcbETH"
  },
  wstETH: {
    address: "0xc1cba3fcea344f92d9239c08c0568f6f2f0ee452",
    decimals: 18,
    name: "Lido Staked Ethereum",
    symbol: "wstETH"
  },
  MOONWELL_wstETH: {
    address: "0x627Fe393Bc6EdDA28e99AE648fD6fF362514304b",
    decimals: 8,
    name: "Moonwell wstETH",
    symbol: "mwstETH"
  },
  rETH: {
    address: "0xb6fe221fe9eef5aba221c348ba20a1bf5e73624c",
    decimals: 18,
    name: "Rocket Pool Staked Ethereum",
    symbol: "rETH"
  },
  MOONWELL_rETH: {
    address: "0xCB1DaCd30638ae38F2B94eA64F066045B7D45f44",
    decimals: 8,
    name: "Moonwell rETH",
    symbol: "mrETH"
  },
  weETH: {
    address: "0x04c0599ae5a44757c0af6f9ec3b93da8976c150a",
    decimals: 18,
    name: "EtherFi Restaked Ethereum",
    symbol: "weETH"
  },
  MOONWELL_weETH: {
    address: "0xb8051464C8c92209C92F3a4CD9C73746C4c3CFb3",
    decimals: 8,
    name: "Moonwell weETH",
    symbol: "mweETH"
  },
  cbBTC: {
    address: "0xcbB7C0000aB88B473b1f5aFd9ef808440eed33Bf",
    decimals: 8,
    name: "Coinbase Bitcoin",
    symbol: "cbBTC"
  },
  MOONWELL_cbBTC: {
    address: "0xF877ACaFA28c19b96727966690b2f44d35aD5976",
    decimals: 8,
    name: "Moonwell cbBTC",
    symbol: "mcbBTC"
  },
  AERO: {
    address: "0x940181a94A35A4569E4529A3CDfB74e38FD98631",
    decimals: 18,
    name: "Aerodrome",
    symbol: "AERO"
  },
  MOONWELL_AERO: {
    address: "0x73902f619CEB9B31FD8EFecf435CbDf89E369Ba6",
    decimals: 8,
    name: "Moonwell AERO",
    symbol: "mAERO"
  },
  DAI: {
    address: "0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb",
    decimals: 18,
    name: "DAI",
    symbol: "DAI"
  },
  MOONWELL_DAI: {
    address: "0x73b06D8d18De422E269645eaCe15400DE7462417",
    decimals: 8,
    name: "Moonwell DAI",
    symbol: "mDAI"
  },
  USDbC: {
    address: "0xd9aaec86b65d86f6a7b5b1b0c42ffa531710b6ca",
    decimals: 6,
    name: "USD Coin",
    symbol: "USDbC"
  },
  MOONWELL_USDbC: {
    address: "0x703843C3379b52F9FF486c9f5892218d2a065cC8",
    decimals: 8,
    name: "Moonwell USDbC",
    symbol: "mUSDC"
  },
  EURC: {
    address: "0x60a3E35Cc302bFA44Cb288Bc5a4F316Fdb1adb42",
    decimals: 6,
    name: "Euro Coin",
    symbol: "EURC"
  },
  MOONWELL_EURC: {
    address: "0xb682c840B5F4FC58B20769E691A6fa1305A501a2",
    decimals: 8,
    name: "Moonwell EURC",
    symbol: "mEURC"
  },
  mwETH: {
    address: "0xa0E430870c4604CcfC7B38Ca7845B1FF653D0ff1",
    decimals: 18,
    name: "Moonwell Flagship ETH",
    symbol: "mwETH"
  },
  mwUSDC: {
    address: "0xc1256Ae5FF1cf2719D4937adb3bbCCab2E00A2Ca",
    decimals: 18,
    name: "Moonwell Flagship USDC",
    symbol: "mwUSDC"
  },
  mwEURC: {
    address: "0xf24608E0CCb972b0b0f4A6446a0BBf58c701a026",
    decimals: 18,
    name: "Moonwell Flagship EURC",
    symbol: "mwEURC"
  },
  mwcbBTC: {
    address: "0x543257eF2161176D7C8cD90BA65C2d4CaEF5a796",
    decimals: 18,
    name: "Moonwell Frontier cbBTC",
    symbol: "mwcbBTC"
  },
  WELL: {
    address: "0xA88594D404727625A9437C3f886C7643872296AE",
    decimals: 18,
    name: "Moonwell",
    symbol: "WELL"
  },
  WORMHOLE_WELL: {
    address: "0xFF8adeC2221f9f4D8dfbAFa6B9a297d17603493D",
    decimals: 18,
    name: "WELL (Wormhole)",
    symbol: "WELL"
  },
  stkWELL: {
    address: "0xe66E3A37C3274Ac24FE8590f7D84A2427194DC17",
    decimals: 18,
    name: "stkWELL",
    symbol: "stkWELL"
  },
  wrsETH: {
    address: "0xEDfa23602D0EC14714057867A78d01e94176BEA0",
    decimals: 18,
    name: "KelpDAO Restaked Ethereum",
    symbol: "wrsETH"
  },
  MOONWELL_wrsETH: {
    address: "0xfC41B49d064Ac646015b459C522820DB9472F4B5",
    decimals: 8,
    name: "Moonwell wrsETH",
    symbol: "mwrsETH"
  },
  MOONWELL_WELL: {
    address: "0xdC7810B47eAAb250De623F0eE07764afa5F71ED1",
    decimals: 8,
    name: "Moonwell WELL",
    symbol: "mWELL"
  },
  PT_LBTC_29MAY2025: {
    address: "0x5d746848005507DA0b1717C137A10C30AD9ee307",
    decimals: 8,
    name: "PT Lombard LBTC 29MAY2025",
    symbol: "PT_LBTC_29MAY2025"
  },
  LBTC: {
    address: "0xecAc9C5F704e954931349Da37F60E39f515c11c1",
    decimals: 8,
    name: "Lombard Staked Bitcoin",
    symbol: "LBTC"
  },
  USDS: {
    address: "0x820C137fa70C8691f0e44Dc420a5e53c168921Dc",
    decimals: 18,
    name: "Sky Dollar",
    symbol: "USDS"
  },
  MOONWELL_USDS: {
    address: "0xb6419c6C2e60c4025D6D06eE4F913ce89425a357",
    decimals: 8,
    name: "Moonwell USDS",
    symbol: "mUSDS"
  },
  tBTC: {
    address: "0x236aa50979D5f3De3Bd1Eeb40E81137F22ab794b",
    decimals: 18,
    name: "Threshold Bitcoin",
    symbol: "tBTC"
  },
  MOONWELL_tBTC: {
    address: "0x9A858ebfF1bEb0D3495BB0e2897c1528eD84A218",
    decimals: 8,
    name: "Moonwell tBTC",
    symbol: "mtBTC"
  },
  MOONWELL_LBTC: {
    address: "0x10fF57877b79e9bd949B3815220eC87B9fc5D2ee",
    decimals: 8,
    name: "Moonwell LBTC",
    symbol: "mLBTC"
  },
  VIRTUAL: {
    address: "0x0b3e328455c4059EEb9e3f84b5543F74E24e7E1b",
    decimals: 18,
    name: "Virtuals Protocol",
    symbol: "VIRTUAL"
  },
  MOONWELL_VIRTUAL: {
    address: "0xdE8Df9d942D78edE3Ca06e60712582F79CFfFC64",
    decimals: 8,
    name: "Moonwell Virtual",
    symbol: "mVIRTUAL"
  },
  MORPHO: {
    address: "0xBAa5CC21fd487B8Fcc2F632f3F4E8D37262a0842",
    decimals: 18,
    name: "Morpho",
    symbol: "MORPHO"
  },
  MOONWELL_MORPHO: {
    address: "0x6308204872BdB7432dF97b04B42443c714904F3E",
    decimals: 8,
    name: "Moonwell MORPHO",
    symbol: "mMORPHO"
  },
  cbXRP: {
    address: "0xcb585250f852C6c6bf90434AB21A00f02833a4af",
    decimals: 6,
    name: "Coinbase XRP",
    symbol: "cbXRP"
  },
  MOONWELL_cbXRP: {
    address: "0xb4fb8fed5b3AaA8434f0B19b1b623d977e07e86d",
    decimals: 8,
    name: "Moonwell cbXRP",
    symbol: "mcbXRP"
  },
  meUSDC: {
    address: "0xe1ba476304255353aef290e6474a417d06e7b773",
    decimals: 18,
    name: "Moonwell Ecosystem USDC Vault",
    symbol: "meUSDC"
  },
  MAMO: {
    address: "0x7300B37DfdfAb110d83290A29DfB31B1740219fE",
    decimals: 18,
    name: "Mamo",
    symbol: "MAMO"
  },
  MOONWELL_MAMO: {
    address: "0x2f90bb22eb3979f5ffad31ea6c3f0792ca66da32",
    decimals: 8,
    name: "Moonwell MAMO",
    symbol: "mMAMO"
  }
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/base/contracts.js
var contracts2 = createContractsConfig({
  tokens,
  contracts: {
    stakingToken: "stkWELL",
    wrappedNativeToken: "WETH",
    governanceToken: "WELL",
    comptroller: "0xfBb21d0380beE3312B33c4353c8936a0F13EF26C",
    views: "0x821Ff3a967b39bcbE8A018a9b1563EAf878bad39",
    multiRewardDistributor: "0xe9005b078701e2A0948D2EaC43010D35870Ad9d2",
    oracle: "0xEC942bE8A8114bFD0396A5052c36027f2cA6a9d0",
    router: "0x70778cfcFC475c7eA0f24cC625Baf6EaE475D0c9",
    temporalGovernor: "0x8b621804a7637b781e2BbD58e256a591F2dF7d51",
    voteCollector: "0xe0278B32c627FF6fFbbe7de6A18Ade145603e949",
    morphoBlue: "0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb",
    morphoBaseBundler: "0x6BFd8137e702540E7A42B74178A4a49Ba43920C4",
    morphoBundler: "0xb98c948CFA24072e58935BC004a8A7b376AE746A",
    morphoPublicAllocator: "0xA090dD1a701408Df1d4d0B85b716c87565f90467",
    morphoViews: "0xc72fCC9793a10b9c363EeaAcaAbe422E0672B42B"
  }
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/base/core-markets.js
var markets = createMarketConfig({
  tokens,
  markets: {
    MOONWELL_USDC: {
      marketToken: "MOONWELL_USDC",
      underlyingToken: "USDC"
    },
    MOONWELL_ETH: {
      marketToken: "MOONWELL_ETH",
      underlyingToken: "ETH"
    },
    MOONWELL_cbETH: {
      marketToken: "MOONWELL_cbETH",
      underlyingToken: "cbETH"
    },
    MOONWELL_wstETH: {
      marketToken: "MOONWELL_wstETH",
      underlyingToken: "wstETH"
    },
    MOONWELL_rETH: {
      marketToken: "MOONWELL_rETH",
      underlyingToken: "rETH"
    },
    MOONWELL_weETH: {
      marketToken: "MOONWELL_weETH",
      underlyingToken: "weETH"
    },
    MOONWELL_cbBTC: {
      marketToken: "MOONWELL_cbBTC",
      underlyingToken: "cbBTC"
    },
    MOONWELL_AERO: {
      marketToken: "MOONWELL_AERO",
      underlyingToken: "AERO"
    },
    MOONWELL_DAI: {
      marketToken: "MOONWELL_DAI",
      underlyingToken: "DAI"
    },
    MOONWELL_USDbC: {
      marketToken: "MOONWELL_USDbC",
      underlyingToken: "USDbC",
      deprecated: true
    },
    MOONWELL_EURC: {
      marketToken: "MOONWELL_EURC",
      underlyingToken: "EURC"
    },
    MOONWELL_wrsETH: {
      marketToken: "MOONWELL_wrsETH",
      underlyingToken: "wrsETH"
    },
    MOONWELL_WELL: {
      marketToken: "MOONWELL_WELL",
      underlyingToken: "WELL"
    },
    MOONWELL_USDS: {
      marketToken: "MOONWELL_USDS",
      underlyingToken: "USDS"
    },
    MOONWELL_tBTC: {
      marketToken: "MOONWELL_tBTC",
      underlyingToken: "tBTC"
    },
    MOONWELL_LBTC: {
      marketToken: "MOONWELL_LBTC",
      underlyingToken: "LBTC"
    },
    MOONWELL_VIRTUAL: {
      marketToken: "MOONWELL_VIRTUAL",
      underlyingToken: "VIRTUAL"
    },
    MOONWELL_MORPHO: {
      marketToken: "MOONWELL_MORPHO",
      underlyingToken: "MORPHO"
    },
    MOONWELL_cbXRP: {
      marketToken: "MOONWELL_cbXRP",
      underlyingToken: "cbXRP"
    },
    MOONWELL_MAMO: {
      marketToken: "MOONWELL_MAMO",
      underlyingToken: "MAMO"
    }
  }
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/base/custom.js
var custom2 = createCustomConfig({
  morpho: {
    minimalDeployment: false,
    subgraphUrl: "https://api.goldsky.com/api/public/project_cm7wv7gztiq1e01vv7uco1h1y/subgraphs/moonwell-morpho-blue-base/production/gn"
  },
  governance: {
    token: "WELL",
    chainIds: []
  },
  wormhole: {
    chainId: 30,
    tokenBridge: { address: "0x8d2de8d2f73F1F4cAB472AC9A881C9b123C79627" }
  },
  socket: {
    gateway: { address: "0x3a23F943181408EAC424116Af7b7790c94Cb97a5" }
  },
  xWELL: {
    bridgeAdapter: { address: "0x734AbBCe07679C9A6B4Fe3bC16325e028fA6DbB7" }
  }
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/base/morpho-markets.js
var morphoMarkets = createMorphoMarketConfig({
  tokens,
  markets: {
    "wstETH-ETH": {
      collateralToken: "wstETH",
      loanToken: "ETH",
      id: "0x3a4048c64ba1b375330d376b1ce40e4047d03b47ab4d48af484edec9fec801ba"
    },
    "USDC-ETH": {
      collateralToken: "USDC",
      loanToken: "ETH",
      id: "0x3b3769cfca57be2eaed03fcc5299c25691b77781a1e124e7a8d520eb9a7eabb5"
    },
    "cbETH-ETH": {
      collateralToken: "cbETH",
      loanToken: "ETH",
      id: "0x84662b4f95b85d6b082b68d32cf71bb565b3f22f216a65509cc2ede7dccdfe8c"
    },
    "rETH-ETH": {
      collateralToken: "rETH",
      loanToken: "ETH",
      id: "0xdc69cf2caae7b7d1783fb5a9576dc875888afad17ab3d1a3fc102f741441c165"
    },
    "cbETH-USDC": {
      collateralToken: "cbETH",
      loanToken: "USDC",
      id: "0x1C21C59DF9DB44BF6F645D854EE710A8CA17B479451447E9F56758AEE10A2FAD"
    },
    "ETH-USDC": {
      collateralToken: "ETH",
      loanToken: "USDC",
      id: "0x8793cf302b8ffd655ab97bd1c695dbd967807e8367a65cb2f4edaf1380ba1bda"
    },
    "wstETH-USDC": {
      collateralToken: "wstETH",
      loanToken: "USDC",
      id: "0x13c42741a359ac4a8aa8287d2be109dcf28344484f91185f9a79bd5a805a55ae"
    },
    "wstETH-USDC-deprecated": {
      collateralToken: "wstETH",
      loanToken: "USDC",
      id: "0xa066f3893b780833699043f824e5bb88b8df039886f524f62b9a1ac83cb7f1f0",
      deprecated: true
    },
    "rETH-USDC": {
      collateralToken: "rETH",
      loanToken: "USDC",
      id: "0xdb0bc9f10a174f29a345c5f30a719933f71ccea7a2a75a632a281929bba1b535"
    },
    "cbBTC-USDC": {
      collateralToken: "cbBTC",
      loanToken: "USDC",
      id: "0x9103c3b4e834476c9a62ea009ba2c884ee42e94e6e314a26f04d312434191836"
    },
    "cbBTC-ETH": {
      collateralToken: "cbBTC",
      loanToken: "ETH",
      id: "0x5dffffc7d75dc5abfa8dbe6fad9cbdadf6680cbe1428bafe661497520c84a94c"
    },
    "cbBTC-EURC": {
      collateralToken: "cbBTC",
      loanToken: "EURC",
      id: "0x67ebd84b2fb39e3bc5a13d97e4c07abe1ea617e40654826e9abce252e95f049e"
    },
    "PT_LBTC_29MAY2025-cbBTC": {
      collateralToken: "PT_LBTC_29MAY2025",
      loanToken: "cbBTC",
      id: "0x9a697eb760dd12aaea23699c96ea2ebbfe48b7af64138d92c4d232b9ed380024",
      deprecated: true
    },
    "LBTC-cbBTC": {
      collateralToken: "LBTC",
      loanToken: "cbBTC",
      id: "0x4944a1169bc07b441473b830308ffe5bb535c10a9f824e33988b60738120c48e"
    },
    "WELL-USDC": {
      collateralToken: "WELL",
      loanToken: "USDC",
      id: "0x018ac6ef4385a1b13886c9170a6f3e0e968268ff2bf988f66512f45607aa38f7"
    },
    "MAMO-USDC": {
      collateralToken: "MAMO",
      loanToken: "USDC",
      id: "0xace0ea2ff0a6c4b7edc51fbce422be4cdbba45471e395d974c46d619aa2a393d"
    },
    "stkWELL-USDC": {
      collateralToken: "stkWELL",
      loanToken: "USDC",
      id: "0xb3920b96dec75b6a1144b71f963f30236fb200f3e33e93c2e9c0d222c1fa53c2"
    }
  }
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/base/morpho-vaults.js
var vaults = createVaultConfig({
  tokens,
  vaults: {
    mwETH: {
      underlyingToken: "ETH",
      vaultToken: "mwETH",
      campaignId: "0x7b6fa69675c0b51216ad7701b382681883b8a7d6bc5e7ed2c53685bb6c689675"
    },
    mwUSDC: {
      underlyingToken: "USDC",
      vaultToken: "mwUSDC",
      campaignId: "0x50dbe3555f6c3b34bd4ced20cee841f35f7268e861fc80ceed1e56de1d4f0ddd"
    },
    mwEURC: {
      underlyingToken: "EURC",
      vaultToken: "mwEURC",
      campaignId: "0x9b6bff1f651d553966e15d1f3e29919cd47b03d2a35536dd8f60ca6e0bd9830b"
    },
    mwcbBTC: {
      underlyingToken: "cbBTC",
      vaultToken: "mwcbBTC"
    },
    meUSDC: {
      underlyingToken: "USDC",
      vaultToken: "meUSDC"
    }
  }
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/base/environment.js
var base2 = defineChain({ ...base, testnet: false });
var createEnvironment = (rpcUrls, indexerUrl, governanceIndexerUrl) => createEnvironmentConfig({
  key: "base",
  name: "Base",
  chain: {
    ...base2,
    rpcUrls: {
      default: { http: rpcUrls || base2.rpcUrls.default.http }
    }
  },
  transport: rpcUrls ? fallback(rpcUrls.map((url) => http(url))) : fallback([
    http(base2.rpcUrls.default.http[0]),
    http("https://base.llamarpc.com"),
    http("https://base-mainnet.public.blastapi.io"),
    http("https://base.lava.build")
  ]),
  indexerUrl: indexerUrl || "https://ponder.moonwell.fi",
  governanceIndexerUrl: governanceIndexerUrl || "https://ponder.moonwell.fi",
  tokens,
  markets,
  vaults,
  morphoMarkets,
  contracts: contracts2,
  custom: custom2
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/moonbeam/tokens.js
var tokens2 = createTokenConfig({
  GLMR: {
    address: zeroAddress,
    decimals: 18,
    name: "Moonbeam",
    symbol: "GLMR"
  },
  WGLMR: {
    address: "0xAcc15dC74880C9944775448304B263D191c6077F",
    decimals: 18,
    name: "Wrapped GLMR",
    symbol: "WGLMR"
  },
  MOONWELL_GLMR: {
    address: "0x091608f4e4a15335145be0A279483C0f8E4c7955",
    decimals: 8,
    name: "Moonwell GLMR",
    symbol: "mGLMR"
  },
  xcDOT: {
    address: "0xffffffff1fcacbd218edc0eba20fc2308c778080",
    decimals: 10,
    name: "Polkadot",
    symbol: "xcDOT"
  },
  MOONWELL_xcDOT: {
    address: "0xD22Da948c0aB3A27f5570b604f3ADef5F68211C3",
    decimals: 8,
    name: "Moonwell xcDOT",
    symbol: "mDOT"
  },
  FRAX: {
    address: "0x322e86852e492a7ee17f28a78c663da38fb33bfb",
    decimals: 18,
    name: "Frax",
    symbol: "FRAX"
  },
  MOONWELL_FRAX: {
    address: "0x1C55649f73CDA2f72CEf3DD6C5CA3d49EFcF484C",
    decimals: 8,
    name: "Moonwell FRAX",
    symbol: "mFRAX"
  },
  xcUSDC: {
    address: "0xFFfffffF7D2B0B761Af01Ca8e25242976ac0aD7D",
    decimals: 6,
    name: "USD Coin",
    symbol: "xcUSDC"
  },
  MOONWELL_xcUSDC: {
    address: "0x22b1a40e3178fe7C7109eFCc247C5bB2B34ABe32",
    decimals: 8,
    name: "Moonwell xcUSDC",
    symbol: "mxcUSDC"
  },
  xcUSDT: {
    address: "0xFFFFFFfFea09FB06d082fd1275CD48b191cbCD1d",
    decimals: 6,
    name: "Tether",
    symbol: "xcUSDT"
  },
  MOONWELL_xcUSDT: {
    address: "0x42A96C0681B74838eC525AdbD13c37f66388f289",
    decimals: 8,
    name: "Moonwell xcUSDT",
    symbol: "mxcUSDT"
  },
  ETH_NOMAD: {
    address: "0x30d2a9f5fdf90ace8c17952cbb4ee48a55d916a7",
    decimals: 18,
    name: "Ethereum",
    symbol: "ETH.mad"
  },
  MOONWELL_ETH_NOMAD: {
    address: "0xc3090f41Eb54A7f18587FD6651d4D3ab477b07a4",
    decimals: 8,
    name: "Moonwell ETH",
    symbol: "mETH"
  },
  BTC_NOMAD: {
    address: "0x1DC78Acda13a8BC4408B207c9E48CDBc096D95e0",
    decimals: 8,
    name: "Bitcoin",
    symbol: "BTC.mad"
  },
  MOONWELL_BTC_NOMAD: {
    address: "0x24A9d8f1f350d59cB0368D3d52A77dB29c833D1D",
    decimals: 8,
    name: "Moonwell BTC",
    symbol: "mWBTC"
  },
  USDC_NOMAD: {
    address: "0x8f552a71efe5eefc207bf75485b356a0b3f01ec9",
    decimals: 6,
    name: "USD Coin",
    symbol: "USDC.mad"
  },
  MOONWELL_USDC_NOMAD: {
    address: "0x02e9081DfadD37A852F9a73C4d7d69e615E61334",
    decimals: 8,
    name: "Moonwell USDC",
    symbol: "mUSDC"
  },
  ETH_WORMHOLE: {
    address: "0xab3f0245b83feb11d15aaffefd7ad465a59817ed",
    decimals: 18,
    name: "Ethereum",
    symbol: "ETH.wh"
  },
  MOONWELL_ETH_WORMHOLE: {
    address: "0xb6c94b3A378537300387B57ab1cC0d2083f9AeaC",
    decimals: 8,
    name: "Moonwell ETH",
    symbol: "mETH.wh"
  },
  BTC_WORMHOLE: {
    address: "0xe57ebd2d67b462e9926e04a8e33f01cd0d64346d",
    decimals: 8,
    name: "Bitcoin",
    symbol: "BTC.wh"
  },
  MOONWELL_BTC_WORMHOLE: {
    address: "0xaaa20c5a584a9fECdFEDD71E46DA7858B774A9ce",
    decimals: 8,
    name: "Moonwell BTC",
    symbol: "mWBTC.wh"
  },
  USDC_WORMHOLE: {
    address: "0x931715fee2d06333043d11f658c8ce934ac61d0c",
    decimals: 6,
    name: "USD Coin",
    symbol: "USDC.wh"
  },
  MOONWELL_USDC_WORMHOLE: {
    address: "0x744b1756e7651c6D57f5311767EAFE5E931D615b",
    decimals: 8,
    name: "Moonwell USDC",
    symbol: "mUSDC.wh"
  },
  BUSD_WORMHOLE: {
    address: "0x692c57641fc054c2ad6551ccc6566eba599de1ba",
    decimals: 18,
    name: "BUSD Coin",
    symbol: "BUSD.wh"
  },
  MOONWELL_BUSD_WORMHOLE: {
    address: "0x298f2E346b82D69a473BF25f329BDF869e17dEc8",
    decimals: 8,
    name: "Moonwell BUSD",
    symbol: "mBUSD.wh"
  },
  WELL: {
    address: "0x511aB53F793683763E5a8829738301368a2411E3",
    decimals: 18,
    name: "WELL",
    symbol: "WELL"
  },
  XWELL: {
    address: "0xA88594D404727625A9437C3f886C7643872296AE",
    decimals: 18,
    name: "WELL",
    symbol: "WELL"
  },
  stkWELL: {
    address: "0x8568A675384d761f36eC269D695d6Ce4423cfaB1",
    decimals: 18,
    name: "stkWELL",
    symbol: "stkWELL"
  }
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/moonbeam/contracts.js
var contracts3 = createContractsConfig({
  tokens: tokens2,
  contracts: {
    governanceToken: "WELL",
    stakingToken: "stkWELL",
    wrappedNativeToken: "WGLMR",
    tokenSale: "0x933fCDf708481c57E9FD82f6BAA084f42e98B60e",
    comptroller: "0x8E00D5e02E65A19337Cdba98bbA9F84d4186a180",
    maximillion: "0xe5Ef9310cC7E3437bAD83466675f24FD62A380c3",
    views: "0xe76C8B8706faC85a8Fbdcac3C42e3E7823c73994",
    oracle: "0xED301cd3EB27217BDB05C4E9B820a8A3c8B665f9",
    governor: "0xfc4DFB17101A12C5CEc5eeDd8E92B5b16557666d",
    multichainGovernor: "0x9A8464C4C11CeA17e191653Deb7CdC1bE30F1Af4"
  }
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/moonbeam/core-markets.js
var markets2 = createMarketConfig({
  tokens: tokens2,
  markets: {
    MOONWELL_GLMR: {
      marketToken: "MOONWELL_GLMR",
      underlyingToken: "GLMR"
    },
    MOONWELL_xcDOT: {
      marketToken: "MOONWELL_xcDOT",
      underlyingToken: "xcDOT",
      badDebt: true
    },
    MOONWELL_FRAX: {
      marketToken: "MOONWELL_FRAX",
      underlyingToken: "FRAX",
      badDebt: true
    },
    MOONWELL_xcUSDC: {
      marketToken: "MOONWELL_xcUSDC",
      underlyingToken: "xcUSDC"
    },
    MOONWELL_xcUSDT: {
      marketToken: "MOONWELL_xcUSDT",
      underlyingToken: "xcUSDT"
    },
    MOONWELL_ETH_NOMAD: {
      marketToken: "MOONWELL_ETH_NOMAD",
      underlyingToken: "ETH_NOMAD",
      deprecated: true
    },
    MOONWELL_BTC_NOMAD: {
      marketToken: "MOONWELL_BTC_NOMAD",
      underlyingToken: "BTC_NOMAD",
      deprecated: true
    },
    MOONWELL_USDC_NOMAD: {
      marketToken: "MOONWELL_USDC_NOMAD",
      underlyingToken: "USDC_NOMAD",
      deprecated: true
    },
    MOONWELL_ETH_WORMHOLE: {
      marketToken: "MOONWELL_ETH_WORMHOLE",
      underlyingToken: "ETH_WORMHOLE"
    },
    MOONWELL_BTC_WORMHOLE: {
      marketToken: "MOONWELL_BTC_WORMHOLE",
      underlyingToken: "BTC_WORMHOLE"
    },
    MOONWELL_USDC_WORMHOLE: {
      marketToken: "MOONWELL_USDC_WORMHOLE",
      underlyingToken: "USDC_WORMHOLE"
    },
    MOONWELL_BUSD_WORMHOLE: {
      marketToken: "MOONWELL_BUSD_WORMHOLE",
      underlyingToken: "BUSD_WORMHOLE",
      deprecated: true
    }
  }
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/moonbeam/custom.js
var custom3 = createCustomConfig({
  governance: {
    token: "WELL",
    chainIds: [base.id, optimism.id],
    proposalIdOffset: 79,
    snapshotEnsName: "moonwell-governance.eth"
  },
  wormhole: {
    chainId: 16,
    tokenBridge: { address: "0xB1731c586ca89a23809861c6103F0b96B3F57D92" }
  },
  socket: {
    gateway: { address: "0x3a23F943181408EAC424116Af7b7790c94Cb97a5" }
  },
  xWELL: {
    bridgeAdapter: { address: "0xb84543e036054E2cD5394A9D99fa701Eef666df4" }
  }
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/moonbeam/environment.js
var createEnvironment2 = (rpcUrls, indexerUrl, governanceIndexerUrl) => createEnvironmentConfig({
  key: "moonbeam",
  name: "Moonbeam",
  chain: {
    ...moonbeam,
    rpcUrls: {
      default: { http: rpcUrls || moonbeam.rpcUrls.default.http }
    }
  },
  transport: rpcUrls ? fallback(rpcUrls.map((url) => http(url))) : http("https://rpc.api.moonbeam.network"),
  indexerUrl: indexerUrl || "https://ponder.moonwell.fi",
  governanceIndexerUrl: governanceIndexerUrl || "https://ponder.moonwell.fi",
  tokens: tokens2,
  markets: markets2,
  vaults: {},
  morphoMarkets: {},
  contracts: contracts3,
  custom: custom3
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/moonriver/tokens.js
var tokens3 = createTokenConfig({
  MOVR: {
    address: zeroAddress,
    decimals: 18,
    name: "MOVR",
    symbol: "MOVR"
  },
  WMOVR: {
    address: "0x98878B06940aE243284CA214f92Bb71a2b032B8A",
    decimals: 18,
    name: "Wrapped MOVR",
    symbol: "MOVR"
  },
  MOONWELL_MOVR: {
    address: "0x6a1A771C7826596652daDC9145fEAaE62b1cd07f",
    decimals: 8,
    name: "Moonwell MOVR",
    symbol: "mMOVR"
  },
  xcKSM: {
    address: "0xffffffff1fcacbd218edc0eba20fc2308c778080",
    decimals: 12,
    name: "Kusama",
    symbol: "xcKSM"
  },
  MOONWELL_xcKSM: {
    address: "0xa0D116513Bd0B8f3F14e6Ea41556c6Ec34688e0f",
    decimals: 8,
    name: "Moonwell xcKSM",
    symbol: "mxcKSM"
  },
  FRAX: {
    address: "0x1A93B23281CC1CDE4C4741353F3064709A16197d",
    decimals: 18,
    name: "Frax",
    symbol: "FRAX"
  },
  MOONWELL_FRAX: {
    address: "0x93Ef8B7c6171BaB1C0A51092B2c9da8dc2ba0e9D",
    decimals: 8,
    name: "Moonwell FRAX",
    symbol: "mFRAX"
  },
  BTC: {
    address: "0x6aB6d61428fde76768D7b45D8BFeec19c6eF91A8",
    decimals: 8,
    name: "Bitcoin",
    symbol: "BTC"
  },
  MOONWELL_BTC: {
    address: "0x6E745367F4Ad2b3da7339aee65dC85d416614D90",
    decimals: 8,
    name: "Moonwell BTC",
    symbol: "mWBTC"
  },
  USDC: {
    address: "0xE3F5a90F9cb311505cd691a46596599aA1A0AD7D",
    decimals: 6,
    name: "USD Coin",
    symbol: "USDC"
  },
  MOONWELL_USDC: {
    address: "0xd0670AEe3698F66e2D4dAf071EB9c690d978BFA8",
    decimals: 8,
    name: "Moonwell USDC",
    symbol: "mUSDC"
  },
  ETH: {
    address: "0x639A647fbe20b6c8ac19E48E2de44ea792c62c5C",
    decimals: 18,
    name: "Ethereum",
    symbol: "ETH"
  },
  MOONWELL_ETH: {
    address: "0x6503D905338e2ebB550c9eC39Ced525b612E77aE",
    decimals: 8,
    name: "Moonwell ETH",
    symbol: "mETH"
  },
  USDT: {
    address: "0xB44a9B6905aF7c801311e8F4E76932ee959c663C",
    decimals: 6,
    name: "Tether",
    symbol: "USDT"
  },
  MOONWELL_USDT: {
    address: "0x36918B66F9A3eC7a59d0007D8458DB17bDffBF21",
    decimals: 8,
    name: "Moonwell USDT",
    symbol: "mUSDT"
  },
  MFAM: {
    address: "0xBb8d88bcD9749636BC4D2bE22aaC4Bb3B01A58F1",
    decimals: 18,
    name: "MFAM",
    symbol: "MFAM"
  },
  stkMFAM: {
    address: "0xCd76e63f3AbFA864c53b4B98F57c1aA6539FDa3a",
    decimals: 18,
    name: "stkMFAM",
    symbol: "stkMFAM"
  }
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/moonriver/contracts.js
var contracts4 = createContractsConfig({
  tokens: tokens3,
  contracts: {
    governanceToken: "MFAM",
    stakingToken: "stkMFAM",
    wrappedNativeToken: "WMOVR",
    comptroller: "0x0b7a0EAA884849c6Af7a129e899536dDDcA4905E",
    maximillion: "0x1650C0AD9483158f9e240fd58d0E173807A80CcC",
    views: "0xb4104C02BBf4E9be85AAa41a62974E4e28D59A33",
    oracle: "0x892bE716Dcf0A6199677F355f45ba8CC123BAF60",
    governor: "0x2BE2e230e89c59c8E20E633C524AD2De246e7370"
  }
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/moonriver/core-markets.js
var markets3 = createMarketConfig({
  tokens: tokens3,
  markets: {
    MOONWELL_MOVR: {
      marketToken: "MOONWELL_MOVR",
      underlyingToken: "MOVR"
    },
    MOONWELL_xcKSM: {
      marketToken: "MOONWELL_xcKSM",
      underlyingToken: "xcKSM"
    },
    MOONWELL_FRAX: {
      marketToken: "MOONWELL_FRAX",
      underlyingToken: "FRAX"
    },
    MOONWELL_BTC: {
      marketToken: "MOONWELL_BTC",
      underlyingToken: "BTC",
      deprecated: true
    },
    MOONWELL_USDC: {
      marketToken: "MOONWELL_USDC",
      underlyingToken: "USDC",
      deprecated: true
    },
    MOONWELL_ETH: {
      marketToken: "MOONWELL_ETH",
      underlyingToken: "ETH",
      deprecated: true
    },
    MOONWELL_USDT: {
      marketToken: "MOONWELL_USDT",
      underlyingToken: "USDT",
      deprecated: true
    }
  }
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/moonriver/custom.js
var custom4 = createCustomConfig({
  governance: {
    token: "MFAM",
    chainIds: [],
    snapshotEnsName: "moonwell-apollo-governance.eth"
  }
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/moonriver/environment.js
var createEnvironment3 = (rpcUrls, indexerUrl, governanceIndexerUrl) => createEnvironmentConfig({
  key: "moonriver",
  name: "Moonriver",
  chain: {
    ...moonriver,
    rpcUrls: {
      default: { http: rpcUrls || moonriver.rpcUrls.default.http }
    }
  },
  transport: rpcUrls ? fallback(rpcUrls.map((url) => http(url))) : http(moonriver.rpcUrls.default.http[0]),
  indexerUrl: indexerUrl || "https://ponder.moonwell.fi",
  governanceIndexerUrl: governanceIndexerUrl || "https://ponder.moonwell.fi",
  tokens: tokens3,
  markets: markets3,
  vaults: {},
  morphoMarkets: {},
  contracts: contracts4,
  custom: custom4
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/optimism/tokens.js
var tokens4 = createTokenConfig({
  USDC: {
    address: "0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85",
    decimals: 6,
    name: "USD Coin",
    symbol: "USDC"
  },
  MOONWELL_USDC: {
    address: "0x8E08617b0d66359D73Aa11E11017834C29155525",
    decimals: 8,
    name: "Moonwell USDC",
    symbol: "mUSDC"
  },
  ETH: {
    address: zeroAddress,
    decimals: 18,
    name: "Ethereum",
    symbol: "ETH"
  },
  WETH: {
    address: "0x4200000000000000000000000000000000000006",
    decimals: 18,
    name: "Wrapped Ethereum",
    symbol: "WETH"
  },
  MOONWELL_ETH: {
    address: "0xb4104C02BBf4E9be85AAa41a62974E4e28D59A33",
    decimals: 8,
    name: "Moonwell ETH",
    symbol: "mWETH"
  },
  cbETH: {
    address: "0xadDb6A0412DE1BA0F936DCaeb8Aaa24578dcF3B2",
    decimals: 18,
    name: "Coinbase Staked Ethereum",
    symbol: "cbETH"
  },
  MOONWELL_cbETH: {
    address: "0x95C84F369bd0251ca903052600A3C96838D78bA1",
    decimals: 8,
    name: "Moonwell cbETH",
    symbol: "mcbETH"
  },
  wstETH: {
    address: "0x1F32b1c2345538c0c6f582fCB022739c4A194Ebb",
    decimals: 18,
    name: "Lido Staked Ethereum",
    symbol: "wstETH"
  },
  MOONWELL_wstETH: {
    address: "0xbb3b1aB66eFB43B10923b87460c0106643B83f9d",
    decimals: 8,
    name: "Moonwell wstETH",
    symbol: "mwstETH"
  },
  rETH: {
    address: "0x9Bcef72be871e61ED4fBbc7630889beE758eb81D",
    decimals: 18,
    name: "Rocket Pool Staked Ethereum",
    symbol: "rETH"
  },
  MOONWELL_rETH: {
    address: "0x4c2E35E3eC4A0C82849637BC04A4609Dbe53d321",
    decimals: 8,
    name: "Moonwell rETH",
    symbol: "mrETH"
  },
  weETH: {
    address: "0x5A7fACB970D094B6C7FF1df0eA68D99E6e73CBFF",
    decimals: 18,
    name: "EtherFi Restaked Ethereum",
    symbol: "weETH"
  },
  MOONWELL_weETH: {
    address: "0xb8051464C8c92209C92F3a4CD9C73746C4c3CFb3",
    decimals: 8,
    name: "Moonwell weETH",
    symbol: "mweETH"
  },
  WBTC: {
    address: "0x68f180fcCe6836688e9084f035309E29Bf0A2095",
    decimals: 8,
    name: "Wrapped Bitcoin",
    symbol: "WBTC"
  },
  MOONWELL_WBTC: {
    address: "0x6e6CA598A06E609c913551B729a228B023f06fDB",
    decimals: 8,
    name: "Moonwell WBTC",
    symbol: "mWBTC"
  },
  USDT: {
    address: "0x94b008aA00579c1307B0EF2c499aD98a8ce58e58",
    decimals: 6,
    name: "Tether",
    symbol: "USDT"
  },
  MOONWELL_USDT: {
    address: "0xa3A53899EE8f9f6E963437C5B3f805FEc538BF84",
    decimals: 8,
    name: "Moonwell USDT",
    symbol: "mUSDT"
  },
  VELO: {
    address: "0x9560e827af36c94d2ac33a39bce1fe78631088db",
    decimals: 18,
    name: "Velodrome",
    symbol: "VELO"
  },
  MOONWELL_VELO: {
    address: "0x866b838b97Ee43F2c818B3cb5Cc77A0dc22003Fc",
    decimals: 8,
    name: "Moonwell VELO",
    symbol: "mVELO"
  },
  DAI: {
    address: "0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1",
    decimals: 18,
    name: "DAI",
    symbol: "DAI"
  },
  MOONWELL_DAI: {
    address: "0x3FE782C2Fe7668C2F1Eb313ACf3022a31feaD6B2",
    decimals: 8,
    name: "Moonwell DAI",
    symbol: "mDAI"
  },
  OP: {
    address: "0x4200000000000000000000000000000000000042",
    decimals: 18,
    name: "Optimism",
    symbol: "OP"
  },
  MOONWELL_OP: {
    address: "0x9fc345a20541Bf8773988515c5950eD69aF01847",
    decimals: 8,
    name: "Moonwell OP",
    symbol: "mOP"
  },
  wrsETH: {
    address: "0x87eEE96D50Fb761AD85B1c982d28A042169d61b1",
    decimals: 18,
    name: "KelpDAO Restaked Ethereum",
    symbol: "wrsETH"
  },
  MOONWELL_wrsETH: {
    address: "0x181bA797ccF779D8aB339721ED6ee827E758668e",
    decimals: 8,
    name: "Moonwell wrsETH",
    symbol: "mwrsETH"
  },
  WELL: {
    address: "0xA88594D404727625A9437C3f886C7643872296AE",
    decimals: 18,
    name: "WELL",
    symbol: "WELL"
  },
  stkWELL: {
    address: "0xfB26A4947A38cb53e2D083c6490060CCCE7438c5",
    decimals: 18,
    name: "stkWELL",
    symbol: "stkWELL"
  },
  mwUSDC: {
    address: "0x3520e1a10038131a3c00bf2158835a75e929642d",
    decimals: 18,
    name: "Moonwell Flagship USDC",
    symbol: "mwUSDC"
  },
  USDT0: {
    address: "0x01bFF41798a0BcF287b996046Ca68b395DbC1071",
    decimals: 6,
    name: "USDT0",
    symbol: "USDT0"
  },
  MOONWELL_USDT0: {
    address: "0xed37cD7872c6fe4020982d35104bE7919b8f8b33",
    decimals: 8,
    name: "Moonwell USDT0",
    symbol: "mUSDT0"
  }
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/optimism/contracts.js
var contracts5 = createContractsConfig({
  tokens: tokens4,
  contracts: {
    governanceToken: "WELL",
    stakingToken: "stkWELL",
    wrappedNativeToken: "WETH",
    comptroller: "0xCa889f40aae37FFf165BccF69aeF1E82b5C511B9",
    views: "0xD6C66868f937f00604d0FB860241970D6CC2CBfE",
    multiRewardDistributor: "0xF9524bfa18C19C3E605FbfE8DFd05C6e967574Aa",
    oracle: "0x2f1490bD6aD10C9CE42a2829afa13EAc0b746dcf",
    router: "0xc4Ab8C031717d7ecCCD653BE898e0f92410E11dC",
    temporalGovernor: "0x17C9ba3fDa7EC71CcfD75f978Ef31E21927aFF3d",
    voteCollector: "0x3C968481BE3ba1a99fed5f73dB2Ff51151037738",
    morphoBlue: "0xce95AfbB8EA029495c66020883F87aaE8864AF92",
    morphoBaseBundler: "0xFBCd3C258feB131D8E038F2A3a670A7bE0507C05",
    morphoBundler: "0x79481C87f24A3C4332442A2E9faaf675e5F141f0",
    morphoPublicAllocator: "0x0d68a97324E602E02799CD83B42D337207B40658",
    morphoViews: "0x90AA62DD4Fd10955A46f77176019d908849451F8"
  }
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/optimism/core-markets.js
var markets4 = createMarketConfig({
  tokens: tokens4,
  markets: {
    MOONWELL_USDC: {
      marketToken: "MOONWELL_USDC",
      underlyingToken: "USDC"
    },
    MOONWELL_ETH: {
      marketToken: "MOONWELL_ETH",
      underlyingToken: "ETH"
    },
    MOONWELL_cbETH: {
      marketToken: "MOONWELL_cbETH",
      underlyingToken: "cbETH"
    },
    MOONWELL_wstETH: {
      marketToken: "MOONWELL_wstETH",
      underlyingToken: "wstETH"
    },
    MOONWELL_rETH: {
      marketToken: "MOONWELL_rETH",
      underlyingToken: "rETH"
    },
    MOONWELL_weETH: {
      marketToken: "MOONWELL_weETH",
      underlyingToken: "weETH"
    },
    MOONWELL_WBTC: {
      marketToken: "MOONWELL_WBTC",
      underlyingToken: "WBTC"
    },
    MOONWELL_USDT: {
      marketToken: "MOONWELL_USDT",
      underlyingToken: "USDT"
    },
    MOONWELL_VELO: {
      marketToken: "MOONWELL_VELO",
      underlyingToken: "VELO"
    },
    MOONWELL_DAI: {
      marketToken: "MOONWELL_DAI",
      underlyingToken: "DAI"
    },
    MOONWELL_OP: {
      marketToken: "MOONWELL_OP",
      underlyingToken: "OP"
    },
    MOONWELL_wrsETH: {
      marketToken: "MOONWELL_wrsETH",
      underlyingToken: "wrsETH"
    },
    MOONWELL_USDT0: {
      marketToken: "MOONWELL_USDT0",
      underlyingToken: "USDT0"
    }
  }
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/optimism/custom.js
var custom5 = createCustomConfig({
  morpho: {
    minimalDeployment: true,
    subgraphUrl: "https://api.goldsky.com/api/public/project_cm7wv7gztiq1e01vv7uco1h1y/subgraphs/moonwell-morpho-blue-optimism/production/gn"
  },
  governance: {
    token: "WELL",
    chainIds: []
  },
  multiRewarder: [{ rewardToken: "WELL" }, { rewardToken: "OP" }]
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/optimism/morpho-markets.js
var morphoMarkets2 = createMorphoMarketConfig({
  tokens: tokens4,
  markets: {
    "ETH-USDC": {
      collateralToken: "ETH",
      loanToken: "USDC",
      id: "0x173b66359f0741b1c7f1963075cd271c739b6dc73b658e108a54ce6febeb279b"
    },
    "wstETH-USDC": {
      collateralToken: "wstETH",
      loanToken: "USDC",
      id: "0xc7ae57c1998c67a4c21804df606db1309b68a518ba5acc8b1dc3ffcb1b26b071"
    }
  }
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/optimism/morpho-vaults.js
var vaults2 = createVaultConfig({
  tokens: tokens4,
  vaults: {
    mwUSDC: {
      underlyingToken: "USDC",
      vaultToken: "mwUSDC",
      multiReward: "0x2EED2b7d44E2cF64a41B6b3f78bE2Fdc56223d2B",
      campaignId: "0x3c5d019808525f25ae0edc7cfe5fdbce6896625281e47ee9a39cbaa6a5c2a1e1"
    }
  }
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/optimism/environment.js
var optimism2 = defineChain({ ...optimism, testnet: false });
var createEnvironment4 = (rpcUrls, indexerUrl, governanceIndexerUrl) => createEnvironmentConfig({
  key: "optimism",
  name: "OP Mainnet",
  chain: {
    ...optimism2,
    rpcUrls: {
      default: { http: rpcUrls || optimism2.rpcUrls.default.http }
    }
  },
  transport: rpcUrls ? fallback(rpcUrls.map((url) => http(url))) : http(optimism2.rpcUrls.default.http[0]),
  indexerUrl: indexerUrl || "https://ponder.moonwell.fi",
  governanceIndexerUrl: governanceIndexerUrl || "https://ponder.moonwell.fi",
  tokens: tokens4,
  markets: markets4,
  vaults: vaults2,
  morphoMarkets: morphoMarkets2,
  contracts: contracts5,
  custom: custom5
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/ethereum/tokens.js
var tokens5 = createTokenConfig({
  ETH: {
    address: zeroAddress,
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  USDC: {
    address: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
    decimals: 6,
    name: "USD Coin",
    symbol: "USDC"
  }
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/ethereum/environment.js
var createEnvironment5 = (rpcUrls, indexerUrl, governanceIndexerUrl) => createEnvironmentConfig({
  key: "ethereum",
  name: "Ethereum",
  chain: {
    ...mainnet,
    rpcUrls: {
      default: { http: rpcUrls || mainnet.rpcUrls.default.http }
    }
  },
  transport: rpcUrls ? fallback(rpcUrls.map((url) => http(url))) : http(mainnet.rpcUrls.default.http[0]),
  indexerUrl: indexerUrl || "https://ponder.moonwell.fi",
  governanceIndexerUrl: governanceIndexerUrl || "https://ponder.moonwell.fi",
  tokens: tokens5,
  markets: {},
  vaults: {},
  morphoMarkets: {},
  contracts: {},
  custom: {}
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/avalanche/tokens.js
var tokens6 = createTokenConfig({
  AVAX: {
    address: zeroAddress,
    decimals: avalanche.nativeCurrency.decimals,
    name: avalanche.nativeCurrency.name,
    symbol: avalanche.nativeCurrency.symbol
  },
  USDC: {
    address: "0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",
    decimals: 6,
    name: "USD Coin",
    symbol: "USDC"
  }
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/avalanche/environment.js
var createEnvironment6 = (rpcUrls, indexerUrl, governanceIndexerUrl) => createEnvironmentConfig({
  key: "avalanche",
  name: "Avalanche",
  chain: {
    ...avalanche,
    rpcUrls: {
      default: { http: rpcUrls || avalanche.rpcUrls.default.http }
    }
  },
  transport: rpcUrls ? fallback(rpcUrls.map((url) => http(url))) : http(avalanche.rpcUrls.default.http[0]),
  indexerUrl: indexerUrl || "https://ponder.moonwell.fi",
  governanceIndexerUrl: governanceIndexerUrl || "https://ponder.moonwell.fi",
  tokens: tokens6,
  markets: {},
  vaults: {},
  morphoMarkets: {},
  contracts: {},
  custom: {}
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/arbitrum/tokens.js
var tokens7 = createTokenConfig({
  ETH: {
    address: zeroAddress,
    decimals: arbitrum.nativeCurrency.decimals,
    name: arbitrum.nativeCurrency.name,
    symbol: arbitrum.nativeCurrency.symbol
  },
  USDC: {
    address: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
    decimals: 6,
    name: "USD Coin",
    symbol: "USDC"
  }
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/arbitrum/environment.js
var createEnvironment7 = (rpcUrls, indexerUrl, governanceIndexerUrl) => createEnvironmentConfig({
  key: "arbitrum",
  name: "Arbitrum",
  chain: {
    ...arbitrum,
    rpcUrls: {
      default: { http: rpcUrls || arbitrum.rpcUrls.default.http }
    }
  },
  transport: rpcUrls ? fallback(rpcUrls.map((url) => http(url))) : http(arbitrum.rpcUrls.default.http[0]),
  indexerUrl: indexerUrl || "https://ponder.moonwell.fi",
  governanceIndexerUrl: governanceIndexerUrl || "https://ponder.moonwell.fi",
  tokens: tokens7,
  markets: {},
  vaults: {},
  morphoMarkets: {},
  contracts: {},
  custom: {}
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/polygon/tokens.js
var tokens8 = createTokenConfig({
  [polygon.nativeCurrency.symbol]: {
    address: zeroAddress,
    decimals: polygon.nativeCurrency.decimals,
    name: polygon.nativeCurrency.name,
    symbol: polygon.nativeCurrency.symbol
  },
  USDC: {
    address: "0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359",
    decimals: 6,
    name: "USD Coin",
    symbol: "USDC"
  }
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/definitions/polygon/environment.js
var createEnvironment8 = (rpcUrls, indexerUrl, governanceIndexerUrl) => createEnvironmentConfig({
  key: "polygon",
  name: "Polygon",
  chain: {
    ...polygon,
    rpcUrls: {
      default: { http: rpcUrls || polygon.rpcUrls.default.http }
    }
  },
  transport: rpcUrls ? fallback(rpcUrls.map((url) => http(url))) : http(polygon.rpcUrls.default.http[0]),
  indexerUrl: indexerUrl || "https://ponder.moonwell.fi",
  governanceIndexerUrl: governanceIndexerUrl || "https://ponder.moonwell.fi",
  tokens: tokens8,
  markets: {},
  vaults: {},
  morphoMarkets: {},
  contracts: {},
  custom: {}
});

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/index.js
var supportedChainsIds = {
  [base2.id]: "base",
  [optimism.id]: "optimism",
  [moonriver.id]: "moonriver",
  [moonbeam.id]: "moonbeam",
  [mainnet.id]: "ethereum",
  [avalanche.id]: "avalanche",
  [arbitrum.id]: "arbitrum",
  [polygon.id]: "polygon"
};
var supportedChains = {
  base: base2,
  optimism,
  moonriver,
  moonbeam,
  ethereum: mainnet,
  avalanche,
  arbitrum,
  polygon
};
var createEnvironment9 = (config) => {
  switch (config.chain.id) {
    case base2.id:
      return createEnvironment(config.rpcUrls, config.indexerUrl);
    case moonbeam.id:
      return createEnvironment2(config.rpcUrls, config.indexerUrl);
    case moonriver.id:
      return createEnvironment3(config.rpcUrls, config.indexerUrl);
    case optimism.id:
      return createEnvironment4(config.rpcUrls, config.indexerUrl);
    case mainnet.id:
      return createEnvironment5(config.rpcUrls, config.indexerUrl);
    case avalanche.id:
      return createEnvironment6(config.rpcUrls, config.indexerUrl);
    case arbitrum.id:
      return createEnvironment7(config.rpcUrls, config.indexerUrl);
    case polygon.id:
      return createEnvironment8(config.rpcUrls, config.indexerUrl);
    default:
      throw new Error("Unsupported chainId");
  }
};
var publicEnvironments = {
  base: createEnvironment(),
  moonbeam: createEnvironment2(),
  moonriver: createEnvironment3(),
  optimism: createEnvironment4(),
  ethereum: createEnvironment5(),
  avalanche: createEnvironment6(),
  arbitrum: createEnvironment7(),
  polygon: createEnvironment8()
};

// node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var { iterator, toStringTag } = Symbol;
var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(toStringTag in val) && !(iterator in val);
};
var isEmptyObject = (val) => {
  if (!isObject(val) || isBuffer(val)) {
    return false;
  }
  try {
    return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
  } catch (e) {
    return false;
  }
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
var trim2 = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    if (isBuffer(obj)) {
      return;
    }
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  if (isBuffer(obj)) {
    return null;
  }
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless, skipUndefined } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else if (!skipUndefined || !isUndefined(val)) {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];
  const _iterator = generator.call(obj);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define2 = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (isBuffer(source)) {
        return source;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
var isIterable = (thing) => thing != null && isFunction(thing[iterator]);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isEmptyObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim: trim2,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  const msg = error && error.message ? error.message : "Error";
  const errCode = code == null && error ? error.code : code;
  AxiosError.call(axiosError, msg, errCode, config, request, response);
  if (error && axiosError.cause == null) {
    Object.defineProperty(axiosError, "cause", { value: error, configurable: true });
  }
  axiosError.name = error && error.name || "Error";
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/helpers/null.js
var null_default = null;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (utils_default.isBoolean(value)) {
      return value.toString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build2(value, path) {
    if (utils_default.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build2(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build2(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  if (utils_default.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// node_modules/axios/lib/platform/browser/index.js
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  navigator: () => _navigator,
  origin: () => origin
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator = typeof navigator === "object" && navigator || void 0;
var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";

// node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports,
  ...browser_default
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), {
    visitor: function(value, key, path, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    },
    ...options
  });
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data, this.parseReviver);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens9 = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens9[match[1]] = match[2];
  }
  return tokens9;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value)) return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else if (utils_default.isObject(header) && utils_default.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils_default.isArray(entry)) {
          throw TypeError("Object iterator must return a key-value pair");
        }
        obj[key = entry[0]] = (dest = obj[key]) ? utils_default.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first7, ...targets) {
    const computed = new this(first7);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/helpers/throttle.js
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn(...args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
var throttle_default = throttle;

// node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
var progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
var asyncDecorator = (fn) => (...args) => utils_default.asap(() => fn(...args));

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
  url = new URL(url, platform_default.origin);
  return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
})(
  new URL(platform_default.origin),
  platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)
) : () => true;

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default.isString(path) && cookie.push("path=" + path);
      utils_default.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, prop, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, prop, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, prop, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
  };
  utils_default.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  if (utils_default.isFormData(data)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if (utils_default.isFunction(data.getHeaders)) {
      const formHeaders = data.getHeaders();
      const allowedHeaders = ["content-type", "content-length"];
      Object.entries(formHeaders).forEach(([key, val]) => {
        if (allowedHeaders.includes(key.toLowerCase())) {
          headers.set(key, val);
        }
      });
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};

// node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig_default(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError(event) {
      const msg = event && event.message ? event.message : "Network Error";
      const err = new AxiosError_default(msg, AxiosError_default.ERR_NETWORK, config, request);
      err.event = event || null;
      reject(err);
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitional_default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// node_modules/axios/lib/helpers/composeSignals.js
var composeSignals = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils_default.asap(unsubscribe);
    return signal;
  }
};
var composeSignals_default = composeSignals;

// node_modules/axios/lib/helpers/trackStream.js
var streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end2;
  while (pos < len) {
    end2 = pos + chunkSize;
    yield chunk.slice(pos, end2);
    pos = end2;
  }
};
var readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
var readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
var trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator2 = readBytes(stream, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator2.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator2.return();
    }
  }, {
    highWaterMark: 2
  });
};

// node_modules/axios/lib/adapters/fetch.js
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var { isFunction: isFunction2 } = utils_default;
var globalFetchAPI = (({ Request, Response }) => ({
  Request,
  Response
}))(utils_default.global);
var {
  ReadableStream: ReadableStream2,
  TextEncoder
} = utils_default.global;
var test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false;
  }
};
var factory = (env) => {
  env = utils_default.merge.call({
    skipUndefined: true
  }, globalFetchAPI, env);
  const { fetch: envFetch, Request, Response } = env;
  const isFetchSupported = envFetch ? isFunction2(envFetch) : typeof fetch === "function";
  const isRequestSupported = isFunction2(Request);
  const isResponseSupported = isFunction2(Response);
  if (!isFetchSupported) {
    return false;
  }
  const isReadableStreamSupported = isFetchSupported && isFunction2(ReadableStream2);
  const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Request(str).arrayBuffer()));
  const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
    let duplexAccessed = false;
    const hasContentType = new Request(platform_default.origin, {
      body: new ReadableStream2(),
      method: "POST",
      get duplex() {
        duplexAccessed = true;
        return "half";
      }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
  });
  const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response("").body));
  const resolvers = {
    stream: supportsResponseStream && ((res) => res.body)
  };
  isFetchSupported && (() => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
      !resolvers[type] && (resolvers[type] = (res, config) => {
        let method = res && res[type];
        if (method) {
          return method.call(res);
        }
        throw new AxiosError_default(`Response type '${type}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config);
      });
    });
  })();
  const getBodyLength = async (body) => {
    if (body == null) {
      return 0;
    }
    if (utils_default.isBlob(body)) {
      return body.size;
    }
    if (utils_default.isSpecCompliantForm(body)) {
      const _request = new Request(platform_default.origin, {
        method: "POST",
        body
      });
      return (await _request.arrayBuffer()).byteLength;
    }
    if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
      return body.byteLength;
    }
    if (utils_default.isURLSearchParams(body)) {
      body = body + "";
    }
    if (utils_default.isString(body)) {
      return (await encodeText(body)).byteLength;
    }
  };
  const resolveBodyLength = async (headers, body) => {
    const length = utils_default.toFiniteNumber(headers.getContentLength());
    return length == null ? getBodyLength(body) : length;
  };
  return async (config) => {
    let {
      url,
      method,
      data,
      signal,
      cancelToken,
      timeout,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = "same-origin",
      fetchOptions
    } = resolveConfig_default(config);
    let _fetch = envFetch || fetch;
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
    let request = null;
    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
    });
    let requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
        let _request = new Request(url, {
          method: "POST",
          body: data,
          duplex: "half"
        });
        let contentTypeHeader;
        if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
          headers.setContentType(contentTypeHeader);
        }
        if (_request.body) {
          const [onProgress, flush] = progressEventDecorator(
            requestContentLength,
            progressEventReducer(asyncDecorator(onUploadProgress))
          );
          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
        }
      }
      if (!utils_default.isString(withCredentials)) {
        withCredentials = withCredentials ? "include" : "omit";
      }
      const isCredentialsSupported = isRequestSupported && "credentials" in Request.prototype;
      const resolvedOptions = {
        ...fetchOptions,
        signal: composedSignal,
        method: method.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data,
        duplex: "half",
        credentials: isCredentialsSupported ? withCredentials : void 0
      };
      request = isRequestSupported && new Request(url, resolvedOptions);
      let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions));
      const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
      if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
        const options = {};
        ["status", "statusText", "headers"].forEach((prop) => {
          options[prop] = response[prop];
        });
        const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
          responseContentLength,
          progressEventReducer(asyncDecorator(onDownloadProgress), true)
        ) || [];
        response = new Response(
          trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
            flush && flush();
            unsubscribe && unsubscribe();
          }),
          options
        );
      }
      responseType = responseType || "text";
      let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config);
      !isStreamResponse && unsubscribe && unsubscribe();
      return await new Promise((resolve, reject) => {
        settle(resolve, reject, {
          data: responseData,
          headers: AxiosHeaders_default.from(response.headers),
          status: response.status,
          statusText: response.statusText,
          config,
          request
        });
      });
    } catch (err) {
      unsubscribe && unsubscribe();
      if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
        throw Object.assign(
          new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request),
          {
            cause: err.cause || err
          }
        );
      }
      throw AxiosError_default.from(err, err && err.code, config, request);
    }
  };
};
var seedCache = /* @__PURE__ */ new Map();
var getFetch = (config) => {
  let env = config ? config.env : {};
  const { fetch: fetch2, Request, Response } = env;
  const seeds = [
    Request,
    Response,
    fetch2
  ];
  let len = seeds.length, i = len, seed, target, map = seedCache;
  while (i--) {
    seed = seeds[i];
    target = map.get(seed);
    target === void 0 && map.set(seed, target = i ? /* @__PURE__ */ new Map() : factory(env));
    map = target;
  }
  return target;
};
var adapter = getFetch();

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default,
  fetch: {
    get: getFetch
  }
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter2) => utils_default.isFunction(adapter2) || adapter2 === null || adapter2 === false;
var adapters_default = {
  getAdapter: (adapters, config) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter2;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;
      adapter2 = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter2 = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter2 === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter2 && (utils_default.isFunction(adapter2) || (adapter2 = adapter2.get(config)))) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter2;
    }
    if (!adapter2) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter2;
  },
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter2 = adapters_default.getAdapter(config.adapter || defaults_default.adapter, config);
  return adapter2(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/env/data.js
var VERSION = "1.12.2";

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
validators.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    if (config.allowAbsoluteUrls !== void 0) {
    } else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }
    validator_default.assertOptions(config, {
      baseUrl: validators2.spelling("baseURL"),
      withXsrfToken: validators2.spelling("withXSRFToken")
    }, true);
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift(...requestInterceptorChain);
      chain.push(...responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new _CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// node_modules/@moonwell-fi/moonwell-sdk/_esm/common/index.js
var import_dayjs = __toESM(require_dayjs_min(), 1);

// node_modules/@moonwell-fi/moonwell-sdk/_esm/common/amount.js
var Amount = class {
  /**
   * Creates an instance of Amount.
   * This class is helpful with exponential values by creating the amount representation as number and as a bigint, converted using a base.
   * @param value - The value of the amount.
   * @param base - The exponential base of the amount.
   * @returns new Amount class with the value as a number, the exponential number as a bigint and the base used in the conversion
   */
  constructor(value, base3) {
    Object.defineProperty(this, "_className", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Amount"
    });
    Object.defineProperty(this, "value", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "exponential", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0n
    });
    Object.defineProperty(this, "base", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
    this.base = base3;
    if (typeof value === "bigint") {
      this.exponential = value;
      this.value = Number(value) / Number(10n ** BigInt(this.base));
    } else {
      this.value = value;
      this.exponential = BigInt(Math.floor(value * 10 ** this.base));
    }
  }
  toString() {
    return this.value.toFixed(this.base);
  }
  toBigString() {
    return this.exponential.toString();
  }
};

// node_modules/@moonwell-fi/moonwell-sdk/_esm/common/error.js
var BaseError2 = class _BaseError extends Error {
  constructor(message) {
    super(message);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseError"
    });
    Object.defineProperty(this, "meta", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.setPrototypeOf(this, _BaseError.prototype);
  }
};
var HttpRequestError = class _HttpRequestError extends BaseError2 {
  constructor(message) {
    super(message);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "HttpRequestError"
    });
    Object.setPrototypeOf(this, _HttpRequestError.prototype);
  }
};

// node_modules/@moonwell-fi/moonwell-sdk/_esm/common/index.js
var SECONDS_PER_DAY = 86400;
var DAYS_PER_YEAR = 365;
var perDay = (value) => value * SECONDS_PER_DAY;
function isStartOfDay(timestamp) {
  const startOfDay = import_dayjs.default.utc(timestamp * 1e3).startOf("day").unix();
  return startOfDay === timestamp;
}
var calculateApy = (value) => ((value * SECONDS_PER_DAY + 1) ** DAYS_PER_YEAR - 1) * 100;
var getEnvironmentFromArgs = (client, args) => {
  if (args) {
    const { chainId, network } = args;
    if (chainId) {
      return Object.values(client.environments).find((env) => env.chainId === chainId);
    }
    if (network) {
      return client.environments[network];
    }
  }
  return void 0;
};
var getEnvironmentsFromArgs = (client, args, onlyWithDeployment) => {
  const onlyEnvironmentsWithDeployment = onlyWithDeployment !== void 0 ? onlyWithDeployment : true;
  if (args) {
    const { chainId, network } = args;
    if (chainId) {
      return [
        Object.values(client.environments).find((env) => env.chainId === chainId)
      ];
    }
    if (network) {
      return [client.environments[network]];
    }
  }
  return Object.values(client.environments).filter((r) => onlyEnvironmentsWithDeployment ? r.contracts.views !== void 0 : true);
};

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/beam/getBeamTokenRoutes.js
async function getBeamTokenRoutes(client) {
  const environments = getEnvironmentsFromArgs(client, void 0, false);
  const acrossRoutesResponse = await axios_default.get("https://across.to/api/available-routes");
  const biconomyInfoResponse = await axios_default.get("https://network.biconomy.io/v1/info");
  const moonwellSupportedTokens = environments.flatMap((env) => {
    const tokens10 = Object.values(env.config.tokens).map((token) => {
      return {
        ...token,
        chainId: env.chainId
      };
    });
    return tokens10;
  }).filter((r) => r.symbol.toLowerCase() !== "usdbc" && r.symbol.toLowerCase() !== "weth");
  const biconomyChains = biconomyInfoResponse.data.supportedChains.filter((supportedChain) => supportedChain.healthCheck.status === "healthy").map((chain) => {
    return {
      ...chain,
      chainId: Number.parseInt(chain.chainId)
    };
  });
  const supportedRoutes = acrossRoutesResponse.data.filter((route) => {
    const originChainSupported = biconomyChains.find((chain) => chain.chainId === route.originChainId);
    const destinationChainSupported = biconomyChains.find((chain) => chain.chainId === route.destinationChainId);
    const originTokenSupported = moonwellSupportedTokens.find((moonwellToken) => moonwellToken.chainId === route.originChainId && (route.isNative ? moonwellToken.address.toLowerCase() === zeroAddress && route.originTokenSymbol.toLowerCase() === moonwellToken.symbol.toLowerCase() : moonwellToken.address.toLowerCase() === route.originToken.toLowerCase()));
    const destinationTokenSupported = moonwellSupportedTokens.find((moonwellToken) => moonwellToken.chainId === route.destinationChainId && (route.isNative ? moonwellToken.address.toLowerCase() === zeroAddress && route.destinationTokenSymbol.toLowerCase() === moonwellToken.symbol.toLowerCase() : moonwellToken.address.toLowerCase() === route.destinationToken.toLowerCase()));
    return originTokenSupported && destinationTokenSupported && originChainSupported && destinationChainSupported;
  });
  const tokens9 = supportedRoutes.map((supportedRoute) => {
    const destinationRoutes = supportedRoutes.filter((route) => route.originChainId === supportedRoute.originChainId && route.originToken.toLowerCase() === supportedRoute.originToken.toLowerCase());
    const originTokenInfo = moonwellSupportedTokens.find((moonwellToken) => (supportedRoute.isNative ? moonwellToken.address.toLowerCase() === zeroAddress && supportedRoute.originTokenSymbol.toLowerCase() === moonwellToken.symbol.toLowerCase() : moonwellToken.address.toLowerCase() === supportedRoute.originToken.toLowerCase()) && moonwellToken.chainId === supportedRoute.originChainId);
    const originChainInfo = biconomyChains.find((chain) => chain.chainId === supportedRoute.originChainId);
    const originChainGasInfo = biconomyInfoResponse.data.supportedGasTokens.find((gas) => gas.chainId === supportedRoute.originChainId)?.paymentTokens.find((gas) => gas.address.toLowerCase() === supportedRoute.originToken.toLowerCase());
    if (destinationRoutes.length > 0 && originTokenInfo && originChainInfo) {
      const routesMap = destinationRoutes.map((destinationRoute) => {
        const destinationTokenInfo = moonwellSupportedTokens.find((moonwellToken) => (destinationRoute.isNative ? moonwellToken.address.toLowerCase() === zeroAddress && destinationRoute.destinationTokenSymbol.toLowerCase() === moonwellToken.symbol.toLowerCase() : moonwellToken.address.toLowerCase() === destinationRoute.destinationToken.toLowerCase()) && moonwellToken.chainId === destinationRoute.destinationChainId);
        const destinationChainInfo = biconomyChains.find((chain) => chain.chainId === destinationRoute.destinationChainId);
        const destinationChainGasInfo = biconomyInfoResponse.data.supportedGasTokens.find((gas) => gas.chainId === destinationRoute.destinationChainId)?.paymentTokens.find((gas) => gas.address.toLowerCase() === destinationRoute.destinationToken.toLowerCase());
        if (destinationChainInfo && destinationTokenInfo) {
          return {
            chainId: destinationChainInfo.chainId,
            address: destinationTokenInfo.address,
            routeTokenAddress: destinationRoute.destinationToken,
            name: destinationTokenInfo.name,
            symbol: destinationTokenInfo.symbol,
            decimals: destinationTokenInfo.decimals,
            isNative: destinationTokenInfo.address === zeroAddress,
            permitEnabled: destinationChainGasInfo?.permitEnabled === true || false
          };
        }
        return void 0;
      });
      const routes = routesMap.filter((route) => route !== void 0);
      const result2 = {
        chainId: supportedRoute.originChainId,
        address: originTokenInfo.address,
        routeTokenAddress: supportedRoute.originToken,
        name: originTokenInfo.name,
        symbol: originTokenInfo.symbol,
        decimals: originTokenInfo.decimals,
        isNative: originTokenInfo.address === zeroAddress,
        permitEnabled: originChainGasInfo?.permitEnabled === true || false,
        routes: dedup(routes)
      };
      return result2;
    } else {
      return void 0;
    }
  });
  const result = tokens9.filter((t) => t !== void 0);
  return dedup(result);
}
function dedup(array) {
  return array.reduce((agg, current) => {
    const x = agg.find((item) => item.chainId === current.chainId && item.routeTokenAddress === current.routeTokenAddress && item.symbol === current.symbol);
    if (!x) {
      return agg.concat([current]);
    } else {
      return agg;
    }
  }, []);
}

// node_modules/@across-protocol/app-sdk/dist/errors/index.js
var HttpError = class extends Error {
  url;
  status;
  constructor(params, opts) {
    super(params.message, opts);
    this.name = params.name ?? "HttpError";
    this.url = params.url;
    this.status = params.status;
  }
};
var AcrossApiError = class extends HttpError {
  constructor(params, opts) {
    super({
      ...params,
      name: params.name ?? "AcrossApiError"
    }, opts);
  }
};
var AcrossApiSimulationError = class extends AcrossApiError {
  transaction;
  constructor(params, opts) {
    super({
      ...params,
      name: "AcrossApiSimulationError",
      status: 400,
      code: "SIMULATION_ERROR"
    }, opts);
    this.transaction = params.transaction;
  }
};
var SimulationError = class extends Error {
  simulationId;
  simulationUrl;
  constructor(params, opts) {
    super(params.message, opts);
    this.name = "SimulationError";
    this.simulationId = params.simulationId;
    this.simulationUrl = params.simulationUrl;
  }
};
var IndexerError = class extends Error {
  url;
  constructor(url, message, error) {
    super(message);
    this.name = error ?? "Indexer Error";
    this.url = url;
  }
};
var ConfigError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "Config Error";
  }
};
var NoDepositLogError = class extends Error {
  constructor(txHash, chainId) {
    super(`Unable to parse depositV3 log for tx ${txHash} on chain ${chainId}`);
    this.name = "Deposit Log Not Found";
  }
};
var NoFillLogError = class extends Error {
  constructor(depositId, chainId, depositTxHash) {
    super(`Unable to find fill log on chain ${chainId} for deposit id #${depositId.toString()} ${depositTxHash ? `with depositTxHash ${depositTxHash}` : "."}`);
    this.name = "Fill Log Not Found";
  }
};

// node_modules/@across-protocol/app-sdk/dist/utils/fetch.js
function buildSearchParams(params) {
  const searchParams = new URLSearchParams();
  for (const key in params) {
    const value = params[key];
    if (!isDefined(value)) {
      continue;
    }
    if (Array.isArray(value)) {
      value.forEach((val) => searchParams.append(key, String(val)));
    } else {
      searchParams.append(key, String(value));
    }
  }
  return searchParams.toString();
}
function isOk(res) {
  if (res.status >= 200 && res.status < 300 || res.status === 304) {
    return true;
  }
  return false;
}
function isDefined(value) {
  return value !== void 0 && value !== null ? true : false;
}
function makeFetcher(name, apiErrorHandler) {
  return async (apiUrl, params, logger) => {
    const searchParams = buildSearchParams(params);
    const url = `${apiUrl}?${searchParams}`;
    logger?.debug(`Fetching ${name}...`, url);
    const res = await fetch(url);
    let data;
    try {
      data = await res.json();
    } catch (e) {
      data = await res.text();
    }
    if (isOk(res)) {
      logger?.debug("OK response", data);
      return data;
    }
    logger?.debug("Error response", {
      status: res.status
    });
    if (apiErrorHandler) {
      apiErrorHandler(res, data, url);
    }
    throw new HttpError({
      status: res.status,
      message: typeof data === "string" ? data : JSON.stringify(data),
      url
    });
  };
}
var fetchAcrossApi = makeFetcher("Across API", (res, data, url) => {
  if (typeof data === "object" && data !== null && "type" in data && data.type === "AcrossApiError") {
    const acrossApiError = data;
    if (acrossApiError.code === "SIMULATION_ERROR") {
      throw new AcrossApiSimulationError({
        message: acrossApiError.message,
        url,
        transaction: acrossApiError.transaction
      });
    }
    throw new AcrossApiError({
      status: res.status,
      message: acrossApiError.message,
      url,
      code: acrossApiError.code
    });
  }
});
var fetchIndexerApi = makeFetcher("Indexer API", (res, data, url) => {
  if (typeof data === "object" && data !== null && "error" in data) {
    throw new IndexerError(url, data?.message, data?.error);
  }
});

// node_modules/@across-protocol/app-sdk/dist/utils/logger.js
var LogLevels = {
  DEBUG: 3,
  INFO: 2,
  WARN: 1,
  ERROR: 0
};
var DefaultLogger = class {
  logLevel;
  secondaryLabel = "@across-protocol/app-sdk";
  logPrefix = ">";
  constructor(logLevel) {
    this.logLevel = logLevel;
  }
  createLogLevelLabel = (logLevel) => {
    const label = `${setColor(colorMap[logLevel].primary)} ${logLevel} ${resetControl}${setColor(colorMap[logLevel].secondary)} ${this.secondaryLabel}${resetControl}`;
    const prefix = `${setColor(colorMap[logLevel].secondary)}${this.logPrefix}${resetControl}`;
    return {
      label,
      prefix
    };
  };
  /**
   * Description - creates an indentation group for each call to `logger.[logLevel]()`
   */
  log(logLevel, ...data) {
    const { label, prefix } = this.createLogLevelLabel(logLevel);
    console.log(`${label}
`);
    data.forEach((item) => {
      console.log(prefix, item, "\n");
    });
  }
  debug(...data) {
    if (LogLevels["DEBUG"] <= LogLevels[this.logLevel]) {
      this.log("DEBUG", ...data);
    }
  }
  info(...data) {
    if (LogLevels["INFO"] <= LogLevels[this.logLevel]) {
      this.log("INFO", ...data);
    }
  }
  warn(...data) {
    if (LogLevels["WARN"] <= LogLevels[this.logLevel]) {
      this.log("WARN", ...data);
    }
  }
  error(...data) {
    if (LogLevels["ERROR"] <= LogLevels[this.logLevel]) {
      this.log("ERROR", ...data);
    }
  }
};
var COLORS = {
  Black: 30,
  Red: 31,
  Green: 32,
  Yellow: 33,
  Blue: 34,
  Magenta: 35,
  Cyan: 36,
  White: 37,
  BgBlack: 40,
  BgRed: 41,
  BgGreen: 42,
  BgYellow: 43,
  BgBlue: 44,
  BgMagenta: 45,
  BgCyan: 46,
  BgWhite: 47
};
var resetControl = "\x1B[0m";
var setColor = (color) => `\x1B[${color}m`;
var colorMap = {
  DEBUG: {
    primary: COLORS.BgBlue,
    secondary: COLORS.Blue
  },
  INFO: {
    primary: COLORS.BgCyan,
    secondary: COLORS.Cyan
  },
  WARN: {
    primary: COLORS.BgYellow,
    secondary: COLORS.Yellow
  },
  ERROR: {
    primary: COLORS.BgRed,
    secondary: COLORS.Red
  }
};

// node_modules/@across-protocol/app-sdk/dist/utils/multicallHandler.js
function getMultiCallHandlerAddress(chainId) {
  const defaultAddress = "0x924a9f036260DdD5808007E1AA95f08eD08aA569";
  switch (chainId) {
    case 324:
      return "0x863859ef502F0Ee9676626ED5B418037252eFeb2";
    case 59144:
      return "0x1015c58894961F4F7Dd7D68ba033e28Ed3ee1cDB";
    default:
      return defaultAddress;
  }
}
function buildMulticallHandlerMessage(params) {
  const instructionsAbiParams = parseAbiParameters("((address target, bytes callData, uint256 value)[], address fallbackRecipient)");
  return encodeAbiParameters(instructionsAbiParams, [
    [
      params.actions.map(({ target, callData, value }) => ({
        target,
        callData,
        value: BigInt(value)
      })),
      params.fallbackRecipient
    ]
  ]);
}
var MulticallHandlerAbi = [
  {
    inputs: [
      { internalType: "uint256", name: "index", type: "uint256" },
      {
        components: [
          { internalType: "address", name: "target", type: "address" },
          { internalType: "bytes", name: "callData", type: "bytes" },
          { internalType: "uint256", name: "value", type: "uint256" }
        ],
        internalType: "struct MulticallHandler.Call[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "CallReverted",
    type: "error"
  },
  {
    inputs: [
      { internalType: "uint256", name: "index", type: "uint256" },
      {
        components: [
          { internalType: "address", name: "target", type: "address" },
          { internalType: "bytes", name: "callData", type: "bytes" },
          { internalType: "uint256", name: "value", type: "uint256" }
        ],
        internalType: "struct MulticallHandler.Call[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "InvalidCall",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        components: [
          { internalType: "address", name: "target", type: "address" },
          { internalType: "bytes", name: "callData", type: "bytes" },
          { internalType: "uint256", name: "value", type: "uint256" }
        ],
        indexed: false,
        internalType: "struct MulticallHandler.Call[]",
        name: "calls",
        type: "tuple[]"
      },
      {
        indexed: true,
        internalType: "address",
        name: "fallbackRecipient",
        type: "address"
      }
    ],
    name: "CallsFailed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "DrainedTokens",
    type: "event"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "target", type: "address" },
          { internalType: "bytes", name: "callData", type: "bytes" },
          { internalType: "uint256", name: "value", type: "uint256" }
        ],
        internalType: "struct MulticallHandler.Call[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "attemptCalls",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "address payable", name: "destination", type: "address" }
    ],
    name: "drainLeftoverTokens",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "address", name: "", type: "address" },
      { internalType: "bytes", name: "message", type: "bytes" }
    ],
    name: "handleV3AcrossMessage",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
];

// node_modules/@across-protocol/app-sdk/dist/utils/hex.js
var DOMAIN_CALLDATA_DELIMITER = "0x1dc0de";
function getIntegratorDataSuffix(integratorId) {
  assertValidIntegratorId(integratorId);
  return concat([DOMAIN_CALLDATA_DELIMITER, integratorId]);
}
function isValidIntegratorId(integratorId) {
  return isHex(integratorId) && // "0x" + 2 bytes = 6 hex characters
  integratorId.length === 6;
}
function assertValidIntegratorId(integratorId) {
  if (!isValidIntegratorId(integratorId)) {
    throw new Error(`Invalid integrator ID: ${integratorId}. Needs to be 2 bytes hex string.`);
  }
  return true;
}
function addressToBytes32(address) {
  if (!isHex(address)) {
    throw new Error("Invalid hex input");
  }
  if (address.length === 66) {
    return address;
  }
  if (!isAddress(address)) {
    throw new Error("Invalid Address, cannot convert to bytes32");
  }
  const padded = padHex(address, { dir: "left", size: 32 });
  return padded;
}
function bytes32ToAddress(hex) {
  if (!isHex(hex)) {
    throw new Error("Invalid hex input");
  }
  if (hex.length === 42) {
    return hex;
  }
  const padding = hex.slice(2, 26);
  const isPadded = /^0{24}$/.test(padding);
  if (isPadded) {
    const addressHex = `0x${hex.slice(-40)}`;
    if (!isAddress(addressHex)) {
      throw new Error("Invalid address extracted from bytes32");
    }
    return addressHex;
  }
  return hex;
}
var ZERO_BYTES_32 = "0x0000000000000000000000000000000000000000000000000000000000000000";
function hasMessage(message) {
  return message !== "" && message !== "0x" && message !== ZERO_BYTES_32;
}

// node_modules/@across-protocol/app-sdk/dist/utils/configurePublicClients.js
function configurePublicClients(chains, pollingInterval, rpcUrls, transports) {
  return new Map(chains.map((chain) => {
    const rpcUrl = rpcUrls?.[chain.id];
    const customTransport = transports?.[chain.id];
    const transport = customTransport ?? (rpcUrl?.startsWith("ws") ? webSocket(rpcUrl) : http(rpcUrl));
    return [
      chain.id,
      createPublicClient({
        chain,
        pollingInterval,
        key: chain.id.toString(),
        transport,
        batch: {
          multicall: true
        }
      })
    ];
  }));
}

// node_modules/@across-protocol/app-sdk/dist/constants/index.js
var MAINNET_API_URL = "https://app.across.to/api";
var TESTNET_API_URL = "https://testnet.across.to/api";
var MAINNET_INDEXER_API = "https://indexer.api.across.to";
var TESTNET_INDEXER_API = "https://dev.indexer.api.across.to";

// node_modules/@across-protocol/app-sdk/dist/utils/getSupportedChains.js
async function getSupportedChains({ logger, apiUrl = MAINNET_API_URL, ...params }) {
  const data = await fetchAcrossApi(`${apiUrl}/chains`, params, logger);
  return data;
}

// node_modules/@across-protocol/app-sdk/dist/utils/tenderly.js
async function simulateTxOnTenderly(params) {
  const simUrl = `https://api.tenderly.co/api/v1/account/${params.accountSlug}/project/${params.projectSlug}/simulate`;
  const simRes = await fetch(simUrl, {
    method: "POST",
    headers: {
      "X-Access-Key": params.accessKey
    },
    body: JSON.stringify({
      network_id: params.networkId,
      from: params.from,
      to: params.to,
      input: params.data,
      gas: params.gas ? Number(params.gas) : void 0,
      block_number: params.blockNumber,
      save: true
    })
  });
  if (!isOk(simRes)) {
    throw new HttpError({
      status: simRes.status,
      url: simUrl,
      message: `Failed to simulate tx on Tenderly - ${simRes.status} ${simRes.statusText} - ${await simRes.text()}`
    });
  }
  const simData = await simRes.json();
  const simulationId = simData.simulation.id;
  if (params.enableShare) {
    const enableShareUrl = `https://api.tenderly.co/api/v1/account/${params.accountSlug}/project/${params.projectSlug}/simulations/${simulationId}/share`;
    const enableShareRes = await fetch(enableShareUrl, {
      method: "POST",
      headers: {
        "X-Access-Key": params.accessKey
      }
    });
    if (!isOk(enableShareRes)) {
      throw new HttpError({
        status: enableShareRes.status,
        url: enableShareUrl,
        message: `Failed to enable sharing Tenderly simulation - ${enableShareRes.status} ${enableShareRes.statusText} - ${await enableShareRes.text()}`
      });
    }
  }
  const url = params.enableShare ? `https://www.tdly.co/shared/simulation/${simulationId}` : `https://dashboard.tenderly.co/${params.accountSlug}/${params.projectSlug}/simulator/${simulationId}`;
  return {
    simulationId,
    simulationUrl: url
  };
}

// node_modules/@across-protocol/app-sdk/dist/utils/typedData.js
function getUpdateDepositTypedData({ signerAddress, originChainId, depositId, updatedMessage, updatedOutputAmount, updatedRecipient }) {
  return {
    account: signerAddress,
    domain: {
      name: "ACROSS-V2",
      version: "1.0.0",
      chainId: Number(originChainId)
    },
    types: {
      UpdateDepositDetails: [
        { name: "depositId", type: "uint256" },
        { name: "originChainId", type: "uint256" },
        { name: "updatedOutputAmount", type: "uint256" },
        { name: "updatedRecipient", type: "address" },
        { name: "updatedMessage", type: "bytes" }
      ]
    },
    primaryType: "UpdateDepositDetails",
    message: {
      depositId: BigInt(depositId),
      originChainId: BigInt(originChainId),
      updatedOutputAmount,
      updatedRecipient,
      updatedMessage
    }
  };
}

// node_modules/@across-protocol/app-sdk/dist/actions/getSuggestedFees.js
async function getSuggestedFees({ apiUrl = MAINNET_API_URL, logger, ...params }) {
  const data = await fetchAcrossApi(`${apiUrl}/suggested-fees`, params, logger);
  return parseSuggestedFees(data);
}
function parseSuggestedFees(raw) {
  return {
    // ensure even unformatted values get passed through
    ...raw,
    outputAmount: BigInt(raw.outputAmount),
    estimatedFillTimeSec: raw.estimatedFillTimeSec,
    capitalFeePct: Number(raw.capitalFeePct),
    capitalFeeTotal: BigInt(raw.capitalFeeTotal),
    relayGasFeePct: Number(raw.relayGasFeePct),
    relayGasFeeTotal: BigInt(raw.relayGasFeeTotal),
    relayFeePct: Number(raw.relayFeePct),
    relayFeeTotal: BigInt(raw.relayFeeTotal),
    lpFeePct: raw.lpFeePct,
    // deprecated
    timestamp: Number(raw.timestamp),
    isAmountTooLow: raw.isAmountTooLow,
    quoteBlock: Number(raw.quoteBlock),
    exclusiveRelayer: raw.exclusiveRelayer,
    exclusivityDeadline: raw.exclusivityDeadline,
    spokePoolAddress: raw.spokePoolAddress,
    destinationSpokePoolAddress: raw.destinationSpokePoolAddress,
    fillDeadline: Number(raw.fillDeadline),
    totalRelayFee: {
      pct: BigInt(raw.totalRelayFee.pct),
      total: BigInt(raw.totalRelayFee.total)
    },
    relayerCapitalFee: {
      pct: BigInt(raw.relayerCapitalFee.pct),
      total: BigInt(raw.relayerCapitalFee.total)
    },
    relayerGasFee: {
      pct: BigInt(raw.relayerGasFee.pct),
      total: BigInt(raw.relayerGasFee.total)
    },
    lpFee: {
      pct: BigInt(raw.lpFee.pct),
      total: BigInt(raw.lpFee.total)
    },
    limits: {
      minDeposit: BigInt(raw.limits.minDeposit),
      maxDeposit: BigInt(raw.limits.maxDeposit),
      maxDepositInstant: BigInt(raw.limits.maxDepositInstant),
      maxDepositShortDelay: BigInt(raw.limits.maxDepositShortDelay),
      recommendedDepositInstant: BigInt(raw.limits.recommendedDepositInstant)
    },
    inputToken: {
      address: raw.inputToken.address,
      symbol: raw.inputToken.symbol,
      decimals: raw.inputToken.decimals,
      chainId: raw.inputToken.chainId
    },
    outputToken: {
      address: raw.outputToken.address,
      symbol: raw.outputToken.symbol,
      decimals: raw.outputToken.decimals,
      chainId: raw.outputToken.chainId
    }
  };
}

// node_modules/@across-protocol/app-sdk/dist/actions/getAvailableRoutes.js
async function getAvailableRoutes({ apiUrl = MAINNET_API_URL, logger, ...params }) {
  const routes = await fetchAcrossApi(`${apiUrl}/available-routes`, params, logger);
  return routes.map((route) => ({
    isNative: route.isNative,
    originChainId: route.originChainId,
    inputToken: route.originToken,
    destinationChainId: route.destinationChainId,
    outputToken: route.destinationToken,
    inputTokenSymbol: route.originTokenSymbol,
    outputTokenSymbol: route.destinationTokenSymbol
  }));
}

// node_modules/@across-protocol/app-sdk/dist/actions/getLimits.js
async function getLimits({ apiUrl = MAINNET_API_URL, logger, ...params }) {
  const limits = await fetchAcrossApi(`${apiUrl}/limits`, params, logger);
  return {
    minDeposit: BigInt(limits.minDeposit),
    maxDeposit: BigInt(limits.maxDeposit),
    maxDepositInstant: BigInt(limits.maxDepositInstant)
  };
}

// node_modules/@across-protocol/app-sdk/dist/actions/getQuote.js
async function getQuote(params) {
  const { route, recipient: _recipient, inputAmount, crossChainMessage, logger, apiUrl } = params;
  let message = "0x";
  let recipient = _recipient;
  if (isHex(crossChainMessage)) {
    message = crossChainMessage;
  }
  if (crossChainMessage && typeof crossChainMessage === "object") {
    if (crossChainMessage.actions.length === 0) {
      throw new Error("No 'crossChainMessage.actions' provided");
    }
    logger?.debug("Building cross chain message for actions:", crossChainMessage.actions);
    message = buildMulticallHandlerMessage({
      actions: crossChainMessage.actions,
      fallbackRecipient: crossChainMessage.fallbackRecipient
    });
    logger?.debug("Original message:", message);
    recipient = getMultiCallHandlerAddress(route.destinationChainId);
    logger?.debug(`Recipient ${recipient}`);
  }
  const { outputAmount, ...fees2 } = await getSuggestedFees({
    ...route,
    amount: inputAmount,
    recipient,
    message,
    logger,
    apiUrl,
    allowUnmatchedDecimals: true
  });
  logger?.debug("fees", fees2);
  if (crossChainMessage && typeof crossChainMessage === "object") {
    for (const action of crossChainMessage.actions) {
      let _callData = action.callData;
      let _value = BigInt(action.value);
      if (action?.update) {
        const maybePromise = action.update(outputAmount);
        if (maybePromise instanceof Promise) {
          const updated = await maybePromise;
          if (updated?.callData) {
            _callData = updated.callData;
          }
          if (updated?.value) {
            _value = updated?.value;
          }
        } else {
          if (maybePromise?.callData) {
            _callData = maybePromise.callData;
          }
          if (maybePromise?.value) {
            _value = maybePromise?.value;
          }
        }
      }
      action.callData = _callData;
      action.value = _value;
      logger?.debug("Updated calldata:", action.callData);
      logger?.debug("Updated value:", action.value);
    }
    message = buildMulticallHandlerMessage({
      actions: crossChainMessage.actions,
      fallbackRecipient: crossChainMessage.fallbackRecipient
    });
    logger?.debug(`Updated message with output amount ${outputAmount}`, message);
  }
  const {
    // partial deposit args
    timestamp,
    exclusiveRelayer,
    exclusivityDeadline,
    spokePoolAddress,
    destinationSpokePoolAddress,
    // limits
    isAmountTooLow,
    limits,
    // fees
    lpFee,
    relayerGasFee,
    relayerCapitalFee,
    totalRelayFee,
    // misc
    estimatedFillTimeSec,
    fillDeadline
  } = fees2;
  return {
    deposit: {
      inputAmount: BigInt(inputAmount),
      outputAmount,
      recipient,
      message,
      quoteTimestamp: Number(timestamp),
      exclusiveRelayer,
      exclusivityDeadline,
      spokePoolAddress,
      destinationSpokePoolAddress,
      fillDeadline,
      ...route
    },
    limits,
    fees: {
      lpFee,
      relayerGasFee,
      relayerCapitalFee,
      totalRelayFee
    },
    isAmountTooLow,
    estimatedFillTimeSec
  };
}

// node_modules/@across-protocol/app-sdk/dist/abis/SpokePool/v3.js
var spokePoolAbiV3 = [
  { inputs: [], name: "DepositsArePaused", type: "error" },
  { inputs: [], name: "DisabledRoute", type: "error" },
  { inputs: [], name: "ExpiredFillDeadline", type: "error" },
  { inputs: [], name: "FillsArePaused", type: "error" },
  { inputs: [], name: "InvalidChainId", type: "error" },
  { inputs: [], name: "InvalidDepositorSignature", type: "error" },
  { inputs: [], name: "InvalidExclusiveRelayer", type: "error" },
  { inputs: [], name: "InvalidExclusivityDeadline", type: "error" },
  { inputs: [], name: "InvalidFillDeadline", type: "error" },
  { inputs: [], name: "InvalidQuoteTimestamp", type: "error" },
  { inputs: [], name: "InvalidRelayerFeePct", type: "error" },
  { inputs: [], name: "MaxTransferSizeExceeded", type: "error" },
  { inputs: [], name: "MsgValueDoesNotMatchInputAmount", type: "error" },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalFilledAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "fillAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "repaymentChainId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "originChainId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "destinationChainId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "int64",
        name: "relayerFeePct",
        type: "int64"
      },
      {
        indexed: false,
        internalType: "int64",
        name: "realizedLpFeePct",
        type: "int64"
      },
      {
        indexed: true,
        internalType: "uint32",
        name: "depositId",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "destinationToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "relayer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "depositor",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      { indexed: false, internalType: "bytes", name: "message", type: "bytes" },
      {
        components: [
          { internalType: "address", name: "recipient", type: "address" },
          { internalType: "bytes", name: "message", type: "bytes" },
          { internalType: "int64", name: "relayerFeePct", type: "int64" },
          { internalType: "bool", name: "isSlowRelay", type: "bool" },
          {
            internalType: "int256",
            name: "payoutAdjustmentPct",
            type: "int256"
          }
        ],
        indexed: false,
        internalType: "struct SpokePool.RelayExecutionInfo",
        name: "updatableRelayData",
        type: "tuple"
      }
    ],
    name: "FilledRelay",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "inputToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "outputToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "inputAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "outputAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "repaymentChainId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "originChainId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint32",
        name: "depositId",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "fillDeadline",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "exclusivityDeadline",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "exclusiveRelayer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "relayer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "depositor",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      { indexed: false, internalType: "bytes", name: "message", type: "bytes" },
      {
        components: [
          {
            internalType: "address",
            name: "updatedRecipient",
            type: "address"
          },
          { internalType: "bytes", name: "updatedMessage", type: "bytes" },
          {
            internalType: "uint256",
            name: "updatedOutputAmount",
            type: "uint256"
          },
          {
            internalType: "enum V3SpokePoolInterface.FillType",
            name: "fillType",
            type: "uint8"
          }
        ],
        indexed: false,
        internalType: "struct V3SpokePoolInterface.V3RelayExecutionEventInfo",
        name: "relayExecutionInfo",
        type: "tuple"
      }
    ],
    name: "FilledV3Relay",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "originChainId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "destinationChainId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "int64",
        name: "relayerFeePct",
        type: "int64"
      },
      {
        indexed: true,
        internalType: "uint32",
        name: "depositId",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "quoteTimestamp",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "originToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "depositor",
        type: "address"
      },
      { indexed: false, internalType: "bytes", name: "message", type: "bytes" }
    ],
    name: "FundsDeposited",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "int64",
        name: "newRelayerFeePct",
        type: "int64"
      },
      {
        indexed: true,
        internalType: "uint32",
        name: "depositId",
        type: "uint32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "depositor",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "updatedRecipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "updatedMessage",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "depositorSignature",
        type: "bytes"
      }
    ],
    name: "RequestedSpeedUpDeposit",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "updatedOutputAmount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint32",
        name: "depositId",
        type: "uint32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "depositor",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "updatedRecipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "updatedMessage",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "depositorSignature",
        type: "bytes"
      }
    ],
    name: "RequestedSpeedUpV3Deposit",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "inputToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "outputToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "inputAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "outputAmount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "originChainId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint32",
        name: "depositId",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "fillDeadline",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "exclusivityDeadline",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "exclusiveRelayer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "depositor",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      { indexed: false, internalType: "bytes", name: "message", type: "bytes" }
    ],
    name: "RequestedV3SlowFill",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "amountToReturn",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      { indexed: true, internalType: "uint32", name: "leafId", type: "uint32" },
      {
        indexed: true,
        internalType: "address",
        name: "l2TokenAddress",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "caller",
        type: "address"
      }
    ],
    name: "TokensBridged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "inputToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "outputToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "inputAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "outputAmount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "destinationChainId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint32",
        name: "depositId",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "quoteTimestamp",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "fillDeadline",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "exclusivityDeadline",
        type: "uint32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "depositor",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "exclusiveRelayer",
        type: "address"
      },
      { indexed: false, internalType: "bytes", name: "message", type: "bytes" }
    ],
    name: "V3FundsDeposited",
    type: "event"
  },
  {
    inputs: [],
    name: "EMPTY_RELAYER",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "EMPTY_REPAYMENT_CHAIN_ID",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "INFINITE_FILL_DEADLINE",
    outputs: [{ internalType: "uint32", name: "", type: "uint32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "MAX_TRANSFER_SIZE",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "UPDATE_V3_DEPOSIT_DETAILS_HASH",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "chainId",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "recipient", type: "address" },
      { internalType: "address", name: "originToken", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "destinationChainId", type: "uint256" },
      { internalType: "int64", name: "relayerFeePct", type: "int64" },
      { internalType: "uint32", name: "quoteTimestamp", type: "uint32" },
      { internalType: "bytes", name: "message", type: "bytes" },
      { internalType: "uint256", name: "", type: "uint256" }
    ],
    name: "deposit",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "depositor", type: "address" },
      { internalType: "address", name: "recipient", type: "address" },
      { internalType: "address", name: "inputToken", type: "address" },
      { internalType: "address", name: "outputToken", type: "address" },
      { internalType: "uint256", name: "inputAmount", type: "uint256" },
      { internalType: "uint256", name: "outputAmount", type: "uint256" },
      { internalType: "uint256", name: "destinationChainId", type: "uint256" },
      { internalType: "address", name: "exclusiveRelayer", type: "address" },
      { internalType: "uint32", name: "quoteTimestamp", type: "uint32" },
      { internalType: "uint32", name: "fillDeadline", type: "uint32" },
      {
        internalType: "uint32",
        name: "exclusivityDeadlineOffset",
        type: "uint32"
      },
      { internalType: "bytes", name: "message", type: "bytes" }
    ],
    name: "depositExclusive",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "depositor", type: "address" },
      { internalType: "address", name: "recipient", type: "address" },
      { internalType: "address", name: "originToken", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "destinationChainId", type: "uint256" },
      { internalType: "int64", name: "relayerFeePct", type: "int64" },
      { internalType: "uint32", name: "quoteTimestamp", type: "uint32" },
      { internalType: "bytes", name: "message", type: "bytes" },
      { internalType: "uint256", name: "", type: "uint256" }
    ],
    name: "depositFor",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "depositQuoteTimeBuffer",
    outputs: [{ internalType: "uint32", name: "", type: "uint32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "depositor", type: "address" },
      { internalType: "address", name: "recipient", type: "address" },
      { internalType: "address", name: "inputToken", type: "address" },
      { internalType: "address", name: "outputToken", type: "address" },
      { internalType: "uint256", name: "inputAmount", type: "uint256" },
      { internalType: "uint256", name: "outputAmount", type: "uint256" },
      { internalType: "uint256", name: "destinationChainId", type: "uint256" },
      { internalType: "address", name: "exclusiveRelayer", type: "address" },
      { internalType: "uint32", name: "quoteTimestamp", type: "uint32" },
      { internalType: "uint32", name: "fillDeadline", type: "uint32" },
      { internalType: "uint32", name: "exclusivityDeadline", type: "uint32" },
      { internalType: "bytes", name: "message", type: "bytes" }
    ],
    name: "depositV3",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "depositor", type: "address" },
      { internalType: "address", name: "recipient", type: "address" },
      { internalType: "address", name: "inputToken", type: "address" },
      { internalType: "address", name: "outputToken", type: "address" },
      { internalType: "uint256", name: "inputAmount", type: "uint256" },
      { internalType: "uint256", name: "outputAmount", type: "uint256" },
      { internalType: "uint256", name: "destinationChainId", type: "uint256" },
      { internalType: "address", name: "exclusiveRelayer", type: "address" },
      { internalType: "uint32", name: "fillDeadlineOffset", type: "uint32" },
      { internalType: "uint32", name: "exclusivityDeadline", type: "uint32" },
      { internalType: "bytes", name: "message", type: "bytes" }
    ],
    name: "depositV3Now",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "uint256", name: "", type: "uint256" }
    ],
    name: "enabledDepositRoutes",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "fillDeadlineBuffer",
    outputs: [{ internalType: "uint32", name: "", type: "uint32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    name: "fillStatuses",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "depositor", type: "address" },
          { internalType: "address", name: "recipient", type: "address" },
          {
            internalType: "address",
            name: "exclusiveRelayer",
            type: "address"
          },
          { internalType: "address", name: "inputToken", type: "address" },
          { internalType: "address", name: "outputToken", type: "address" },
          { internalType: "uint256", name: "inputAmount", type: "uint256" },
          { internalType: "uint256", name: "outputAmount", type: "uint256" },
          { internalType: "uint256", name: "originChainId", type: "uint256" },
          { internalType: "uint32", name: "depositId", type: "uint32" },
          { internalType: "uint32", name: "fillDeadline", type: "uint32" },
          {
            internalType: "uint32",
            name: "exclusivityDeadline",
            type: "uint32"
          },
          { internalType: "bytes", name: "message", type: "bytes" }
        ],
        internalType: "struct V3SpokePoolInterface.V3RelayData",
        name: "relayData",
        type: "tuple"
      },
      { internalType: "uint256", name: "repaymentChainId", type: "uint256" }
    ],
    name: "fillV3Relay",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "depositor", type: "address" },
          { internalType: "address", name: "recipient", type: "address" },
          {
            internalType: "address",
            name: "exclusiveRelayer",
            type: "address"
          },
          { internalType: "address", name: "inputToken", type: "address" },
          { internalType: "address", name: "outputToken", type: "address" },
          { internalType: "uint256", name: "inputAmount", type: "uint256" },
          { internalType: "uint256", name: "outputAmount", type: "uint256" },
          { internalType: "uint256", name: "originChainId", type: "uint256" },
          { internalType: "uint32", name: "depositId", type: "uint32" },
          { internalType: "uint32", name: "fillDeadline", type: "uint32" },
          {
            internalType: "uint32",
            name: "exclusivityDeadline",
            type: "uint32"
          },
          { internalType: "bytes", name: "message", type: "bytes" }
        ],
        internalType: "struct V3SpokePoolInterface.V3RelayData",
        name: "relayData",
        type: "tuple"
      },
      { internalType: "uint256", name: "repaymentChainId", type: "uint256" },
      { internalType: "uint256", name: "updatedOutputAmount", type: "uint256" },
      { internalType: "address", name: "updatedRecipient", type: "address" },
      { internalType: "bytes", name: "updatedMessage", type: "bytes" },
      { internalType: "bytes", name: "depositorSignature", type: "bytes" }
    ],
    name: "fillV3RelayWithUpdatedDeposit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "getCurrentTime",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }],
    name: "multicall",
    outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "numberOfDeposits",
    outputs: [{ internalType: "uint32", name: "", type: "uint32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "depositor", type: "address" },
          { internalType: "address", name: "recipient", type: "address" },
          {
            internalType: "address",
            name: "exclusiveRelayer",
            type: "address"
          },
          { internalType: "address", name: "inputToken", type: "address" },
          { internalType: "address", name: "outputToken", type: "address" },
          { internalType: "uint256", name: "inputAmount", type: "uint256" },
          { internalType: "uint256", name: "outputAmount", type: "uint256" },
          { internalType: "uint256", name: "originChainId", type: "uint256" },
          { internalType: "uint32", name: "depositId", type: "uint32" },
          { internalType: "uint32", name: "fillDeadline", type: "uint32" },
          {
            internalType: "uint32",
            name: "exclusivityDeadline",
            type: "uint32"
          },
          { internalType: "bytes", name: "message", type: "bytes" }
        ],
        internalType: "struct V3SpokePoolInterface.V3RelayData",
        name: "relayData",
        type: "tuple"
      }
    ],
    name: "requestV3SlowFill",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "depositor", type: "address" },
      { internalType: "uint32", name: "depositId", type: "uint32" },
      { internalType: "uint256", name: "updatedOutputAmount", type: "uint256" },
      { internalType: "address", name: "updatedRecipient", type: "address" },
      { internalType: "bytes", name: "updatedMessage", type: "bytes" },
      { internalType: "bytes", name: "depositorSignature", type: "bytes" }
    ],
    name: "speedUpV3Deposit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }],
    name: "tryMulticall",
    outputs: [
      {
        components: [
          { internalType: "bool", name: "success", type: "bool" },
          { internalType: "bytes", name: "returnData", type: "bytes" }
        ],
        internalType: "struct MultiCallerUpgradeable.Result[]",
        name: "results",
        type: "tuple[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "wrappedNativeToken",
    outputs: [
      { internalType: "contract WETH9Interface", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
];

// node_modules/@across-protocol/app-sdk/dist/abis/SpokePool/v3_5.js
var spokePoolAbiV3_5 = [
  {
    inputs: [],
    name: "ClaimedMerkleLeaf",
    type: "error"
  },
  {
    inputs: [],
    name: "DepositsArePaused",
    type: "error"
  },
  {
    inputs: [],
    name: "DisabledRoute",
    type: "error"
  },
  {
    inputs: [],
    name: "ExpiredFillDeadline",
    type: "error"
  },
  {
    inputs: [],
    name: "FillsArePaused",
    type: "error"
  },
  {
    inputs: [],
    name: "InsufficientSpokePoolBalanceToExecuteLeaf",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidBytes32",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidChainId",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidCrossDomainAdmin",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidDepositorSignature",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidExclusiveRelayer",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidFillDeadline",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidMerkleLeaf",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidMerkleProof",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidPayoutAdjustmentPct",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidQuoteTimestamp",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidRelayerFeePct",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidSlowFillRequest",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidWithdrawalRecipient",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "LowLevelCallFailed",
    type: "error"
  },
  {
    inputs: [],
    name: "MaxTransferSizeExceeded",
    type: "error"
  },
  {
    inputs: [],
    name: "MsgValueDoesNotMatchInputAmount",
    type: "error"
  },
  {
    inputs: [],
    name: "NoRelayerRefundToClaim",
    type: "error"
  },
  {
    inputs: [],
    name: "NoSlowFillsInExclusivityWindow",
    type: "error"
  },
  {
    inputs: [],
    name: "NotEOA",
    type: "error"
  },
  {
    inputs: [],
    name: "NotExclusiveRelayer",
    type: "error"
  },
  {
    inputs: [],
    name: "RelayFilled",
    type: "error"
  },
  {
    inputs: [],
    name: "WrongERC7683OrderId",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "previousAdmin",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newAdmin",
        type: "address"
      }
    ],
    name: "AdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "beacon",
        type: "address"
      }
    ],
    name: "BeaconUpgraded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "l2TokenAddress",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "refundAddress",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address"
      }
    ],
    name: "ClaimedRelayerRefund",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "rootBundleId",
        type: "uint256"
      }
    ],
    name: "EmergencyDeletedRootBundle",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "originToken",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "destinationChainId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "enabled",
        type: "bool"
      }
    ],
    name: "EnabledDepositRoute",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "amountToReturn",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "refundAmounts",
        type: "uint256[]"
      },
      {
        indexed: true,
        internalType: "uint32",
        name: "rootBundleId",
        type: "uint32"
      },
      {
        indexed: true,
        internalType: "uint32",
        name: "leafId",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "l2TokenAddress",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address[]",
        name: "refundAddresses",
        type: "address[]"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "deferredRefunds",
        type: "bool"
      },
      {
        indexed: false,
        internalType: "address",
        name: "caller",
        type: "address"
      }
    ],
    name: "ExecutedRelayerRefundRoot",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bytes32",
        name: "inputToken",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "outputToken",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "inputAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "outputAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "repaymentChainId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "originChainId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "depositId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "fillDeadline",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "exclusivityDeadline",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "exclusiveRelayer",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "relayer",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "depositor",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "recipient",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "messageHash",
        type: "bytes32"
      },
      {
        components: [
          {
            internalType: "bytes32",
            name: "updatedRecipient",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "updatedMessageHash",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "updatedOutputAmount",
            type: "uint256"
          },
          {
            internalType: "enum V3SpokePoolInterface.FillType",
            name: "fillType",
            type: "uint8"
          }
        ],
        indexed: false,
        internalType: "struct V3SpokePoolInterface.V3RelayExecutionEventInfo",
        name: "relayExecutionInfo",
        type: "tuple"
      }
    ],
    name: "FilledRelay",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "inputToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "outputToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "inputAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "outputAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "repaymentChainId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "originChainId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint32",
        name: "depositId",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "fillDeadline",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "exclusivityDeadline",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "exclusiveRelayer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "relayer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "depositor",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "message",
        type: "bytes"
      },
      {
        components: [
          {
            internalType: "address",
            name: "updatedRecipient",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "updatedMessage",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "updatedOutputAmount",
            type: "uint256"
          },
          {
            internalType: "enum V3SpokePoolInterface.FillType",
            name: "fillType",
            type: "uint8"
          }
        ],
        indexed: false,
        internalType: "struct V3SpokePoolInterface.LegacyV3RelayExecutionEventInfo",
        name: "relayExecutionInfo",
        type: "tuple"
      }
    ],
    name: "FilledV3Relay",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bytes32",
        name: "inputToken",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "outputToken",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "inputAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "outputAmount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "destinationChainId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "depositId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "quoteTimestamp",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "fillDeadline",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "exclusivityDeadline",
        type: "uint32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "depositor",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "recipient",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "exclusiveRelayer",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "message",
        type: "bytes"
      }
    ],
    name: "FundsDeposited",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint8",
        name: "version",
        type: "uint8"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "isPaused",
        type: "bool"
      }
    ],
    name: "PausedDeposits",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "isPaused",
        type: "bool"
      }
    ],
    name: "PausedFills",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint32",
        name: "rootBundleId",
        type: "uint32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "relayerRefundRoot",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "slowRelayRoot",
        type: "bytes32"
      }
    ],
    name: "RelayedRootBundle",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bytes32",
        name: "inputToken",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "outputToken",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "inputAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "outputAmount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "originChainId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "depositId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "fillDeadline",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "exclusivityDeadline",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "exclusiveRelayer",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "depositor",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "recipient",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "messageHash",
        type: "bytes32"
      }
    ],
    name: "RequestedSlowFill",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "updatedOutputAmount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "depositId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "depositor",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "updatedRecipient",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "updatedMessage",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "depositorSignature",
        type: "bytes"
      }
    ],
    name: "RequestedSpeedUpDeposit",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "updatedOutputAmount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint32",
        name: "depositId",
        type: "uint32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "depositor",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "updatedRecipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "updatedMessage",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "depositorSignature",
        type: "bytes"
      }
    ],
    name: "RequestedSpeedUpV3Deposit",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "inputToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "outputToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "inputAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "outputAmount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "originChainId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint32",
        name: "depositId",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "fillDeadline",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "exclusivityDeadline",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "exclusiveRelayer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "depositor",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "message",
        type: "bytes"
      }
    ],
    name: "RequestedV3SlowFill",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newWithdrawalRecipient",
        type: "address"
      }
    ],
    name: "SetWithdrawalRecipient",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newAdmin",
        type: "address"
      }
    ],
    name: "SetXDomainAdmin",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "amountToReturn",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint32",
        name: "leafId",
        type: "uint32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "l2TokenAddress",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "caller",
        type: "address"
      }
    ],
    name: "TokensBridged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "Upgraded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "inputToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "outputToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "inputAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "outputAmount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "destinationChainId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint32",
        name: "depositId",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "quoteTimestamp",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "fillDeadline",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "exclusivityDeadline",
        type: "uint32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "depositor",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "exclusiveRelayer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "message",
        type: "bytes"
      }
    ],
    name: "V3FundsDeposited",
    type: "event"
  },
  {
    inputs: [],
    name: "EMPTY_RELAYER",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "EMPTY_REPAYMENT_CHAIN_ID",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "INFINITE_FILL_DEADLINE",
    outputs: [
      {
        internalType: "uint32",
        name: "",
        type: "uint32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "MAX_EXCLUSIVITY_PERIOD_SECONDS",
    outputs: [
      {
        internalType: "uint32",
        name: "",
        type: "uint32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "MAX_TRANSFER_SIZE",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "UPDATE_ADDRESS_DEPOSIT_DETAILS_HASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "UPDATE_BYTES32_DEPOSIT_DETAILS_HASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "_initialDepositId",
        type: "uint32"
      },
      {
        internalType: "address",
        name: "_crossDomainAdmin",
        type: "address"
      },
      {
        internalType: "address",
        name: "_withdrawalRecipient",
        type: "address"
      }
    ],
    name: "__SpokePool_init",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "chainId",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "l2TokenAddress",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "refundAddress",
        type: "bytes32"
      }
    ],
    name: "claimRelayerRefund",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "crossDomainAdmin",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "depositor",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "recipient",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "inputToken",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "outputToken",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "inputAmount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputAmount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "destinationChainId",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "exclusiveRelayer",
        type: "bytes32"
      },
      {
        internalType: "uint32",
        name: "quoteTimestamp",
        type: "uint32"
      },
      {
        internalType: "uint32",
        name: "fillDeadline",
        type: "uint32"
      },
      {
        internalType: "uint32",
        name: "exclusivityParameter",
        type: "uint32"
      },
      {
        internalType: "bytes",
        name: "message",
        type: "bytes"
      }
    ],
    name: "deposit",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "address",
        name: "originToken",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "destinationChainId",
        type: "uint256"
      },
      {
        internalType: "int64",
        name: "relayerFeePct",
        type: "int64"
      },
      {
        internalType: "uint32",
        name: "quoteTimestamp",
        type: "uint32"
      },
      {
        internalType: "bytes",
        name: "message",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "depositDeprecated_5947912356",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "depositor",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "address",
        name: "originToken",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "destinationChainId",
        type: "uint256"
      },
      {
        internalType: "int64",
        name: "relayerFeePct",
        type: "int64"
      },
      {
        internalType: "uint32",
        name: "quoteTimestamp",
        type: "uint32"
      },
      {
        internalType: "bytes",
        name: "message",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "depositFor",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "depositor",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "recipient",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "inputToken",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "outputToken",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "inputAmount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputAmount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "destinationChainId",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "exclusiveRelayer",
        type: "bytes32"
      },
      {
        internalType: "uint32",
        name: "fillDeadlineOffset",
        type: "uint32"
      },
      {
        internalType: "uint32",
        name: "exclusivityPeriod",
        type: "uint32"
      },
      {
        internalType: "bytes",
        name: "message",
        type: "bytes"
      }
    ],
    name: "depositNow",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "depositQuoteTimeBuffer",
    outputs: [
      {
        internalType: "uint32",
        name: "",
        type: "uint32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "depositor",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "address",
        name: "inputToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "outputToken",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "inputAmount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputAmount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "destinationChainId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "exclusiveRelayer",
        type: "address"
      },
      {
        internalType: "uint32",
        name: "quoteTimestamp",
        type: "uint32"
      },
      {
        internalType: "uint32",
        name: "fillDeadline",
        type: "uint32"
      },
      {
        internalType: "uint32",
        name: "exclusivityParameter",
        type: "uint32"
      },
      {
        internalType: "bytes",
        name: "message",
        type: "bytes"
      }
    ],
    name: "depositV3",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "depositor",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "address",
        name: "inputToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "outputToken",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "inputAmount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputAmount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "destinationChainId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "exclusiveRelayer",
        type: "address"
      },
      {
        internalType: "uint32",
        name: "fillDeadlineOffset",
        type: "uint32"
      },
      {
        internalType: "uint32",
        name: "exclusivityPeriod",
        type: "uint32"
      },
      {
        internalType: "bytes",
        name: "message",
        type: "bytes"
      }
    ],
    name: "depositV3Now",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "rootBundleId",
        type: "uint256"
      }
    ],
    name: "emergencyDeleteRootBundle",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "enabledDepositRoutes",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "rootBundleId",
        type: "uint32"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "amountToReturn",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "chainId",
            type: "uint256"
          },
          {
            internalType: "uint256[]",
            name: "refundAmounts",
            type: "uint256[]"
          },
          {
            internalType: "uint32",
            name: "leafId",
            type: "uint32"
          },
          {
            internalType: "address",
            name: "l2TokenAddress",
            type: "address"
          },
          {
            internalType: "address[]",
            name: "refundAddresses",
            type: "address[]"
          }
        ],
        internalType: "struct SpokePoolInterface.RelayerRefundLeaf",
        name: "relayerRefundLeaf",
        type: "tuple"
      },
      {
        internalType: "bytes32[]",
        name: "proof",
        type: "bytes32[]"
      }
    ],
    name: "executeRelayerRefundLeaf",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            components: [
              {
                internalType: "bytes32",
                name: "depositor",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "recipient",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "exclusiveRelayer",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "inputToken",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "outputToken",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "inputAmount",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "outputAmount",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "originChainId",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "depositId",
                type: "uint256"
              },
              {
                internalType: "uint32",
                name: "fillDeadline",
                type: "uint32"
              },
              {
                internalType: "uint32",
                name: "exclusivityDeadline",
                type: "uint32"
              },
              {
                internalType: "bytes",
                name: "message",
                type: "bytes"
              }
            ],
            internalType: "struct V3SpokePoolInterface.V3RelayData",
            name: "relayData",
            type: "tuple"
          },
          {
            internalType: "uint256",
            name: "chainId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "updatedOutputAmount",
            type: "uint256"
          }
        ],
        internalType: "struct V3SpokePoolInterface.V3SlowFill",
        name: "slowFillLeaf",
        type: "tuple"
      },
      {
        internalType: "uint32",
        name: "rootBundleId",
        type: "uint32"
      },
      {
        internalType: "bytes32[]",
        name: "proof",
        type: "bytes32[]"
      }
    ],
    name: "executeSlowRelayLeaf",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "orderId",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "originData",
        type: "bytes"
      },
      {
        internalType: "bytes",
        name: "fillerData",
        type: "bytes"
      }
    ],
    name: "fill",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "fillDeadlineBuffer",
    outputs: [
      {
        internalType: "uint32",
        name: "",
        type: "uint32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "bytes32",
            name: "depositor",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "recipient",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "exclusiveRelayer",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "inputToken",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "outputToken",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "inputAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "outputAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "originChainId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "depositId",
            type: "uint256"
          },
          {
            internalType: "uint32",
            name: "fillDeadline",
            type: "uint32"
          },
          {
            internalType: "uint32",
            name: "exclusivityDeadline",
            type: "uint32"
          },
          {
            internalType: "bytes",
            name: "message",
            type: "bytes"
          }
        ],
        internalType: "struct V3SpokePoolInterface.V3RelayData",
        name: "relayData",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "repaymentChainId",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "repaymentAddress",
        type: "bytes32"
      }
    ],
    name: "fillRelay",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "bytes32",
            name: "depositor",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "recipient",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "exclusiveRelayer",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "inputToken",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "outputToken",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "inputAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "outputAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "originChainId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "depositId",
            type: "uint256"
          },
          {
            internalType: "uint32",
            name: "fillDeadline",
            type: "uint32"
          },
          {
            internalType: "uint32",
            name: "exclusivityDeadline",
            type: "uint32"
          },
          {
            internalType: "bytes",
            name: "message",
            type: "bytes"
          }
        ],
        internalType: "struct V3SpokePoolInterface.V3RelayData",
        name: "relayData",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "repaymentChainId",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "repaymentAddress",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "updatedOutputAmount",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "updatedRecipient",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "updatedMessage",
        type: "bytes"
      },
      {
        internalType: "bytes",
        name: "depositorSignature",
        type: "bytes"
      }
    ],
    name: "fillRelayWithUpdatedDeposit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    name: "fillStatuses",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "depositor",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "address",
            name: "exclusiveRelayer",
            type: "address"
          },
          {
            internalType: "address",
            name: "inputToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "outputToken",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "inputAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "outputAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "originChainId",
            type: "uint256"
          },
          {
            internalType: "uint32",
            name: "depositId",
            type: "uint32"
          },
          {
            internalType: "uint32",
            name: "fillDeadline",
            type: "uint32"
          },
          {
            internalType: "uint32",
            name: "exclusivityDeadline",
            type: "uint32"
          },
          {
            internalType: "bytes",
            name: "message",
            type: "bytes"
          }
        ],
        internalType: "struct V3SpokePoolInterface.V3RelayDataLegacy",
        name: "relayData",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "repaymentChainId",
        type: "uint256"
      }
    ],
    name: "fillV3Relay",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "getCurrentTime",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "l2TokenAddress",
        type: "address"
      },
      {
        internalType: "address",
        name: "refundAddress",
        type: "address"
      }
    ],
    name: "getRelayerRefund",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "msgSender",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "depositor",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "depositNonce",
        type: "uint256"
      }
    ],
    name: "getUnsafeDepositId",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "numberOfDeposits",
    outputs: [
      {
        internalType: "uint32",
        name: "",
        type: "uint32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bool",
        name: "pause",
        type: "bool"
      }
    ],
    name: "pauseDeposits",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bool",
        name: "pause",
        type: "bool"
      }
    ],
    name: "pauseFills",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "pausedDeposits",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pausedFills",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "proxiableUUID",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "relayerRefundRoot",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "slowRelayRoot",
        type: "bytes32"
      }
    ],
    name: "relayRootBundle",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "relayerRefund",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "bytes32",
            name: "depositor",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "recipient",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "exclusiveRelayer",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "inputToken",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "outputToken",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "inputAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "outputAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "originChainId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "depositId",
            type: "uint256"
          },
          {
            internalType: "uint32",
            name: "fillDeadline",
            type: "uint32"
          },
          {
            internalType: "uint32",
            name: "exclusivityDeadline",
            type: "uint32"
          },
          {
            internalType: "bytes",
            name: "message",
            type: "bytes"
          }
        ],
        internalType: "struct V3SpokePoolInterface.V3RelayData",
        name: "relayData",
        type: "tuple"
      }
    ],
    name: "requestSlowFill",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "rootBundles",
    outputs: [
      {
        internalType: "bytes32",
        name: "slowRelayRoot",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "relayerRefundRoot",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newCrossDomainAdmin",
        type: "address"
      }
    ],
    name: "setCrossDomainAdmin",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "originToken",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "destinationChainId",
        type: "uint256"
      },
      {
        internalType: "bool",
        name: "enabled",
        type: "bool"
      }
    ],
    name: "setEnableRoute",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newWithdrawalRecipient",
        type: "address"
      }
    ],
    name: "setWithdrawalRecipient",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "depositor",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "depositId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "updatedOutputAmount",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "updatedRecipient",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "updatedMessage",
        type: "bytes"
      },
      {
        internalType: "bytes",
        name: "depositorSignature",
        type: "bytes"
      }
    ],
    name: "speedUpDeposit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "depositor",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "depositId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "updatedOutputAmount",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "updatedRecipient",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "updatedMessage",
        type: "bytes"
      },
      {
        internalType: "bytes",
        name: "depositorSignature",
        type: "bytes"
      }
    ],
    name: "speedUpV3Deposit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "tryMulticall",
    outputs: [
      {
        components: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "returnData",
            type: "bytes"
          }
        ],
        internalType: "struct MultiCallerUpgradeable.Result[]",
        name: "results",
        type: "tuple[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "depositor",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "recipient",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "inputToken",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "outputToken",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "inputAmount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputAmount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "destinationChainId",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "exclusiveRelayer",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "depositNonce",
        type: "uint256"
      },
      {
        internalType: "uint32",
        name: "quoteTimestamp",
        type: "uint32"
      },
      {
        internalType: "uint32",
        name: "fillDeadline",
        type: "uint32"
      },
      {
        internalType: "uint32",
        name: "exclusivityParameter",
        type: "uint32"
      },
      {
        internalType: "bytes",
        name: "message",
        type: "bytes"
      }
    ],
    name: "unsafeDeposit",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newImplementation",
        type: "address"
      }
    ],
    name: "upgradeTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newImplementation",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "upgradeToAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "withdrawalRecipient",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "wrappedNativeToken",
    outputs: [
      {
        internalType: "contract WETH9Interface",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    stateMutability: "payable",
    type: "receive"
  }
];

// node_modules/@across-protocol/app-sdk/dist/actions/simulateDepositTx.js
async function simulateDepositTx(params) {
  const { walletClient, deposit, publicClient, integratorId, logger } = params;
  const { originChainId, destinationChainId, inputToken, outputToken, inputAmount, outputAmount, recipient, message, isNative, spokePoolAddress, fillDeadline, exclusiveRelayer, exclusivityDeadline, quoteTimestamp } = deposit;
  const account = walletClient.account;
  if (!account) {
    throw new Error("Wallet account has to be set");
  }
  const connectedChainId = await walletClient.getChainId();
  if (connectedChainId !== originChainId) {
    throw new Error(`Connected chainId ${connectedChainId} does not match originChainId ${originChainId}`);
  }
  const useExclusiveRelayer = exclusiveRelayer !== zeroAddress && exclusivityDeadline > 0;
  logger?.debug(`Using exclusive relayer: ${useExclusiveRelayer}`);
  const result = await publicClient.simulateContract({
    account: walletClient.account,
    abi: spokePoolAbiV3_5,
    address: spokePoolAddress,
    functionName: "deposit",
    args: [
      addressToBytes32(account.address),
      addressToBytes32(recipient ?? account.address),
      addressToBytes32(inputToken),
      addressToBytes32(outputToken),
      BigInt(inputAmount),
      outputAmount,
      BigInt(destinationChainId),
      addressToBytes32(exclusiveRelayer),
      quoteTimestamp,
      fillDeadline,
      exclusivityDeadline,
      message
    ],
    value: isNative ? BigInt(inputAmount) : 0n,
    dataSuffix: getIntegratorDataSuffix(integratorId)
  });
  logger?.debug("Simulation result", result);
  return result;
}

// node_modules/@across-protocol/app-sdk/dist/actions/getDepositFromLogs.js
function parseDepositLogs(logs, filter2) {
  const blockData = {
    depositTxHash: logs[0].blockHash,
    depositTxBlock: logs[0].blockNumber
  };
  const parsedV3_5Logs = parseEventLogs({
    abi: spokePoolAbiV3_5,
    eventName: "FundsDeposited",
    logs,
    args: filter2
  });
  const v3_5Log = parsedV3_5Logs?.[0];
  if (v3_5Log) {
    return {
      ...blockData,
      depositId: v3_5Log.args.depositId,
      inputToken: bytes32ToAddress(v3_5Log.args.inputToken),
      outputToken: bytes32ToAddress(v3_5Log.args.outputToken),
      inputAmount: v3_5Log.args.inputAmount,
      outputAmount: v3_5Log.args.outputAmount,
      destinationChainId: Number(v3_5Log.args.destinationChainId),
      message: v3_5Log.args.message,
      depositor: bytes32ToAddress(v3_5Log.args.depositor),
      recipient: bytes32ToAddress(v3_5Log.args.recipient),
      exclusiveRelayer: bytes32ToAddress(v3_5Log.args.exclusiveRelayer),
      quoteTimestamp: v3_5Log.args.quoteTimestamp,
      fillDeadline: v3_5Log.args.fillDeadline,
      exclusivityDeadline: v3_5Log.args.exclusivityDeadline,
      status: "pending"
    };
  }
  const parsedV3Logs = parseEventLogs({
    abi: spokePoolAbiV3_5,
    eventName: "V3FundsDeposited",
    logs,
    args: filter2
  });
  const v3Log = parsedV3Logs?.[0];
  if (v3Log) {
    return {
      ...blockData,
      depositId: BigInt(v3Log.args.depositId),
      inputToken: v3Log.args.inputToken,
      outputToken: v3Log.args.outputToken,
      inputAmount: v3Log.args.inputAmount,
      outputAmount: v3Log.args.outputAmount,
      destinationChainId: Number(v3Log.args.destinationChainId),
      message: v3Log.args.message,
      depositor: v3Log.args.depositor,
      recipient: v3Log.args.recipient,
      exclusiveRelayer: v3Log.args.exclusiveRelayer,
      quoteTimestamp: v3Log.args.quoteTimestamp,
      fillDeadline: v3Log.args.fillDeadline,
      exclusivityDeadline: v3Log.args.exclusivityDeadline,
      status: "pending"
    };
  }
  return void 0;
}
function getDepositFromLogs(params) {
  const { originChainId, receipt, filter: filter2 } = params;
  const standardizedDeposit = parseDepositLogs(receipt.logs, filter2);
  if (!standardizedDeposit) {
    throw new Error("No deposit log found.");
  }
  return {
    ...standardizedDeposit,
    depositTxHash: receipt.transactionHash,
    depositTxBlock: receipt.blockNumber,
    originChainId
  };
}

// node_modules/@across-protocol/app-sdk/dist/actions/waitForDepositTx.js
async function waitForDepositTx(params) {
  const { transactionHash, originChainId, publicClient } = params;
  const receipt = await publicClient.waitForTransactionReceipt({
    hash: transactionHash
  });
  const depositLog = getDepositFromLogs({ originChainId, receipt });
  if (!depositLog || !depositLog.depositId) {
    throw new NoDepositLogError(receipt.transactionHash, publicClient.chain.id);
  }
  const depositId = depositLog.depositId;
  return {
    depositTxReceipt: receipt,
    depositId
  };
}

// node_modules/@across-protocol/app-sdk/dist/actions/waitForFillTx.js
async function waitForFillTx(params) {
  try {
    const statusFromFilter = await waitForFillTxEvent(params);
    return statusFromFilter;
  } catch (e) {
    const message = "Event filtering currently disabled for this RPC provider, switching to getFillByDepositTx()";
    params?.logger ? params.logger.error(message, {
      cause: e
    }) : console.error(message, {
      cause: e
    });
    const statusFromLogs = await waitForFillByDepositTx({
      ...params,
      deposit: {
        ...params.deposit,
        depositTxHash: params.depositTxHash,
        depositId: params.depositId
      }
    });
    return statusFromLogs;
  }
}
async function waitForFillTxEvent(params) {
  const { logger } = params;
  try {
    const status = await waitForFillEvent(params);
    return status;
  } catch (error) {
    logger ? logger.error("Error waiting for fill events", error) : console.error("Error waiting for fill events", error);
    throw error;
  }
}
async function waitForFillEvent(params) {
  const { depositId, destinationChainClient, deposit, fromBlock, logger } = params;
  return new Promise((resolve, reject) => {
    const unwatch = destinationChainClient.watchContractEvent({
      address: deposit.destinationSpokePoolAddress,
      abi: spokePoolAbiV3_5,
      eventName: "FilledRelay",
      args: {
        depositId: BigInt(depositId),
        originChainId: BigInt(deposit.originChainId)
      },
      fromBlock,
      onError: async (error) => {
        logger ? logger.error("Watch FilledRelay event error", error) : console.error("Watch FilledRelay event error", error);
        unwatch();
        reject(error);
      },
      onLogs: async (fillLogs) => {
        if (fillLogs.length) {
          logger ? logger.debug("V3_5 Fill events found in block", fillLogs) : console.log("V3_5 Fill events found in block", fillLogs);
        }
        const [fillLog] = fillLogs;
        if (fillLog) {
          try {
            const [fillTxReceipt, fillBlock] = await Promise.all([
              destinationChainClient.getTransactionReceipt({
                hash: fillLog.transactionHash
              }),
              destinationChainClient.getBlock({
                blockNumber: fillLog.blockNumber
              })
            ]);
            const parsedFillEvent = parseFillLogs([fillLog]);
            unwatch();
            if (hasMessage(deposit.message)) {
              const logs = parseEventLogs({
                abi: MulticallHandlerAbi,
                logs: fillTxReceipt.logs
              });
              logger?.debug("Fill Logs", logs);
              const actionSuccess = !logs.some((log) => log.eventName === "CallsFailed");
              resolve({
                actionSuccess,
                fillTxReceipt,
                fillTxTimestamp: fillBlock.timestamp,
                parsedFillEvent
              });
            }
            resolve({
              fillTxReceipt,
              fillTxTimestamp: fillBlock.timestamp,
              parsedFillEvent
            });
          } catch (error) {
            unwatch();
            reject(error);
          }
        }
      }
    });
  });
}
function parseFillLogs(logs, filter2) {
  const blockData = {
    depositTxHash: logs[0].blockHash,
    depositTxBlock: logs[0].blockNumber
  };
  const parsedV3_5Logs = parseEventLogs({
    abi: spokePoolAbiV3_5,
    eventName: "FilledRelay",
    logs,
    args: {
      ...filter2,
      depositId: filter2?.depositId ? BigInt(filter2?.depositId) : void 0
    }
  });
  const v3_5Log = parsedV3_5Logs?.[0];
  if (v3_5Log) {
    return {
      ...blockData,
      inputToken: bytes32ToAddress(v3_5Log.args.inputToken),
      outputToken: bytes32ToAddress(v3_5Log.args.outputToken),
      inputAmount: v3_5Log.args.inputAmount,
      outputAmount: v3_5Log.args.outputAmount,
      repaymentChainId: v3_5Log.args.repaymentChainId,
      originChainId: v3_5Log.args.originChainId,
      depositId: v3_5Log.args.depositId,
      fillDeadline: v3_5Log.args.fillDeadline,
      exclusivityDeadline: v3_5Log.args.exclusivityDeadline,
      exclusiveRelayer: bytes32ToAddress(v3_5Log.args.exclusiveRelayer),
      relayer: bytes32ToAddress(v3_5Log.args.relayer),
      depositor: bytes32ToAddress(v3_5Log.args.depositor),
      recipient: bytes32ToAddress(v3_5Log.args.recipient),
      messageHash: v3_5Log.args.messageHash,
      relayExecutionInfo: {
        ...v3_5Log.args.relayExecutionInfo,
        updatedRecipient: bytes32ToAddress(v3_5Log.args.relayExecutionInfo.updatedRecipient),
        fillType: FillType?.[v3_5Log.args.relayExecutionInfo.fillType]
      }
    };
  }
  const parsedV3Logs = parseEventLogs({
    abi: spokePoolAbiV3,
    eventName: "FilledV3Relay",
    logs,
    args: { ...filter2, depositId: Number(filter2?.depositId) }
  });
  const v3Log = parsedV3Logs?.[0];
  if (v3Log) {
    return {
      ...blockData,
      inputToken: v3Log.args.inputToken,
      outputToken: v3Log.args.outputToken,
      inputAmount: v3Log.args.inputAmount,
      outputAmount: v3Log.args.outputAmount,
      repaymentChainId: v3Log.args.repaymentChainId,
      originChainId: v3Log.args.originChainId,
      depositId: v3Log.args.depositId,
      fillDeadline: v3Log.args.fillDeadline,
      exclusivityDeadline: v3Log.args.exclusivityDeadline,
      exclusiveRelayer: v3Log.args.exclusiveRelayer,
      relayer: v3Log.args.relayer,
      depositor: v3Log.args.depositor,
      recipient: v3Log.args.recipient,
      message: v3Log.args.message,
      relayExecutionInfo: {
        ...v3Log.args.relayExecutionInfo,
        fillType: FillType?.[v3Log.args.relayExecutionInfo.fillType]
      }
    };
  }
}
var FillType = {
  // Fast fills are normal fills that do not replace a slow fill request.
  0: "FastFill",
  // Replaced slow fills are fast fills that replace a slow fill request. This type is used by the Dataworker
  // to know when to send excess funds from the SpokePool to the HubPool because they can no longer be used
  // for a slow fill execution.
  1: "ReplacedSlowFill",
  2: "SlowFill"
};

// node_modules/@across-protocol/app-sdk/dist/actions/getFillByDepositTx.js
async function getFillByDepositTx(params) {
  const { indexerUrl = MAINNET_INDEXER_API, logger } = params;
  try {
    const data = await fetchIndexerApi(`${indexerUrl}/deposit/status`, {
      depositId: BigInt(params.deposit.depositId),
      originChainId: params.deposit.originChainId
    });
    if (data?.status === "filled" && data?.fillTx) {
      const fillTxReceipt2 = await params.destinationChainClient.getTransactionReceipt({
        hash: data.fillTx
      });
      const fillTxBlock = await params.destinationChainClient.getBlock({
        blockNumber: fillTxReceipt2.blockNumber
      });
      const parsedFillEvent2 = parseFillLogs(fillTxReceipt2.logs);
      if (params.deposit.message !== "0x") {
        const [callsFailedLog] = parseEventLogs({
          abi: [
            parseAbiItem("event CallsFailed(Call[] calls, address indexed fallbackRecipient)")
          ],
          logs: fillTxReceipt2.logs
        });
        return {
          actionSuccess: !callsFailedLog,
          fillTxReceipt: fillTxReceipt2,
          fillTxTimestamp: fillTxBlock.timestamp,
          parsedFillEvent: parsedFillEvent2
        };
      }
      return {
        fillTxReceipt: fillTxReceipt2,
        fillTxTimestamp: fillTxBlock.timestamp,
        parsedFillEvent: parsedFillEvent2
      };
    }
  } catch (e) {
    logger?.warn(`Failed to get fill status from indexer: ${e}`);
  }
  const [fillEvent] = await getFillLogs(params);
  if (!fillEvent) {
    throw new NoFillLogError(BigInt(params.deposit.depositId), params.deposit.destinationChainId, params.deposit.depositTxHash);
  }
  const [fillTxReceipt, fillBlock] = await Promise.all([
    params.destinationChainClient.getTransactionReceipt({
      hash: fillEvent.transactionHash
    }),
    params.destinationChainClient.getBlock({
      blockNumber: fillEvent.blockNumber
    })
  ]);
  const parsedFillEvent = parseFillLogs(fillTxReceipt.logs);
  if (params.deposit.message !== "0x") {
    const [callsFailedLog] = parseEventLogs({
      abi: [
        parseAbiItem("event CallsFailed(Call[] calls, address indexed fallbackRecipient)")
      ],
      logs: fillTxReceipt.logs
    });
    return {
      actionSuccess: !callsFailedLog,
      fillTxReceipt,
      fillTxTimestamp: fillBlock.timestamp,
      parsedFillEvent
    };
  }
  return {
    fillTxReceipt,
    fillTxTimestamp: fillBlock.timestamp,
    parsedFillEvent
  };
}
async function waitForFillByDepositTx(params) {
  const interval = params?.pollingInterval ?? params.destinationChainClient.pollingInterval;
  return new Promise((res) => {
    const poll = () => {
      getFillByDepositTx(params).then((response) => {
        if (response.fillTxReceipt) {
          res(response);
        } else {
          setTimeout(poll, interval);
        }
      }).catch((error) => {
        params?.logger ? params.logger.error(error) : console.log(error);
        setTimeout(poll, interval);
      });
    };
    poll();
  });
}
async function getFillLogs(params) {
  const { deposit, fromBlock, destinationChainClient } = params;
  const [v3Logs, v3_5Logs] = await Promise.all([
    destinationChainClient.getLogs({
      address: deposit.destinationSpokePoolAddress,
      event: {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "inputToken",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "outputToken",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "inputAmount",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "outputAmount",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "repaymentChainId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "originChainId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "uint32",
            name: "depositId",
            type: "uint32"
          },
          {
            indexed: false,
            internalType: "uint32",
            name: "fillDeadline",
            type: "uint32"
          },
          {
            indexed: false,
            internalType: "uint32",
            name: "exclusivityDeadline",
            type: "uint32"
          },
          {
            indexed: false,
            internalType: "address",
            name: "exclusiveRelayer",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "relayer",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "depositor",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "message",
            type: "bytes"
          },
          {
            components: [
              {
                internalType: "address",
                name: "updatedRecipient",
                type: "address"
              },
              { internalType: "bytes", name: "updatedMessage", type: "bytes" },
              {
                internalType: "uint256",
                name: "updatedOutputAmount",
                type: "uint256"
              },
              {
                internalType: "enum V3SpokePoolInterface.FillType",
                name: "fillType",
                type: "uint8"
              }
            ],
            indexed: false,
            internalType: "struct V3SpokePoolInterface.V3RelayExecutionEventInfo",
            name: "relayExecutionInfo",
            type: "tuple"
          }
        ],
        name: "FilledV3Relay",
        type: "event"
      },
      args: {
        depositId: Number(deposit.depositId),
        originChainId: BigInt(deposit.originChainId)
      },
      fromBlock: fromBlock ?? 0n
    }),
    destinationChainClient.getLogs({
      address: deposit.destinationSpokePoolAddress,
      event: {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "bytes32",
            name: "inputToken",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "bytes32",
            name: "outputToken",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "inputAmount",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "outputAmount",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "repaymentChainId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "originChainId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "depositId",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint32",
            name: "fillDeadline",
            type: "uint32"
          },
          {
            indexed: false,
            internalType: "uint32",
            name: "exclusivityDeadline",
            type: "uint32"
          },
          {
            indexed: false,
            internalType: "bytes32",
            name: "exclusiveRelayer",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "relayer",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "bytes32",
            name: "depositor",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "bytes32",
            name: "recipient",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "bytes32",
            name: "messageHash",
            type: "bytes32"
          },
          {
            components: [
              {
                internalType: "bytes32",
                name: "updatedRecipient",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "updatedMessageHash",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "updatedOutputAmount",
                type: "uint256"
              },
              {
                internalType: "enum V3SpokePoolInterface.FillType",
                name: "fillType",
                type: "uint8"
              }
            ],
            indexed: false,
            internalType: "struct V3SpokePoolInterface.V3RelayExecutionEventInfo",
            name: "relayExecutionInfo",
            type: "tuple"
          }
        ],
        name: "FilledRelay",
        type: "event"
      },
      args: {
        depositId: BigInt(deposit.depositId),
        originChainId: BigInt(deposit.originChainId)
      },
      fromBlock: fromBlock ?? 0n
    })
  ]);
  return v3Logs ?? v3_5Logs;
}

// node_modules/@across-protocol/app-sdk/dist/actions/getDeposit.js
async function getDeposit(params) {
  const { originChainClient, destinationChainClient, findBy, depositLogFromBlock, fillLogFromBlock, indexerUrl } = params;
  const { originChainId, destinationSpokePoolAddress } = findBy;
  let rawDeposit;
  if (!(findBy.depositTxHash || findBy.depositId && findBy.originSpokePoolAddress)) {
    throw new Error("You must provide either a 'depositTxHash' or 'depositId' + 'spokePoolAddress'");
  }
  if (findBy.depositTxHash) {
    const depositTxHash = findBy.depositTxHash;
    if (!isHash(depositTxHash)) {
      throw new Error(`Can't get receipt for tx hash: ${depositTxHash}`);
    }
    const receipt = await originChainClient.getTransactionReceipt({
      hash: depositTxHash
    });
    if (!receipt) {
      throw new Error(`No receipt found for tx hash: ${depositTxHash}`);
    }
    rawDeposit = getDepositFromLogs({ originChainId, receipt });
  } else if (findBy.depositId && findBy.originSpokePoolAddress) {
    const { depositId, originSpokePoolAddress } = findBy;
    const _depositId = BigInt(findBy.depositId);
    const depositLogs = await getDepositLogs({
      depositId,
      depositLogFromBlock,
      originChainClient: params.originChainClient,
      originSpokePoolAddress
    });
    if (!depositLogs?.length) {
      throw new Error(`No deposit logs found for deposit id: ${depositId}`);
    }
    const parsedDepositLog = parseDepositLogs(depositLogs);
    if (!parsedDepositLog) {
      throw new Error(`Unable to parse Deposit logs for deposit id: ${depositId}`);
    }
    rawDeposit = {
      ...parsedDepositLog,
      depositId: _depositId,
      originChainId
    };
  }
  if (!rawDeposit) {
    throw new Error(`No deposit found for ${JSON.stringify(findBy)}`);
  }
  try {
    const fill = await getFillByDepositTx({
      deposit: {
        depositId: rawDeposit.depositId,
        originChainId: rawDeposit.originChainId,
        destinationSpokePoolAddress,
        message: rawDeposit.message,
        depositTxHash: rawDeposit.depositTxHash,
        destinationChainId: rawDeposit.destinationChainId
      },
      fromBlock: fillLogFromBlock,
      destinationChainClient,
      indexerUrl
    });
    rawDeposit.fillTxHash = fill.fillTxReceipt.transactionHash;
    rawDeposit.fillTxBlock = fill.fillTxReceipt.blockNumber;
    rawDeposit.status = "filled";
    rawDeposit.actionSuccess = fill.actionSuccess;
  } catch (e) {
    if (e instanceof NoFillLogError) {
    } else {
      throw e;
    }
  }
  return rawDeposit;
}
async function getDepositLogs({ depositId, depositLogFromBlock, originChainClient, originSpokePoolAddress }) {
  const [v3Logs, v3_5Logs] = await Promise.all([
    originChainClient.getLogs({
      address: originSpokePoolAddress,
      event: {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "inputToken",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "outputToken",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "inputAmount",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "outputAmount",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "destinationChainId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "uint32",
            name: "depositId",
            type: "uint32"
          },
          {
            indexed: false,
            internalType: "uint32",
            name: "quoteTimestamp",
            type: "uint32"
          },
          {
            indexed: false,
            internalType: "uint32",
            name: "fillDeadline",
            type: "uint32"
          },
          {
            indexed: false,
            internalType: "uint32",
            name: "exclusivityDeadline",
            type: "uint32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "depositor",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "exclusiveRelayer",
            type: "address"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "message",
            type: "bytes"
          }
        ],
        name: "V3FundsDeposited",
        type: "event"
      },
      args: {
        depositId: Number(depositId)
      },
      fromBlock: depositLogFromBlock ?? 0n
    }),
    originChainClient.getLogs({
      address: originSpokePoolAddress,
      event: {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "bytes32",
            name: "inputToken",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "bytes32",
            name: "outputToken",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "inputAmount",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "outputAmount",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "destinationChainId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "depositId",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint32",
            name: "quoteTimestamp",
            type: "uint32"
          },
          {
            indexed: false,
            internalType: "uint32",
            name: "fillDeadline",
            type: "uint32"
          },
          {
            indexed: false,
            internalType: "uint32",
            name: "exclusivityDeadline",
            type: "uint32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "depositor",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "bytes32",
            name: "recipient",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "bytes32",
            name: "exclusiveRelayer",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "message",
            type: "bytes"
          }
        ],
        name: "FundsDeposited",
        type: "event"
      },
      args: {
        depositId: BigInt(depositId)
      },
      fromBlock: depositLogFromBlock ?? 0n
    })
  ]);
  return v3Logs ?? v3_5Logs;
}

// node_modules/@across-protocol/app-sdk/dist/actions/simulateApproveTx.js
async function simulateApproveTx(params) {
  const { walletClient, publicClient, spender, approvalAmount, tokenAddress } = params;
  if (!walletClient.account) {
    throw new Error("Wallet account has to be set");
  }
  const simulationResult = await publicClient.simulateContract({
    account: walletClient.account,
    abi: parseAbi([
      "function approve(address spender, uint256 amount) public returns (bool)"
    ]),
    address: bytes32ToAddress(tokenAddress),
    functionName: "approve",
    args: [bytes32ToAddress(spender), approvalAmount]
  });
  return simulationResult;
}

// node_modules/@across-protocol/app-sdk/dist/actions/executeQuote.js
async function executeQuote(params) {
  const { integratorId, deposit, walletClient, originClient, destinationClient, skipAllowanceCheck, infiniteApproval, throwOnError = true, forceOriginChain, onProgress, logger } = params;
  const onProgressHandler = onProgress || ((progress) => defaultProgressHandler(progress, logger));
  let txRequest;
  let currentTransactionProgress = {
    status: "idle",
    step: "approve"
  };
  let currentProgressMeta;
  try {
    const account = walletClient.account;
    if (!account) {
      throw new Error("Wallet account has to be set");
    }
    if (forceOriginChain) {
      await walletClient.switchChain({
        id: deposit.originChainId
      });
    }
    const connectedChainId = await walletClient.getChainId();
    if (connectedChainId !== deposit.originChainId) {
      throw new Error(`Connected chain ${connectedChainId} does not match 'originChainId' ${deposit.originChainId}`);
    }
    const { inputToken, inputAmount, spokePoolAddress } = deposit;
    if (!skipAllowanceCheck && !deposit.isNative) {
      const allowance = await originClient.readContract({
        address: inputToken,
        abi: parseAbi([
          "function allowance(address owner, address spender) public view returns (uint256)"
        ]),
        functionName: "allowance",
        args: [account.address, spokePoolAddress]
      });
      logger?.debug("Allowance", {
        allowance,
        owner: account.address,
        spender: spokePoolAddress,
        inputToken
      });
      if (BigInt(inputAmount) > allowance) {
        const approvalAmount = infiniteApproval ? maxUint256 : BigInt(inputAmount);
        currentProgressMeta = {
          approvalAmount,
          spender: spokePoolAddress
        };
        currentTransactionProgress = {
          step: "approve",
          status: "simulationPending",
          meta: currentProgressMeta
        };
        onProgressHandler(currentTransactionProgress);
        const { request } = await simulateApproveTx({
          walletClient,
          publicClient: originClient,
          spender: spokePoolAddress,
          approvalAmount,
          tokenAddress: inputToken
        });
        txRequest = request;
        currentTransactionProgress = {
          ...currentTransactionProgress,
          status: "simulationSuccess",
          txRequest: request
        };
        onProgressHandler(currentTransactionProgress);
        const approveTxHash = await walletClient.writeContract({
          account,
          ...txRequest
        });
        currentTransactionProgress = {
          ...currentTransactionProgress,
          status: "txPending",
          txHash: approveTxHash
        };
        onProgressHandler(currentTransactionProgress);
        const approveTxReceipt = await originClient.waitForTransactionReceipt({
          hash: approveTxHash
        });
        currentTransactionProgress = {
          ...currentTransactionProgress,
          status: "txSuccess",
          txReceipt: approveTxReceipt
        };
        onProgressHandler(currentTransactionProgress);
      }
    }
    currentProgressMeta = {
      deposit
    };
    currentTransactionProgress = {
      step: "deposit",
      status: "simulationPending",
      meta: currentProgressMeta
    };
    onProgressHandler(currentTransactionProgress);
    const { request: _request } = await simulateDepositTx({
      walletClient,
      publicClient: originClient,
      deposit,
      integratorId,
      logger
    });
    txRequest = _request;
    currentTransactionProgress = {
      ...currentTransactionProgress,
      status: "simulationSuccess",
      txRequest: _request
    };
    onProgressHandler(currentTransactionProgress);
    const depositTxHash = await walletClient.writeContract({
      account,
      ...txRequest
    });
    currentTransactionProgress = {
      ...currentTransactionProgress,
      status: "txPending",
      txHash: depositTxHash
    };
    onProgressHandler(currentTransactionProgress);
    const destinationBlock = await destinationClient.getBlockNumber();
    const { depositId, depositTxReceipt } = await waitForDepositTx({
      originChainId: deposit.originChainId,
      transactionHash: depositTxHash,
      publicClient: originClient
    });
    const depositLog = parseDepositLogs(depositTxReceipt.logs);
    currentTransactionProgress = {
      ...currentTransactionProgress,
      status: "txSuccess",
      txReceipt: depositTxReceipt,
      depositId,
      depositLog
    };
    onProgressHandler(currentTransactionProgress);
    currentProgressMeta = {
      depositId,
      deposit
    };
    currentTransactionProgress = {
      step: "fill",
      status: "txPending",
      meta: currentProgressMeta
    };
    onProgressHandler(currentTransactionProgress);
    const { fillTxReceipt, fillTxTimestamp, actionSuccess } = await waitForFillTx({
      deposit,
      depositId,
      depositTxHash,
      destinationChainClient: destinationClient,
      fromBlock: destinationBlock - 100n
      // TODO: use dynamic block buffer based chain
    });
    const fillLog = parseFillLogs(fillTxReceipt.logs);
    currentTransactionProgress = {
      ...currentTransactionProgress,
      status: "txSuccess",
      txReceipt: fillTxReceipt,
      fillTxTimestamp,
      actionSuccess,
      fillLog
    };
    onProgressHandler(currentTransactionProgress);
    return { depositId, depositTxReceipt, fillTxReceipt };
  } catch (error) {
    const errorStatus = currentTransactionProgress.status === "txPending" ? "txError" : currentTransactionProgress.status === "simulationPending" ? "simulationError" : "error";
    onProgressHandler({
      ...currentTransactionProgress,
      status: errorStatus,
      error,
      meta: currentProgressMeta
    });
    if (!throwOnError) {
      return { error };
    }
    throw error;
  }
}
function defaultProgressHandler(progress, logger) {
  if (!logger) {
    return;
  }
  logger.debug("Progress", progress);
}

// node_modules/@across-protocol/app-sdk/dist/actions/signUpdateDeposit.js
async function signUpdateDepositTypedData(params) {
  const { walletClient, depositId, originChainId, updatedMessage, updatedOutputAmount, updatedRecipient } = params;
  const account = walletClient.account;
  if (!account) {
    throw new Error("Wallet account has to be set");
  }
  const signature = await walletClient.signTypedData(getUpdateDepositTypedData({
    signerAddress: account.address,
    originChainId,
    depositId,
    updatedMessage,
    updatedOutputAmount,
    updatedRecipient
  }));
  return signature;
}

// node_modules/@across-protocol/app-sdk/dist/actions/simulateUpdateDepositTx.js
async function simulateUpdateDepositTx(params) {
  const { walletClient, deposit: _deposit, update, originChainClient, destinationChainClient, logger, apiUrl } = params;
  const { originChainId, originSpokePoolAddress, destinationChainId, destinationSpokePoolAddress, depositId } = _deposit;
  const account = walletClient.account;
  if (!account) {
    throw new Error("Wallet account has to be set");
  }
  const connectedChainId = await walletClient.getChainId();
  if (connectedChainId !== originChainId) {
    throw new Error(`Connected chainId ${connectedChainId} does not match originChainId ${originChainId}`);
  }
  const prevDeposit = await getDeposit({
    originChainClient,
    destinationChainClient,
    findBy: {
      depositId,
      originChainId,
      destinationChainId,
      destinationSpokePoolAddress
    }
  });
  if (prevDeposit.depositor !== account.address) {
    throw new Error(`Connected account ${account.address} does not match depositor ${prevDeposit.depositor}`);
  }
  const updatedRecipient = update.recipient ?? prevDeposit.recipient;
  const newQuote = await getQuote({
    route: {
      originChainId,
      destinationChainId,
      inputToken: prevDeposit.inputToken,
      outputToken: prevDeposit.outputToken
    },
    inputAmount: prevDeposit.inputAmount,
    recipient: updatedRecipient,
    crossChainMessage: update.crossChainMessage ?? prevDeposit.message,
    logger,
    apiUrl
  });
  if (update.outputAmount && update.outputAmount < newQuote.deposit.outputAmount) {
    throw new Error(`Provided 'update.outputAmount' ${update.outputAmount} is less than the required ${newQuote.deposit.outputAmount}`);
  }
  const updatedOutputAmount = update.outputAmount ?? newQuote.deposit.outputAmount;
  const updatedMessage = newQuote.deposit.message;
  const signature = await signUpdateDepositTypedData({
    walletClient,
    updatedMessage,
    updatedOutputAmount,
    updatedRecipient,
    originChainId,
    depositId
  });
  const result = await originChainClient.simulateContract({
    account,
    abi: spokePoolAbiV3_5,
    address: originSpokePoolAddress,
    functionName: "speedUpV3Deposit",
    args: [
      account.address,
      prevDeposit.depositId,
      updatedOutputAmount,
      updatedRecipient,
      updatedMessage,
      signature
    ]
  });
  logger?.debug("'speedUpV3Deposit' sim result", result);
  return result;
}

// node_modules/@across-protocol/app-sdk/dist/client.js
var CLIENT_DEFAULTS = {
  pollingInterval: 3e3,
  integratorId: "0xdead",
  logLevel: "ERROR"
};
var AcrossClient = class _AcrossClient {
  static instance = null;
  integratorId;
  publicClients;
  chainInfo;
  walletClient;
  apiUrl;
  indexerUrl;
  logger;
  // Tenderly related options
  tenderly;
  get isTenderlyEnabled() {
    return Boolean(this.tenderly?.accessKey && this.tenderly?.accountSlug && this.tenderly?.projectSlug);
  }
  constructor(args) {
    const integratorId = args?.integratorId ?? CLIENT_DEFAULTS.integratorId;
    assertValidIntegratorId(integratorId);
    this.integratorId = integratorId;
    this.walletClient = args?.walletClient;
    this.publicClients = configurePublicClients(args.chains, args.pollingInterval ?? CLIENT_DEFAULTS.pollingInterval, args?.rpcUrls);
    this.indexerUrl = args?.useTestnet === true ? TESTNET_INDEXER_API : MAINNET_INDEXER_API;
    this.apiUrl = args?.useTestnet === true ? TESTNET_API_URL : MAINNET_API_URL;
    this.logger = args?.logger ?? new DefaultLogger(args?.logLevel ?? CLIENT_DEFAULTS.logLevel);
    this.tenderly = args.tenderly;
    if (this.tenderly) {
      this.tenderly.simOnError = args.tenderly?.simOnError ?? true;
    }
    this.logger.debug("Client created with args: \n", args);
  }
  /**
   * Create a new `AcrossClient` instance as a singleton.
   * @param options - See {@link AcrossClientOptions}.
   * @returns A new `AcrossClient` instance if it doesn't exist, otherwise the existing
   * instance.
   */
  static create(options) {
    if (this.instance === null) {
      this.instance = new _AcrossClient(options);
    }
    return this.instance;
  }
  /**
   * Get the existing `AcrossClient` singleton instance.
   * @returns The existing `AcrossClient` instance.
   * @throws If the instance is not initialized.
   */
  static getInstance() {
    if (this.instance === null) {
      throw new Error("AcrossClient has not been initialized. Call create() first.");
    }
    return this.instance;
  }
  update(params) {
    this.walletClient = params.walletClient;
  }
  /**
   * @internal
   */
  getPublicClient(chainId) {
    const client = this.publicClients.get(chainId);
    if (!client) {
      throw new ConfigError(`SDK not configured for chain with id ${chainId}.`);
    }
    this.logger.debug(`Using configured public client for chain ${chainId}.`);
    return client;
  }
  async getSpokePoolAddress(chainId) {
    const chainInfo = await this.getChainInfo(chainId);
    return chainInfo.spokePool;
  }
  /**
   * @param chainId - number
   * @returns See {@link AcrossChain}.
   */
  async getChainInfo(chainId) {
    if (!this.chainInfo) {
      const acrossChains = await this.getSupportedChains({
        chainId: Array.from(this.publicClients.keys())
      });
      this.chainInfo = new Map(acrossChains.map((acrossChain) => [acrossChain.chainId, acrossChain]));
    }
    if (!this.chainInfo.has(chainId)) {
      throw new Error(`Could not find chainInfo for chain with id ${chainId}`);
    }
    return this.chainInfo.get(chainId);
  }
  /**
   * Execute a quote by:
   * 1. Approving the SpokePool contract if necessary
   * 2. Depositing the input token on the origin chain
   * 3. Waiting for the deposit to be filled on the destination chain
   *
   * See {@link executeQuote} for more details.
   *
   * @example
   * ```ts
   * const quote = await client.getQuote({ route, inputAmount });
   * const { depositId } = await client.executeQuote({ deposit: quote.deposit });
   * ```
   *
   * @param params - See {@link ExecuteQuoteParams}.
   * @returns The deposit ID and receipts for the deposit and fill transactions.
   */
  async executeQuote(params) {
    const logger = params?.logger ?? this.logger;
    const originClient = params?.originClient ?? this.getPublicClient(params.deposit.originChainId);
    const destinationClient = params?.destinationClient ?? this.getPublicClient(params.deposit.destinationChainId);
    const integratorId = params?.integratorId ?? this.integratorId;
    const walletClient = params?.walletClient ?? this?.walletClient;
    if (!walletClient) {
      throw new ConfigError("WalletClient needs to be set to call 'executeQuote'");
    }
    try {
      await executeQuote({
        ...params,
        integratorId,
        logger,
        walletClient,
        originClient,
        destinationClient
      });
    } catch (e) {
      if (!this.isTenderlyEnabled || !this.tenderly?.simOnError || !(e instanceof AcrossApiSimulationError || e instanceof ContractFunctionExecutionError)) {
        throw e;
      }
      const isFillSimulationError = e instanceof AcrossApiSimulationError;
      const simParams = isFillSimulationError ? {
        networkId: params.deposit.destinationChainId.toString(),
        from: e.transaction.from,
        to: e.transaction.to,
        data: e.transaction.data
      } : {
        networkId: params.deposit.originChainId.toString(),
        from: e.sender,
        to: e.contractAddress,
        data: encodeFunctionData({
          abi: e.abi,
          functionName: e.functionName,
          args: e.args
        })
      };
      const { simulationId, simulationUrl } = await this.simulateTxOnTenderly({
        value: params.deposit.isNative ? String(params.deposit.inputAmount) : "0",
        ...simParams
      });
      const reason = isFillSimulationError ? e.message : e.shortMessage;
      throw new SimulationError({
        simulationId,
        simulationUrl,
        message: `simulation failed while executing quote: ${reason}`
      });
    }
  }
  /**
   * Get the available routes for a given set of parameters. See {@link getAvailableRoutes}.
   * @param params - See {@link GetAvailableRoutesParams}.
   * @returns See {@link GetAvailableRoutesReturnType}.
   */
  async getAvailableRoutes(params) {
    return getAvailableRoutes({
      ...params,
      apiUrl: params?.apiUrl || this.apiUrl,
      logger: params?.logger ?? this.logger
    });
  }
  /**
   * Get the suggested fees for a given route. See {@link getSuggestedFees}.
   * @param params - See {@link GetSuggestedFeesParams}.
   * @returns See {@link GetSuggestedFeesReturnType}.
   */
  async getSuggestedFees(params) {
    try {
      const fees2 = await getSuggestedFees({
        ...params,
        apiUrl: params?.apiUrl ?? this.apiUrl,
        logger: params?.logger ?? this.logger
      });
      return fees2;
    } catch (e) {
      if (!this.isTenderlyEnabled || !this.tenderly?.simOnError || !(e instanceof AcrossApiSimulationError)) {
        throw e;
      }
      const { simulationId, simulationUrl } = await this.simulateTxOnTenderly({
        networkId: params.destinationChainId.toString(),
        to: e.transaction.to,
        data: e.transaction.data,
        from: e.transaction.from,
        value: e.transaction.value ?? "0"
      });
      throw new SimulationError({
        simulationId,
        simulationUrl,
        message: `simulation failed while fetching suggested fees: ${e.message}`
      });
    }
  }
  /**
   * Get the deposit limits for a given route. See {@link getLimits}.
   * @param params - See {@link GetLimitsParams}.
   * @returns See {@link GetLimitsReturnType}.
   */
  async getLimits(params) {
    try {
      const limits = await getLimits({
        ...params,
        apiUrl: params?.apiUrl ?? this.apiUrl,
        logger: params?.logger ?? this.logger
      });
      return limits;
    } catch (e) {
      if (!this.tenderly?.simOnError || !(e instanceof AcrossApiSimulationError)) {
        throw e;
      }
      const { simulationId, simulationUrl } = await this.simulateTxOnTenderly({
        networkId: params.destinationChainId.toString(),
        to: e.transaction.to,
        data: e.transaction.data,
        from: e.transaction.from,
        value: e.transaction.value ?? "0"
      });
      throw new SimulationError({
        simulationId,
        simulationUrl,
        message: `simulation failed while fetching limits: ${e.message}`
      });
    }
  }
  /**
   * Get a quote for a given set of parameters. See {@link getQuote}.
   * @param params - See {@link GetQuoteParams}.
   * @returns See {@link Quote}.
   */
  async getQuote(params) {
    try {
      const quote = await getQuote({
        ...params,
        logger: params?.logger ?? this.logger,
        apiUrl: params?.apiUrl ?? this.apiUrl
      });
      return quote;
    } catch (e) {
      if (!this.tenderly?.simOnError || !(e instanceof AcrossApiSimulationError)) {
        throw e;
      }
      const { simulationId, simulationUrl } = await this.simulateTxOnTenderly({
        networkId: params.route.originChainId.toString(),
        to: e.transaction.to,
        data: e.transaction.data,
        from: e.transaction.from,
        value: e.transaction.value ?? "0"
      });
      throw new SimulationError({
        simulationId,
        simulationUrl,
        message: `simulation failed while fetching quote: ${e.message}`
      });
    }
  }
  async simulateDepositTx(params) {
    try {
      const result = await simulateDepositTx({
        ...params,
        integratorId: params?.integratorId ?? this.integratorId,
        publicClient: params?.publicClient ?? this.getPublicClient(params.deposit.originChainId),
        logger: params?.logger ?? this.logger
      });
      return result;
    } catch (e) {
      if (!this.tenderly?.simOnError || !this.isTenderlyEnabled || !(e instanceof ContractFunctionExecutionError)) {
        throw e;
      }
      const { simulationId, simulationUrl } = await this.simulateTxOnTenderly({
        networkId: params.deposit.originChainId.toString(),
        from: e.sender,
        to: e.contractAddress,
        data: encodeFunctionData({
          abi: e.abi,
          functionName: e.functionName,
          args: e.args
        }),
        value: params.deposit.isNative ? String(params.deposit.inputAmount) : "0"
      });
      throw new SimulationError({
        simulationId,
        simulationUrl,
        message: `deposit simulation failed: ${e.shortMessage}`
      });
    }
  }
  /**
   * This function simulates the update of a deposit on the origin chain. Can be used to
   * update:
   * - the recipient address
   * - the output amount, i.e. the fees
   * - the cross-chain message
   *
   * Note that this requires a signature from the depositor.
   *
   * See {@link simulateUpdateDepositTx}.
   *
   * @param params - See {@link SimulateUpdateDepositTxParams}.
   * @returns The result of the simulation.
   * @example
   * ```ts
   * const result = await client.simulateUpdateDepositTx({
   *   deposit: {
   *     // deposit details
   *   },
   *   update: {
   *     recipient: "0xNEW_RECIPIENT_ADDRESS",
   *   },
   *  });
   * const txHash = await walletClient.writeContract({
   *   account,
   *   ...txRequest,
   * });
   * ```
   */
  async simulateUpdateDepositTx(params) {
    try {
      const result = await simulateUpdateDepositTx({
        logger: this.logger,
        apiUrl: this.apiUrl,
        ...params,
        originChainClient: params.originChainClient ?? this.getPublicClient(params.deposit.originChainId),
        destinationChainClient: params.destinationChainClient ?? this.getPublicClient(params.deposit.destinationChainId)
      });
      return result;
    } catch (e) {
      if (!this.tenderly?.simOnError || !this.isTenderlyEnabled || !(e instanceof ContractFunctionExecutionError)) {
        throw e;
      }
      const { simulationId, simulationUrl } = await this.simulateTxOnTenderly({
        networkId: params.deposit.originChainId.toString(),
        from: e.sender,
        to: e.contractAddress,
        data: encodeFunctionData({
          abi: e.abi,
          functionName: e.functionName,
          args: e.args
        }),
        value: "0"
      });
      throw new SimulationError({
        simulationId,
        simulationUrl,
        message: `speedUpV3Deposit simulation failed: ${e.shortMessage}`
      });
    }
  }
  async signUpdateDepositTypedData(params) {
    if (!this.walletClient) {
      throw new ConfigError(`'walletClient' needs to be set to sign`);
    }
    return signUpdateDepositTypedData({
      walletClient: this.walletClient,
      ...params
    });
  }
  async waitForDepositTx(params) {
    return waitForDepositTx({
      ...params,
      publicClient: params?.publicClient ?? this.getPublicClient(params.originChainId)
    });
  }
  /**
   * Get a fill after a deposit has been made. See {@link getFillByDepositTx}.
   * @param params - See {@link GetFillByDepositTxParams}.
   * @returns See {@link FillStatus}.
   */
  async getFillByDepositTx(params) {
    return getFillByDepositTx({
      ...params,
      destinationChainClient: params?.destinationChainClient ?? this.getPublicClient(params.deposit.destinationChainId),
      indexerUrl: params?.indexerUrl ?? this.indexerUrl,
      logger: params?.logger ?? this.logger
    });
  }
  async waitForFillTx(params) {
    return waitForFillTx({
      ...params,
      destinationChainClient: params?.destinationChainClient ?? this.getPublicClient(params.deposit.destinationChainId),
      logger: params?.logger ?? this.logger
    });
  }
  /**
   * Get a deposit by its deposit tx hash or deposit id + spoke pool address. See {@link getDeposit}.
   * @param params - See {@link GetDepositParams}.
   * @returns See {@link Deposit}.
   */
  async getDeposit(params) {
    const originSpokePoolAddress = params.findBy.originSpokePoolAddress ?? await this.getSpokePoolAddress(params.findBy.originChainId);
    const destinationSpokePoolAddress = params.findBy.destinationSpokePoolAddress ?? await this.getSpokePoolAddress(params.findBy.destinationChainId);
    return getDeposit({
      ...params,
      findBy: {
        ...params.findBy,
        originSpokePoolAddress,
        destinationSpokePoolAddress
      },
      indexerUrl: params?.indexerUrl ?? this.indexerUrl,
      originChainClient: params?.originChainClient ?? this.getPublicClient(params.findBy.originChainId),
      destinationChainClient: params?.destinationChainClient ?? this.getPublicClient(params.findBy.destinationChainId)
    });
  }
  /* -------------------------------- Utilities ------------------------------- */
  async getSupportedChains(params) {
    return getSupportedChains({
      ...params,
      logger: params?.logger ?? this.logger,
      apiUrl: params?.apiUrl ?? this.apiUrl
    });
  }
  async simulateTxOnTenderly(params) {
    const accessKey = params?.accessKey ?? this.tenderly?.accessKey;
    const accountSlug = params?.accountSlug ?? this.tenderly?.accountSlug;
    const projectSlug = params?.projectSlug ?? this.tenderly?.projectSlug;
    const enableShare = params?.enableShare ?? true;
    if (!accessKey || !accountSlug || !projectSlug) {
      throw new ConfigError("Tenderly credentials not set. Client needs to be configured with 'tenderly.accessKey', 'tenderly.accountSlug', and 'tenderly.projectSlug'.");
    }
    return simulateTxOnTenderly({
      ...params,
      accessKey,
      accountSlug,
      projectSlug,
      enableShare
    });
  }
};
function createAcrossClient(options) {
  return AcrossClient.create(options);
}

// node_modules/@biconomy/abstractjs/dist/_esm/account/utils/Constants.js
var CALLTYPE_SINGLE = "0x00";
var CALLTYPE_BATCH = "0x01";
var EXECTYPE_DEFAULT = "0x00";
var EXECTYPE_TRY = "0x01";
var EXECTYPE_DELEGATE = "0xFF";
var MODE_DEFAULT = "0x00000000";
var UNUSED = "0x00000000";
var MODE_PAYLOAD = "0x00000000000000000000000000000000000000000000";
var SENTINEL_ADDRESS = "0x0000000000000000000000000000000000000001";
var MODULE_ENABLE_MODE_TYPE_HASH = keccak256(toHex("ModuleEnableMode(address module, bytes32 initDataHash)"));
var PARENT_TYPEHASH = "TypedDataSign(Contents contents,string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)Contents(bytes32 stuff)";
var EXECUTE_SINGLE = concat([
  CALLTYPE_SINGLE,
  EXECTYPE_DEFAULT,
  MODE_DEFAULT,
  UNUSED,
  MODE_PAYLOAD
]);
var EXECUTE_BATCH = concat([
  CALLTYPE_BATCH,
  EXECTYPE_DEFAULT,
  MODE_DEFAULT,
  UNUSED,
  MODE_PAYLOAD
]);
var ACCOUNT_MODES = {
  DEFAULT_SINGLE: concat([
    pad(EXECTYPE_DEFAULT, { size: 1 }),
    pad(CALLTYPE_SINGLE, { size: 1 }),
    pad(UNUSED, { size: 4 }),
    pad(MODE_DEFAULT, { size: 4 }),
    pad(MODE_PAYLOAD, { size: 22 })
  ]),
  DEFAULT_BATCH: concat([
    pad(EXECTYPE_DEFAULT, { size: 1 }),
    pad(CALLTYPE_BATCH, { size: 1 }),
    pad(UNUSED, { size: 4 }),
    pad(MODE_DEFAULT, { size: 4 }),
    pad(MODE_PAYLOAD, { size: 22 })
  ]),
  TRY_BATCH: concat([
    pad(EXECTYPE_TRY, { size: 1 }),
    pad(CALLTYPE_BATCH, { size: 1 }),
    pad(UNUSED, { size: 4 }),
    pad(MODE_DEFAULT, { size: 4 }),
    pad(MODE_PAYLOAD, { size: 22 })
  ]),
  TRY_SINGLE: concat([
    pad(EXECTYPE_TRY, { size: 1 }),
    pad(CALLTYPE_SINGLE, { size: 1 }),
    pad(UNUSED, { size: 4 }),
    pad(MODE_DEFAULT, { size: 4 }),
    pad(MODE_PAYLOAD, { size: 22 })
  ]),
  DELEGATE_SINGLE: concat([
    pad(EXECTYPE_DELEGATE, { size: 1 }),
    pad(CALLTYPE_SINGLE, { size: 1 }),
    pad(UNUSED, { size: 4 }),
    pad(MODE_DEFAULT, { size: 4 }),
    pad(MODE_PAYLOAD, { size: 22 })
  ])
};

// node_modules/@biconomy/abstractjs/dist/_esm/constants/abi/EntryPointABI.js
var EntrypointAbi = [
  {
    inputs: [
      { internalType: "bool", name: "success", type: "bool" },
      { internalType: "bytes", name: "ret", type: "bytes" }
    ],
    name: "DelegateAndRevert",
    type: "error"
  },
  {
    inputs: [
      { internalType: "uint256", name: "opIndex", type: "uint256" },
      { internalType: "string", name: "reason", type: "string" }
    ],
    name: "FailedOp",
    type: "error"
  },
  {
    inputs: [
      { internalType: "uint256", name: "opIndex", type: "uint256" },
      { internalType: "string", name: "reason", type: "string" },
      { internalType: "bytes", name: "inner", type: "bytes" }
    ],
    name: "FailedOpWithRevert",
    type: "error"
  },
  {
    inputs: [{ internalType: "bytes", name: "returnData", type: "bytes" }],
    name: "PostOpReverted",
    type: "error"
  },
  { inputs: [], name: "ReentrancyGuardReentrantCall", type: "error" },
  {
    inputs: [{ internalType: "address", name: "sender", type: "address" }],
    name: "SenderAddressResult",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "aggregator", type: "address" }],
    name: "SignatureValidationFailed",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "factory",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "paymaster",
        type: "address"
      }
    ],
    name: "AccountDeployed",
    type: "event"
  },
  { anonymous: false, inputs: [], name: "BeforeExecution", type: "event" },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalDeposit",
        type: "uint256"
      }
    ],
    name: "Deposited",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "revertReason",
        type: "bytes"
      }
    ],
    name: "PostOpRevertReason",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "aggregator",
        type: "address"
      }
    ],
    name: "SignatureAggregatorChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalStaked",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "unstakeDelaySec",
        type: "uint256"
      }
    ],
    name: "StakeLocked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "withdrawTime",
        type: "uint256"
      }
    ],
    name: "StakeUnlocked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "StakeWithdrawn",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "paymaster",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      },
      { indexed: false, internalType: "bool", name: "success", type: "bool" },
      {
        indexed: false,
        internalType: "uint256",
        name: "actualGasCost",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "actualGasUsed",
        type: "uint256"
      }
    ],
    name: "UserOperationEvent",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      }
    ],
    name: "UserOperationPrefundTooLow",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "revertReason",
        type: "bytes"
      }
    ],
    name: "UserOperationRevertReason",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Withdrawn",
    type: "event"
  },
  {
    inputs: [
      { internalType: "uint32", name: "unstakeDelaySec", type: "uint32" }
    ],
    name: "addStake",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "target", type: "address" },
      { internalType: "bytes", name: "data", type: "bytes" }
    ],
    name: "delegateAndRevert",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "depositTo",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "deposits",
    outputs: [
      { internalType: "uint256", name: "deposit", type: "uint256" },
      { internalType: "bool", name: "staked", type: "bool" },
      { internalType: "uint112", name: "stake", type: "uint112" },
      { internalType: "uint32", name: "unstakeDelaySec", type: "uint32" },
      { internalType: "uint48", name: "withdrawTime", type: "uint48" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "getDepositInfo",
    outputs: [
      {
        components: [
          { internalType: "uint256", name: "deposit", type: "uint256" },
          { internalType: "bool", name: "staked", type: "bool" },
          { internalType: "uint112", name: "stake", type: "uint112" },
          { internalType: "uint32", name: "unstakeDelaySec", type: "uint32" },
          { internalType: "uint48", name: "withdrawTime", type: "uint48" }
        ],
        internalType: "struct IStakeManager.DepositInfo",
        name: "info",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "sender", type: "address" },
      { internalType: "uint192", name: "key", type: "uint192" }
    ],
    name: "getNonce",
    outputs: [{ internalType: "uint256", name: "nonce", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes", name: "initCode", type: "bytes" }],
    name: "getSenderAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "sender", type: "address" },
          { internalType: "uint256", name: "nonce", type: "uint256" },
          { internalType: "bytes", name: "initCode", type: "bytes" },
          { internalType: "bytes", name: "callData", type: "bytes" },
          {
            internalType: "bytes32",
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          { internalType: "bytes32", name: "gasFees", type: "bytes32" },
          { internalType: "bytes", name: "paymasterAndData", type: "bytes" },
          { internalType: "bytes", name: "signature", type: "bytes" }
        ],
        internalType: "struct PackedUserOperation",
        name: "userOp",
        type: "tuple"
      }
    ],
    name: "getUserOpHash",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            components: [
              { internalType: "address", name: "sender", type: "address" },
              { internalType: "uint256", name: "nonce", type: "uint256" },
              { internalType: "bytes", name: "initCode", type: "bytes" },
              { internalType: "bytes", name: "callData", type: "bytes" },
              {
                internalType: "bytes32",
                name: "accountGasLimits",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              { internalType: "bytes32", name: "gasFees", type: "bytes32" },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              { internalType: "bytes", name: "signature", type: "bytes" }
            ],
            internalType: "struct PackedUserOperation[]",
            name: "userOps",
            type: "tuple[]"
          },
          {
            internalType: "contract IAggregator",
            name: "aggregator",
            type: "address"
          },
          { internalType: "bytes", name: "signature", type: "bytes" }
        ],
        internalType: "struct IEntryPoint.UserOpsPerAggregator[]",
        name: "opsPerAggregator",
        type: "tuple[]"
      },
      { internalType: "address payable", name: "beneficiary", type: "address" }
    ],
    name: "handleAggregatedOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "sender", type: "address" },
          { internalType: "uint256", name: "nonce", type: "uint256" },
          { internalType: "bytes", name: "initCode", type: "bytes" },
          { internalType: "bytes", name: "callData", type: "bytes" },
          {
            internalType: "bytes32",
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          { internalType: "bytes32", name: "gasFees", type: "bytes32" },
          { internalType: "bytes", name: "paymasterAndData", type: "bytes" },
          { internalType: "bytes", name: "signature", type: "bytes" }
        ],
        internalType: "struct PackedUserOperation[]",
        name: "ops",
        type: "tuple[]"
      },
      { internalType: "address payable", name: "beneficiary", type: "address" }
    ],
    name: "handleOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint192", name: "key", type: "uint192" }],
    name: "incrementNonce",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes", name: "callData", type: "bytes" },
      {
        components: [
          {
            components: [
              { internalType: "address", name: "sender", type: "address" },
              { internalType: "uint256", name: "nonce", type: "uint256" },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "paymasterVerificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "paymasterPostOpGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              { internalType: "address", name: "paymaster", type: "address" },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              }
            ],
            internalType: "struct EntryPoint.MemoryUserOp",
            name: "mUserOp",
            type: "tuple"
          },
          { internalType: "bytes32", name: "userOpHash", type: "bytes32" },
          { internalType: "uint256", name: "prefund", type: "uint256" },
          { internalType: "uint256", name: "contextOffset", type: "uint256" },
          { internalType: "uint256", name: "preOpGas", type: "uint256" }
        ],
        internalType: "struct EntryPoint.UserOpInfo",
        name: "opInfo",
        type: "tuple"
      },
      { internalType: "bytes", name: "context", type: "bytes" }
    ],
    name: "innerHandleOp",
    outputs: [
      { internalType: "uint256", name: "actualGasCost", type: "uint256" }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "uint192", name: "", type: "uint192" }
    ],
    name: "nonceSequenceNumber",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "unlockStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address payable",
        name: "withdrawAddress",
        type: "address"
      }
    ],
    name: "withdrawStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address payable",
        name: "withdrawAddress",
        type: "address"
      },
      { internalType: "uint256", name: "withdrawAmount", type: "uint256" }
    ],
    name: "withdrawTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
];

// node_modules/@biconomy/abstractjs/dist/_esm/constants/abi/TokenWithPermitAbi.js
var TokenWithPermitAbi = [
  {
    inputs: [
      {
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        internalType: "string",
        name: "symbol",
        type: "string"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "ECDSAInvalidSignature",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "length",
        type: "uint256"
      }
    ],
    name: "ECDSAInvalidSignatureLength",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "ECDSAInvalidSignatureS",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      }
    ],
    name: "ERC1271InvalidSigner",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "allowance",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "needed",
        type: "uint256"
      }
    ],
    name: "ERC20InsufficientAllowance",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "balance",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "needed",
        type: "uint256"
      }
    ],
    name: "ERC20InsufficientBalance",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "approver",
        type: "address"
      }
    ],
    name: "ERC20InvalidApprover",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      }
    ],
    name: "ERC20InvalidReceiver",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "ERC20InvalidSender",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "ERC20InvalidSpender",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      }
    ],
    name: "ERC2612ExpiredSignature",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "signer",
        type: "address"
      },
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "ERC2612InvalidSigner",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "currentNonce",
        type: "uint256"
      }
    ],
    name: "InvalidAccountNonce",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidShortString",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "str",
        type: "string"
      }
    ],
    name: "StringTooLong",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [],
    name: "EIP712DomainChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "PERMIT_TYPEHASH_LOCAL",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      {
        internalType: "bytes1",
        name: "fields",
        type: "bytes1"
      },
      {
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        internalType: "string",
        name: "version",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "verifyingContract",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "salt",
        type: "bytes32"
      },
      {
        internalType: "uint256[]",
        name: "extensions",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "mint",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "version",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "nonces",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "permit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "permitWith1271",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@biconomy/abstractjs/dist/_esm/constants/abi/AccountFactory.js
var AccountFactoryAbi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "implementation_",
        type: "address"
      },
      {
        internalType: "address",
        name: "owner_",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "AccountAlreadyDeployed",
    type: "error"
  },
  {
    inputs: [],
    name: "AlreadyInitialized",
    type: "error"
  },
  {
    inputs: [],
    name: "ImplementationAddressCanNotBeZero",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidEntryPointAddress",
    type: "error"
  },
  {
    inputs: [],
    name: "NewOwnerIsZeroAddress",
    type: "error"
  },
  {
    inputs: [],
    name: "NoHandoverRequest",
    type: "error"
  },
  {
    inputs: [],
    name: "Unauthorized",
    type: "error"
  },
  {
    inputs: [],
    name: "ZeroAddressNotAllowed",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "bytes",
        name: "initData",
        type: "bytes"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "salt",
        type: "bytes32"
      }
    ],
    name: "AccountCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "pendingOwner",
        type: "address"
      }
    ],
    name: "OwnershipHandoverCanceled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "pendingOwner",
        type: "address"
      }
    ],
    name: "OwnershipHandoverRequested",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "oldOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    inputs: [],
    name: "ACCOUNT_IMPLEMENTATION",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "epAddress",
        type: "address"
      },
      {
        internalType: "uint32",
        name: "unstakeDelaySec",
        type: "uint32"
      }
    ],
    name: "addStake",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "cancelOwnershipHandover",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "pendingOwner",
        type: "address"
      }
    ],
    name: "completeOwnershipHandover",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "initData",
        type: "bytes"
      },
      {
        internalType: "bytes32",
        name: "salt",
        type: "bytes32"
      }
    ],
    name: "computeAccountAddress",
    outputs: [
      {
        internalType: "address payable",
        name: "expectedAddress",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "initData",
        type: "bytes"
      },
      {
        internalType: "bytes32",
        name: "salt",
        type: "bytes32"
      }
    ],
    name: "createAccount",
    outputs: [
      {
        internalType: "address payable",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "result",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "pendingOwner",
        type: "address"
      }
    ],
    name: "ownershipHandoverExpiresAt",
    outputs: [
      {
        internalType: "uint256",
        name: "result",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "requestOwnershipHandover",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "epAddress",
        type: "address"
      }
    ],
    name: "unlockStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "epAddress",
        type: "address"
      },
      {
        internalType: "address payable",
        name: "withdrawAddress",
        type: "address"
      }
    ],
    name: "withdrawStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@biconomy/abstractjs/dist/_esm/constants/abi/NexusBootstrapAbi.js
var NexusBootstrapAbi = [
  {
    type: "constructor",
    inputs: [
      {
        name: "defaultValidator",
        type: "address",
        internalType: "address"
      },
      {
        name: "initData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "error",
    name: "CanNotRemoveLastValidator",
    inputs: []
  },
  {
    type: "error",
    name: "DefaultValidatorAlreadyInstalled",
    inputs: []
  },
  {
    type: "error",
    name: "EmergencyUninstallSigError",
    inputs: []
  },
  {
    type: "error",
    name: "EnableModeSigError",
    inputs: []
  },
  {
    type: "error",
    name: "FallbackAlreadyInstalledForSelector",
    inputs: [
      {
        name: "selector",
        type: "bytes4",
        internalType: "bytes4"
      }
    ]
  },
  {
    type: "error",
    name: "FallbackCallTypeInvalid",
    inputs: []
  },
  {
    type: "error",
    name: "FallbackHandlerUninstallFailed",
    inputs: []
  },
  {
    type: "error",
    name: "FallbackNotInstalledForSelector",
    inputs: [
      {
        name: "selector",
        type: "bytes4",
        internalType: "bytes4"
      }
    ]
  },
  {
    type: "error",
    name: "FallbackSelectorForbidden",
    inputs: []
  },
  {
    type: "error",
    name: "HookAlreadyInstalled",
    inputs: [
      {
        name: "currentHook",
        type: "address",
        internalType: "address"
      }
    ]
  },
  {
    type: "error",
    name: "HookPostCheckFailed",
    inputs: []
  },
  {
    type: "error",
    name: "InvalidInput",
    inputs: []
  },
  {
    type: "error",
    name: "InvalidModule",
    inputs: [
      {
        name: "module",
        type: "address",
        internalType: "address"
      }
    ]
  },
  {
    type: "error",
    name: "InvalidModuleTypeId",
    inputs: [
      {
        name: "moduleTypeId",
        type: "uint256",
        internalType: "uint256"
      }
    ]
  },
  {
    type: "error",
    name: "InvalidNonce",
    inputs: []
  },
  {
    type: "error",
    name: "LinkedList_AlreadyInitialized",
    inputs: []
  },
  {
    type: "error",
    name: "LinkedList_EntryAlreadyInList",
    inputs: [
      {
        name: "entry",
        type: "address",
        internalType: "address"
      }
    ]
  },
  {
    type: "error",
    name: "LinkedList_InvalidEntry",
    inputs: [
      {
        name: "entry",
        type: "address",
        internalType: "address"
      }
    ]
  },
  {
    type: "error",
    name: "LinkedList_InvalidPage",
    inputs: []
  },
  {
    type: "error",
    name: "MismatchModuleTypeId",
    inputs: []
  },
  {
    type: "error",
    name: "MissingFallbackHandler",
    inputs: [
      {
        name: "selector",
        type: "bytes4",
        internalType: "bytes4"
      }
    ]
  },
  {
    type: "error",
    name: "ModuleAddressCanNotBeZero",
    inputs: []
  },
  {
    type: "error",
    name: "ModuleAlreadyInstalled",
    inputs: [
      {
        name: "moduleTypeId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "module",
        type: "address",
        internalType: "address"
      }
    ]
  },
  {
    type: "error",
    name: "ModuleNotInstalled",
    inputs: [
      {
        name: "moduleTypeId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "module",
        type: "address",
        internalType: "address"
      }
    ]
  },
  {
    type: "error",
    name: "NoValidatorInstalled",
    inputs: []
  },
  {
    type: "error",
    name: "PrevalidationHookAlreadyInstalled",
    inputs: [
      {
        name: "currentPreValidationHook",
        type: "address",
        internalType: "address"
      }
    ]
  },
  {
    type: "error",
    name: "UnauthorizedOperation",
    inputs: [
      {
        name: "operator",
        type: "address",
        internalType: "address"
      }
    ]
  },
  {
    type: "error",
    name: "UnsupportedCallType",
    inputs: [
      {
        name: "callType",
        type: "bytes1",
        internalType: "CallType"
      }
    ]
  },
  {
    type: "error",
    name: "ValidatorNotInstalled",
    inputs: [
      {
        name: "module",
        type: "address",
        internalType: "address"
      }
    ]
  },
  {
    type: "event",
    name: "ERC7484RegistryConfigured",
    inputs: [
      {
        name: "registry",
        type: "address",
        indexed: true,
        internalType: "contract IERC7484"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "ModuleInstalled",
    inputs: [
      {
        name: "moduleTypeId",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "module",
        type: "address",
        indexed: false,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "ModuleUninstalled",
    inputs: [
      {
        name: "moduleTypeId",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "module",
        type: "address",
        indexed: false,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "fallback",
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "eip712Domain",
    inputs: [],
    outputs: [
      {
        name: "fields",
        type: "bytes1",
        internalType: "bytes1"
      },
      {
        name: "name",
        type: "string",
        internalType: "string"
      },
      {
        name: "version",
        type: "string",
        internalType: "string"
      },
      {
        name: "chainId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "verifyingContract",
        type: "address",
        internalType: "address"
      },
      {
        name: "salt",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "extensions",
        type: "uint256[]",
        internalType: "uint256[]"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getActiveHook",
    inputs: [],
    outputs: [
      {
        name: "hook",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getExecutorsPaginated",
    inputs: [
      {
        name: "cursor",
        type: "address",
        internalType: "address"
      },
      {
        name: "size",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "array",
        type: "address[]",
        internalType: "address[]"
      },
      {
        name: "next",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getFallbackHandlerBySelector",
    inputs: [
      {
        name: "selector",
        type: "bytes4",
        internalType: "bytes4"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes1",
        internalType: "CallType"
      },
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getRegistry",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "contract IERC7484"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getValidatorsPaginated",
    inputs: [
      {
        name: "cursor",
        type: "address",
        internalType: "address"
      },
      {
        name: "size",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "array",
        type: "address[]",
        internalType: "address[]"
      },
      {
        name: "next",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "initNexus",
    inputs: [
      {
        name: "validators",
        type: "tuple[]",
        internalType: "struct BootstrapConfig[]",
        components: [
          {
            name: "module",
            type: "address",
            internalType: "address"
          },
          {
            name: "data",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "executors",
        type: "tuple[]",
        internalType: "struct BootstrapConfig[]",
        components: [
          {
            name: "module",
            type: "address",
            internalType: "address"
          },
          {
            name: "data",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "hook",
        type: "tuple",
        internalType: "struct BootstrapConfig",
        components: [
          {
            name: "module",
            type: "address",
            internalType: "address"
          },
          {
            name: "data",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "fallbacks",
        type: "tuple[]",
        internalType: "struct BootstrapConfig[]",
        components: [
          {
            name: "module",
            type: "address",
            internalType: "address"
          },
          {
            name: "data",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "preValidationHooks",
        type: "tuple[]",
        internalType: "struct BootstrapPreValidationHookConfig[]",
        components: [
          {
            name: "hookType",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "module",
            type: "address",
            internalType: "address"
          },
          {
            name: "data",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "registryConfig",
        type: "tuple",
        internalType: "struct RegistryConfig",
        components: [
          {
            name: "registry",
            type: "address",
            internalType: "contract IERC7484"
          },
          {
            name: "attesters",
            type: "address[]",
            internalType: "address[]"
          },
          {
            name: "threshold",
            type: "uint8",
            internalType: "uint8"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "initNexusNoRegistry",
    inputs: [
      {
        name: "validators",
        type: "tuple[]",
        internalType: "struct BootstrapConfig[]",
        components: [
          {
            name: "module",
            type: "address",
            internalType: "address"
          },
          {
            name: "data",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "executors",
        type: "tuple[]",
        internalType: "struct BootstrapConfig[]",
        components: [
          {
            name: "module",
            type: "address",
            internalType: "address"
          },
          {
            name: "data",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "hook",
        type: "tuple",
        internalType: "struct BootstrapConfig",
        components: [
          {
            name: "module",
            type: "address",
            internalType: "address"
          },
          {
            name: "data",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "fallbacks",
        type: "tuple[]",
        internalType: "struct BootstrapConfig[]",
        components: [
          {
            name: "module",
            type: "address",
            internalType: "address"
          },
          {
            name: "data",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "preValidationHooks",
        type: "tuple[]",
        internalType: "struct BootstrapPreValidationHookConfig[]",
        components: [
          {
            name: "hookType",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "module",
            type: "address",
            internalType: "address"
          },
          {
            name: "data",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "initNexusScoped",
    inputs: [
      {
        name: "validators",
        type: "tuple[]",
        internalType: "struct BootstrapConfig[]",
        components: [
          {
            name: "module",
            type: "address",
            internalType: "address"
          },
          {
            name: "data",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "hook",
        type: "tuple",
        internalType: "struct BootstrapConfig",
        components: [
          {
            name: "module",
            type: "address",
            internalType: "address"
          },
          {
            name: "data",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "registryConfig",
        type: "tuple",
        internalType: "struct RegistryConfig",
        components: [
          {
            name: "registry",
            type: "address",
            internalType: "contract IERC7484"
          },
          {
            name: "attesters",
            type: "address[]",
            internalType: "address[]"
          },
          {
            name: "threshold",
            type: "uint8",
            internalType: "uint8"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "initNexusScopedNoRegistry",
    inputs: [
      {
        name: "validators",
        type: "tuple[]",
        internalType: "struct BootstrapConfig[]",
        components: [
          {
            name: "module",
            type: "address",
            internalType: "address"
          },
          {
            name: "data",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "hook",
        type: "tuple",
        internalType: "struct BootstrapConfig",
        components: [
          {
            name: "module",
            type: "address",
            internalType: "address"
          },
          {
            name: "data",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "initNexusWithDefaultValidator",
    inputs: [
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "initNexusWithDefaultValidatorAndOtherModules",
    inputs: [
      {
        name: "defaultValidatorInitData",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "executors",
        type: "tuple[]",
        internalType: "struct BootstrapConfig[]",
        components: [
          {
            name: "module",
            type: "address",
            internalType: "address"
          },
          {
            name: "data",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "hook",
        type: "tuple",
        internalType: "struct BootstrapConfig",
        components: [
          {
            name: "module",
            type: "address",
            internalType: "address"
          },
          {
            name: "data",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "fallbacks",
        type: "tuple[]",
        internalType: "struct BootstrapConfig[]",
        components: [
          {
            name: "module",
            type: "address",
            internalType: "address"
          },
          {
            name: "data",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "preValidationHooks",
        type: "tuple[]",
        internalType: "struct BootstrapPreValidationHookConfig[]",
        components: [
          {
            name: "hookType",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "module",
            type: "address",
            internalType: "address"
          },
          {
            name: "data",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "registryConfig",
        type: "tuple",
        internalType: "struct RegistryConfig",
        components: [
          {
            name: "registry",
            type: "address",
            internalType: "contract IERC7484"
          },
          {
            name: "attesters",
            type: "address[]",
            internalType: "address[]"
          },
          {
            name: "threshold",
            type: "uint8",
            internalType: "uint8"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "initNexusWithDefaultValidatorAndOtherModulesNoRegistry",
    inputs: [
      {
        name: "defaultValidatorInitData",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "validators",
        type: "tuple[]",
        internalType: "struct BootstrapConfig[]",
        components: [
          {
            name: "module",
            type: "address",
            internalType: "address"
          },
          {
            name: "data",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "executors",
        type: "tuple[]",
        internalType: "struct BootstrapConfig[]",
        components: [
          {
            name: "module",
            type: "address",
            internalType: "address"
          },
          {
            name: "data",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "hook",
        type: "tuple",
        internalType: "struct BootstrapConfig",
        components: [
          {
            name: "module",
            type: "address",
            internalType: "address"
          },
          {
            name: "data",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "fallbacks",
        type: "tuple[]",
        internalType: "struct BootstrapConfig[]",
        components: [
          {
            name: "module",
            type: "address",
            internalType: "address"
          },
          {
            name: "data",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "preValidationHooks",
        type: "tuple[]",
        internalType: "struct BootstrapPreValidationHookConfig[]",
        components: [
          {
            name: "hookType",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "module",
            type: "address",
            internalType: "address"
          },
          {
            name: "data",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "initNexusWithSingleValidator",
    inputs: [
      {
        name: "validator",
        type: "address",
        internalType: "address"
      },
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "registryConfig",
        type: "tuple",
        internalType: "struct RegistryConfig",
        components: [
          {
            name: "registry",
            type: "address",
            internalType: "contract IERC7484"
          },
          {
            name: "attesters",
            type: "address[]",
            internalType: "address[]"
          },
          {
            name: "threshold",
            type: "uint8",
            internalType: "uint8"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "initNexusWithSingleValidatorNoRegistry",
    inputs: [
      {
        name: "validator",
        type: "address",
        internalType: "address"
      },
      {
        name: "data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "installModule",
    inputs: [
      {
        name: "moduleTypeId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "module",
        type: "address",
        internalType: "address"
      },
      {
        name: "initData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "isModuleInstalled",
    inputs: [
      {
        name: "moduleTypeId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "module",
        type: "address",
        internalType: "address"
      },
      {
        name: "additionalContext",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [
      {
        name: "installed",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "uninstallModule",
    inputs: [
      {
        name: "moduleTypeId",
        type: "uint256",
        internalType: "uint256"
      },
      {
        name: "module",
        type: "address",
        internalType: "address"
      },
      {
        name: "deInitData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "receive",
    stateMutability: "payable"
  }
];

// node_modules/@biconomy/abstractjs/dist/_esm/constants/abi/AavePoolAbi.js
var AavePoolAbi = [
  {
    inputs: [
      {
        internalType: "contract IPoolAddressesProvider",
        name: "provider",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "reserve",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "backer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      { indexed: false, internalType: "uint256", name: "fee", type: "uint256" }
    ],
    name: "BackUnbacked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "reserve",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "onBehalfOf",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "enum DataTypes.InterestRateMode",
        name: "interestRateMode",
        type: "uint8"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "borrowRate",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint16",
        name: "referralCode",
        type: "uint16"
      }
    ],
    name: "Borrow",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "initiator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "enum DataTypes.InterestRateMode",
        name: "interestRateMode",
        type: "uint8"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "premium",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint16",
        name: "referralCode",
        type: "uint16"
      }
    ],
    name: "FlashLoan",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalDebt",
        type: "uint256"
      }
    ],
    name: "IsolationModeTotalDebtUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "collateralAsset",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "debtAsset",
        type: "address"
      },
      { indexed: true, internalType: "address", name: "user", type: "address" },
      {
        indexed: false,
        internalType: "uint256",
        name: "debtToCover",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "liquidatedCollateralAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "liquidator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "receiveAToken",
        type: "bool"
      }
    ],
    name: "LiquidationCall",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "reserve",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "onBehalfOf",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint16",
        name: "referralCode",
        type: "uint16"
      }
    ],
    name: "MintUnbacked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "reserve",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amountMinted",
        type: "uint256"
      }
    ],
    name: "MintedToTreasury",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "reserve",
        type: "address"
      },
      { indexed: true, internalType: "address", name: "user", type: "address" },
      {
        indexed: true,
        internalType: "address",
        name: "repayer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      { indexed: false, internalType: "bool", name: "useATokens", type: "bool" }
    ],
    name: "Repay",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "reserve",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "liquidityRate",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "stableBorrowRate",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "variableBorrowRate",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "liquidityIndex",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "variableBorrowIndex",
        type: "uint256"
      }
    ],
    name: "ReserveDataUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "reserve",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "liquidityRate",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "stableBorrowRate",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "variableBorrowRate",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "liquidityIndex",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "variableBorrowIndex",
        type: "uint256"
      }
    ],
    name: "ReserveDataUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "reserve",
        type: "address"
      },
      { indexed: true, internalType: "address", name: "user", type: "address" }
    ],
    name: "ReserveUsedAsCollateralDisabled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "reserve",
        type: "address"
      },
      { indexed: true, internalType: "address", name: "user", type: "address" }
    ],
    name: "ReserveUsedAsCollateralEnabled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "reserve",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "onBehalfOf",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint16",
        name: "referralCode",
        type: "uint16"
      }
    ],
    name: "Supply",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "user", type: "address" },
      {
        indexed: false,
        internalType: "uint8",
        name: "categoryId",
        type: "uint8"
      }
    ],
    name: "UserEModeSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "reserve",
        type: "address"
      },
      { indexed: true, internalType: "address", name: "user", type: "address" },
      { indexed: true, internalType: "address", name: "to", type: "address" },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Withdraw",
    type: "event"
  },
  {
    inputs: [],
    name: "ADDRESSES_PROVIDER",
    outputs: [
      {
        internalType: "contract IPoolAddressesProvider",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "BRIDGE_PROTOCOL_FEE",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "FLASHLOAN_PREMIUM_TOTAL",
    outputs: [{ internalType: "uint128", name: "", type: "uint128" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "FLASHLOAN_PREMIUM_TO_PROTOCOL",
    outputs: [{ internalType: "uint128", name: "", type: "uint128" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "MAX_NUMBER_RESERVES",
    outputs: [{ internalType: "uint16", name: "", type: "uint16" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "POOL_REVISION",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "fee", type: "uint256" }
    ],
    name: "backUnbacked",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "interestRateMode", type: "uint256" },
      { internalType: "uint16", name: "referralCode", type: "uint16" },
      { internalType: "address", name: "onBehalfOf", type: "address" }
    ],
    name: "borrow",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes32", name: "args", type: "bytes32" }],
    name: "borrow",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint8", name: "id", type: "uint8" },
      {
        components: [
          { internalType: "uint16", name: "ltv", type: "uint16" },
          {
            internalType: "uint16",
            name: "liquidationThreshold",
            type: "uint16"
          },
          { internalType: "uint16", name: "liquidationBonus", type: "uint16" },
          { internalType: "string", name: "label", type: "string" }
        ],
        internalType: "struct DataTypes.EModeCategoryBaseConfiguration",
        name: "category",
        type: "tuple"
      }
    ],
    name: "configureEModeCategory",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint8", name: "id", type: "uint8" },
      { internalType: "uint128", name: "borrowableBitmap", type: "uint128" }
    ],
    name: "configureEModeCategoryBorrowableBitmap",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint8", name: "id", type: "uint8" },
      { internalType: "uint128", name: "collateralBitmap", type: "uint128" }
    ],
    name: "configureEModeCategoryCollateralBitmap",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "address", name: "onBehalfOf", type: "address" },
      { internalType: "uint16", name: "referralCode", type: "uint16" }
    ],
    name: "deposit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "asset", type: "address" }],
    name: "dropReserve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "balanceFromBefore", type: "uint256" },
      { internalType: "uint256", name: "balanceToBefore", type: "uint256" }
    ],
    name: "finalizeTransfer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "receiverAddress", type: "address" },
      { internalType: "address[]", name: "assets", type: "address[]" },
      { internalType: "uint256[]", name: "amounts", type: "uint256[]" },
      {
        internalType: "uint256[]",
        name: "interestRateModes",
        type: "uint256[]"
      },
      { internalType: "address", name: "onBehalfOf", type: "address" },
      { internalType: "bytes", name: "params", type: "bytes" },
      { internalType: "uint16", name: "referralCode", type: "uint16" }
    ],
    name: "flashLoan",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "receiverAddress", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "bytes", name: "params", type: "bytes" },
      { internalType: "uint16", name: "referralCode", type: "uint16" }
    ],
    name: "flashLoanSimple",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "getBorrowLogic",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "getBridgeLogic",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "asset", type: "address" }],
    name: "getConfiguration",
    outputs: [
      {
        components: [
          { internalType: "uint256", name: "data", type: "uint256" }
        ],
        internalType: "struct DataTypes.ReserveConfigurationMap",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint8", name: "id", type: "uint8" }],
    name: "getEModeCategoryBorrowableBitmap",
    outputs: [{ internalType: "uint128", name: "", type: "uint128" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint8", name: "id", type: "uint8" }],
    name: "getEModeCategoryCollateralBitmap",
    outputs: [{ internalType: "uint128", name: "", type: "uint128" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint8", name: "id", type: "uint8" }],
    name: "getEModeCategoryCollateralConfig",
    outputs: [
      {
        components: [
          { internalType: "uint16", name: "ltv", type: "uint16" },
          {
            internalType: "uint16",
            name: "liquidationThreshold",
            type: "uint16"
          },
          { internalType: "uint16", name: "liquidationBonus", type: "uint16" }
        ],
        internalType: "struct DataTypes.CollateralConfig",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint8", name: "id", type: "uint8" }],
    name: "getEModeCategoryData",
    outputs: [
      {
        components: [
          { internalType: "uint16", name: "ltv", type: "uint16" },
          {
            internalType: "uint16",
            name: "liquidationThreshold",
            type: "uint16"
          },
          { internalType: "uint16", name: "liquidationBonus", type: "uint16" },
          { internalType: "address", name: "priceSource", type: "address" },
          { internalType: "string", name: "label", type: "string" }
        ],
        internalType: "struct DataTypes.EModeCategoryLegacy",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint8", name: "id", type: "uint8" }],
    name: "getEModeCategoryLabel",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getEModeLogic",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "getFlashLoanLogic",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "asset", type: "address" }],
    name: "getLiquidationGracePeriod",
    outputs: [{ internalType: "uint40", name: "", type: "uint40" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "getLiquidationLogic",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "getPoolLogic",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint16", name: "id", type: "uint16" }],
    name: "getReserveAddressById",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "asset", type: "address" }],
    name: "getReserveData",
    outputs: [
      {
        components: [
          {
            components: [
              { internalType: "uint256", name: "data", type: "uint256" }
            ],
            internalType: "struct DataTypes.ReserveConfigurationMap",
            name: "configuration",
            type: "tuple"
          },
          { internalType: "uint128", name: "liquidityIndex", type: "uint128" },
          {
            internalType: "uint128",
            name: "currentLiquidityRate",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "variableBorrowIndex",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "currentVariableBorrowRate",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "currentStableBorrowRate",
            type: "uint128"
          },
          {
            internalType: "uint40",
            name: "lastUpdateTimestamp",
            type: "uint40"
          },
          { internalType: "uint16", name: "id", type: "uint16" },
          { internalType: "address", name: "aTokenAddress", type: "address" },
          {
            internalType: "address",
            name: "stableDebtTokenAddress",
            type: "address"
          },
          {
            internalType: "address",
            name: "variableDebtTokenAddress",
            type: "address"
          },
          {
            internalType: "address",
            name: "interestRateStrategyAddress",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "accruedToTreasury",
            type: "uint128"
          },
          { internalType: "uint128", name: "unbacked", type: "uint128" },
          {
            internalType: "uint128",
            name: "isolationModeTotalDebt",
            type: "uint128"
          }
        ],
        internalType: "struct DataTypes.ReserveDataLegacy",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "asset", type: "address" }],
    name: "getReserveDataExtended",
    outputs: [
      {
        components: [
          {
            components: [
              { internalType: "uint256", name: "data", type: "uint256" }
            ],
            internalType: "struct DataTypes.ReserveConfigurationMap",
            name: "configuration",
            type: "tuple"
          },
          { internalType: "uint128", name: "liquidityIndex", type: "uint128" },
          {
            internalType: "uint128",
            name: "currentLiquidityRate",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "variableBorrowIndex",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "currentVariableBorrowRate",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "__deprecatedStableBorrowRate",
            type: "uint128"
          },
          {
            internalType: "uint40",
            name: "lastUpdateTimestamp",
            type: "uint40"
          },
          { internalType: "uint16", name: "id", type: "uint16" },
          {
            internalType: "uint40",
            name: "liquidationGracePeriodUntil",
            type: "uint40"
          },
          { internalType: "address", name: "aTokenAddress", type: "address" },
          {
            internalType: "address",
            name: "__deprecatedStableDebtTokenAddress",
            type: "address"
          },
          {
            internalType: "address",
            name: "variableDebtTokenAddress",
            type: "address"
          },
          {
            internalType: "address",
            name: "interestRateStrategyAddress",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "accruedToTreasury",
            type: "uint128"
          },
          { internalType: "uint128", name: "unbacked", type: "uint128" },
          {
            internalType: "uint128",
            name: "isolationModeTotalDebt",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "virtualUnderlyingBalance",
            type: "uint128"
          }
        ],
        internalType: "struct DataTypes.ReserveData",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "asset", type: "address" }],
    name: "getReserveNormalizedIncome",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "asset", type: "address" }],
    name: "getReserveNormalizedVariableDebt",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getReservesCount",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getReservesList",
    outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getSupplyLogic",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "user", type: "address" }],
    name: "getUserAccountData",
    outputs: [
      { internalType: "uint256", name: "totalCollateralBase", type: "uint256" },
      { internalType: "uint256", name: "totalDebtBase", type: "uint256" },
      {
        internalType: "uint256",
        name: "availableBorrowsBase",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "currentLiquidationThreshold",
        type: "uint256"
      },
      { internalType: "uint256", name: "ltv", type: "uint256" },
      { internalType: "uint256", name: "healthFactor", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "user", type: "address" }],
    name: "getUserConfiguration",
    outputs: [
      {
        components: [
          { internalType: "uint256", name: "data", type: "uint256" }
        ],
        internalType: "struct DataTypes.UserConfigurationMap",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "user", type: "address" }],
    name: "getUserEMode",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "asset", type: "address" }],
    name: "getVirtualUnderlyingBalance",
    outputs: [{ internalType: "uint128", name: "", type: "uint128" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "address", name: "aTokenAddress", type: "address" },
      { internalType: "address", name: "variableDebtAddress", type: "address" },
      {
        internalType: "address",
        name: "interestRateStrategyAddress",
        type: "address"
      }
    ],
    name: "initReserve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IPoolAddressesProvider",
        name: "provider",
        type: "address"
      }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "collateralAsset", type: "address" },
      { internalType: "address", name: "debtAsset", type: "address" },
      { internalType: "address", name: "user", type: "address" },
      { internalType: "uint256", name: "debtToCover", type: "uint256" },
      { internalType: "bool", name: "receiveAToken", type: "bool" }
    ],
    name: "liquidationCall",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "args1", type: "bytes32" },
      { internalType: "bytes32", name: "args2", type: "bytes32" }
    ],
    name: "liquidationCall",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address[]", name: "assets", type: "address[]" }],
    name: "mintToTreasury",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "address", name: "onBehalfOf", type: "address" },
      { internalType: "uint16", name: "referralCode", type: "uint16" }
    ],
    name: "mintUnbacked",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes32", name: "args", type: "bytes32" }],
    name: "repay",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "interestRateMode", type: "uint256" },
      { internalType: "address", name: "onBehalfOf", type: "address" }
    ],
    name: "repay",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "interestRateMode", type: "uint256" }
    ],
    name: "repayWithATokens",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes32", name: "args", type: "bytes32" }],
    name: "repayWithATokens",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "args", type: "bytes32" },
      { internalType: "bytes32", name: "r", type: "bytes32" },
      { internalType: "bytes32", name: "s", type: "bytes32" }
    ],
    name: "repayWithPermit",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "interestRateMode", type: "uint256" },
      { internalType: "address", name: "onBehalfOf", type: "address" },
      { internalType: "uint256", name: "deadline", type: "uint256" },
      { internalType: "uint8", name: "permitV", type: "uint8" },
      { internalType: "bytes32", name: "permitR", type: "bytes32" },
      { internalType: "bytes32", name: "permitS", type: "bytes32" }
    ],
    name: "repayWithPermit",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "rescueTokens",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "asset", type: "address" }],
    name: "resetIsolationModeTotalDebt",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      {
        components: [
          { internalType: "uint256", name: "data", type: "uint256" }
        ],
        internalType: "struct DataTypes.ReserveConfigurationMap",
        name: "configuration",
        type: "tuple"
      }
    ],
    name: "setConfiguration",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint40", name: "until", type: "uint40" }
    ],
    name: "setLiquidationGracePeriod",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "address", name: "rateStrategyAddress", type: "address" }
    ],
    name: "setReserveInterestRateStrategyAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint8", name: "categoryId", type: "uint8" }],
    name: "setUserEMode",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes32", name: "args", type: "bytes32" }],
    name: "setUserUseReserveAsCollateral",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "bool", name: "useAsCollateral", type: "bool" }
    ],
    name: "setUserUseReserveAsCollateral",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "address", name: "onBehalfOf", type: "address" },
      { internalType: "uint16", name: "referralCode", type: "uint16" }
    ],
    name: "supply",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes32", name: "args", type: "bytes32" }],
    name: "supply",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "address", name: "onBehalfOf", type: "address" },
      { internalType: "uint16", name: "referralCode", type: "uint16" },
      { internalType: "uint256", name: "deadline", type: "uint256" },
      { internalType: "uint8", name: "permitV", type: "uint8" },
      { internalType: "bytes32", name: "permitR", type: "bytes32" },
      { internalType: "bytes32", name: "permitS", type: "bytes32" }
    ],
    name: "supplyWithPermit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "args", type: "bytes32" },
      { internalType: "bytes32", name: "r", type: "bytes32" },
      { internalType: "bytes32", name: "s", type: "bytes32" }
    ],
    name: "supplyWithPermit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "asset", type: "address" }],
    name: "syncIndexesState",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "asset", type: "address" }],
    name: "syncRatesState",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "protocolFee", type: "uint256" }],
    name: "updateBridgeProtocolFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint128",
        name: "flashLoanPremiumTotal",
        type: "uint128"
      },
      {
        internalType: "uint128",
        name: "flashLoanPremiumToProtocol",
        type: "uint128"
      }
    ],
    name: "updateFlashloanPremiums",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "address", name: "to", type: "address" }
    ],
    name: "withdraw",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes32", name: "args", type: "bytes32" }],
    name: "withdraw",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@biconomy/abstractjs/dist/_esm/constants/abi/UniswapSwapRouterAbi.js
var UniswapSwapRouterAbi = [
  {
    inputs: [
      { internalType: "address", name: "_factoryV2", type: "address" },
      { internalType: "address", name: "factoryV3", type: "address" },
      { internalType: "address", name: "_positionManager", type: "address" },
      { internalType: "address", name: "_WETH9", type: "address" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "WETH9",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "token", type: "address" }],
    name: "approveMax",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "token", type: "address" }],
    name: "approveMaxMinusOne",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "token", type: "address" }],
    name: "approveZeroThenMax",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "token", type: "address" }],
    name: "approveZeroThenMaxMinusOne",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes", name: "data", type: "bytes" }],
    name: "callPositionManager",
    outputs: [{ internalType: "bytes", name: "result", type: "bytes" }],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes[]", name: "paths", type: "bytes[]" },
      { internalType: "uint128[]", name: "amounts", type: "uint128[]" },
      { internalType: "uint24", name: "maximumTickDivergence", type: "uint24" },
      { internalType: "uint32", name: "secondsAgo", type: "uint32" }
    ],
    name: "checkOracleSlippage",
    outputs: [],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes", name: "path", type: "bytes" },
      { internalType: "uint24", name: "maximumTickDivergence", type: "uint24" },
      { internalType: "uint32", name: "secondsAgo", type: "uint32" }
    ],
    name: "checkOracleSlippage",
    outputs: [],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "bytes", name: "path", type: "bytes" },
          { internalType: "address", name: "recipient", type: "address" },
          { internalType: "uint256", name: "amountIn", type: "uint256" },
          { internalType: "uint256", name: "amountOutMinimum", type: "uint256" }
        ],
        internalType: "struct IV3SwapRouter.ExactInputParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "exactInput",
    outputs: [{ internalType: "uint256", name: "amountOut", type: "uint256" }],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "tokenIn", type: "address" },
          { internalType: "address", name: "tokenOut", type: "address" },
          { internalType: "uint24", name: "fee", type: "uint24" },
          { internalType: "address", name: "recipient", type: "address" },
          { internalType: "uint256", name: "amountIn", type: "uint256" },
          {
            internalType: "uint256",
            name: "amountOutMinimum",
            type: "uint256"
          },
          {
            internalType: "uint160",
            name: "sqrtPriceLimitX96",
            type: "uint160"
          }
        ],
        internalType: "struct IV3SwapRouter.ExactInputSingleParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "exactInputSingle",
    outputs: [{ internalType: "uint256", name: "amountOut", type: "uint256" }],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "bytes", name: "path", type: "bytes" },
          { internalType: "address", name: "recipient", type: "address" },
          { internalType: "uint256", name: "amountOut", type: "uint256" },
          { internalType: "uint256", name: "amountInMaximum", type: "uint256" }
        ],
        internalType: "struct IV3SwapRouter.ExactOutputParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "exactOutput",
    outputs: [{ internalType: "uint256", name: "amountIn", type: "uint256" }],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "tokenIn", type: "address" },
          { internalType: "address", name: "tokenOut", type: "address" },
          { internalType: "uint24", name: "fee", type: "uint24" },
          { internalType: "address", name: "recipient", type: "address" },
          { internalType: "uint256", name: "amountOut", type: "uint256" },
          { internalType: "uint256", name: "amountInMaximum", type: "uint256" },
          {
            internalType: "uint160",
            name: "sqrtPriceLimitX96",
            type: "uint160"
          }
        ],
        internalType: "struct IV3SwapRouter.ExactOutputSingleParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "exactOutputSingle",
    outputs: [{ internalType: "uint256", name: "amountIn", type: "uint256" }],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "factory",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "factoryV2",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "getApprovalType",
    outputs: [
      {
        internalType: "enum IApproveAndCall.ApprovalType",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "token0", type: "address" },
          { internalType: "address", name: "token1", type: "address" },
          { internalType: "uint256", name: "tokenId", type: "uint256" },
          { internalType: "uint256", name: "amount0Min", type: "uint256" },
          { internalType: "uint256", name: "amount1Min", type: "uint256" }
        ],
        internalType: "struct IApproveAndCall.IncreaseLiquidityParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "increaseLiquidity",
    outputs: [{ internalType: "bytes", name: "result", type: "bytes" }],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "token0", type: "address" },
          { internalType: "address", name: "token1", type: "address" },
          { internalType: "uint24", name: "fee", type: "uint24" },
          { internalType: "int24", name: "tickLower", type: "int24" },
          { internalType: "int24", name: "tickUpper", type: "int24" },
          { internalType: "uint256", name: "amount0Min", type: "uint256" },
          { internalType: "uint256", name: "amount1Min", type: "uint256" },
          { internalType: "address", name: "recipient", type: "address" }
        ],
        internalType: "struct IApproveAndCall.MintParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "mint",
    outputs: [{ internalType: "bytes", name: "result", type: "bytes" }],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "previousBlockhash", type: "bytes32" },
      { internalType: "bytes[]", name: "data", type: "bytes[]" }
    ],
    name: "multicall",
    outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "deadline", type: "uint256" },
      { internalType: "bytes[]", name: "data", type: "bytes[]" }
    ],
    name: "multicall",
    outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }],
    name: "multicall",
    outputs: [{ internalType: "bytes[]", name: "results", type: "bytes[]" }],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "positionManager",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "pull",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "refundETH",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" },
      { internalType: "uint8", name: "v", type: "uint8" },
      { internalType: "bytes32", name: "r", type: "bytes32" },
      { internalType: "bytes32", name: "s", type: "bytes32" }
    ],
    name: "selfPermit",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "nonce", type: "uint256" },
      { internalType: "uint256", name: "expiry", type: "uint256" },
      { internalType: "uint8", name: "v", type: "uint8" },
      { internalType: "bytes32", name: "r", type: "bytes32" },
      { internalType: "bytes32", name: "s", type: "bytes32" }
    ],
    name: "selfPermitAllowed",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "nonce", type: "uint256" },
      { internalType: "uint256", name: "expiry", type: "uint256" },
      { internalType: "uint8", name: "v", type: "uint8" },
      { internalType: "bytes32", name: "r", type: "bytes32" },
      { internalType: "bytes32", name: "s", type: "bytes32" }
    ],
    name: "selfPermitAllowedIfNecessary",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" },
      { internalType: "uint8", name: "v", type: "uint8" },
      { internalType: "bytes32", name: "r", type: "bytes32" },
      { internalType: "bytes32", name: "s", type: "bytes32" }
    ],
    name: "selfPermitIfNecessary",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "amountIn", type: "uint256" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "address[]", name: "path", type: "address[]" },
      { internalType: "address", name: "to", type: "address" }
    ],
    name: "swapExactTokensForTokens",
    outputs: [{ internalType: "uint256", name: "amountOut", type: "uint256" }],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "amountOut", type: "uint256" },
      { internalType: "uint256", name: "amountInMax", type: "uint256" },
      { internalType: "address[]", name: "path", type: "address[]" },
      { internalType: "address", name: "to", type: "address" }
    ],
    name: "swapTokensForExactTokens",
    outputs: [{ internalType: "uint256", name: "amountIn", type: "uint256" }],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amountMinimum", type: "uint256" },
      { internalType: "address", name: "recipient", type: "address" }
    ],
    name: "sweepToken",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amountMinimum", type: "uint256" }
    ],
    name: "sweepToken",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amountMinimum", type: "uint256" },
      { internalType: "uint256", name: "feeBips", type: "uint256" },
      { internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "sweepTokenWithFee",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amountMinimum", type: "uint256" },
      { internalType: "address", name: "recipient", type: "address" },
      { internalType: "uint256", name: "feeBips", type: "uint256" },
      { internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "sweepTokenWithFee",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "int256", name: "amount0Delta", type: "int256" },
      { internalType: "int256", name: "amount1Delta", type: "int256" },
      { internalType: "bytes", name: "_data", type: "bytes" }
    ],
    name: "uniswapV3SwapCallback",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "amountMinimum", type: "uint256" },
      { internalType: "address", name: "recipient", type: "address" }
    ],
    name: "unwrapWETH9",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "amountMinimum", type: "uint256" }
    ],
    name: "unwrapWETH9",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "amountMinimum", type: "uint256" },
      { internalType: "address", name: "recipient", type: "address" },
      { internalType: "uint256", name: "feeBips", type: "uint256" },
      { internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "unwrapWETH9WithFee",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "amountMinimum", type: "uint256" },
      { internalType: "uint256", name: "feeBips", type: "uint256" },
      { internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "unwrapWETH9WithFee",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "value", type: "uint256" }],
    name: "wrapETH",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
];

// node_modules/@biconomy/abstractjs/dist/_esm/constants/abi/ComposabilityAbi.js
var COMPOSABILITY_MODULE_ABI_V1_0_0 = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    inputs: [
      { internalType: "address", name: "smartAccount", type: "address" }
    ],
    name: "AlreadyInitialized",
    type: "error"
  },
  { inputs: [], name: "ComposableExecutionFailed", type: "error" },
  {
    inputs: [
      {
        internalType: "enum ConstraintType",
        name: "constraintType",
        type: "uint8"
      }
    ],
    name: "ConstraintNotMet",
    type: "error"
  },
  { inputs: [], name: "FailedToReturnMsgValue", type: "error" },
  { inputs: [], name: "InvalidConstraintType", type: "error" },
  { inputs: [], name: "InvalidOutputParamFetcherType", type: "error" },
  { inputs: [], name: "InvalidParameterEncoding", type: "error" },
  {
    inputs: [
      { internalType: "address", name: "smartAccount", type: "address" }
    ],
    name: "NotInitialized",
    type: "error"
  },
  { inputs: [], name: "OnlyEntryPointOrAccount", type: "error" },
  { inputs: [], name: "Output_StaticCallFailed", type: "error" },
  { inputs: [], name: "ZeroAddressNotAllowed", type: "error" },
  {
    inputs: [],
    name: "ENTRY_POINT_V07_ADDRESS",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "to", type: "address" },
          { internalType: "uint256", name: "value", type: "uint256" },
          { internalType: "bytes4", name: "functionSig", type: "bytes4" },
          {
            components: [
              {
                internalType: "enum InputParamFetcherType",
                name: "fetcherType",
                type: "uint8"
              },
              { internalType: "bytes", name: "paramData", type: "bytes" },
              {
                components: [
                  {
                    internalType: "enum ConstraintType",
                    name: "constraintType",
                    type: "uint8"
                  },
                  {
                    internalType: "bytes",
                    name: "referenceData",
                    type: "bytes"
                  }
                ],
                internalType: "struct Constraint[]",
                name: "constraints",
                type: "tuple[]"
              }
            ],
            internalType: "struct InputParam[]",
            name: "inputParams",
            type: "tuple[]"
          },
          {
            components: [
              {
                internalType: "enum OutputParamFetcherType",
                name: "fetcherType",
                type: "uint8"
              },
              { internalType: "bytes", name: "paramData", type: "bytes" }
            ],
            internalType: "struct OutputParam[]",
            name: "outputParams",
            type: "tuple[]"
          }
        ],
        internalType: "struct ComposableExecution[]",
        name: "executions",
        type: "tuple[]"
      }
    ],
    name: "executeComposable",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "to", type: "address" },
          { internalType: "uint256", name: "value", type: "uint256" },
          { internalType: "bytes4", name: "functionSig", type: "bytes4" },
          {
            components: [
              {
                internalType: "enum InputParamFetcherType",
                name: "fetcherType",
                type: "uint8"
              },
              { internalType: "bytes", name: "paramData", type: "bytes" },
              {
                components: [
                  {
                    internalType: "enum ConstraintType",
                    name: "constraintType",
                    type: "uint8"
                  },
                  {
                    internalType: "bytes",
                    name: "referenceData",
                    type: "bytes"
                  }
                ],
                internalType: "struct Constraint[]",
                name: "constraints",
                type: "tuple[]"
              }
            ],
            internalType: "struct InputParam[]",
            name: "inputParams",
            type: "tuple[]"
          },
          {
            components: [
              {
                internalType: "enum OutputParamFetcherType",
                name: "fetcherType",
                type: "uint8"
              },
              { internalType: "bytes", name: "paramData", type: "bytes" }
            ],
            internalType: "struct OutputParam[]",
            name: "outputParams",
            type: "tuple[]"
          }
        ],
        internalType: "struct ComposableExecution[]",
        name: "executions",
        type: "tuple[]"
      }
    ],
    name: "executeComposableCall",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "to", type: "address" },
          { internalType: "uint256", name: "value", type: "uint256" },
          { internalType: "bytes4", name: "functionSig", type: "bytes4" },
          {
            components: [
              {
                internalType: "enum InputParamFetcherType",
                name: "fetcherType",
                type: "uint8"
              },
              { internalType: "bytes", name: "paramData", type: "bytes" },
              {
                components: [
                  {
                    internalType: "enum ConstraintType",
                    name: "constraintType",
                    type: "uint8"
                  },
                  {
                    internalType: "bytes",
                    name: "referenceData",
                    type: "bytes"
                  }
                ],
                internalType: "struct Constraint[]",
                name: "constraints",
                type: "tuple[]"
              }
            ],
            internalType: "struct InputParam[]",
            name: "inputParams",
            type: "tuple[]"
          },
          {
            components: [
              {
                internalType: "enum OutputParamFetcherType",
                name: "fetcherType",
                type: "uint8"
              },
              { internalType: "bytes", name: "paramData", type: "bytes" }
            ],
            internalType: "struct OutputParam[]",
            name: "outputParams",
            type: "tuple[]"
          }
        ],
        internalType: "struct ComposableExecution[]",
        name: "executions",
        type: "tuple[]"
      }
    ],
    name: "executeComposableDelegateCall",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "getEntryPoint",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "isInitialized",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "moduleTypeId", type: "uint256" }
    ],
    name: "isModuleType",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes", name: "data", type: "bytes" }],
    name: "onInstall",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes", name: "data", type: "bytes" }],
    name: "onUninstall",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "_entryPoint", type: "address" }],
    name: "setEntryPoint",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
var COMPOSABILITY_MODULE_ABI_V1_1_0 = [
  {
    type: "constructor",
    inputs: [
      { name: "_defaultEpAddress", type: "address", internalType: "address" }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "DEFAULT_EP_ADDRESS",
    inputs: [],
    outputs: [{ name: "", type: "address", internalType: "address" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "executeComposable",
    inputs: [
      {
        name: "cExecutions",
        type: "tuple[]",
        internalType: "struct ComposableExecution[]",
        components: [
          { name: "functionSig", type: "bytes4", internalType: "bytes4" },
          {
            name: "inputParams",
            type: "tuple[]",
            internalType: "struct InputParam[]",
            components: [
              {
                name: "paramType",
                type: "uint8",
                internalType: "enum InputParamType"
              },
              {
                name: "fetcherType",
                type: "uint8",
                internalType: "enum InputParamFetcherType"
              },
              { name: "paramData", type: "bytes", internalType: "bytes" },
              {
                name: "constraints",
                type: "tuple[]",
                internalType: "struct Constraint[]",
                components: [
                  {
                    name: "constraintType",
                    type: "uint8",
                    internalType: "enum ConstraintType"
                  },
                  {
                    name: "referenceData",
                    type: "bytes",
                    internalType: "bytes"
                  }
                ]
              }
            ]
          },
          {
            name: "outputParams",
            type: "tuple[]",
            internalType: "struct OutputParam[]",
            components: [
              {
                name: "fetcherType",
                type: "uint8",
                internalType: "enum OutputParamFetcherType"
              },
              { name: "paramData", type: "bytes", internalType: "bytes" }
            ]
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "executeComposableCall",
    inputs: [
      {
        name: "cExecutions",
        type: "tuple[]",
        internalType: "struct ComposableExecution[]",
        components: [
          { name: "functionSig", type: "bytes4", internalType: "bytes4" },
          {
            name: "inputParams",
            type: "tuple[]",
            internalType: "struct InputParam[]",
            components: [
              {
                name: "paramType",
                type: "uint8",
                internalType: "enum InputParamType"
              },
              {
                name: "fetcherType",
                type: "uint8",
                internalType: "enum InputParamFetcherType"
              },
              { name: "paramData", type: "bytes", internalType: "bytes" },
              {
                name: "constraints",
                type: "tuple[]",
                internalType: "struct Constraint[]",
                components: [
                  {
                    name: "constraintType",
                    type: "uint8",
                    internalType: "enum ConstraintType"
                  },
                  {
                    name: "referenceData",
                    type: "bytes",
                    internalType: "bytes"
                  }
                ]
              }
            ]
          },
          {
            name: "outputParams",
            type: "tuple[]",
            internalType: "struct OutputParam[]",
            components: [
              {
                name: "fetcherType",
                type: "uint8",
                internalType: "enum OutputParamFetcherType"
              },
              { name: "paramData", type: "bytes", internalType: "bytes" }
            ]
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "executeComposableDelegateCall",
    inputs: [
      {
        name: "cExecutions",
        type: "tuple[]",
        internalType: "struct ComposableExecution[]",
        components: [
          { name: "functionSig", type: "bytes4", internalType: "bytes4" },
          {
            name: "inputParams",
            type: "tuple[]",
            internalType: "struct InputParam[]",
            components: [
              {
                name: "paramType",
                type: "uint8",
                internalType: "enum InputParamType"
              },
              {
                name: "fetcherType",
                type: "uint8",
                internalType: "enum InputParamFetcherType"
              },
              { name: "paramData", type: "bytes", internalType: "bytes" },
              {
                name: "constraints",
                type: "tuple[]",
                internalType: "struct Constraint[]",
                components: [
                  {
                    name: "constraintType",
                    type: "uint8",
                    internalType: "enum ConstraintType"
                  },
                  {
                    name: "referenceData",
                    type: "bytes",
                    internalType: "bytes"
                  }
                ]
              }
            ]
          },
          {
            name: "outputParams",
            type: "tuple[]",
            internalType: "struct OutputParam[]",
            components: [
              {
                name: "fetcherType",
                type: "uint8",
                internalType: "enum OutputParamFetcherType"
              },
              { name: "paramData", type: "bytes", internalType: "bytes" }
            ]
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "getEntryPoint",
    inputs: [{ name: "account", type: "address", internalType: "address" }],
    outputs: [{ name: "", type: "address", internalType: "address" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isInitialized",
    inputs: [{ name: "account", type: "address", internalType: "address" }],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isModuleType",
    inputs: [
      { name: "moduleTypeId", type: "uint256", internalType: "uint256" }
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "onInstall",
    inputs: [{ name: "data", type: "bytes", internalType: "bytes" }],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "onUninstall",
    inputs: [{ name: "data", type: "bytes", internalType: "bytes" }],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setEntryPoint",
    inputs: [{ name: "_entryPoint", type: "address", internalType: "address" }],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "error",
    name: "AlreadyInitialized",
    inputs: [{ name: "smartAccount", type: "address", internalType: "address" }]
  },
  { type: "error", name: "ComposableExecutionFailed", inputs: [] },
  {
    type: "error",
    name: "ConstraintNotMet",
    inputs: [
      {
        name: "constraintType",
        type: "uint8",
        internalType: "enum ConstraintType"
      }
    ]
  },
  { type: "error", name: "DelegateCallOnly", inputs: [] },
  { type: "error", name: "FailedToReturnMsgValue", inputs: [] },
  { type: "error", name: "InvalidConstraintType", inputs: [] },
  { type: "error", name: "InvalidOutputParamFetcherType", inputs: [] },
  {
    type: "error",
    name: "InvalidParameterEncoding",
    inputs: [{ name: "message", type: "string", internalType: "string" }]
  },
  {
    type: "error",
    name: "NotInitialized",
    inputs: [{ name: "smartAccount", type: "address", internalType: "address" }]
  },
  { type: "error", name: "OnlyEntryPointOrAccount", inputs: [] },
  { type: "error", name: "Output_StaticCallFailed", inputs: [] },
  { type: "error", name: "ZeroAddressNotAllowed", inputs: [] }
];

// node_modules/@biconomy/abstractjs/dist/_esm/constants/abi/ForwarderAbi.js
var ForwarderAbi = [
  { inputs: [], name: "ForwardFailed", type: "error" },
  { inputs: [], name: "UseForwardFunction", type: "error" },
  { inputs: [], name: "ZeroAddress", type: "error" },
  { stateMutability: "payable", type: "fallback" },
  {
    inputs: [{ internalType: "address", name: "destination", type: "address" }],
    name: "forward",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
];

// node_modules/@biconomy/abstractjs/dist/_esm/modules/utils/Types.js
var SafeHookType;
(function(SafeHookType3) {
  SafeHookType3[SafeHookType3["GLOBAL"] = 0] = "GLOBAL";
  SafeHookType3[SafeHookType3["SIG"] = 1] = "SIG";
})(SafeHookType || (SafeHookType = {}));

// node_modules/@biconomy/abstractjs/dist/_esm/account/utils/Utils.js
var isNullOrUndefined = (value) => {
  return value === null || value === void 0;
};
var isBigInt = (value) => {
  try {
    BigInt(value);
    return true;
  } catch {
    return false;
  }
};
var sanitizeUrl = (value) => {
  return value.replace(/https?:\/\/[^\s]+/g, "");
};
var addressEquals = (a, b) => !!a && !!b && a?.toLowerCase() === b.toLowerCase();
var isNativeToken = (tokenAddress) => addressEquals(tokenAddress, "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee") || addressEquals(tokenAddress, "0x0000000000000000000000000000000000000000");
function getTypesForEIP712Domain({ domain }) {
  return [
    typeof domain?.name === "string" && { name: "name", type: "string" },
    domain?.version && { name: "version", type: "string" },
    typeof domain?.chainId === "number" && {
      name: "chainId",
      type: "uint256"
    },
    domain?.verifyingContract && {
      name: "verifyingContract",
      type: "address"
    },
    domain?.salt && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
var eip712WrapHash = (typedHash, appDomainSeparator) => keccak256(concat(["0x1901", appDomainSeparator, typedHash]));
function typeToString(typeDef) {
  return Object.entries(typeDef).map(([key, fields]) => {
    const fieldStrings = (fields ?? []).map((field) => `${field.type} ${field.name}`).join(",");
    return `${key}(${fieldStrings})`;
  });
}
var getAccountDomainStructFields = async (publicClient, accountAddress) => {
  const accountDomainStructFields = await publicClient.readContract({
    address: accountAddress,
    abi: parseAbi([
      "function eip712Domain() public view returns (bytes1 fields, string memory name, string memory version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] memory extensions)"
    ]),
    functionName: "eip712Domain"
  });
  const [, name, version, chainId, verifyingContract, salt] = accountDomainStructFields;
  const params = parseAbiParameters([
    "bytes32",
    "bytes32",
    "uint256",
    "address",
    "bytes32"
  ]);
  return encodeAbiParameters(params, [
    keccak256(toBytes(name)),
    keccak256(toBytes(version)),
    chainId,
    verifyingContract,
    salt
  ]);
};
async function supportsCancun({ transport, chain }) {
  const cancunSupportedChains = {
    "1": true,
    "11155111": true,
    "8453": true,
    "84532": true,
    "137": true,
    "80002": true,
    "42161": true,
    "421614": true,
    "10": true,
    "11155420": true,
    "56": true,
    "97": true,
    "146": true,
    "57054": true,
    "534352": true,
    "534351": true,
    "100": true,
    "10200": true,
    "43114": true,
    "43113": true,
    "33139": true,
    "33111": true,
    "999": true,
    "1116": true,
    "267": true,
    "1329": true,
    "1328": true,
    "130": true,
    "1301": true,
    "747474": true,
    "1135": true,
    "480": true,
    "4801": true,
    "20993": true,
    "10143": true,
    "143": true,
    "88882": false
  };
  if (cancunSupportedChains[chain.id.toString()]) {
    return cancunSupportedChains[chain.id.toString()];
  }
  const client = createPublicClient({
    chain,
    transport
  });
  const block = await client.getBlock({
    blockTag: "latest"
  });
  if (block.blobGasUsed !== void 0 || block.excessBlobGas !== void 0) {
    return true;
  }
  return false;
}

// node_modules/@biconomy/abstractjs/dist/_esm/account/utils/AccountNotFound.js
var AccountNotFoundError2 = class extends BaseError {
  constructor({ docsPath } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."
    ].join("\n"), {
      docsPath,
      docsSlug: "account",
      name: "AccountNotFoundError"
    });
  }
};

// node_modules/@biconomy/abstractjs/dist/_esm/account/decorators/instructions/buildBatch.js
var buildBatch = async (baseParams, parameters) => {
  const { currentInstructions = [] } = baseParams;
  const { instructions } = parameters;
  if (instructions.length < 2) {
    throw new Error("A Batch must contain at least 2 instructions");
  }
  const resolvedInstructions = await resolveInstructions(instructions);
  if (resolvedInstructions.some(({ chainId }) => Number(chainId) !== Number(resolvedInstructions[0].chainId))) {
    throw new Error("All instructions must be on the same chain");
  }
  const isComposable = resolvedInstructions.some(({ isComposable: isComposable2 }) => isComposable2 === true);
  if (!resolvedInstructions.every((inx) => !!inx.isComposable === !!isComposable)) {
    throw new Error(`${isComposable ? "All the instructions must be built with buildComposable in order to support the runtime time parameters." : "All the instructions must be non composable when there are no runtime parameters"}`);
  }
  const calls = resolvedInstructions.flatMap(({ calls: calls2 }) => calls2);
  const metadata = resolvedInstructions.flatMap(({ metadata: metadata2 }) => metadata2 || []);
  return [
    ...currentInstructions,
    {
      calls: isComposable ? calls : calls,
      chainId: resolvedInstructions[0].chainId,
      // Batch instructions must be on the same chain
      isComposable,
      metadata
    }
  ];
};
var buildBatch_default = buildBatch;

// node_modules/@biconomy/abstractjs/dist/_esm/account/utils/batchInstructions.js
var batchInstructions = async (parameters) => {
  const { accountAddress, instructions, meeVersions } = parameters;
  const result = [];
  const batchesByChainId = /* @__PURE__ */ new Map();
  const chainIds = /* @__PURE__ */ new Set();
  for (const instruction of instructions) {
    const chainId = String(instruction.chainId);
    chainIds.add(chainId);
    const batch = batchesByChainId.get(chainId) || [];
    batch.push(instruction);
    batchesByChainId.set(chainId, batch);
  }
  for (const chainId of [...chainIds]) {
    const batch = batchesByChainId.get(chainId) || [];
    if (batch.length > 1) {
      const [batchedOp] = await buildBatch({ accountAddress, meeVersions }, { instructions: batch });
      result.push(batchedOp);
    } else {
      result.push(...batch);
    }
  }
  return result;
};

// node_modules/@rhinestone/module-sdk/_esm/account/api/getAccount.js
var getAccount = ({ address, initCode, type, deployedOnChains = [] }) => {
  return {
    address,
    initCode,
    type,
    deployedOnChains
  };
};

// node_modules/@rhinestone/module-sdk/_esm/constants.js
var ACCOUNT_LOCKER_HOOK = "0x29BDcBc36e344061393f8AB58D2D6AABaedeAaAE";
var ACCOUNT_LOCKER_SOURCE_EXECUTOR = "0xE1058634834E01038CadbaE8208BFfF81B1Ede51";
var ACCOUNT_LOCKER_TARGET_EXECUTOR = "0xA90F831363708B32a3f1502165253E0210cf680d";
var AUTO_SAVINGS_ADDRESS = "0x6AE48bD83B6bdc8489584Ea0814086f963d1BD95";
var COLD_STORAGE_FLASHLOAN_ADDRESS = "0x4422dbC3D055D59ee08F4A4D60E1046A9aFb287f";
var COLD_STORAGE_HOOK_ADDRESS = "0x7E31543b269632ddc55a23553f902f84C9DD8454";
var DEADMAN_SWITCH_ADDRESS = "0x8bAdE54bca47199B6732EB2F92318DD666bdE413";
var SMART_SESSIONS_FALLBACK_TARGET_FLAG = "0x0000000000000000000000000000000000000001";
var SMART_SESSIONS_FALLBACK_TARGET_SELECTOR_FLAG = "0x00000001";
var HOOK_MULTI_PLEXER_ADDRESS = "0xF6782ed057F95f334D04F0Af1Af4D14fb84DE549";
var INDEXER_URL = "https://indexer.bigdevenergy.link/c03b38d/v1/graphql";
var MULTI_FACTOR_VALIDATOR_ADDRESS = "0xf6bDf42c9BE18cEcA5C06c42A43DAf7FBbe7896b";
var OWNABLE_EXECUTOR_ADDRESS = "0x4Fd8d57b94966982B62e9588C27B4171B55E8354";
var OWNABLE_VALIDATOR_ADDRESS = "0x2483DA3A338895199E5e538530213157e931Bf06";
var REGISTRY_ADDRESS = "0x000000000069E2a187AEFFb852bF3cCdC95151B2";
var REGISTRY_HOOK_ADDRESS = "0x0ac6160DBA30d665cCA6e6b6a2CDf147DC3dED22";
var SCHEDULED_ORDERS_EXECUTOR_ADDRESS = "0x40dc90D670C89F322fa8b9f685770296428DCb6b";
var SCHEDULED_TRANSFERS_EXECUTOR_ADDRESS = "0xA8E374779aeE60413c974b484d6509c7E4DDb6bA";
var SMART_SESSIONS_ADDRESS = "0x00000000002B0eCfbD0496EE71e01257dA0E37DE";
var SMART_SESSIONS_COMPATIBILITY_FALLBACK_ADDRESS = "0xBad7E91C4F2803978cd6c7C3Fe80B5Fd7f7B0b50";
var SOCIAL_RECOVERY_ADDRESS = "0xA04D053b3C8021e8D5bF641816c42dAA75D8b597";
var SPENDING_LIMITS_POLICY_ADDRESS = "0x00000088D48cF102A8Cdb0137A9b173f957c6343";
var TIME_FRAME_POLICY_ADDRESS = "0x8177451511dE0577b911C254E9551D981C26dc72";
var SUDO_POLICY_ADDRESS = "0x0000003111cD8e92337C100F22B7A9dbf8DEE301";
var UNIVERSAL_ACTION_POLICY_ADDRESS = "0x0000006DDA6c463511C4e9B05CFc34C1247fCF1F";
var UNIVERSAL_EMAIL_RECOVERY_ADDRESS = "0x636632FA22052d2a4Fb6e3Bab84551B620b9C1F9";
var USAGE_LIMIT_POLICY_ADDRESS = "0x1F34eF8311345A3A4a4566aF321b313052F51493";
var VALUE_LIMIT_POLICY_ADDRESS = "0x730DA93267E7E513e932301B47F2ac7D062abC83";
var WEBAUTHN_VALIDATOR_ADDRESS = "0x2f167e55d42584f65e2e30a748f41ee75a311414";
var DEFAULT_CONSTANTS = {
  ACCOUNT_LOCKER_HOOK,
  ACCOUNT_LOCKER_SOURCE_EXECUTOR,
  ACCOUNT_LOCKER_TARGET_EXECUTOR,
  AUTO_SAVINGS_ADDRESS,
  COLD_STORAGE_FLASHLOAN_ADDRESS,
  COLD_STORAGE_HOOK_ADDRESS,
  DEADMAN_SWITCH_ADDRESS,
  SMART_SESSIONS_FALLBACK_TARGET_FLAG,
  SMART_SESSIONS_FALLBACK_TARGET_SELECTOR_FLAG,
  HOOK_MULTI_PLEXER_ADDRESS,
  INDEXER_URL,
  MULTI_FACTOR_VALIDATOR_ADDRESS,
  OWNABLE_EXECUTOR_ADDRESS,
  OWNABLE_VALIDATOR_ADDRESS,
  REGISTRY_ADDRESS,
  REGISTRY_HOOK_ADDRESS,
  SCHEDULED_ORDERS_EXECUTOR_ADDRESS,
  SCHEDULED_TRANSFERS_EXECUTOR_ADDRESS,
  SMART_SESSIONS_ADDRESS,
  SMART_SESSIONS_COMPATIBILITY_FALLBACK_ADDRESS,
  SOCIAL_RECOVERY_ADDRESS,
  SPENDING_LIMITS_POLICY_ADDRESS,
  TIME_FRAME_POLICY_ADDRESS,
  UNIVERSAL_ACTION_POLICY_ADDRESS,
  SUDO_POLICY_ADDRESS,
  UNIVERSAL_EMAIL_RECOVERY_ADDRESS,
  USAGE_LIMIT_POLICY_ADDRESS,
  VALUE_LIMIT_POLICY_ADDRESS,
  WEBAUTHN_VALIDATOR_ADDRESS
};
var GLOBAL_CONSTANTS = {
  ...DEFAULT_CONSTANTS
};

// node_modules/@rhinestone/module-sdk/_esm/account/erc7579-implementation/constants/abis.js
var accountAbi = [
  "function getActiveHook() external view returns (address hook)",
  "function getValidatorsPaginated(address cursor,uint256 size) returns (address[] memory, address)",
  "function getExecutorsPaginated(address cursor,uint256 size) returns (address[] memory, address)",
  "function installModule(uint256 moduleTypeId,address module,bytes calldata initData)",
  "function uninstallModule(uint256 moduleTypeId,address module,bytes calldata deInitData)",
  "function isModuleInstalled(uint256 moduleTypeId,address module,bytes calldata additionalContext) returns (bool)"
];

// node_modules/@rhinestone/module-sdk/_esm/common/constants.js
var SENTINEL_ADDRESS2 = "0x0000000000000000000000000000000000000001";

// node_modules/@rhinestone/module-sdk/_esm/module/types.js
var CallType;
(function(CallType2) {
  CallType2["CALLTYPE_SINGLE"] = "0x00";
  CallType2["CALLTYPE_BATCH"] = "0x01";
  CallType2["CALLTYPE_STATIC"] = "0xFE";
  CallType2["CALLTYPE_DELEGATECALL"] = "0xFF";
})(CallType || (CallType = {}));

// node_modules/@rhinestone/module-sdk/_esm/account/kernel/constants/abis.js
var accountAbi2 = [...accountAbi];

// node_modules/@rhinestone/module-sdk/_esm/account/safe/constants/abis.js
var accountAbi4 = [...accountAbi];

// node_modules/@rhinestone/module-sdk/_esm/account/safe/types.js
var SafeHookType2;
(function(SafeHookType3) {
  SafeHookType3[SafeHookType3["GLOBAL"] = 0] = "GLOBAL";
  SafeHookType3[SafeHookType3["SIG"] = 1] = "SIG";
})(SafeHookType2 || (SafeHookType2 = {}));
var SafeCallType;
(function(SafeCallType2) {
  SafeCallType2["CALLTYPE_SINGLE"] = "0x00";
  SafeCallType2["CALLTYPE_BATCH"] = "0x01";
})(SafeCallType || (SafeCallType = {}));

// node_modules/@rhinestone/module-sdk/_esm/module/ownable-validator/abi.js
var abi2 = [
  {
    inputs: [
      { internalType: "address", name: "smartAccount", type: "address" }
    ],
    name: "AlreadyInitialized",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "owner", type: "address" }],
    name: "InvalidOwner",
    type: "error"
  },
  { inputs: [], name: "InvalidSignature", type: "error" },
  { inputs: [], name: "InvalidThreshold", type: "error" },
  { inputs: [], name: "LinkedList_AlreadyInitialized", type: "error" },
  {
    inputs: [{ internalType: "address", name: "entry", type: "address" }],
    name: "LinkedList_EntryAlreadyInList",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "entry", type: "address" }],
    name: "LinkedList_InvalidEntry",
    type: "error"
  },
  { inputs: [], name: "LinkedList_InvalidPage", type: "error" },
  { inputs: [], name: "MaxOwnersReached", type: "error" },
  {
    inputs: [
      { internalType: "address", name: "smartAccount", type: "address" }
    ],
    name: "NotInitialized",
    type: "error"
  },
  { inputs: [], name: "NotSortedAndUnique", type: "error" },
  { inputs: [], name: "ThresholdNotSet", type: "error" },
  {
    inputs: [
      { internalType: "bytes", name: "contractSignature", type: "bytes" }
    ],
    name: "WrongContractSignature",
    type: "error"
  },
  {
    inputs: [
      { internalType: "uint256", name: "s", type: "uint256" },
      {
        internalType: "uint256",
        name: "contractSignatureLen",
        type: "uint256"
      },
      { internalType: "uint256", name: "signaturesLen", type: "uint256" }
    ],
    name: "WrongContractSignatureFormat",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "owner", type: "address" }],
    name: "addOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "getOwners",
    outputs: [
      { internalType: "address[]", name: "ownersArray", type: "address[]" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "smartAccount", type: "address" }
    ],
    name: "isInitialized",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "typeID", type: "uint256" }],
    name: "isModuleType",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "bytes32", name: "hash", type: "bytes32" },
      { internalType: "bytes", name: "data", type: "bytes" }
    ],
    name: "isValidSignatureWithSender",
    outputs: [{ internalType: "bytes4", name: "", type: "bytes4" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes", name: "data", type: "bytes" }],
    name: "onInstall",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes", name: "", type: "bytes" }],
    name: "onUninstall",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "ownerCount",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "prevOwner", type: "address" },
      { internalType: "address", name: "owner", type: "address" }
    ],
    name: "removeOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "_threshold", type: "uint256" }],
    name: "setThreshold",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "threshold",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "hash", type: "bytes32" },
      { internalType: "bytes", name: "signature", type: "bytes" },
      { internalType: "bytes", name: "data", type: "bytes" }
    ],
    name: "validateSignatureWithData",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "sender", type: "address" },
          { internalType: "uint256", name: "nonce", type: "uint256" },
          { internalType: "bytes", name: "initCode", type: "bytes" },
          { internalType: "bytes", name: "callData", type: "bytes" },
          {
            internalType: "bytes32",
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          { internalType: "bytes32", name: "gasFees", type: "bytes32" },
          { internalType: "bytes", name: "paymasterAndData", type: "bytes" },
          { internalType: "bytes", name: "signature", type: "bytes" }
        ],
        internalType: "struct PackedUserOperation",
        name: "userOp",
        type: "tuple"
      },
      { internalType: "bytes32", name: "userOpHash", type: "bytes32" }
    ],
    name: "validateUserOp",
    outputs: [
      {
        internalType: "ERC7579ValidatorBase.ValidationData",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "version",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "pure",
    type: "function"
  }
];

// node_modules/@rhinestone/module-sdk/_esm/module/ownable-validator/usage.js
var getSetOwnableValidatorThresholdAction = ({ threshold }) => {
  const data = encodeFunctionData({
    functionName: "setThreshold",
    abi: abi2,
    args: [BigInt(threshold)]
  });
  return {
    to: GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
    target: GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
    value: BigInt(0),
    callData: data,
    data
  };
};
var getAddOwnableValidatorOwnerAction = async ({ owner, client, account }) => {
  const owners = await getOwnableValidatorOwners({ account, client });
  const currentOwnerIndex = owners.findIndex((o) => o === owner);
  if (currentOwnerIndex !== -1) {
    throw new Error("Owner already exists");
  }
  const data = encodeFunctionData({
    functionName: "addOwner",
    abi: abi2,
    args: [owner]
  });
  return {
    to: GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
    target: GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
    value: BigInt(0),
    callData: data,
    data
  };
};
var getRemoveOwnableValidatorOwnerAction = async ({ client, account, owner }) => {
  const owners = await getOwnableValidatorOwners({ account, client });
  let prevOwner;
  const currentOwnerIndex = owners.findIndex((o) => o === owner);
  if (currentOwnerIndex === -1) {
    throw new Error("Owner not found");
  } else if (currentOwnerIndex === 0) {
    prevOwner = SENTINEL_ADDRESS2;
  } else {
    prevOwner = getAddress(owners[currentOwnerIndex - 1]);
  }
  const data = encodeFunctionData({
    functionName: "removeOwner",
    abi: abi2,
    args: [prevOwner, owner]
  });
  return {
    to: GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
    target: GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
    value: BigInt(0),
    callData: data,
    data
  };
};
var getOwnableValidatorOwners = async ({ account, client }) => {
  try {
    const owners = await client.readContract({
      address: GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
      abi: abi2,
      functionName: "getOwners",
      args: [account.address]
    });
    return owners;
  } catch (err) {
    console.error(err);
    return [];
  }
};
var getOwnableValidatorThreshold = async ({ account, client }) => {
  try {
    const threshold = await client.readContract({
      address: GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
      abi: abi2,
      functionName: "threshold",
      args: [account.address]
    });
    return Number(threshold);
  } catch {
    throw new Error("Failed to get threshold");
  }
};

// node_modules/@rhinestone/module-sdk/_esm/module/hook-multi-plexer/types.js
var HookType;
(function(HookType2) {
  HookType2[HookType2["GLOBAL"] = 0] = "GLOBAL";
  HookType2[HookType2["DELEGATECALL"] = 1] = "DELEGATECALL";
  HookType2[HookType2["VALUE"] = 2] = "VALUE";
  HookType2[HookType2["SIG"] = 3] = "SIG";
  HookType2[HookType2["TARGET"] = 4] = "TARGET";
})(HookType || (HookType = {}));

// node_modules/@rhinestone/module-sdk/_esm/module/smart-sessions/abi.js
var abi13 = [
  {
    type: "function",
    name: "areActionsEnabled",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      {
        name: "actions",
        type: "tuple[]",
        internalType: "struct ActionData[]",
        components: [
          {
            name: "actionTargetSelector",
            type: "bytes4",
            internalType: "bytes4"
          },
          {
            name: "actionTarget",
            type: "address",
            internalType: "address"
          },
          {
            name: "actionPolicies",
            type: "tuple[]",
            internalType: "struct PolicyData[]",
            components: [
              {
                name: "policy",
                type: "address",
                internalType: "address"
              },
              { name: "initData", type: "bytes", internalType: "bytes" }
            ]
          }
        ]
      }
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "areERC1271PoliciesEnabled",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      {
        name: "erc1271Policies",
        type: "tuple[]",
        internalType: "struct PolicyData[]",
        components: [
          { name: "policy", type: "address", internalType: "address" },
          { name: "initData", type: "bytes", internalType: "bytes" }
        ]
      }
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "areUserOpPoliciesEnabled",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      {
        name: "userOpPolicies",
        type: "tuple[]",
        internalType: "struct PolicyData[]",
        components: [
          { name: "policy", type: "address", internalType: "address" },
          { name: "initData", type: "bytes", internalType: "bytes" }
        ]
      }
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "disableActionId",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "actionId", type: "bytes32", internalType: "ActionId" }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "disableActionPolicies",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "actionId", type: "bytes32", internalType: "ActionId" },
      { name: "policies", type: "address[]", internalType: "address[]" }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "disableERC1271Policies",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      {
        name: "policies",
        type: "address[]",
        internalType: "address[]"
      },
      {
        name: "contexts",
        type: "tuple[]",
        internalType: "struct ERC7739Context[]",
        components: [
          {
            name: "appDomainSeparator",
            type: "bytes32",
            internalType: "bytes32"
          },
          {
            name: "contentName",
            type: "string[]",
            internalType: "string[]"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "disableUserOpPolicies",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "policies", type: "address[]", internalType: "address[]" }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "enableActionPolicies",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      {
        name: "actionPolicies",
        type: "tuple[]",
        internalType: "struct ActionData[]",
        components: [
          {
            name: "actionTargetSelector",
            type: "bytes4",
            internalType: "bytes4"
          },
          {
            name: "actionTarget",
            type: "address",
            internalType: "address"
          },
          {
            name: "actionPolicies",
            type: "tuple[]",
            internalType: "struct PolicyData[]",
            components: [
              {
                name: "policy",
                type: "address",
                internalType: "address"
              },
              { name: "initData", type: "bytes", internalType: "bytes" }
            ]
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "enableERC1271Policies",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      {
        name: "erc1271Policies",
        type: "tuple",
        internalType: "struct ERC7739Data",
        components: [
          {
            name: "allowedERC7739Content",
            type: "tuple[]",
            internalType: "struct ERC7739Context[]",
            components: [
              {
                name: "appDomainSeparator",
                type: "bytes32",
                internalType: "bytes32"
              },
              {
                name: "contentName",
                type: "string[]",
                internalType: "string[]"
              }
            ]
          },
          {
            name: "erc1271Policies",
            type: "tuple[]",
            internalType: "struct PolicyData[]",
            components: [
              {
                name: "policy",
                type: "address",
                internalType: "address"
              },
              { name: "initData", type: "bytes", internalType: "bytes" }
            ]
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "enableSessions",
    inputs: [
      {
        name: "sessions",
        type: "tuple[]",
        internalType: "struct Session[]",
        components: [
          {
            name: "sessionValidator",
            type: "address",
            internalType: "contract ISessionValidator"
          },
          {
            name: "sessionValidatorInitData",
            type: "bytes",
            internalType: "bytes"
          },
          { name: "salt", type: "bytes32", internalType: "bytes32" },
          {
            name: "userOpPolicies",
            type: "tuple[]",
            internalType: "struct PolicyData[]",
            components: [
              {
                name: "policy",
                type: "address",
                internalType: "address"
              },
              { name: "initData", type: "bytes", internalType: "bytes" }
            ]
          },
          {
            name: "erc7739Policies",
            type: "tuple",
            internalType: "struct ERC7739Data",
            components: [
              {
                name: "allowedERC7739Content",
                type: "tuple[]",
                internalType: "struct ERC7739Context[]",
                components: [
                  {
                    name: "appDomainSeparator",
                    type: "bytes32",
                    internalType: "bytes32"
                  },
                  {
                    name: "contentName",
                    type: "string[]",
                    internalType: "string[]"
                  }
                ]
              },
              {
                name: "erc1271Policies",
                type: "tuple[]",
                internalType: "struct PolicyData[]",
                components: [
                  {
                    name: "policy",
                    type: "address",
                    internalType: "address"
                  },
                  {
                    name: "initData",
                    type: "bytes",
                    internalType: "bytes"
                  }
                ]
              }
            ]
          },
          {
            name: "actions",
            type: "tuple[]",
            internalType: "struct ActionData[]",
            components: [
              {
                name: "actionTargetSelector",
                type: "bytes4",
                internalType: "bytes4"
              },
              {
                name: "actionTarget",
                type: "address",
                internalType: "address"
              },
              {
                name: "actionPolicies",
                type: "tuple[]",
                internalType: "struct PolicyData[]",
                components: [
                  {
                    name: "policy",
                    type: "address",
                    internalType: "address"
                  },
                  {
                    name: "initData",
                    type: "bytes",
                    internalType: "bytes"
                  }
                ]
              }
            ]
          },
          {
            name: "permitERC4337Paymaster",
            type: "bool",
            internalType: "bool"
          }
        ]
      }
    ],
    outputs: [
      {
        name: "permissionIds",
        type: "bytes32[]",
        internalType: "PermissionId[]"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "enableUserOpPolicies",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      {
        name: "userOpPolicies",
        type: "tuple[]",
        internalType: "struct PolicyData[]",
        components: [
          { name: "policy", type: "address", internalType: "address" },
          { name: "initData", type: "bytes", internalType: "bytes" }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "getActionPolicies",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "actionId", type: "bytes32", internalType: "ActionId" }
    ],
    outputs: [{ name: "", type: "address[]", internalType: "address[]" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getERC1271Policies",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      }
    ],
    outputs: [{ name: "", type: "address[]", internalType: "address[]" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getEnabledActions",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      }
    ],
    outputs: [{ name: "", type: "bytes32[]", internalType: "bytes32[]" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getEnabledERC7739Content",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      }
    ],
    outputs: [
      {
        name: "enabledERC7739ContentHashes",
        type: "tuple[]",
        internalType: "struct ERC7739ContextHashes[]",
        components: [
          {
            name: "appDomainSeparator",
            type: "bytes32",
            internalType: "bytes32"
          },
          {
            name: "contentNameHashes",
            type: "bytes32[]",
            internalType: "bytes32[]"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getNonce",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "account", type: "address", internalType: "address" }
    ],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getPermissionIDs",
    inputs: [{ name: "account", type: "address", internalType: "address" }],
    outputs: [
      {
        name: "permissionIds",
        type: "bytes32[]",
        internalType: "PermissionId[]"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getPermissionId",
    inputs: [
      {
        name: "session",
        type: "tuple",
        internalType: "struct Session",
        components: [
          {
            name: "sessionValidator",
            type: "address",
            internalType: "contract ISessionValidator"
          },
          {
            name: "sessionValidatorInitData",
            type: "bytes",
            internalType: "bytes"
          },
          { name: "salt", type: "bytes32", internalType: "bytes32" },
          {
            name: "userOpPolicies",
            type: "tuple[]",
            internalType: "struct PolicyData[]",
            components: [
              {
                name: "policy",
                type: "address",
                internalType: "address"
              },
              { name: "initData", type: "bytes", internalType: "bytes" }
            ]
          },
          {
            name: "erc7739Policies",
            type: "tuple",
            internalType: "struct ERC7739Data",
            components: [
              {
                name: "allowedERC7739Content",
                type: "tuple[]",
                internalType: "struct ERC7739Context[]",
                components: [
                  {
                    name: "appDomainSeparator",
                    type: "bytes32",
                    internalType: "bytes32"
                  },
                  {
                    name: "contentName",
                    type: "string[]",
                    internalType: "string[]"
                  }
                ]
              },
              {
                name: "erc1271Policies",
                type: "tuple[]",
                internalType: "struct PolicyData[]",
                components: [
                  {
                    name: "policy",
                    type: "address",
                    internalType: "address"
                  },
                  {
                    name: "initData",
                    type: "bytes",
                    internalType: "bytes"
                  }
                ]
              }
            ]
          },
          {
            name: "actions",
            type: "tuple[]",
            internalType: "struct ActionData[]",
            components: [
              {
                name: "actionTargetSelector",
                type: "bytes4",
                internalType: "bytes4"
              },
              {
                name: "actionTarget",
                type: "address",
                internalType: "address"
              },
              {
                name: "actionPolicies",
                type: "tuple[]",
                internalType: "struct PolicyData[]",
                components: [
                  {
                    name: "policy",
                    type: "address",
                    internalType: "address"
                  },
                  {
                    name: "initData",
                    type: "bytes",
                    internalType: "bytes"
                  }
                ]
              }
            ]
          },
          {
            name: "permitERC4337Paymaster",
            type: "bool",
            internalType: "bool"
          }
        ]
      }
    ],
    outputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      }
    ],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "getSessionDigest",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "account", type: "address", internalType: "address" },
      {
        name: "data",
        type: "tuple",
        internalType: "struct Session",
        components: [
          {
            name: "sessionValidator",
            type: "address",
            internalType: "contract ISessionValidator"
          },
          {
            name: "sessionValidatorInitData",
            type: "bytes",
            internalType: "bytes"
          },
          { name: "salt", type: "bytes32", internalType: "bytes32" },
          {
            name: "userOpPolicies",
            type: "tuple[]",
            internalType: "struct PolicyData[]",
            components: [
              {
                name: "policy",
                type: "address",
                internalType: "address"
              },
              { name: "initData", type: "bytes", internalType: "bytes" }
            ]
          },
          {
            name: "erc7739Policies",
            type: "tuple",
            internalType: "struct ERC7739Data",
            components: [
              {
                name: "allowedERC7739Content",
                type: "tuple[]",
                internalType: "struct ERC7739Context[]",
                components: [
                  {
                    name: "appDomainSeparator",
                    type: "bytes32",
                    internalType: "bytes32"
                  },
                  {
                    name: "contentName",
                    type: "string[]",
                    internalType: "string[]"
                  }
                ]
              },
              {
                name: "erc1271Policies",
                type: "tuple[]",
                internalType: "struct PolicyData[]",
                components: [
                  {
                    name: "policy",
                    type: "address",
                    internalType: "address"
                  },
                  {
                    name: "initData",
                    type: "bytes",
                    internalType: "bytes"
                  }
                ]
              }
            ]
          },
          {
            name: "actions",
            type: "tuple[]",
            internalType: "struct ActionData[]",
            components: [
              {
                name: "actionTargetSelector",
                type: "bytes4",
                internalType: "bytes4"
              },
              {
                name: "actionTarget",
                type: "address",
                internalType: "address"
              },
              {
                name: "actionPolicies",
                type: "tuple[]",
                internalType: "struct PolicyData[]",
                components: [
                  {
                    name: "policy",
                    type: "address",
                    internalType: "address"
                  },
                  {
                    name: "initData",
                    type: "bytes",
                    internalType: "bytes"
                  }
                ]
              }
            ]
          },
          {
            name: "permitERC4337Paymaster",
            type: "bool",
            internalType: "bool"
          }
        ]
      },
      {
        name: "mode",
        type: "uint8",
        internalType: "enum SmartSessionMode"
      }
    ],
    outputs: [{ name: "", type: "bytes32", internalType: "bytes32" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getSessionValidatorAndConfig",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      }
    ],
    outputs: [
      {
        name: "sessionValidator",
        type: "address",
        internalType: "address"
      },
      {
        name: "sessionValidatorData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getUserOpPolicies",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      }
    ],
    outputs: [{ name: "", type: "address[]", internalType: "address[]" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isActionIdEnabled",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "actionId", type: "bytes32", internalType: "ActionId" }
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isActionPolicyEnabled",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "actionId", type: "bytes32", internalType: "ActionId" },
      { name: "policy", type: "address", internalType: "address" }
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isERC1271PolicyEnabled",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "policy", type: "address", internalType: "address" }
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isERC7739ContentEnabled",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      {
        name: "appDomainSeparator",
        type: "bytes32",
        internalType: "bytes32"
      },
      { name: "content", type: "string", internalType: "string" }
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isISessionValidatorSet",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "account", type: "address", internalType: "address" }
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isInitialized",
    inputs: [
      { name: "smartAccount", type: "address", internalType: "address" }
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isModuleType",
    inputs: [{ name: "typeID", type: "uint256", internalType: "uint256" }],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "isPermissionEnabled",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "account", type: "address", internalType: "address" }
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isUserOpPolicyEnabled",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "policy", type: "address", internalType: "address" }
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isValidSignatureWithSender",
    inputs: [
      { name: "sender", type: "address", internalType: "address" },
      { name: "hash", type: "bytes32", internalType: "bytes32" },
      { name: "signature", type: "bytes", internalType: "bytes" }
    ],
    outputs: [{ name: "result", type: "bytes4", internalType: "bytes4" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "onInstall",
    inputs: [{ name: "data", type: "bytes", internalType: "bytes" }],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "onUninstall",
    inputs: [{ name: "", type: "bytes", internalType: "bytes" }],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "removeSession",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "revokeEnableSignature",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setpermitERC4337Paymaster",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "enabled", type: "bool", internalType: "bool" }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "validateUserOp",
    inputs: [
      {
        name: "userOp",
        type: "tuple",
        internalType: "struct PackedUserOperation",
        components: [
          { name: "sender", type: "address", internalType: "address" },
          { name: "nonce", type: "uint256", internalType: "uint256" },
          { name: "initCode", type: "bytes", internalType: "bytes" },
          { name: "callData", type: "bytes", internalType: "bytes" },
          {
            name: "accountGasLimits",
            type: "bytes32",
            internalType: "bytes32"
          },
          {
            name: "preVerificationGas",
            type: "uint256",
            internalType: "uint256"
          },
          { name: "gasFees", type: "bytes32", internalType: "bytes32" },
          {
            name: "paymasterAndData",
            type: "bytes",
            internalType: "bytes"
          },
          { name: "signature", type: "bytes", internalType: "bytes" }
        ]
      },
      { name: "userOpHash", type: "bytes32", internalType: "bytes32" }
    ],
    outputs: [{ name: "vd", type: "uint256", internalType: "ValidationData" }],
    stateMutability: "nonpayable"
  },
  {
    type: "event",
    name: "ActionIdDisabled",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        indexed: false,
        internalType: "PermissionId"
      },
      {
        name: "actionId",
        type: "bytes32",
        indexed: false,
        internalType: "ActionId"
      },
      {
        name: "smartAccount",
        type: "address",
        indexed: false,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "NonceIterated",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        indexed: false,
        internalType: "PermissionId"
      },
      {
        name: "account",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "newValue",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "PermissionIdpermitERC4337Paymaster",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        indexed: false,
        internalType: "PermissionId"
      },
      {
        name: "smartAccount",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "enabled",
        type: "bool",
        indexed: false,
        internalType: "bool"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "PolicyDisabled",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        indexed: false,
        internalType: "PermissionId"
      },
      {
        name: "policyType",
        type: "uint8",
        indexed: false,
        internalType: "enum PolicyType"
      },
      {
        name: "policy",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "smartAccount",
        type: "address",
        indexed: false,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "PolicyEnabled",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        indexed: false,
        internalType: "PermissionId"
      },
      {
        name: "policyType",
        type: "uint8",
        indexed: false,
        internalType: "enum PolicyType"
      },
      {
        name: "policy",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "smartAccount",
        type: "address",
        indexed: false,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "SessionCreated",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        indexed: false,
        internalType: "PermissionId"
      },
      {
        name: "account",
        type: "address",
        indexed: false,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "SessionRemoved",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        indexed: false,
        internalType: "PermissionId"
      },
      {
        name: "smartAccount",
        type: "address",
        indexed: false,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "SessionValidatorDisabled",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        indexed: false,
        internalType: "PermissionId"
      },
      {
        name: "sessionValidator",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "smartAccount",
        type: "address",
        indexed: false,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "SessionValidatorEnabled",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        indexed: false,
        internalType: "PermissionId"
      },
      {
        name: "sessionValidator",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "smartAccount",
        type: "address",
        indexed: false,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "error",
    name: "AssociatedArray_OutOfBounds",
    inputs: [{ name: "index", type: "uint256", internalType: "uint256" }]
  },
  {
    type: "error",
    name: "ChainIdMismatch",
    inputs: [
      {
        name: "providedChainId",
        type: "uint64",
        internalType: "uint64"
      }
    ]
  },
  {
    type: "error",
    name: "ChainIdMismatch",
    inputs: [
      {
        name: "providedChainId",
        type: "uint64",
        internalType: "uint64"
      }
    ]
  },
  { type: "error", name: "ForbiddenValidationData", inputs: [] },
  {
    type: "error",
    name: "HashIndexOutOfBounds",
    inputs: [{ name: "index", type: "uint256", internalType: "uint256" }]
  },
  {
    type: "error",
    name: "HashMismatch",
    inputs: [
      {
        name: "providedHash",
        type: "bytes32",
        internalType: "bytes32"
      },
      { name: "computedHash", type: "bytes32", internalType: "bytes32" }
    ]
  },
  {
    type: "error",
    name: "HashMismatch",
    inputs: [
      {
        name: "providedHash",
        type: "bytes32",
        internalType: "bytes32"
      },
      { name: "computedHash", type: "bytes32", internalType: "bytes32" }
    ]
  },
  { type: "error", name: "InvalidActionId", inputs: [] },
  { type: "error", name: "InvalidCallTarget", inputs: [] },
  { type: "error", name: "InvalidData", inputs: [] },
  {
    type: "error",
    name: "InvalidEnableSignature",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      { name: "hash", type: "bytes32", internalType: "bytes32" }
    ]
  },
  {
    type: "error",
    name: "InvalidISessionValidator",
    inputs: [
      {
        name: "sessionValidator",
        type: "address",
        internalType: "contract ISessionValidator"
      }
    ]
  },
  { type: "error", name: "InvalidMode", inputs: [] },
  {
    type: "error",
    name: "InvalidPermissionId",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      }
    ]
  },
  { type: "error", name: "InvalidSelfCall", inputs: [] },
  {
    type: "error",
    name: "InvalidSession",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      }
    ]
  },
  {
    type: "error",
    name: "InvalidSessionKeySignature",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      {
        name: "sessionValidator",
        type: "address",
        internalType: "address"
      },
      { name: "account", type: "address", internalType: "address" },
      { name: "userOpHash", type: "bytes32", internalType: "bytes32" }
    ]
  },
  { type: "error", name: "InvalidTarget", inputs: [] },
  {
    type: "error",
    name: "InvalidUserOpSender",
    inputs: [{ name: "sender", type: "address", internalType: "address" }]
  },
  { type: "error", name: "NoExecutionsInBatch", inputs: [] },
  {
    type: "error",
    name: "NoPoliciesSet",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      }
    ]
  },
  { type: "error", name: "PartlyEnabledActions", inputs: [] },
  { type: "error", name: "PartlyEnabledPolicies", inputs: [] },
  {
    type: "error",
    name: "PaymasterValidationNotEnabled",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      }
    ]
  },
  {
    type: "error",
    name: "PolicyViolation",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "policy", type: "address", internalType: "address" }
    ]
  },
  {
    type: "error",
    name: "SignerNotFound",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "account", type: "address", internalType: "address" }
    ]
  },
  {
    type: "error",
    name: "SignerNotFound",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "account", type: "address", internalType: "address" }
    ]
  },
  {
    type: "error",
    name: "SmartSessionModuleAlreadyInstalled",
    inputs: [{ name: "account", type: "address", internalType: "address" }]
  },
  { type: "error", name: "UnsupportedExecutionType", inputs: [] },
  {
    type: "error",
    name: "UnsupportedPolicy",
    inputs: [{ name: "policy", type: "address", internalType: "address" }]
  },
  {
    type: "error",
    name: "UnsupportedSmartSessionMode",
    inputs: [
      {
        name: "mode",
        type: "uint8",
        internalType: "enum SmartSessionMode"
      }
    ]
  }
];

// node_modules/@rhinestone/module-sdk/_esm/module/smart-sessions/types.js
var SmartSessionMode = {
  USE: "0x00",
  ENABLE: "0x01",
  UNSAFE_ENABLE: "0x02"
};

// node_modules/@rhinestone/module-sdk/_esm/module/smart-sessions/usage.js
var import_solady = __toESM(require_solady(), 1);
var getEnableSessionsAction = ({ sessions }) => {
  const data = encodeFunctionData({
    abi: abi13,
    functionName: "enableSessions",
    args: [sessions]
  });
  return {
    to: GLOBAL_CONSTANTS.SMART_SESSIONS_ADDRESS,
    target: GLOBAL_CONSTANTS.SMART_SESSIONS_ADDRESS,
    value: BigInt(0),
    callData: data,
    data
  };
};
var getRemoveSessionAction = ({ permissionId }) => {
  const data = encodeFunctionData({
    abi: abi13,
    functionName: "removeSession",
    args: [permissionId]
  });
  return {
    to: GLOBAL_CONSTANTS.SMART_SESSIONS_ADDRESS,
    target: GLOBAL_CONSTANTS.SMART_SESSIONS_ADDRESS,
    value: BigInt(0),
    callData: data,
    data
  };
};
var getEnableUserOpPoliciesAction = ({ permissionId, userOpPolicies }) => {
  const data = encodeFunctionData({
    abi: abi13,
    functionName: "enableUserOpPolicies",
    args: [permissionId, userOpPolicies]
  });
  return {
    to: GLOBAL_CONSTANTS.SMART_SESSIONS_ADDRESS,
    target: GLOBAL_CONSTANTS.SMART_SESSIONS_ADDRESS,
    value: BigInt(0),
    callData: data,
    data
  };
};
var getDisableUserOpPoliciesAction = ({ permissionId, userOpPolicies }) => {
  const data = encodeFunctionData({
    abi: abi13,
    functionName: "disableUserOpPolicies",
    args: [permissionId, userOpPolicies]
  });
  return {
    to: GLOBAL_CONSTANTS.SMART_SESSIONS_ADDRESS,
    target: GLOBAL_CONSTANTS.SMART_SESSIONS_ADDRESS,
    value: BigInt(0),
    callData: data,
    data
  };
};
var getEnableERC1271PoliciesAction = ({ permissionId, erc1271Policies }) => {
  const data = encodeFunctionData({
    abi: abi13,
    functionName: "enableERC1271Policies",
    args: [permissionId, erc1271Policies]
  });
  return {
    to: GLOBAL_CONSTANTS.SMART_SESSIONS_ADDRESS,
    target: GLOBAL_CONSTANTS.SMART_SESSIONS_ADDRESS,
    value: BigInt(0),
    callData: data,
    data
  };
};
var getDisableERC1271PoliciesAction = ({ permissionId, policies, contents }) => {
  const data = encodeFunctionData({
    abi: abi13,
    functionName: "disableERC1271Policies",
    args: [permissionId, policies, contents]
  });
  return {
    to: GLOBAL_CONSTANTS.SMART_SESSIONS_ADDRESS,
    target: GLOBAL_CONSTANTS.SMART_SESSIONS_ADDRESS,
    value: BigInt(0),
    callData: data,
    data
  };
};
var getEnableActionPoliciesAction = ({ permissionId, actionPolicies }) => {
  const data = encodeFunctionData({
    abi: abi13,
    functionName: "enableActionPolicies",
    args: [permissionId, actionPolicies]
  });
  return {
    to: GLOBAL_CONSTANTS.SMART_SESSIONS_ADDRESS,
    target: GLOBAL_CONSTANTS.SMART_SESSIONS_ADDRESS,
    value: BigInt(0),
    callData: data,
    data
  };
};
var getDisableActionPoliciesAction = ({ permissionId, actionId, policies }) => {
  const data = encodeFunctionData({
    abi: abi13,
    functionName: "disableActionPolicies",
    args: [permissionId, actionId, policies]
  });
  return {
    to: GLOBAL_CONSTANTS.SMART_SESSIONS_ADDRESS,
    target: GLOBAL_CONSTANTS.SMART_SESSIONS_ADDRESS,
    value: BigInt(0),
    callData: data,
    data
  };
};

// node_modules/@rhinestone/module-sdk/_esm/module/smart-sessions/constants.js
var SMART_SESSIONS_ADDRESS2 = "0x00000000002B0eCfbD0496EE71e01257dA0E37DE";

// node_modules/@rhinestone/module-sdk/_esm/module/smart-sessions/policies/universal-action-policy/types.js
var ParamCondition;
(function(ParamCondition3) {
  ParamCondition3[ParamCondition3["EQUAL"] = 0] = "EQUAL";
  ParamCondition3[ParamCondition3["GREATER_THAN"] = 1] = "GREATER_THAN";
  ParamCondition3[ParamCondition3["LESS_THAN"] = 2] = "LESS_THAN";
  ParamCondition3[ParamCondition3["GREATER_THAN_OR_EQUAL"] = 3] = "GREATER_THAN_OR_EQUAL";
  ParamCondition3[ParamCondition3["LESS_THAN_OR_EQUAL"] = 4] = "LESS_THAN_OR_EQUAL";
  ParamCondition3[ParamCondition3["NOT_EQUAL"] = 5] = "NOT_EQUAL";
  ParamCondition3[ParamCondition3["IN_RANGE"] = 6] = "IN_RANGE";
})(ParamCondition || (ParamCondition = {}));

// node_modules/@rhinestone/module-sdk/_esm/module/zk-email-recovery/universal-email-recovery/constants.js
var MINIMUM_RECOVERY_WINDOW = 2 * 24 * 60 * 60;
var CANCEL_EXPIRED_RECOVERY_COOLDOWN = 24 * 60 * 60;

// node_modules/@biconomy/abstractjs/dist/_esm/account/utils/getMultichainContract.js
var LARGE_DEFAULT_GAS_LIMIT = 700000n;
function createChainSpecificContract(abi23, chainId, address) {
  return new Proxy({}, {
    get: (_, prop) => {
      if (!abi23.some((item) => item.type === "function" && item.name === prop)) {
        throw new Error(`Function ${prop} not found in ABI`);
      }
      return ({ args, gasLimit = LARGE_DEFAULT_GAS_LIMIT, value = 0n }) => {
        const params = {
          abi: abi23,
          functionName: prop,
          args
        };
        const data = encodeFunctionData(params);
        const call2 = {
          to: address,
          gasLimit,
          value,
          data
        };
        return {
          calls: [call2],
          chainId
        };
      };
    }
  });
}
function getMultichainContract(config) {
  const deployments = new Map(config.deployments.map((deployment) => {
    const [address, chainId] = deployment;
    return [chainId, address];
  }));
  return {
    abi: config.abi,
    deployments,
    on: (chainId) => {
      const address = deployments.get(chainId);
      if (!address) {
        throw new Error(`No deployment found for chain ${chainId}`);
      }
      return createChainSpecificContract(config.abi, chainId, address);
    },
    build: async (params) => {
      const { data: { chainId, args: args_, gasLimit }, type: functionName } = params;
      const address = deployments.get(chainId);
      if (!address) {
        throw new Error(`No deployment found for chain ${chainId}`);
      }
      const result = createChainSpecificContract(config.abi, chainId, address)[functionName]({
        args: args_,
        ...gasLimit ? { gasLimit } : {}
      });
      return {
        chainId,
        calls: result.calls
      };
    },
    addressOn: (chainId) => {
      const address = deployments.get(chainId);
      if (!address) {
        throw new Error(`No deployment found for chain ${chainId}`);
      }
      return address;
    },
    read: async (params) => {
      const abiFunction = config.abi.find((item) => item.type === "function" && item.name === params.functionName && (item.stateMutability === "view" || item.stateMutability === "pure"));
      if (!abiFunction) {
        throw new Error(`Function ${params.functionName} not found in ABI or is not a read function`);
      }
      const results = await Promise.all(params.onChains.map(async (chain) => {
        const address = deployments.get(chain.id);
        if (!address) {
          throw new Error(`No deployment found for chain ${chain.id}`);
        }
        const deployment = params.account.deploymentOn(chain.id);
        if (!deployment) {
          throw new Error(`No deployment found for chain ${chain.id}`);
        }
        const client = deployment.client;
        const result = await client.readContract({
          address,
          abi: config.abi,
          functionName: params.functionName,
          args: params.args
        });
        return {
          chainId: chain.id,
          result
        };
      }));
      return results;
    }
  };
}

// node_modules/@biconomy/abstractjs/dist/_esm/constants/tokens/__AUTO_GENERATED__.js
var mcUSDT = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xdAC17F958D2ee523a2206206994597C13D831ec7", 1],
    ["0xfde4C96c8593536E31F229EA8f37b2ADa2699bb2", 8453],
    ["0x94b008aA00579c1307B0EF2c499aD98a8ce58e58", 10],
    ["0x919C1c267BC06a7039e03fcc2eF738525769109c", 2222],
    ["0x919C1c267BC06a7039e03fcc2eF738525769109c", 2222],
    ["0x48065fbBE25f71C9282ddf5e1cD6D6A887483D5e", 42220],
    ["0x9702230A8Ea53601f5cD2dc00fDBc13d4dF4A8c7", 43114]
  ]
});
var mcUSDC = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", 1],
    ["0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85", 10],
    ["0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359", 137],
    ["0x1d17CBcF0D6D143135aE902365D2E5e2A16538D4", 324],
    ["0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913", 8453],
    ["0xaf88d065e77c8cC2239327C5EDb3A432268e5831", 42161],
    ["0xcebA9300f2b948710d2653dD7B07f33A8B32118C", 42220],
    ["0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E", 43114]
  ]
});
var mcTON = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x582d872A1B094FC48F5DE31D3B73F2D9bE47def1", 1],
    ["0x76A797A59Ba2C17726896976B7B3747BfD1d220f", 56]
  ]
});
var mcLINK = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x514910771AF9Ca656af840dff83E8264EcF986CA", 1],
    ["0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6", 10],
    ["0xF8A0BF9cF54Bb92F17374d9e9A321E6a111a51bD", 56],
    ["0xE2e73A1c69ecF83F464EFCE6A5be353a37cA09b2", 100],
    ["0x9e004545c59D359F6B7BFB06a26390b087717b42", 128],
    ["0x53E0bca35eC356BD5ddDFebbD1Fc0fD03FaBad39", 137],
    ["0xb3654dc3D10Ea7645f8319668E8F54d2574FBdC8", 250],
    ["0xf390830DF829cf22c53c8840554B98eafC5dCBc2", 2001],
    ["0x68Ca48cA2626c415A89756471D4ADe2CC9034008", 39797],
    ["0xf97f4df75117a78c1A5a0DBb814Af92458539FB4", 42161],
    ["0x5947BB275c521040051D82396192181b413227A3", 43114],
    ["0x218532a12a389a4a92fC0C5Fb22901D1c19198aA", 16666e5]
  ]
});
var mcUNI = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984", 1],
    ["0x6fd9d7AD17242c41f7131d257212c54A0e816691", 10],
    ["0xBf5140A22578168FD562DCcF235E5D43A02ce9B1", 56],
    ["0x4537e328Bf7e4eFA29D05CAeA260D7fE26af9D74", 100],
    ["0x22C54cE8321A4015740eE1109D9cBc25815C46E6", 128],
    ["0xb33EaAd8d922B1083446DC23f610c2567fB5180f", 137],
    ["0x665B3A802979eC24e076c80025bFF33c18eB6007", 39797],
    ["0xFa7F8980b0f1E64A2062791cc3b0871572f1F7f0", 42161],
    ["0x8eBAf22B6F053dFFeaf46f4Dd9eFA95D89ba8580", 43114],
    ["0x90D81749da8867962c760414C1C25ec926E889b6", 16666e5]
  ]
});
var mcBGB = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x54D2252757e1672EEaD234D27B1270728fF90581", 1],
    ["0x55d1f1879969bdbB9960d269974564C58DBc3238", 2818]
  ]
});
var mcPEPE = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x6982508145454Ce325dDbE47a25d4ec3d2311933", 1],
    ["0x25d887Ce7a35172C62FeBFD67a1856F20FaEbB00", 56],
    ["0x25d887Ce7a35172C62FeBFD67a1856F20FaEbB00", 42161]
  ]
});
var mcWEETH = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xCd5fE23C85820F7B72D0926FC9b05b43E359b7ee", 1],
    ["0x35751007a407ca6FEFfE80b3cB397736D2cf4dbe", 42161]
  ]
});
var mcUSDS = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xdC035D45d973E3EC169d2276DDab16f1e407384F", 1],
    ["0x820C137fa70C8691f0e44Dc420a5e53c168921Dc", 8453]
  ]
});
var mcAAVE = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9", 1],
    ["0x76FB31fb4af56892A25e32cFC43De717950c9278", 10],
    ["0xfb6115445Bff7b52FeB98650C87f44907E58f802", 56],
    ["0x202b4936fE1a82A4965220860aE46d7d3939Bb25", 128],
    ["0xD6DF932A45C0f255f85145f286eA0b292B21C90B", 137],
    ["0x6a07A792ab2965C72a5B8088d3a069A7aC3a993B", 250],
    ["0xA7F2f790355E0C32CAb03f92F6EB7f488E6F049a", 39797],
    ["0xba5DdD1f9d7F570dc94a51479a000E3BCE967196", 42161],
    ["0x63a72806098Bd3D9520cC43356dD78afe5D386D9", 43114],
    ["0xcF323Aad9E522B93F11c352CaA519Ad0E14eB40F", 16666e5]
  ]
});
var mcMNT = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x3c3a81e81dc49A522A592e7622A7E711c06bf354", 1],
    ["0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000", 5e3]
  ]
});
var mcRENDER = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x6De037ef9aD2725EB40118Bb1702EBb27e4Aeb24", 1],
    ["0x61299774020dA444Af134c82fa83E3810b309991", 137]
  ]
});
var mcPOL = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x455e53CBB86018Ac2B8092FdCd39d8444aFFC3F6", 1],
    ["0x0000000000000000000000000000000000001010", 137]
  ]
});
var mcOM = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x3593D125a4f7849a1B059E64F4517A86Dd60c95d", 1],
    ["0xF78D2e7936F5Fe18308A3B2951A93b6c4a41F5e2", 56],
    ["0xC3Ec80343D2bae2F8E680FDADDe7C17E71E114ea", 137],
    ["0x3992B27dA26848C2b19CeA6Fd25ad5568B68AB98", 8453]
  ]
});
var mcFET = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xaea46A60368A7bD060eec7DF8CBa43b7EF41Ad85", 1],
    ["0x031b41e504677879370e9DBcF937283A8691Fa7f", 56]
  ]
});
var mcVIRTUAL = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x44ff8620b8cA30902395A7bD3F2407e1A091BF73", 1],
    ["0x0b3e328455c4059EEb9e3f84b5543F74E24e7E1b", 8453]
  ]
});
var mcARB = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xB50721BCf8d664c30412Cfbc6cf7a15145234ad1", 1],
    ["0x912CE59144191C1204E64559FE8253a0e49E6548", 42161],
    ["0xf823C3cD3CeBE0a1fA952ba88Dc9EEf8e0Bf46AD", 42170]
  ]
});
var mcOKB = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x75231F58b43240C9718Dd58B4967c5114342a86c", 1],
    ["0xdF54B6c6195EA4d948D03bfD818D365cf175cFC2", 66]
  ]
});
var mcBONK = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x1151CB3d861920e07a38e03eEAd12C32178567F6", 1],
    ["0xA697e272a73744b343528C3Bc4702F2565b2F422", 56],
    ["0xe5B49820e5A1063F6F4DdF851327b5E8B2301048", 137],
    ["0x09199d9A5F4448D0848e4395D065e1ad9c4a1F74", 42161],
    ["0xD4B6520f7Fb78E1EE75639F3376c581a71bcdb0E", 245022934]
  ]
});
var mcINJ = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xe28b3B32B6c345A34Ff64674606124Dd5Aceca30", 1],
    ["0xa2B726B1145A4773F68593CF171187d8EBe4d495", 56]
  ]
});
var mcCBBTC = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xcbB7C0000aB88B473b1f5aFd9ef808440eed33Bf", 1],
    ["0xcbB7C0000aB88B473b1f5aFd9ef808440eed33Bf", 8453],
    ["0xcbB7C0000aB88B473b1f5aFd9ef808440eed33Bf", 42161]
  ]
});
var mcGRT = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xc944E90C64B2c07662A292be6244BDf05Cda44a7", 1],
    ["0x5fe2B58c013d7601147DcdD68C143A77499f5531", 137],
    ["0x771513bA693D457Df3678c951c448701f2eAAad5", 39797],
    ["0x9623063377AD1B27544C965cCd7342f7EA7e88C7", 42161],
    ["0x8a0cAc13c7da965a312f08ea4229c37869e85cB9", 43114],
    ["0x002FA662F2E09de7C306d2BaB0085EE9509488Ff", 16666e5]
  ]
});
var mcWLD = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x163f8C2467924be0ae7B5347228CABF260318753", 1],
    ["0xdC6fF44d5d932Cbd77B52E5612Ba0529DC6226F1", 10],
    ["0x2cFc85d8E48F8EAB294be644d9E25C3030863003", 480]
  ]
});
var mcUSD0 = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x73A15FeD60Bf67631dC6cd7Bc5B6e8da8190aCF5", 1],
    ["0x35f1C5cB7Fb977E669fD244C567Da99d8a3a6850", 42161]
  ]
});
var mcFDUSD = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xc5f0f7b66764F6ec8C8Dff7BA683102295E16409", 1],
    ["0xc5f0f7b66764F6ec8C8Dff7BA683102295E16409", 56]
  ]
});
var mcRETH = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xae78736Cd615f374D3085123A210448E74Fc6393", 1],
    ["0x9Bcef72be871e61ED4fBbc7630889beE758eb81D", 10],
    ["0x0266F4F08D82372CF0FcbCCc0Ff74309089c74d1", 137],
    ["0xB6fe221Fe9EeF5aBa221c348bA20A1Bf5e73624c", 8453],
    ["0xEC70Dcb4A1EFa46b8F2D97C310C9c4790ba5ffA8", 42161]
  ]
});
var mcFLOKI = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xcf0C122c6b73ff809C693DB761e7BaeBe62b6a2E", 1],
    ["0xfb5B838b6cfEEdC2873aB27866079AC55363D37E", 56]
  ]
});
var mcLBTC = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x8236a87084f8B84306f72007F36F2618A5634494", 1],
    ["0xecAc9C5F704e954931349Da37F60E39f515c11c1", 56],
    ["0xecAc9C5F704e954931349Da37F60E39f515c11c1", 8453]
  ]
});
var mcLDO = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x5A98FcBEA516Cf06857215779Fd812CA3beF1B32", 1],
    ["0xFdb794692724153d1488CcdBE0C56c252596735F", 10],
    ["0xC3C7d422809852031b44ab29EEC9F1EfF2A58756", 137],
    ["0x13Ad51ed4F1B7e9Dc168d8a00cB3f4dDD85EfA60", 42161]
  ]
});
var mcMETH = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xd5F7838F5C461fefF7FE49ea5ebaF7728bB0ADfa", 1],
    ["0xcDA86A272531e8640cD7F1a92c01839911B90bb0", 5e3]
  ]
});
var mcQNT = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x4a220E6096B25EADb88358cb44068A3248254675", 1],
    ["0x462B35452E552A66B519EcF70aEdb1835d434965", 39797]
  ]
});
var mcSAND = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x3845badAde8e6dFF049820680d1F14bD3903a5d0", 1],
    ["0xBbba073C31bF03b8ACf7c28EF0738DeCF3695683", 137],
    ["0x73a4AC88c12D66AD08c1cfC891bF47883919ba74", 39797],
    ["0x35de8649e1e4Fd1A7Bd3B14F7e24e5e7887174Ed", 16666e5]
  ]
});
var mcSPX = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xE0f63A424a4439cBE457D80E4f4b51aD25b2c56C", 1],
    ["0x50dA645f148798F68EF2d7dB7C1CB22A6819bb2C", 8453]
  ]
});
var mcNEXO = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xB62132e35a6c13ee1EE0f84dC5d40bad8d815206", 1],
    ["0x41b3966B4FF7b427969ddf5da3627d6AEAE9a48E", 137],
    ["0x7C598c96D02398d89FbCb9d41Eab3DF0C16F227D", 250],
    ["0x04640Dc771eDd73cbeB934FB5461674830BAea11", 39797]
  ]
});
var mcSOLVBTC = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x7A56E1C57C7475CCf742a1832B028F0456652F97", 1],
    ["0x4aae823a6a0b376De6A78e74eCC5b079d38cBCf7", 56],
    ["0x41D9036454BE47d3745A823C4aaCD0e29cFB0f71", 4200],
    ["0xa68d25fC2AF7278db4BcdcAabce31814252642a9", 5e3],
    ["0x3B86Ad95859b6AB773f55f8d94B4b9d443EE931f", 8453],
    ["0x3647c54c4c2C65bC7a2D63c0Da2809B399DBBDC0", 42161],
    ["0xbc78D84Ba0c46dFe32cf2895a19939c86b81a777", 43114],
    ["0xbEAf16cFD8eFe0FC97C2a07E349B9411F5dC272C", 810180]
  ]
});
var mcMKR = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2", 1],
    ["0x6f7C932e7684666C9fd1d44527765433e01fF61d", 137],
    ["0x050317d93f29D1bA5FF3EaC3b8157fD4E345588D", 39797],
    ["0x88128fd4b259552A9A1D457f435a6527AAb72d42", 43114]
  ]
});
var mcBEAM = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x62D0A8458eD7719FDAF978fe5929C6D342B0bFcE", 1],
    ["0x62D0A8458eD7719FDAF978fe5929C6D342B0bFcE", 56],
    ["0x62D0A8458eD7719FDAF978fe5929C6D342B0bFcE", 43114]
  ]
});
var mcAIOZ = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x626E8036dEB333b408Be468F951bdB42433cBF18", 1],
    ["0x33d08D8C7a168333a85285a68C0042b39fC3741D", 56]
  ]
});
var mcBTT = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xC669928185DbCE49d2230CC9B0979BE6DC797957", 1],
    ["0x352Cb5E19b12FC216548a2677bD0fce83BaE434B", 56],
    ["0x0000000000000000000000000000000000001010", 199],
    ["0xF1BdCF2D4163adF9554111439dAbdD6f18fF9BA7", 39797]
  ]
});
var mcCRV = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xD533a949740bb3306d119CC777fa900bA034cd52", 1],
    ["0x0994206dfE8De6Ec6920FF4D779B0d950605Fb53", 10],
    ["0x172370d5Cd63279eFa6d502DAB29171933a610AF", 137],
    ["0x1E4F97b9f9F913c46F1632781732927B9019C68b", 250],
    ["0xd3319EAF3c4743ac75AaCE77befCFA445Ed6E69E", 39797],
    ["0x11cDb42B0EB46D95f990BeDD4695A6e3fA034978", 42161]
  ]
});
var mcSUSDS = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xa3931d71877C0E7a3148CB7Eb4463524FEc27fbD", 1],
    ["0x5875eEE11Cf8398102FdAd704C9E96607675467a", 8453]
  ]
});
var mcAXS = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xBB0E17EF65F82Ab018d8EDd776e8DD940327B28b", 1],
    ["0x715D400F88C167884bbCc41C5FeA407ed4D2f8A0", 56],
    ["0x97a9107C1793BC407d6F527b77e7fff4D812bece", 2020],
    ["0x7CD3D51beE45434Dd80822c5D58b999333b69FfB", 39797],
    ["0x14A7B318fED66FfDcc80C1517C172c13852865De", 16666e5]
  ]
});
var mcSOLVBTC_BBN = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xd9D920AA40f578ab794426F5C90F6C731D159DEf", 1],
    ["0x1346b618dC92810EC74163e4c27004c921D446a5", 56],
    ["0x1760900aCA15B90Fa2ECa70CE4b4EC441c2CF6c5", 4200],
    ["0x1d40baFC49c37CdA49F2a5427E2FB95E1e3FCf20", 5e3],
    ["0xC26C9099BD3789107888c35bb41178079B282561", 8453],
    ["0x346c574C56e1A4aAa8dc88Cda8F7EB12b39947aB", 42161],
    ["0xCC0966D8418d412c599A6421b760a847eB169A8c", 43114]
  ]
});
var mcMANA = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x0F5D2fB29fb7d3CFeE444a200298f468908cC942", 1],
    ["0xA1c57f48F0Deb89f569dFbE6E2B7f46D33606fD4", 137]
  ]
});
var mcDEXE = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xde4EE8057785A7e8e800Db58F9784845A5C2Cbd6", 1],
    ["0x6E88056E8376Ae7709496Ba64d37fa2f8015ce3e", 56]
  ]
});
var mcMATIC = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0", 1],
    ["0xCC42724C6683B7E57334c4E856f4c9965ED682bD", 56],
    ["0x3405A1bd46B85c5C029483FbECf2F3E611026e45", 1284],
    ["0x682F81e57EAa716504090C3ECBa8595fB54561D8", 1285],
    ["0x98997E1651919fAeacEe7B96aFbB3DfD96cb6036", 39797],
    ["0x301259f392B551CA8c592C9f676FCD2f9A0A84C5", 16666e5]
  ]
});
var mcMOG = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xaaeE1A9723aaDB7afA2810263653A34bA2C21C7a", 1],
    ["0x2Da56AcB9Ea78330f947bD57C54119Debda7AF71", 8453]
  ]
});
var mcAPE = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x4d224452801ACEd8B2F0aebE155379bb5D594381", 1],
    ["0xB7b31a6BC18e48888545CE79e83E06003bE70930", 137]
  ]
});
var mcRSR = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x320623b8E4fF03373931769A31Fc52A4E78B5d70", 1],
    ["0xaB36452DbAC151bE02b16Ca17d8919826072f64a", 8453],
    ["0xfcE13BB63B60f6e20ed846ae73ed242D29129800", 39797],
    ["0xCa5Ca9083702c56b481D1eec86F1776FDbd2e594", 42161]
  ]
});
var mcUSDD = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x0C10bF8FcB7Bf5412187A595ab97a3609160b5c6", 1],
    ["0xd17479997F34dd9156Deef8F95A52D81D265be9c", 56],
    ["0x17F235FD5974318E4E2a5e37919a209f7c37A6d1", 199],
    ["0x680447595e8b7b3Aa1B43beB9f6098C79ac2Ab3f", 42161],
    ["0xB514CABD09eF5B169eD3fe0FA8DBd590741E81C2", 43114]
  ]
});
var mcPRIME = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xb23d80f5FefcDDaa212212F028021B41DEd428CF", 1],
    ["0xfA980cEd6895AC314E7dE34Ef1bFAE90a5AdD21b", 8453]
  ]
});
var mcW = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xB0fFa8000886e57F86dd5264b9582b2Ad87b2b91", 1],
    ["0xB0fFa8000886e57F86dd5264b9582b2Ad87b2b91", 8453],
    ["0xB0fFa8000886e57F86dd5264b9582b2Ad87b2b91", 42161]
  ]
});
var mcPENDLE = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x808507121B80c02388fAd14726482e061B8da827", 1],
    ["0xBC7B1Ff1c6989f006a1185318eD4E7b5796e66E1", 10],
    ["0xb3Ed0A426155B79B898849803E3B36552f7ED507", 56],
    ["0xA99F6e6785Da0F5d6fB42495Fe424BCE029Eeb3E", 8453],
    ["0x0c880f6761F1af8d9Aa9C466984b80DAb9a8c9e8", 42161]
  ]
});
var mcCAKE = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x152649eA73beAb28c5b49B26eb48f7EAD6d4c898", 1],
    ["0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82", 56],
    ["0x2779106e4F4A8A28d77A24c18283651a2AE22D1C", 204],
    ["0x3A287a06c66f9E95a56327185cA2BDF5f031cEcD", 324],
    ["0x0D1E753a25eBda689453309112904807625bEFBe", 1101],
    ["0x3055913c90Fcc1A6CE9a358911721eEb942013A1", 8453],
    ["0x1b896893dfc86bb67Cf57767298b9073D2c1bA2c", 42161],
    ["0x0D1E753a25eBda689453309112904807625bEFBe", 59144]
  ]
});
var mcGNO = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x6810e776880C02933D47DB1b9fc05908e5386b96", 1],
    ["0x9C58BAcC331c9aa871AFD802DB6379a98e80CEdb", 100],
    ["0xF452bff8e958C6F335F06fC3aAc427Ee195366fE", 39797],
    ["0xa0b862F60edEf4452F25B4160F177db44DeB6Cf1", 42161]
  ]
});
var mcCMETH = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xE6829d9a7eE3040e1276Fa75293Bde931859e8fA", 1],
    ["0xE6829d9a7eE3040e1276Fa75293Bde931859e8fA", 5e3]
  ]
});
var mcFRAX = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x853d955aCEf822Db058eb8505911ED77F175b99e", 1],
    ["0x2E3D870790dC77A83DD1d18184Acc7439A53f475", 10],
    ["0x90C97F71E18723b0Cf0dfa30ee176Ab653E89F40", 56],
    ["0x45c32fA6DF82ead1e2EF74d17b76547EDdFaFF89", 137],
    ["0xdc301622e621166BD8E82f2cA0A26c13Ad0BE355", 250],
    ["0x7562F525106F5d54E891e005867Bf489B5988CD9", 288],
    ["0xFf8544feD5379D9ffa8D47a74cE6b91e632AC44D", 1101],
    ["0x322E86852e492a7Ee17f28a78c663da38FB33bfb", 1284],
    ["0x1A93B23281CC1CDE4C4741353F3064709A16197d", 1285],
    ["0x80Eede496655FB9047dd39d9f418d5483ED600df", 1329],
    ["0xE03494D0033687543a80c9B1ca7D6237F2EA8BD8", 9001],
    ["0x17FC002b466eEc40DaE837Fc4bE5c67993ddBd6F", 42161],
    ["0xD24C2Ad096400B6FBcd2ad8B24E7acBc21A1da64", 43114],
    ["0xE4B9e004389d91e4134a28F19BD833cBA1d994B6", 1313161554],
    ["0xFa7191D292d5633f702B0bd7E3E3BcCC0e633200", 16666e5]
  ]
});
var mcCOMP = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xc00e94Cb662C3520282E6f5717214004A7f26888", 1],
    ["0x52CE071Bd9b1C4B00A0b92D298c512478CaD67e8", 56],
    ["0x8505b9d2254A7Ae468c0E9dd10Ccea3A837aef5c", 137],
    ["0x9e1028F5F1D5eDE59748FFceE5532509976840E0", 8453],
    ["0x66bC411714e16B6F0C68be12bD9c666cc4576063", 39797],
    ["0x354A6dA3fcde098F8389cad84b0182725c6C91dE", 42161],
    ["0xc3048E19E76CB9a3Aa9d77D8C03c29Fc906e2437", 43114],
    ["0x32137b9275EA35162812883582623cd6f6950958", 16666e5]
  ]
});
var mcSNX = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F", 1],
    ["0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4", 10],
    ["0x777850281719d5a96C29812ab72f822E0e09F3Da", 128],
    ["0x50B728D8D964fd00C2d0AAD81718b71311feF68a", 137],
    ["0x56ee926bD8c72B2d5fa1aF4d9E4Cbb515a1E3Adc", 250],
    ["0x22e6966B799c4D5B13BE962E1D117b56327FDa66", 8453],
    ["0xa255461fF545d6ecE153283f421D67D2DE5D0E29", 39797],
    ["0xBeC243C995409E6520D7C41E404da5dEba4b209B", 43114],
    ["0x7b9c523d59AeFd362247Bd5601A89722e3774dD2", 16666e5]
  ]
});
var mcAMP = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xfF20817765cB7f73d4bde2e66e067E58D11095C2", 1],
    ["0xAD7ABE6f12F1059bDf48aE67bfF92B00438ceD95", 39797]
  ]
});
var mcUSDX = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xf3527ef8dE265eAa3716FB312c12847bFBA66Cef", 1],
    ["0xf3527ef8dE265eAa3716FB312c12847bFBA66Cef", 56],
    ["0xf3527ef8dE265eAa3716FB312c12847bFBA66Cef", 42161]
  ]
});
var mcSUPER = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xe53EC727dbDEB9E2d5456c3be40cFF031AB40A55", 1],
    ["0xa1428174F516F527fafdD146b883bB4428682737", 137]
  ]
});
var mcAXL = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x467719aD09025FcC6cF6F8311755809d45a5E5f3", 1],
    ["0x23ee2343B892b1BB63503a4FAbc840E0e2C6810f", 10],
    ["0x8b1f4432F943c465A973FeDC6d7aa50Fc96f1f65", 56],
    ["0x6e4E624106Cb12E168E6533F8ec7c82263358940", 137],
    ["0x8b1f4432F943c465A973FeDC6d7aa50Fc96f1f65", 250],
    ["0x467719aD09025FcC6cF6F8311755809d45a5E5f3", 1284],
    ["0x23ee2343B892b1BB63503a4FAbc840E0e2C6810f", 8453],
    ["0x23ee2343B892b1BB63503a4FAbc840E0e2C6810f", 42161],
    ["0x44c784266cf024a60e8acF2427b9857Ace194C5d", 43114]
  ]
});
var mcCBETH = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xBe9895146f7AF43049ca1c1AE358B0541Ea49704", 1],
    ["0xadDb6A0412DE1BA0F936DCaeb8Aaa24578dcF3B2", 10],
    ["0x4b4327dB1600B8B1440163F667e199CEf35385f5", 137],
    ["0x2Ae3F1Ec7F1F5012CFEab0185bfc7aa3cf0DEc22", 8453],
    ["0x1DEBd73E752bEaF79865Fd6446b0c970EaE7732f", 42161]
  ]
});
var mcZRO = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x6985884C4392D348587B19cb9eAAf157F13271cd", 1],
    ["0x6985884C4392D348587B19cb9eAAf157F13271cd", 10],
    ["0x6985884C4392D348587B19cb9eAAf157F13271cd", 56],
    ["0x6985884C4392D348587B19cb9eAAf157F13271cd", 137],
    ["0x6985884C4392D348587B19cb9eAAf157F13271cd", 8453],
    ["0x6985884C4392D348587B19cb9eAAf157F13271cd", 42161],
    ["0x6985884C4392D348587B19cb9eAAf157F13271cd", 43114]
  ]
});
var mc_1INCH = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x111111111117dC0aa78b770fA6A738034120C302", 1],
    ["0x111111111117dC0aa78b770fA6A738034120C302", 56],
    ["0x9c2C5fd7b07E95EE044DDeba0E97a665F142394f", 137],
    ["0xDDa6205Dc3f47e5280Eb726613B27374Eee9D130", 39797],
    ["0xd501281565bf7789224523144Fe5D98e8B28f267", 43114],
    ["0x58f1b044d8308812881a1433d9Bbeff99975e70C", 16666e5]
  ]
});
var mcMORPHO = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x58D97B57BB95320F9a05dC918Aef65434969c2B2", 1],
    ["0xBAa5CC21fd487B8Fcc2F632f3F4E8D37262a0842", 8453]
  ]
});
var mcLPT = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x58b6A8A3302369DAEc383334672404Ee733aB239", 1],
    ["0x289ba1701C2F088cf0faf8B3705246331cB8A839", 42161],
    ["0xBD3E698b51D340Cc53B0CC549b598c13e0172B7c", 16666e5]
  ]
});
var mcNFT = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x198d14F2Ad9CE69E76ea330B374DE4957C3F850a", 1],
    ["0x20eE7B720f4E4c4FFcB00C4065cdae55271aECCa", 56]
  ]
});
var mcSAFE = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x5aFE3855358E112B5647B952709E6165e1c1eEEe", 1],
    ["0x4d18815D14fe5c3304e87B3FA18318baa5c23820", 100]
  ]
});
var mcPUMPBTC = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xF469fBD2abcd6B9de8E169d128226C0Fc90a012e", 1],
    ["0xf9C4FF105803A77eCB5DAE300871Ad76c2794fa4", 56]
  ]
});
var mcTUSD = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x0000000000085d4780B73119b644AE5ecd22b376", 1],
    ["0x40af3827F39D0EAcBF4A168f8D4ee67c121D11c9", 56],
    ["0x1C20E891Bab6b1727d14Da358FAe2984Ed9B59EB", 43114]
  ]
});
var mcFRXETH = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x5E8422345238F34275888049021821E8E08CAa1f", 1],
    ["0x6806411765Af15Bddd26f8f544A34cC40cb9838B", 10],
    ["0x64048A7eEcF3a2F1BA9e144aAc3D7dB6e58F555e", 56],
    ["0xEe327F889d5947c1dc1934Bb208a1E792F953E96", 137],
    ["0x9E73F99EE061C8807F69f9c6CCc44ea3d8c373ee", 250],
    ["0xCf7eceE185f19e2E970a301eE37F93536ed66179", 1101],
    ["0x82bbd1b6f6De2B7bb63D3e1546e6b1553508BE99", 1284],
    ["0x178412e79c25968a32e89b11f63B33F733770c2A", 42161]
  ]
});
var mcBABYDOGE = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xAC57De9C1A09FeC648E93EB98875B212DB0d460B", 1],
    ["0xc748673057861a797275CD8A068AbB95A902e8de", 56]
  ]
});
var mcUSDY = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x96F6eF951840721AdBF46Ac996b59E0235CB985C", 1],
    ["0x5bE26527e817998A7206475496fDE1E68957c5A6", 5e3],
    ["0x35e050d3C0eC2d29D269a8EcEa763a183bDF9A9D", 42161]
  ]
});
var mcSWETH = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xf951E335afb289353dc249e82926178EaC7DEd78", 1],
    ["0xbc011A12Da28e8F0f528d9eE5E7039E22F91cf18", 42161]
  ]
});
var mcETHFI = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xFe0c30065B384F05761f15d0CC899D4F9F9Cc0eB", 1],
    ["0x7189fb5B6504bbfF6a852B13B7B82a3c118fDc27", 42161]
  ]
});
var mcTBTC = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x18084fbA666a33d37592fA2633fD49a74DD93a88", 1],
    ["0x6c84a8f1c29108F47a79964b5Fe888D4f4D0dE40", 10],
    ["0x236aa50979D5f3De3Bd1Eeb40E81137F22ab794b", 137],
    ["0x236aa50979D5f3De3Bd1Eeb40E81137F22ab794b", 8453],
    ["0x6c84a8f1c29108F47a79964b5Fe888D4f4D0dE40", 42161]
  ]
});
var mcTEL = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x467Bccd9d29f223BcE8043b84E8C8B282827790F", 1],
    ["0xdF7837DE1F2Fa4631D716CF2502f8b230F1dcc32", 137]
  ]
});
var mcZRX = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xE41d2489571d322189246DaFA5ebDe1F4699F498", 1],
    ["0x591C19DC0821704BEDAA5Bbc6A66fee277d9437e", 39797],
    ["0x596fA47043f99A4e0F122243B841E55375cdE0d2", 43114],
    ["0x8143E2A1085939cAA9cEf6665c2Ff32f7bc08435", 16666e5]
  ]
});
var mcCHEX = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x9Ce84F6A69986a83d92C324df10bC8E64771030f", 1],
    ["0x9Ce84F6A69986a83d92C324df10bC8E64771030f", 56],
    ["0xc43F3Ae305a92043bd9b62eBd2FE14F7547ee485", 8453]
  ]
});
var mcHOT = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x6c6EE5e31d828De241282B9606C8e98Ea48526E2", 1],
    ["0x34b97EEaB6FD9BBe95A5eAF4645307c5a6f3D4d0", 39797],
    ["0x5dfEaDCDD2d4eB29aC5Ae876dAA07FfD07Bf6483", 16666e5]
  ]
});
var mcANKR = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x8290333ceF9e6D528dD5618Fb97a76f268f3EDD4", 1],
    ["0xAeAeeD23478c3a4b798e4ed40D8B7F41366Ae861", 10],
    ["0xf307910A4c7bbc79691fD374889b36d8531B08e3", 56],
    ["0x101A023270368c0D50BFfb62780F4aFd4ea79C35", 137],
    ["0xDF474B7109b73b7D57926d43598D5934131136b2", 250],
    ["0xDF474B7109b73b7D57926d43598D5934131136b2", 1101],
    ["0xDF474B7109b73b7D57926d43598D5934131136b2", 34443],
    ["0xAeAeeD23478c3a4b798e4ed40D8B7F41366Ae861", 42161],
    ["0xDF474B7109b73b7D57926d43598D5934131136b2", 43114],
    ["0xa8Ae6365383eb907e6b4B1B7E82A35752cC5Ef8C", 59144],
    ["0x3580ac35BED2981d6bDD671a5982c2467d301241", 81457],
    ["0xDF474B7109b73b7D57926d43598D5934131136b2", 534352]
  ]
});
var mcZETA = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xf091867EC603A6628eD83D274E835539D82e9cc8", 1],
    ["0x0000028a2eB8346cd5c0267856aB7594B7a55308", 56]
  ]
});
var mcELF = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xbf2179859fc6D5BEE9Bf9158632Dc51678a4100e", 1],
    ["0xa3f020a5C92e15be13CAF0Ee5C95cF79585EeCC9", 56]
  ]
});
var mcWOO = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x4691937a7508860F876c9c0a2a617E7d9E945D4B", 1],
    ["0x4691937a7508860F876c9c0a2a617E7d9E945D4B", 56],
    ["0x1B815d120B3eF02039Ee11dC2d33DE7aA4a8C603", 137],
    ["0x6626c47c00F1D87902fc13EECfaC3ed06D5E8D8a", 250],
    ["0x9E22D758629761FC5708c171d06c2faBB60B5159", 324],
    ["0xF3df0A31ec5EA438150987805e841F960b9471b6", 5e3],
    ["0xF3df0A31ec5EA438150987805e841F960b9471b6", 8453],
    ["0xcAFcD85D8ca7Ad1e1C6F82F651fA15E33AEfD07b", 42161],
    ["0xaBC9547B534519fF73921b1FBA6E672b5f58D083", 43114],
    ["0xF3df0A31ec5EA438150987805e841F960b9471b6", 59144]
  ]
});
var mcENJ = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xF629cBd94d3791C9250152BD8dfBDF380E2a3B9c", 1],
    ["0x204a90B57d15417864080df1Cd6e907831c206A6", 39797],
    ["0xadbd41bFb4389dE499535C14A8a3A12Fead8F66A", 16666e5]
  ]
});
var mcATH = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xbe0Ed4138121EcFC5c0E56B40517da27E6c5226B", 1],
    ["0xc87B37a581ec3257B734886d9d3a581F5A9d056c", 42161]
  ]
});
var mcGLM = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x7DD9c5Cba05E151C895FDe1CF355C9A1D5DA6429", 1],
    ["0xf3ff3bF1d1afCbeBD98A304482c4099Dc953E9a8", 39797]
  ]
});
var mcVANRY = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x8DE5B80a0C1B02Fe4976851D030B36122dbb8624", 1],
    ["0x8DE5B80a0C1B02Fe4976851D030B36122dbb8624", 137]
  ]
});
var mcGMT = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xe3c408BD53c31C085a1746AF401A4042954ff740", 1],
    ["0x3019BF2a2eF8040C242C9a4c5c4BD4C81678b2A1", 56],
    ["0x714DB550b574b3E927af3D93E26127D15721D4C2", 137]
  ]
});
var mcBAT = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x0D8775F648430679A709E98d2b0Cb6250d2887EF", 1],
    ["0x3Cef98bb43d732E2F285eE605a8158cDE967D219", 137],
    ["0xe8Ba8D7765bD33BA7Ff3B19b9020C15BF14123B6", 39797],
    ["0x98443B96EA4b0858FDF3219Cd13e98C7A4690588", 43114],
    ["0x2875B4CfAb0A4cc4bdc7fBDf94b6E376826A4332", 16666e5]
  ]
});
var mcMX = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x11eeF04c884E24d9B7B4760e7476D06ddF797f36", 1],
    ["0x0BEeF4B01281D85492713a015d51fEc5b6D14687", 2818]
  ]
});
var mcSFRXETH = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xac3E018457B222d93114458476f3E3416Abbe38F", 1],
    ["0x484c2D6e3cDd945a8B2DF735e079178C1036578c", 10],
    ["0x3Cd55356433C89E50DC51aB07EE0fa0A95623D53", 56],
    ["0x6d1FdBB266fCc09A16a22016369210A15bb95761", 137],
    ["0xb90CCD563918fF900928dc529aA01046795ccb4A", 250],
    ["0xecf91116348aF1cfFe335e9807f0051332BE128D", 1284],
    ["0x95aB45875cFFdba1E5f451B950bC2E42c0053f39", 42161]
  ]
});
var mcIOTX = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x6fB3e0A217407EFFf7Ca062D46c26E5d60a14d69", 1],
    ["0xBCBAf311ceC8a4EAC0430193A528d9FF27ae38C1", 8453]
  ]
});
var mcSFP = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x12e2b8033420270db2F3b328E32370Cb5B2Ca134", 1],
    ["0xD41FDb03Ba84762dD66a0af1a6C8540FF1ba5dfb", 56],
    ["0x12490d720747E312bE64029Dfd475837Ed285cFe", 39797]
  ]
});
var mcOHM = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x64aa3364F17a4D01c6f1751Fd97C2BD3D7e7f1D5", 1],
    ["0x060cb087a9730E13aa191f31A6d86bFF8DfcdCC0", 8453],
    ["0xf0cb2dc0db5e6c66B9a70Ac27B06b878da017028", 42161]
  ]
});
var mcBORG = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x64d0f55Cd8C7133a9D7102b13987235F486F2224", 1],
    ["0x5666444647f4fD66DECF411D69f994B8244EbeE3", 39797]
  ]
});
var mcSUSHI = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x6B3595068778DD592e39A122f4f5a5cF09C90fE2", 1],
    ["0x947950BcC74888a40Ffa2593C5798F11Fc9124C4", 56],
    ["0x0b3F868E0BE5597D5DB7fEB59E1CADBb0fdDa50a", 137],
    ["0xae75A438b2E0cB8Bb01Ec1E1e376De11D44477CC", 250],
    ["0x7D49a065D17d6d4a55dc13649901fdBB98B2AFBA", 8453],
    ["0x32Aff6ADC46331dAc93E608A9CD4b0332d93a23a", 39797],
    ["0xd4d42F0b6DEF4CE0383636770eF773390d85c61A", 42161],
    ["0xD15EC721C2A896512Ad29C671997DD68f9593226", 42220],
    ["0x37B608519F91f70F2EeB0e5Ed9AF4061722e4F76", 43114],
    ["0xBEC775Cb42AbFa4288dE81F387a9b1A3c4Bc552A", 16666e5]
  ]
});
var mcFXS = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x3432B6A60D23Ca0dFCa7761B7ab56459D9C964D0", 1],
    ["0xe48A3d7d0Bc88d552f730B62c006bC925eadB9eE", 56],
    ["0x1a3acf6D19267E2d3e7f898f42803e90C9219062", 137],
    ["0x7d016eec9c25232b01F23EF992D98ca97fc2AF5a", 250],
    ["0x6b856a14CeA1d7dCfaF80fA6936c0b75972cCacE", 1101],
    ["0x6f1D1Ee50846Fcbc3de91723E61cb68CFa6D0E98", 1285],
    ["0xd8176865DD0D672c6Ab4A427572f80A72b4B4A9C", 9001],
    ["0x9d2F299715D94d8A7E6F5eaa8E654E8c74a988A7", 42161],
    ["0x214DB107654fF987AD859F34125307783fC8e387", 43114],
    ["0x0767D8E1b05eFA8d6A301a65b324B6b66A1CC14c", 16666e5]
  ]
});
var mcMASK = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x69af81e73A73B40adF4f3d4223Cd9b1ECE623074", 1],
    ["0x2eD9a5C8C13b93955103B9a7C167B67Ef4d568a3", 56],
    ["0x2B9E7ccDF0F4e5B24757c1E1a80e311E34Cb10c7", 137],
    ["0x746514E2c7D91E1e84C20c54d1F6F537b28A7d8e", 39797]
  ]
});
var mcYFI = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e", 1],
    ["0x9046D36440290FfDE54FE0DD84Db8b1CfEE9107B", 10],
    ["0xbf65bfcb5da067446CeE6A706ba3Fe2fB1a9fdFd", 100],
    ["0xB4F019bEAc758AbBEe2F906033AAa2f0F6Dacb35", 128],
    ["0xDA537104D6A5edd53c6fBba9A898708E465260b6", 137],
    ["0x29b0Da86e484E1C0029B56e817912d778aC0EC69", 250],
    ["0x9EaF8C1E34F05a589EDa6BAfdF391Cf6Ad3CB239", 8453],
    ["0x2726Dd5efb3A209a54C512e9562A2045B8F45DBc", 39797],
    ["0x82e3A8F066a6989666b031d916c43672085b1582", 42161],
    ["0x9eAaC1B23d935365bD7b542Fe22cEEe2922f52dc", 43114],
    ["0xa0dc05F84A27FcCBD341305839019aB86576bc07", 16666e5]
  ]
});
var mcILV = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x767FE9EDC9E0dF98E07454847909b5E959D7ca0E", 1],
    ["0xA4ECF6D10B8D61D4A022821A6FF8b9536a47c70D", 39797]
  ]
});
var mcBICO = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xF17e65822b568B3903685a7c9F496CF7656Cc6C2", 1],
    ["0xa68Ec98D7ca870cF1Dd0b00EBbb7c4bF60A8e74d", 42161]
  ]
});
var mcGAL = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x5fAa989Af96Af85384b8a938c2EdE4A7378D9875", 1],
    ["0xe4Cc45Bb5DBDA06dB6183E8bf016569f40497Aa5", 56]
  ]
});
var mcWBETH = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xa2E3356610840701BDf5611a53974510Ae27E2e1", 1],
    ["0xa2E3356610840701BDf5611a53974510Ae27E2e1", 56]
  ]
});
var mcALT = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x8457CA5040ad67fdebbCC8EdCE889A335Bc0fbFB", 1],
    ["0x8457CA5040ad67fdebbCC8EdCE889A335Bc0fbFB", 56]
  ]
});
var mcMETIS = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x9E32b13ce7f2E80A01932B42553652E053D6ed8e", 1],
    ["0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000", 1088]
  ]
});
var mcLRC = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xBBbbCA6A901c926F240b89EacB641d8Aec7AEafD", 1],
    ["0x193Da10f8A969D4C081b9097B15337b1488CBbEC", 39797],
    ["0x46d0cE7de6247b0A95f67b43B589b4041BaE7fbE", 42161]
  ]
});
var mcSKL = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x00c83aeCC790e8a4453e5dD3B0B4b3680501a7A7", 1],
    ["0xE0595a049d02b7674572b0d59cd4880Db60EDC50", 2046399126]
  ]
});
var mcCORGIAI = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x6b431B8a964BFcf28191b07c91189fF4403957D0", 1],
    ["0x6b431B8a964BFcf28191b07c91189fF4403957D0", 25]
  ]
});
var mcG = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x9C7BEBa8F6eF6643aBd725e45a4E8387eF260649", 1],
    ["0x9C7BEBa8F6eF6643aBd725e45a4E8387eF260649", 56],
    ["0x9C7BEBa8F6eF6643aBd725e45a4E8387eF260649", 8453]
  ]
});
var mcCOW = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xDEf1CA1fb7FBcDC777520aa7f396b4E015F497aB", 1],
    ["0x177127622c4A00F3d409B75571e12cB3c8973d3c", 100],
    ["0xcb8b5CD20BdCaea9a010aC1F8d835824F5C87A04", 42161]
  ]
});
var mcRPL = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xD33526068D116cE69F19A9ee46F0bd304F21A51f", 1],
    ["0x7205705771547cF79201111B4bd8aaF29467b9eC", 137],
    ["0xB766039cc6DB368759C1E56B79AFfE831d0Cc507", 42161]
  ]
});
var mcUSDA = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x8A60E489004Ca22d775C5F2c657598278d17D9c2", 1],
    ["0x9356086146be5158E98aD827E21b5cF944699894", 56],
    ["0x075df695b8E7f4361FA7F8c1426C63f11B06e326", 5e3]
  ]
});
var mcAVAIL = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xEeB4d8400AEefafC1B2953e0094134A887C76Bd8", 1],
    ["0xd89d90d26B48940FA8F58385Fe84625d468E057a", 8453]
  ]
});
var mcFLUID = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x6f40d4A6237C257fff2dB00FA0510DeEECd303eb", 1],
    ["0xf50D05A1402d0adAfA880D36050736f9f6ee7dee", 137]
  ]
});
var mcUMA = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x04Fa0d235C4abf4BcF4787aF4CF447DE572eF828", 1],
    ["0x3Bd2B1c7ED8D396dbb98DED3aEbb41350a5b2339", 43114]
  ]
});
var mcACX = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x44108f0223A3C3028F5Fe7AEC7f9bb2E66beF82F", 1],
    ["0xFf733b2A3557a7ed6697007ab5D11B79FdD1b76B", 10],
    ["0xF328b73B6c685831F238c30a23Fc19140CB4D8FC", 137],
    ["0x96821b258955587069F680729cD77369C0892B40", 288],
    ["0x53691596d1BCe8CEa565b84d4915e69e03d9C99d", 42161],
    ["0x7E63A5f1a8F0B4d0934B2f2327DAED3F6bb2ee75", 59144]
  ]
});
var mcBAND = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xBA11D00c5f74255f56a5E366F4F77f5A186d7f55", 1],
    ["0x46E7628E8b4350b2716ab470eE0bA1fa9e76c6C5", 250],
    ["0xb2Ef65460BF71a05d59FDf5e8F114A32d445D164", 39797]
  ]
});
var mcGOMINING = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x7Ddc52c4De30e94Be3A6A0A2b259b2850f421989", 1],
    ["0x7Ddc52c4De30e94Be3A6A0A2b259b2850f421989", 56]
  ]
});
var mcSXP = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x8CE9137d39326AD0cD6491fb5CC0CbA0e089b6A9", 1],
    ["0x47BEAd2563dCBf3bF2c9407fEa4dC236fAbA485A", 56],
    ["0x77d046614710fdDf5CA3E3cE85F4f09f7ABC283c", 16666e5]
  ]
});
var mcMMX = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x614Da3b37B6F66F7Ce69B4Bbbcf9a55CE6168707", 1],
    ["0x95A62521c655e7A24A3919AA1f99764C05B7ec4E", 137]
  ]
});
var mcHT = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x6f259637dcD74C767781E37Bc6133cd6A68aa161", 1],
    ["0xeceefC50f9aAcF0795586Ed90a8b9E24f55Ce3F3", 20],
    ["0xBAA0974354680B0e8146d64bB27Fb92C03C4A2f2", 16666e5]
  ]
});
var mcAGI = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x7dA2641000Cbb407C329310C461b2cB9c70C3046", 1],
    ["0x818835503F55283cd51A4399f595e295A9338753", 56]
  ]
});
var mcDOGE = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x1121AcC14c63f3C872BFcA497d10926A6098AAc5", 1],
    ["0x67f0870BB897F5E1c369976b4A2962d527B9562c", 8453]
  ]
});
var mcBITCOIN = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x72e4f9F808C49A2a61dE9C5896298920Dc4EEEa9", 1],
    ["0x2a06A17CBC6d0032Cac2c6696DA90f29D39a1a29", 8453]
  ]
});

// node_modules/@biconomy/abstractjs/dist/_esm/constants/tokens/tokens.js
var mcAUSDC = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x98c23e9d8f34fefb1b7bd6a91b7ff122f4e16f5c", mainnet.id],
    ["0x38d693cE1dF5AaDF7bC62595A37D667aD57922e5", optimism.id],
    ["0x4e65fE4DbA92790696d040ac24Aa414708F5c0AB", base.id]
  ]
});
var testnetMcUSDC = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238", sepolia.id],
    ["0x036cbd53842c5426634e7929541ec2318f3dcf7e", baseSepolia.id],
    ["0x5fd84259d66Cd46123540766Be93DFE6D43130D7", optimismSepolia.id]
  ]
});
var testnetMcFusion = getMultichainContract({
  abi: erc20Abi,
  deployments: [["0x232fb0469e5fc7f8f5a04eddbcc11f677143f715", baseSepolia.id]]
});
var mcWeth = getMultichainContract({
  abi: erc20Abi,
  deployments: [
    ["0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", 1],
    ["0x4200000000000000000000000000000000000006", 10],
    ["0x4200000000000000000000000000000000000006", 8453]
  ]
});

// node_modules/@biconomy/abstractjs/dist/_esm/constants/protocols/index.js
var mcAaveV3Pool = getMultichainContract({
  abi: AavePoolAbi,
  deployments: [
    ["0x794a61358D6845594F94dc1DB02A252b5b4814aD", optimism.id],
    ["0xA238Dd80C259a72e81d7e4664a9801593F98d1c5", base.id],
    ["0x794a61358D6845594F94dc1DB02A252b5b4814aD", polygon.id],
    ["0x794a61358D6845594F94dc1DB02A252b5b4814aD", arbitrum.id]
  ]
});
var mcUniswapSwapRouter = getMultichainContract({
  abi: UniswapSwapRouterAbi,
  deployments: [
    ["0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45", arbitrum.id],
    ["0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45", optimism.id],
    ["0x2626664c2603336E57B271c5C0b26F421741e481", base.id]
  ]
});
var testnetMcUniswapSwapRouter = getMultichainContract({
  abi: UniswapSwapRouterAbi,
  deployments: [
    ["0x101F443B4d1b059569D643917553c771E1b9663E", arbitrumSepolia.id],
    ["0x94cC0AaC535CCDB3C01d6787D6413C739ae12bc4", optimismSepolia.id],
    ["0x94cC0AaC535CCDB3C01d6787D6413C739ae12bc4", baseSepolia.id]
  ]
});

// node_modules/@biconomy/abstractjs/dist/_esm/constants/index.js
var MEEVersion;
(function(MEEVersion2) {
  MEEVersion2["V2_2_0"] = "2.2.0";
  MEEVersion2["V2_1_0"] = "2.1.0";
  MEEVersion2["V2_0_0"] = "2.0.0";
  MEEVersion2["V1_1_0"] = "1.1.0";
  MEEVersion2["V1_0_0"] = "1.0.0";
})(MEEVersion || (MEEVersion = {}));
var ComposabilityVersion;
(function(ComposabilityVersion2) {
  ComposabilityVersion2["V1_1_0"] = "1.1.0";
  ComposabilityVersion2["V1_0_0"] = "1.0.0";
})(ComposabilityVersion || (ComposabilityVersion = {}));
var DEFAULT_MEE_VERSION = MEEVersion.V2_0_0;
var ENTRY_POINT_ADDRESS = "0x0000000071727De22E5E9d8BAf0edAc6f37da032";
var DEFAULT_CONFIGURATIONS_BY_MEE_VERSION = {
  [MEEVersion.V2_2_0]: {
    // https://docs.biconomy.io/contracts-and-audits/#nexus-with-latest-mee-k1-validator
    version: MEEVersion.V2_2_0,
    accountId: "biconomy.nexus.1.2.1",
    factoryAddress: "0xDB1D73d8c7e8D50F760083449390b1D4080108dF",
    // Nexus Account Factory Address
    bootStrapAddress: "0x0000003eDf18913c01cBc482C978bBD3D6E8ffA3",
    implementationAddress: "0x0E12B6ED74b95aFEc6dc578Dc0b29292C0A95c90",
    // Nexus 1.2.1 => with native token runtime injection support
    validatorAddress: "0x0000000031ef4155C978d48a8A7d4EDba03b04fE",
    // K1 MEE Validator Address
    defaultValidatorAddress: zeroAddress,
    ethForwarderAddress: "0x000000Afe527A978Ecb761008Af475cfF04132a1",
    composabilityVersion: ComposabilityVersion.V1_1_0
  },
  [MEEVersion.V2_1_0]: {
    // https://docs.biconomy.io/contracts-and-audits/#nexus-with-latest-mee-k1-validator
    version: MEEVersion.V2_1_0,
    accountId: "biconomy.nexus.1.2.0",
    factoryAddress: "0x0000006648ED9B2B842552BE63Af870bC74af837",
    // Nexus Account Factory Address
    bootStrapAddress: "0x0000003eDf18913c01cBc482C978bBD3D6E8ffA3",
    implementationAddress: "0x00000000383e8cBe298514674Ea60Ee1d1de50ac",
    validatorAddress: "0x0000000031ef4155C978d48a8A7d4EDba03b04fE",
    // K1 MEE Validator Address
    defaultValidatorAddress: zeroAddress,
    ethForwarderAddress: "0x000000Afe527A978Ecb761008Af475cfF04132a1",
    composabilityVersion: ComposabilityVersion.V1_0_0
  },
  [MEEVersion.V2_0_0]: {
    version: MEEVersion.V2_0_0,
    accountId: "biconomy.nexus.1.2.0",
    factoryAddress: "0x000000001D1D5004a02bAfAb9de2D6CE5b7B13de",
    // Nexus Account Factory Address
    bootStrapAddress: "0x00000000D3254452a909E4eeD47455Af7E27C289",
    implementationAddress: "0x000000004F43C49e93C970E84001853a70923B03",
    validatorAddress: "0x00000000d12897DDAdC2044614A9677B191A2d95",
    // K1 MEE Validator Address
    defaultValidatorAddress: zeroAddress,
    ethForwarderAddress: "0x000000Afe527A978Ecb761008Af475cfF04132a1",
    composabilityVersion: ComposabilityVersion.V1_0_0
  },
  [MEEVersion.V1_1_0]: {
    version: MEEVersion.V1_1_0,
    accountId: "biconomy.nexus.1.0.2",
    factoryAddress: "0x0000000C8B6b3329cEa5d15C9d8C15F1f254ec3C",
    // Nexus Account Factory Address
    bootStrapAddress: "0x000000c4781Be3349F81d341027fd7A4EdFa4Dd2",
    implementationAddress: "0x000000001964d23C59962Fc7A912872EE8fB3b6A",
    validatorAddress: "0x00000000E894100bEcFc7c934Ab7aC8FBA08A44c",
    // K1 MEE Validator Address
    defaultValidatorAddress: "0x00000000E894100bEcFc7c934Ab7aC8FBA08A44c",
    // K1 MEE Validator Address
    moduleRegistry: {
      registryAddress: zeroAddress,
      attesters: [],
      attesterThreshold: 0
    },
    composableModuleAddress: "0x000000eff5C221A6bdB12381868307c9Db5eB462",
    ethForwarderAddress: "0x000000001f1c68bD5bF69aa1cCc1d429700D41Da",
    composabilityVersion: ComposabilityVersion.V1_0_0
  },
  [MEEVersion.V1_0_0]: {
    version: MEEVersion.V1_0_0,
    accountId: "biconomy.nexus.1.0.2",
    factoryAddress: "0x000000c3A93d2c5E02Cb053AC675665b1c4217F9",
    // Nexus Account Factory Address
    bootStrapAddress: "0x879fa30248eeb693dcCE3eA94a743622170a3658",
    implementationAddress: "0x000000aC74357BFEa72BBD0781833631F732cf19",
    validatorAddress: "0x00000000d12897DDAdC2044614A9677B191A2d95",
    // K1 MEE Validator Address
    defaultValidatorAddress: "0x00000000d12897DDAdC2044614A9677B191A2d95",
    // K1 MEE Validator Address
    moduleRegistry: {
      registryAddress: zeroAddress,
      attesters: [],
      attesterThreshold: 0
    },
    composableModuleAddress: "0x00000004430bB055dB66eBef6Fe5Ee1DA9668B10",
    ethForwarderAddress: "0x000000Afe527A978Ecb761008Af475cfF04132a1",
    composabilityVersion: ComposabilityVersion.V1_0_0
  }
};
var UNIVERSAL_ACTION_POLICY_ADDRESS2 = GLOBAL_CONSTANTS.UNIVERSAL_ACTION_POLICY_ADDRESS;
var TIME_FRAME_POLICY_ADDRESS2 = GLOBAL_CONSTANTS.TIME_FRAME_POLICY_ADDRESS;
var VALUE_LIMIT_POLICY_ADDRESS2 = GLOBAL_CONSTANTS.VALUE_LIMIT_POLICY_ADDRESS;
var USAGE_LIMIT_POLICY_ADDRESS2 = GLOBAL_CONSTANTS.USAGE_LIMIT_POLICY_ADDRESS;
var SPENDING_LIMITS_POLICY_ADDRESS2 = GLOBAL_CONSTANTS.SPENDING_LIMITS_POLICY_ADDRESS;
var SUDO_POLICY_ADDRESS2 = GLOBAL_CONSTANTS.SUDO_POLICY_ADDRESS;
var PERMIT_TYPEHASH = "0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9";

// node_modules/@biconomy/abstractjs/dist/_esm/account/utils/getChain.js
var CUSTOM_CHAINS = [
  {
    id: 81457,
    name: "Blast",
    nativeCurrency: {
      decimals: 18,
      name: "Ethereum",
      symbol: "ETH"
    },
    rpcUrls: {
      public: { http: ["https://rpc.blast.io"] },
      default: { http: ["https://rpc.blast.io"] }
    },
    blockExplorers: {
      etherscan: { name: "Blastscan", url: "https://blastscan.io/" },
      default: { name: "Blastscan", url: "https://blastscan.io/" }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 88189
      }
    }
  }
];
var getChain = (chainId) => {
  const allChains = [...Object.values(chains_exports), ...CUSTOM_CHAINS];
  for (const chain of allChains) {
    if (Number(chain.id) === Number(chainId)) {
      return chain;
    }
  }
  throw new Error(`Chain ${chainId} not found. Please add a customChain into your config using the getCustomChain(...) helper`);
};

// node_modules/@biconomy/abstractjs/dist/_esm/account/utils/explorer.js
var getExplorerTxLink = (hash, chain_) => {
  try {
    const chain = typeof chain_ === "number" || typeof chain_ === "string" ? getChain(Number(chain_)) : chain_;
    return `${chain.blockExplorers?.default.url}/tx/${hash}`;
  } catch (error) {
    return `https://v2.jiffyscan.xyz/tx/${hash}`;
  }
};
var getJiffyScanLink = (userOpHash) => {
  return `https://v2.jiffyscan.xyz/tx/${userOpHash}`;
};
var getMeeScanLink = (hash) => {
  return `https://meescan.biconomy.io/details/${hash}`;
};

// node_modules/@biconomy/abstractjs/dist/_esm/account/utils/getVersion.js
var semverCompare = (a, b) => {
  const aParts = a.split(".").map((part) => Number.parseInt(part, 10));
  const bParts = b.split(".").map((part) => Number.parseInt(part, 10));
  const maxLength = Math.max(aParts.length, bParts.length);
  while (aParts.length < maxLength)
    aParts.push(0);
  while (bParts.length < maxLength)
    bParts.push(0);
  for (let i = 0; i < maxLength; i++) {
    if (aParts[i] !== bParts[i]) {
      return aParts[i] - bParts[i];
    }
  }
  return 0;
};
var isVersionOlder = (currentVersion, referenceVersion) => {
  const comparison = semverCompare(currentVersion, referenceVersion);
  return comparison < 0;
};

// node_modules/@biconomy/abstractjs/dist/_esm/account/decorators/getNexusAddress.js
var getNexusAddress = async (params) => {
  const { publicClient, initData, factoryAddress, index = 0n } = params;
  const salt = pad(toHex(index), { size: 32 });
  return await publicClient.readContract({
    address: factoryAddress,
    abi: AccountFactoryAbi,
    functionName: "computeAccountAddress",
    args: [initData, salt]
  });
};

// node_modules/@biconomy/abstractjs/dist/_esm/modules/utils/runtimeAbiEncoding.js
var integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
var encodeString = (value) => {
  const hexValue = stringToHex(value);
  const partsLength = Math.ceil(size(hexValue) / 32);
  const parts = [];
  for (let i = 0; i < partsLength; i++) {
    parts.push(padHex(slice(hexValue, i * 32, (i + 1) * 32), {
      dir: "right"
    }));
  }
  return {
    dynamic: true,
    data: [
      concat([padHex(numberToHex(size(hexValue), { size: 32 })), ...parts])
      // Concat string len + right padded string hex value
    ]
  };
};
var encodeBytes = (value, { param }) => {
  const [, paramSize] = param.type.split("bytes");
  if (isRuntimeComposableValue(value)) {
    if (paramSize) {
      return { dynamic: false, data: [value] };
    }
    const inputParamsLength = getRuntimeValueLength(value.inputParams);
    const firstInputParam = {
      fetcherType: InputParamFetcherType.RAW_BYTES,
      paramData: numberToHex(inputParamsLength, { size: 32 }),
      constraints: []
    };
    value.inputParams = [firstInputParam, ...value.inputParams];
    return { dynamic: true, data: [value] };
  }
  const bytesSize = size(value);
  if (!paramSize) {
    let value_ = value;
    if (bytesSize % 32 !== 0)
      value_ = padHex(value_, {
        dir: "right",
        size: Math.ceil((value.length - 2) / 2 / 32) * 32
      });
    return {
      dynamic: true,
      data: [padHex(numberToHex(bytesSize, { size: 32 })), value_]
      // Length + Value
    };
  }
  if (bytesSize !== Number.parseInt(paramSize))
    throw new AbiEncodingBytesSizeMismatchError({
      expectedSize: Number.parseInt(paramSize),
      value
    });
  return { dynamic: false, data: [padHex(value, { dir: "right" })] };
};
var encodeNumber = (value, { signed, size: size2 = 256 }) => {
  if (typeof size2 === "number") {
    const max = BigInt(2) ** (BigInt(size2) - (signed ? BigInt(1) : BigInt(0))) - BigInt(1);
    const min = signed ? -max - BigInt(1) : BigInt(0);
    if (value > max || value < min)
      throw new IntegerOutOfRangeError({
        max: max.toString(),
        min: min.toString(),
        signed,
        size: size2 / 8,
        value: value.toString()
      });
  }
  return {
    dynamic: false,
    data: [
      numberToHex(value, {
        size: 32,
        signed
      })
    ]
  };
};
var encodeBool = (value) => {
  if (typeof value !== "boolean")
    throw new BaseError(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);
  return { dynamic: false, data: [padHex(boolToHex(value))] };
};
var encodeAddress = (value) => {
  if (!isAddress(value))
    throw new InvalidAddressError({ address: value });
  return { dynamic: false, data: [padHex(value.toLowerCase())] };
};
var encodeArray = (value, { length, param }) => {
  const dynamic = length === null;
  if (!Array.isArray(value))
    throw new InvalidArrayError(value);
  if (!dynamic && value.length !== length)
    throw new AbiEncodingArrayLengthMismatchError({
      expectedLength: length,
      givenLength: value.length,
      type: `${param.type}[${length}]`
    });
  let dynamicChild = false;
  const preparedParams = [];
  for (let i = 0; i < value.length; i++) {
    const preparedParam = prepareParam({ param, value: value[i] });
    if (preparedParam.dynamic)
      dynamicChild = true;
    preparedParams.push(preparedParam);
  }
  if (dynamic || dynamicChild) {
    const data2 = encodeParams(preparedParams);
    if (dynamic) {
      const length2 = numberToHex(preparedParams.length, { size: 32 });
      return {
        dynamic: true,
        data: preparedParams.length > 0 ? [length2, ...data2] : [length2]
        // The entire array will be placed at the tail
      };
    }
    if (dynamicChild)
      return { dynamic: true, data: data2 };
  }
  const data = preparedParams.flatMap(({ data: data2 }) => data2);
  return {
    dynamic: false,
    data
  };
};
var encodeTuple = (value, { param }) => {
  let dynamic = false;
  const preparedParams = [];
  for (let i = 0; i < param.components.length; i++) {
    const param_ = param.components[i];
    const index = Array.isArray(value) ? i : param_.name;
    const preparedParam = prepareParam({
      param: param_,
      value: value[index]
    });
    preparedParams.push(preparedParam);
    if (preparedParam.dynamic)
      dynamic = true;
  }
  return {
    dynamic,
    data: dynamic ? encodeParams(preparedParams) : preparedParams.flatMap(({ data }) => data)
    // If the tuple is static, it is simply placed on after another in head
  };
};
var getArrayComponents = (type) => {
  const matches = type.match(/^(.*)\[(\d+)?\]$/);
  return matches ? (
    // Return `null` if the array is dynamic.
    [matches[2] ? Number(matches[2]) : null, matches[1]]
  ) : void 0;
};
var encodeParams = (preparedParams) => {
  let staticSize = 0;
  for (let i = 0; i < preparedParams.length; i++) {
    const { dynamic, data } = preparedParams[i];
    if (dynamic) {
      staticSize += 32;
    } else {
      const len = data.reduce((acc, val) => {
        if (isRuntimeComposableValue(val)) {
          const inputParamsLength = getRuntimeValueLength(val.inputParams);
          return acc + inputParamsLength;
        }
        return acc + size(val);
      }, 0);
      staticSize += len;
    }
  }
  const staticParams = [];
  const dynamicParams = [];
  let dynamicSize = 0;
  for (let i = 0; i < preparedParams.length; i++) {
    const { dynamic, data } = preparedParams[i];
    if (dynamic) {
      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));
      const len = data.reduce((acc, val) => {
        if (isRuntimeComposableValue(val)) {
          const inputParamsLength = getRuntimeValueLength(val.inputParams);
          return acc + inputParamsLength;
        }
        return acc + size(val);
      }, 0);
      dynamicParams.push(...data);
      dynamicSize += len;
    } else {
      staticParams.push(...data);
    }
  }
  return [...staticParams, ...dynamicParams];
};
var prepareParams = ({ params, values }) => {
  const preparedParams = [];
  for (let i = 0; i < params.length; i++) {
    preparedParams.push(prepareParam({ param: params[i], value: values[i] }));
  }
  return preparedParams;
};
var prepareParam = ({ param, value }) => {
  const runtimeValue = { dynamic: false, data: [value] };
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length, type] = arrayComponents;
    return encodeArray(value, { length, param: { ...param, type } });
  }
  if (param.type === "address") {
    if (isRuntimeComposableValue(value))
      return runtimeValue;
    return encodeAddress(value);
  }
  if (param.type === "bool") {
    if (isRuntimeComposableValue(value))
      return runtimeValue;
    return encodeBool(value);
  }
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    if (isRuntimeComposableValue(value))
      return runtimeValue;
    const signed = param.type.startsWith("int");
    const [, , size2 = "256"] = integerRegex.exec(param.type) ?? [];
    return encodeNumber(value, {
      signed,
      size: Number(size2)
    });
  }
  if (param.type.startsWith("bytes")) {
    return encodeBytes(value, { param });
  }
  if (param.type === "string") {
    if (isRuntimeComposableValue(value))
      return runtimeValue;
    return encodeString(value);
  }
  if (param.type === "tuple") {
    return encodeTuple(value, {
      param
    });
  }
  throw new InvalidAbiEncodingTypeError(param.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
};
var encodeRuntimeFunctionData = (inputs, args) => {
  if (!inputs || inputs.length === 0) {
    return ["0x"];
  }
  if (inputs.length !== args.length) {
    throw new AbiEncodingLengthMismatchError({
      expectedLength: inputs.length,
      givenLength: args.length
    });
  }
  const preparedParams = prepareParams({
    params: inputs,
    values: args
  });
  const data = encodeParams(preparedParams);
  if (data.length === 0)
    return ["0x"];
  return data;
};
var getFunctionContextFromAbi = (functionSig, abi23) => {
  if (abi23.length === 0) {
    throw new Error("Invalid ABI");
  }
  const [functionInfo] = abi23.filter((item) => item.type === "function" && item.name === functionSig);
  if (!functionInfo) {
    throw new Error(`${functionSig} not found on the ABI`);
  }
  const { inputs, name, outputs, stateMutability } = functionInfo;
  return {
    inputs,
    name,
    outputs,
    functionType: ["view", "pure"].includes(stateMutability) ? "read" : "write",
    functionSig: toFunctionSelector(functionInfo)
  };
};
var getRuntimeValueLength = (inputParams) => {
  return inputParams.reduce((acc, inputParam) => {
    if (inputParam.fetcherType === InputParamFetcherType.STATIC_CALL || inputParam.fetcherType === InputParamFetcherType.BALANCE) {
      return acc + 32;
    }
    return acc + size(inputParam.paramData);
  }, 0);
};

// node_modules/@biconomy/abstractjs/dist/_esm/modules/utils/composabilityCalls.js
var InputParamType = {
  TARGET: 0,
  VALUE: 1,
  CALL_DATA: 2
};
var InputParamFetcherType = {
  RAW_BYTES: 0,
  STATIC_CALL: 1,
  BALANCE: 2
};
var ConstraintType = {
  EQ: 0,
  GTE: 1,
  LTE: 2,
  IN: 3
};
var isRuntimeComposableValue = (value) => {
  if (value && typeof value === "object" && !Array.isArray(value) && value.isRuntime) {
    return true;
  }
  return false;
};
var prepareInputParam = (fetcherType, paramData, constraints = []) => {
  return { fetcherType, paramData, constraints };
};
var prepareConstraint = (constraintType, referenceData) => {
  return { constraintType, referenceData };
};
var greaterThanOrEqualTo = (value) => {
  return { type: ConstraintType.GTE, value };
};
var validateAndProcessConstraints = (constraints) => {
  const constraintsToAdd = [];
  if (constraints.length > 0) {
    for (const constraint of constraints) {
      if (!Object.values(ConstraintType).slice(0, 3).includes(constraint.type)) {
        throw new Error("Invalid constraint type");
      }
      if (typeof constraint.value !== "bigint" || constraint.value < BigInt(0)) {
        throw new Error("Invalid constraint value");
      }
      const valueHex = `0x${constraint.value.toString(16).padStart(64, "0")}`;
      const encodedConstraintValue = encodeAbiParameters([{ type: "bytes32" }], [valueHex]);
      constraintsToAdd.push(prepareConstraint(constraint.type, encodedConstraintValue));
    }
  }
  return constraintsToAdd;
};
var runtimeNonceOf = ({ smartAccountAddress, nonceKey, constraints = [] }) => {
  const defaultFunctionSig = "getNonce";
  const entryPointNonceAbi = parseAbi([
    "function getNonce(address sender, uint192 key) public view returns (uint256)"
  ]);
  const encodedParam = encodeAbiParameters([{ type: "address" }, { type: "bytes" }], [
    ENTRY_POINT_ADDRESS,
    encodeFunctionData({
      abi: entryPointNonceAbi,
      functionName: defaultFunctionSig,
      args: [smartAccountAddress, nonceKey]
    })
  ]);
  const constraintsToAdd = validateAndProcessConstraints(constraints);
  return {
    isRuntime: true,
    inputParams: [
      prepareInputParam(InputParamFetcherType.STATIC_CALL, encodedParam, constraintsToAdd)
    ],
    outputParams: []
  };
};
var runtimeERC20AllowanceOf = ({ owner, spender, tokenAddress, constraints = [] }) => {
  const encodedParam = encodeAbiParameters([{ type: "address" }, { type: "bytes" }], [
    tokenAddress,
    encodeFunctionData({
      abi: erc20Abi,
      functionName: "allowance",
      args: [owner, spender]
    })
  ]);
  const constraintsToAdd = validateAndProcessConstraints(constraints);
  return {
    isRuntime: true,
    inputParams: [
      prepareInputParam(InputParamFetcherType.STATIC_CALL, encodedParam, constraintsToAdd)
    ],
    outputParams: []
  };
};
var runtimeNativeBalanceOf = ({ targetAddress, constraints = [] }) => {
  return getBalanceOf({
    targetAddress,
    tokenAddress: zeroAddress,
    constraints
  });
};
var runtimeERC20BalanceOf = ({ targetAddress, tokenAddress, constraints = [] }) => {
  return getBalanceOf({
    targetAddress,
    tokenAddress,
    constraints
  });
};
var getBalanceOf = ({ targetAddress, tokenAddress, constraints = [] }) => {
  const constraintsToAdd = validateAndProcessConstraints(constraints);
  const encodedInputParamData = encodePacked(["address", "address"], [tokenAddress, targetAddress]);
  return {
    isRuntime: true,
    inputParams: [
      prepareInputParam(InputParamFetcherType.BALANCE, encodedInputParamData, constraintsToAdd)
    ],
    outputParams: []
  };
};
var runtimeEncodeAbiParameters = (inputs, args) => {
  const inputParams = prepareComposableInputCalldataParams(inputs, args);
  return {
    isRuntime: true,
    inputParams,
    outputParams: []
  };
};
var isComposableCallRequired = (functionContext, args) => {
  if (!functionContext.inputs || functionContext.inputs.length <= 0)
    return false;
  const isComposableCall = functionContext.inputs.some((input, inputIndex) => {
    if (input.type === "tuple") {
      const isComposableCallDetected = Object.values(args[inputIndex]).some((internalArg) => isRuntimeComposableValue(internalArg));
      return isComposableCallDetected;
    }
    if (input.type.match(/^(.*)\[(\d+)?\]$/)) {
      const isComposableCallDetected = args[inputIndex].some((internalArg) => isRuntimeComposableValue(internalArg));
      return isComposableCallDetected;
    }
    return isRuntimeComposableValue(args[inputIndex]);
  });
  return isComposableCall;
};
var prepareComposableInputCalldataParams = (inputs, args) => {
  const composableParams = encodeRuntimeFunctionData(inputs, args).map((calldata) => {
    if (isRuntimeComposableValue(calldata)) {
      return calldata?.inputParams;
    }
    return [
      prepareInputParam(InputParamFetcherType.RAW_BYTES, calldata)
    ];
  });
  return composableParams.flat();
};
var prepareRawComposableParams = (calldata) => {
  const composableParams = [
    prepareInputParam(InputParamFetcherType.RAW_BYTES, calldata)
  ];
  return composableParams.flat();
};

// node_modules/@biconomy/abstractjs/dist/_esm/modules/utils/createChainAddressMap.js
function createChainAddressMap(entries) {
  const map = {};
  for (const [chainId, address] of entries) {
    map[chainId] = address;
  }
  map.get = (chainId) => map[chainId];
  map.has = (chainId) => chainId in map;
  return map;
}

// node_modules/@biconomy/abstractjs/dist/_esm/modules/utils/Helpers.js
var isPermitSupported = async (walletClient, tokenAddress) => {
  try {
    const client = walletClient.extend(publicActions);
    const permitSelector = toFunctionSelector("permit(address,address,uint256,uint256,uint8,bytes32,bytes32)");
    const domainSeparatorSelector = "0x3644e515";
    const noncesSelector = "0x7ecebe00";
    const checkPermitEnabled = async (selector, padding = "") => {
      return client.call({
        to: tokenAddress,
        data: `${selector}${padding}`
      }).then(() => true).catch((error) => {
        if (selector === permitSelector) {
          return error.message.includes("revert") && !error.message.includes("function selector");
        }
        return false;
      });
    };
    const [hasPermit, hasDomainSeparator, hasNonces] = await Promise.all([
      checkPermitEnabled(permitSelector, "0".repeat(64)),
      checkPermitEnabled(domainSeparatorSelector),
      checkPermitEnabled(noncesSelector, `000000000000000000000000${"0".repeat(40)}`)
    ]);
    return hasPermit && hasDomainSeparator && hasNonces;
  } catch (err) {
    console.error("Error checking permit support:", err);
    return false;
  }
};
var functionNameToLabel = (functionName) => {
  return functionName.replace(/([a-z0-9])([A-Z])/g, "$1 $2").replace(/[_\-:]+/g, " ").trim().replace(/\b\w/g, (char) => char.toUpperCase());
};

// node_modules/@biconomy/abstractjs/dist/_esm/modules/utils/conditions.js
var ConditionType;
(function(ConditionType2) {
  ConditionType2["GTE"] = "gte";
  ConditionType2["LTE"] = "lte";
  ConditionType2["EQ"] = "eq";
})(ConditionType || (ConditionType = {}));
var createConditionInputParam = (condition) => {
  const encodedParam = encodeAbiParameters([{ type: "address" }, { type: "bytes" }], [
    condition.targetContract,
    encodeFunctionData({
      abi: condition.functionAbi,
      functionName: condition.functionName,
      args: condition.args
    })
  ]);
  const constraintsToAdd = validateAndProcessConstraints([condition.constraint]);
  return prepareInputParam(InputParamFetcherType.STATIC_CALL, encodedParam, constraintsToAdd);
};

// node_modules/@biconomy/abstractjs/dist/_esm/account/decorators/instructions/buildComposable.js
var buildComposableCall = async (parameters, composabilityParameters) => {
  const { to, gasLimit, value, functionName, args, abi: abi23, conditions } = parameters;
  const {
    efficientMode = true,
    // saving gas by default
    composabilityVersion
  } = composabilityParameters;
  if (!composabilityVersion) {
    throw new Error(`Composability version is required to build a composable call.
      This error may be caused by using a non-composable .build decorator with a composable call.
      Please use buildComposable instead.`);
  }
  if (!functionName || !args) {
    throw new Error("Invalid params for composable call");
  }
  if (!abi23) {
    throw new Error("Invalid ABI");
  }
  if (args.length <= 0) {
    throw new Error("Composable call is not required for a instruction which has zero args");
  }
  const functionContext = getFunctionContextFromAbi(functionName, abi23);
  if (functionContext?.inputs?.length !== args?.length) {
    throw new Error(`Invalid arguments for the ${functionName} function`);
  }
  const versionAgnosticComposableInputParams = prepareComposableInputCalldataParams([...functionContext.inputs], args);
  const allInputParams = conditions?.length ? [
    ...versionAgnosticComposableInputParams,
    ...conditions.map(createConditionInputParam)
  ] : versionAgnosticComposableInputParams;
  const composableCall = formatComposableCallWithVersion(composabilityVersion, efficientMode, allInputParams, functionContext.functionSig, to, value, gasLimit);
  return [composableCall];
};
var formatComposableCallWithVersion = (composabilityVersion, efficientMode, versionAgnosticComposableInputParams, functionSig, to, value, gasLimit) => {
  let composableCall;
  if (composabilityVersion === ComposabilityVersion.V1_0_0) {
    if (isRuntimeComposableValue(to)) {
      throw new Error("Runtime injected target is not supported for Composability v1.0.0");
    }
    if (!isAddress(to)) {
      throw new Error("Invalid target contract address");
    }
    if (isRuntimeComposableValue(value)) {
      throw new Error("Runtime injected value is not supported for Composability v1.0.0");
    }
    composableCall = {
      to,
      value: value ?? BigInt(0),
      functionSig,
      inputParams: formatCallDataInputParamsWithVersion(composabilityVersion, efficientMode, versionAgnosticComposableInputParams),
      outputParams: [],
      // In the current scope, output params are not handled. When more composability functions are added, this will change
      ...gasLimit ? { gasLimit } : {}
    };
  } else {
    const callDataInputParams = formatCallDataInputParamsWithVersion(composabilityVersion, efficientMode, versionAgnosticComposableInputParams);
    const { targetInputParam, valueInputParam } = prepareTargetAndValueInputParams(to, value);
    const inputParams = [
      ...callDataInputParams,
      targetInputParam,
      ...valueInputParam ? [valueInputParam] : []
      // do not add valueInputParam if it is undefined
    ];
    composableCall = {
      functionSig,
      inputParams,
      outputParams: [],
      // In the current scope, output params are not handled. When more composability functions are added, this will change
      ...gasLimit ? { gasLimit } : {}
    };
  }
  return composableCall;
};
var formatCallDataInputParamsWithVersion = (composabilityVersion, efficientMode, versionAgnosticInputParams) => {
  const compressedVersionAgnosticInputParams = efficientMode ? compressCalldataInputParams(versionAgnosticInputParams) : versionAgnosticInputParams;
  if (composabilityVersion === ComposabilityVersion.V1_0_0) {
    return compressedVersionAgnosticInputParams.map((param) => {
      if (param.fetcherType === InputParamFetcherType.BALANCE) {
        const tokenAddress = `0x${param.paramData.slice(2, 42)}`;
        const targetAddress = `0x${param.paramData.slice(42, 82)}`;
        if (isNativeToken(tokenAddress)) {
          throw new Error("Native token balance as a runtime value is not supported for Composability v1.0.0");
        }
        const encodedParam = encodeAbiParameters([{ type: "address" }, { type: "bytes" }], [
          tokenAddress,
          encodeFunctionData({
            abi: erc20Abi,
            functionName: "balanceOf",
            args: [targetAddress]
          })
        ]);
        return prepareInputParam(InputParamFetcherType.STATIC_CALL, encodedParam, param.constraints);
      }
      return param;
    });
  }
  return compressedVersionAgnosticInputParams.map((param) => ({
    ...param,
    paramType: InputParamType.CALL_DATA
  }));
};
var buildComposableUtil = async (baseParams, parameters, composabilityParams) => {
  const { currentInstructions = [] } = baseParams;
  const { metadata } = parameters;
  const calls = await buildComposableCall(parameters, composabilityParams);
  const defaultMetadata = [
    {
      type: "CUSTOM",
      description: `${functionNameToLabel(parameters.functionName)} on-chain action`,
      chainId: parameters.chainId
    }
  ];
  return [
    ...currentInstructions,
    {
      calls,
      chainId: parameters.chainId,
      isComposable: true,
      metadata: metadata || defaultMetadata
    }
  ];
};
var buildComposable_default = buildComposableUtil;
var compressCalldataInputParams = (inputParams) => {
  const compressedParams = [];
  let currentParam = {
    fetcherType: InputParamFetcherType.RAW_BYTES,
    constraints: [],
    paramData: ""
  };
  for (const param of inputParams) {
    if (param.paramType === InputParamType.TARGET || param.paramType === InputParamType.VALUE) {
      throw new Error("Target or value input params should not be compressed");
    }
    if (param.fetcherType === InputParamFetcherType.STATIC_CALL || param.fetcherType === InputParamFetcherType.BALANCE || param.constraints.length > 0) {
      if (currentParam.paramData.length > 0) {
        compressedParams.push(currentParam);
        currentParam = {
          fetcherType: InputParamFetcherType.RAW_BYTES,
          constraints: [],
          paramData: ""
        };
      }
      compressedParams.push(param);
      continue;
    }
    currentParam.paramData = concatHex([
      currentParam.paramData,
      param.paramData
    ]);
  }
  if (currentParam.paramData.length > 0) {
    compressedParams.push(currentParam);
  }
  return compressedParams;
};
var prepareTargetAndValueInputParams = (to, value) => {
  let targetInputParam;
  if (isAddress(to)) {
    targetInputParam = {
      paramType: InputParamType.TARGET,
      fetcherType: InputParamFetcherType.RAW_BYTES,
      paramData: encodeAddress(to).data[0],
      constraints: []
    };
  } else {
    targetInputParam = {
      ...to.inputParams[0],
      paramType: InputParamType.TARGET
    };
  }
  let valueInputParam;
  if (!value) {
    valueInputParam = void 0;
  } else if (value.isRuntime && value.inputParams.length > 0) {
    valueInputParam = {
      ...value.inputParams[0],
      paramType: InputParamType.VALUE
    };
  } else {
    if (value !== 0n) {
      valueInputParam = {
        paramType: InputParamType.VALUE,
        fetcherType: InputParamFetcherType.RAW_BYTES,
        paramData: value.toString(16).padStart(64, "0"),
        constraints: []
      };
    }
  }
  return { targetInputParam, valueInputParam };
};

// node_modules/@biconomy/abstractjs/dist/_esm/account/decorators/instructions/buildTransfer.js
var buildTransfer = async (baseParams, parameters, composabilityParams) => {
  const { currentInstructions = [], accountAddress } = baseParams;
  const { chainId, tokenAddress, amount, gasLimit, recipient, metadata } = parameters;
  const { forceComposableEncoding } = composabilityParams ?? {
    forceComposableEncoding: false
  };
  const abi23 = TokenWithPermitAbi;
  const functionSig = "transfer";
  const args = [
    recipient,
    amount
  ];
  const functionContext = getFunctionContextFromAbi(functionSig, abi23);
  const isComposableCall = forceComposableEncoding ? true : isComposableCallRequired(functionContext, args);
  let triggerCalls;
  if (isComposableCall) {
    if (!composabilityParams) {
      throw new Error("Composability params are required to build a composable call");
    }
    const composableCallParams = {
      to: tokenAddress,
      functionName: functionSig,
      args,
      abi: abi23,
      chainId,
      ...gasLimit ? { gasLimit } : {}
    };
    triggerCalls = await buildComposableCall(composableCallParams, composabilityParams);
  } else {
    triggerCalls = [
      {
        to: tokenAddress,
        data: encodeFunctionData({
          abi: abi23,
          functionName: functionSig,
          args
        }),
        ...gasLimit ? { gasLimit } : {}
      }
    ];
  }
  const defaultMetadata = [
    {
      type: "TRANSFER",
      tokenAddress: isRuntimeComposableValue(tokenAddress) ? "RUNTIME_VALUE" : tokenAddress,
      fromAddress: accountAddress,
      toAddress: recipient,
      amount: isRuntimeComposableValue(amount) ? "RUNTIME_VALUE" : amount,
      chainId
    }
  ];
  return [
    ...currentInstructions,
    {
      calls: triggerCalls,
      chainId,
      isComposable: isComposableCall,
      metadata: metadata || defaultMetadata
    }
  ];
};
var buildTransfer_default = buildTransfer;

// node_modules/@biconomy/abstractjs/dist/_esm/account/decorators/instructions/buildAcrossIntentComposable.js
var defaultAcrossIntentWrapperAddress = "0x000000E2E47D694bDAa5a46056A894e747ED2854";
var acrossIntentWrappers = createChainAddressMap([
  // [Number(base.id), "0x000000E2E47D694bDAa5a46056A894e747ED2854"],
]);
var acrossSpokePool = createChainAddressMap([
  [41455, "0x13fDac9F9b4777705db45291bbFF3c972c6d1d97"],
  // Aleph Zero
  [42161, "0xe35e9842fceaca96570b734083f4a58e8f7c5f2a"],
  // Arbitrum
  [421614, "0x7E63A5f1a8F0B4d0934B2f2327DAED3F6bb2ee75"],
  // Arbitrum Sepolia
  [8453, "0x09aea4b2242abC8bb4BB78D537A67a245A7bEC64"],
  // Base
  [84532, "0x82B564983aE7274c86695917BBf8C99ECb6F0F8F"],
  // Base Sepolia
  [81457, "0x2D509190Ed0172ba588407D4c2df918F955Cc6E1"],
  // Blast
  [168587773, "0x5545092553Cf5Bf786e87a87192E902D50D8f022"],
  // Blast Sepolia
  [56, "0x4e8E101924eDE233C13e2D8622DC8aED2872d505"],
  // BNB Smart chain
  [1, "0x5c7BCd6E7De5423a257D81B442095A1a6ced35C5"],
  // Ethereum
  [11155111, "0x5ef6C01E11889d86803e0B23e3cB3F9E9d97B662"],
  // Sepolia
  [57073, "0xeF684C38F94F48775959ECf2012D7E864ffb9dd4"],
  // Ink
  [232, "0xe7cb3e167e7475dE1331Cf6E0CEb187654619E12"],
  // Lens
  [59144, "0x7E63A5f1a8F0B4d0934B2f2327DAED3F6bb2ee75"],
  // Linea
  [1135, "0x9552a0a6624A23B848060AE5901659CDDa1f83f8"],
  // Lisk
  [4202, "0xeF684C38F94F48775959ECf2012D7E864ffb9dd4"],
  // Lisk Sepolia
  [34443, "0x3baD7AD0728f9917d1Bf08af5782dCbD516cDd96"],
  // Mode
  [919, "0xbd886FC0725Cc459b55BbFEb3E4278610331f83b"],
  // Mode Sepolia
  [10, "0x6f26Bf09B1C792e3228e5467807a900A503c0281"],
  // Optimism
  [11155420, "0x4e8E101924eDE233C13e2D8622DC8aED2872d505"],
  // OP Sepolia
  [137, "0x9295ee1d8C5b022Be115A2AD3c30C72E34e7F096"],
  // Polygon
  [80002, "0xd08baaE74D6d2eAb1F3320B2E1a53eeb391ce8e5"],
  // Polygon Mumbai
  [690, "0x13fDac9F9b4777705db45291bbFF3c972c6d1d97"],
  // Redstone
  [534352, "0x3bad7ad0728f9917d1bf08af5782dcbd516cdd96"],
  // Scroll
  [1868, "0x3baD7AD0728f9917d1Bf08af5782dCbD516cDd96"],
  // Soneium
  [130, "0x09aea4b2242abC8bb4BB78D537A67a245A7bEC64"],
  // Unichain
  [1301, "0x6999526e507Cc3b03b180BbE05E1Ff938259A874"],
  // Unichain Sepolia
  [480, "0x09aea4b2242abC8bb4BB78D537A67a245A7bEC64"],
  // Worldchain
  [324, "0xE0B015E54d54fc84a6cB9B666099c46adE9335FF"],
  // Zksync
  [7777777, "0x13fDac9F9b4777705db45291bbFF3c972c6d1d97"]
  // Zora
]);
var buildAcrossIntentComposable = async (baseParams, parameters, composabilityParams) => {
  const { depositor, recipient, inputToken, outputToken, inputAmountRuntimeParams, approximateExpectedInputAmount, originChainId, destinationChainId, message, relayerAddress, gasLimit, pool = acrossSpokePool[originChainId], fees: fees_, metadata } = parameters;
  if (destinationChainId === originChainId) {
    throw new Error("Destination chain and origin should be different");
  }
  if (!pool) {
    throw new Error("Across SpokePool seems not to be present on the origin chain");
  }
  const acrossIntentWrapperOnOrigin = _getAcrossIntentWrapper(originChainId);
  const transferFromNexusToWrapperInstruction = await buildTransfer_default(baseParams, {
    chainId: originChainId,
    tokenAddress: inputToken,
    amount: runtimeERC20BalanceOf(inputAmountRuntimeParams),
    // use without changes
    recipient: acrossIntentWrapperOnOrigin
  }, composabilityParams);
  const fees2 = fees_ ?? await getAcrossSuggestedFees({
    amount: approximateExpectedInputAmount,
    originChainId,
    inputToken,
    destinationChainId,
    outputToken
  });
  const { outputAmount: approximateExpectedOutputAmount } = calculateAcrossFees({
    fees: fees2,
    amount: approximateExpectedInputAmount
  });
  const outputRatioPrecision = 10000n;
  const outputRatio = approximateExpectedOutputAmount * outputRatioPrecision / approximateExpectedInputAmount;
  const outputRatioPacked = concatHex([
    padHex(outputRatio.toString(16), { size: 16 }),
    padHex(outputRatioPrecision.toString(16), { size: 16 })
  ]);
  const acrossSpokePoolWrapperAbi = parseAbi([
    "function depositV3Composable(address pool, address depositor, address recipient, address inputToken, address outputToken, uint256 inputAmount, uint256 outputRatioPacked, uint256 destinationChainId, address exclusiveRelayer, uint32 quoteTimestamp, uint32 fillDeadline, uint32 exclusivityDeadline, bytes calldata message) external payable"
  ]);
  const { constraints } = inputAmountRuntimeParams;
  const wrapperRuntimeBalance = runtimeERC20BalanceOf({
    targetAddress: acrossIntentWrapperOnOrigin,
    tokenAddress: inputAmountRuntimeParams.tokenAddress,
    constraints: constraints ?? [greaterThanOrEqualTo(1n)]
  });
  const bridgeMetadata = [
    {
      type: "BRIDGE",
      fromAddress: depositor,
      toAddress: recipient,
      fromTokenAddress: inputToken,
      toTokenAddress: outputToken,
      amount: "RUNTIME_VALUE",
      fromChainId: originChainId,
      toChainId: destinationChainId,
      protocolNames: ["Across"]
    }
  ];
  const depositToPoolInstruction = await buildComposableUtil(baseParams, {
    // BuildComposableParameters
    to: acrossIntentWrapperOnOrigin,
    abi: acrossSpokePoolWrapperAbi,
    functionName: "depositV3Composable",
    args: [
      pool,
      depositor,
      recipient,
      inputToken,
      outputToken,
      wrapperRuntimeBalance,
      // the runtime param
      outputRatioPacked,
      destinationChainId,
      relayerAddress ?? zeroAddress,
      Number(fees2.timestamp),
      Number(fees2.fillDeadline),
      0,
      message ?? "0x"
    ],
    chainId: originChainId,
    gasLimit,
    metadata: metadata || bridgeMetadata
  }, composabilityParams);
  return buildBatch_default(baseParams, {
    instructions: [
      ...transferFromNexusToWrapperInstruction,
      ...depositToPoolInstruction
    ]
  });
};
var buildAcrossIntentComposable_default = buildAcrossIntentComposable;
async function getAcrossSuggestedFees(parameters) {
  const { inputToken, outputToken, originChainId, destinationChainId, amount, depositor, recipient, message, relayerAddress, referrer } = parameters;
  const url = new URL("https://app.across.to/api/suggested-fees");
  url.searchParams.append("inputToken", getAddress(inputToken));
  url.searchParams.append("outputToken", getAddress(outputToken));
  url.searchParams.append("originChainId", originChainId.toString());
  url.searchParams.append("destinationChainId", destinationChainId.toString());
  url.searchParams.append("amount", amount.toString());
  if (depositor) {
    url.searchParams.append("depositor", getAddress(depositor));
  }
  if (recipient) {
    url.searchParams.append("recipient", getAddress(recipient));
  }
  if (message) {
    url.searchParams.append("message", message);
  }
  if (relayerAddress) {
    url.searchParams.append("relayerAddress", getAddress(relayerAddress));
  }
  if (referrer) {
    url.searchParams.append("referrer", getAddress(referrer));
  }
  const response = await fetch(url.toString(), {
    method: "GET",
    headers: {
      Accept: "application/json"
    }
  });
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}, message: ${response.statusText} <= with url: ${url.toString()}`);
  }
  const data = await response.json();
  return {
    totalRelayFee: {
      pct: BigInt(data.totalRelayFee.pct),
      total: BigInt(data.totalRelayFee.total)
    },
    relayerCapitalFee: {
      pct: BigInt(data.relayerCapitalFee.pct),
      total: BigInt(data.relayerCapitalFee.total)
    },
    relayerGasFee: {
      pct: BigInt(data.relayerGasFee.pct),
      total: BigInt(data.relayerGasFee.total)
    },
    lpFee: {
      pct: BigInt(data.lpFee.pct),
      total: BigInt(data.lpFee.total)
    },
    timestamp: BigInt(data.timestamp),
    isAmountTooLow: data.isAmountTooLow,
    quoteBlock: BigInt(data.quoteBlock),
    spokePoolAddress: getAddress(data.spokePoolAddress),
    fillDeadline: BigInt(data.fillDeadline),
    limits: {
      minDeposit: BigInt(data.limits.minDeposit),
      maxDeposit: BigInt(data.limits.maxDeposit),
      maxDepositInstant: BigInt(data.limits.maxDepositInstant),
      maxDepositShortDelay: BigInt(data.limits.maxDepositShortDelay),
      recommendedDepositInstant: BigInt(data.limits.recommendedDepositInstant)
    }
  };
}
function calculateAcrossFees(parameters) {
  const { fees: fees2, amount } = parameters;
  const PRECISION = 10n ** 18n;
  const relayerFees = amount * fees2.totalRelayFee.pct / PRECISION;
  const lpFees = amount * fees2.lpFee.pct / PRECISION;
  const totalFees = relayerFees + lpFees;
  const outputAmount = amount - totalFees;
  return {
    totalFees,
    relayerFees,
    lpFees,
    outputAmount
  };
}
var _getAcrossIntentWrapper = (chainId) => {
  const acrossIntentWrapper = acrossIntentWrappers.get(chainId);
  if (acrossIntentWrapper) {
    return acrossIntentWrapper;
  }
  return defaultAcrossIntentWrapperAddress;
};

// node_modules/@biconomy/abstractjs/dist/_esm/account/decorators/instructions/buildApprove.js
var buildApprove = async (baseParams, parameters, composabilityParams) => {
  const { currentInstructions = [], accountAddress } = baseParams;
  const { chainId, tokenAddress, amount, gasLimit, spender, metadata } = parameters;
  const { forceComposableEncoding } = composabilityParams ?? {
    forceComposableEncoding: false
  };
  const abi23 = erc20Abi;
  const functionSig = "approve";
  const args = [
    spender,
    amount
  ];
  const functionContext = getFunctionContextFromAbi(functionSig, abi23);
  const isComposableCall = forceComposableEncoding ? true : isComposableCallRequired(functionContext, args);
  let approvalCall;
  if (isComposableCall) {
    if (!composabilityParams) {
      throw new Error("Composability params are required to build a composable call");
    }
    const composableCallParams = {
      to: tokenAddress,
      functionName: functionSig,
      args,
      abi: abi23,
      chainId,
      ...gasLimit ? { gasLimit } : {}
    };
    approvalCall = await buildComposableCall(composableCallParams, composabilityParams);
  } else {
    approvalCall = [
      {
        to: tokenAddress,
        data: encodeFunctionData({
          abi: abi23,
          functionName: functionSig,
          args
        }),
        ...gasLimit ? { gasLimit } : {}
      }
    ];
  }
  const defaultMetadata = [
    {
      type: "APPROVE",
      tokenAddress: isRuntimeComposableValue(tokenAddress) ? "RUNTIME_VALUE" : tokenAddress,
      fromAddress: accountAddress,
      toAddress: spender,
      amount: isRuntimeComposableValue(amount) ? "RUNTIME_VALUE" : amount,
      chainId
    }
  ];
  return [
    ...currentInstructions,
    {
      calls: approvalCall,
      chainId,
      isComposable: isComposableCall,
      metadata: metadata || defaultMetadata
    }
  ];
};

// node_modules/@biconomy/abstractjs/dist/_esm/account/decorators/instructions/buildDefaultInstructions.js
var buildDefaultInstructions = async (baseParams, instructions) => {
  const { currentInstructions = [] } = baseParams;
  return [
    ...currentInstructions,
    ...Array.isArray(instructions) ? instructions : [instructions]
  ];
};

// node_modules/@biconomy/abstractjs/dist/_esm/account/utils/parseErrorMessage.js
var extractFailedOpError = (message) => {
  const aaMatch = message.match(/errorArgs=\[.*?,\s*"(AA[0-9]+[^"]+)"/);
  if (aaMatch) {
    return aaMatch[1];
  }
  const aaHexMatch = message.match(/errorArgs=\[.*?,\s*"AA[0-9]+[^"]+",\s*"(0x[^"]+)"\]/);
  if (aaHexMatch && aaHexMatch[1] !== "0x") {
    try {
      const hexData = aaHexMatch[1].slice(130);
      const decoded = Buffer.from(hexData.replace(/00+$/, ""), "hex").toString().replace(/[\u0000-\u001F]/g, "");
      return decoded;
    } catch {
      return null;
    }
  }
  const match = message.match(/errorArgs=\[.*?,\s*"([^"]+)"\]/);
  return match?.[1] || null;
};
var extractGasLimitError = (message) => {
  const match = message.match(/code=([A-Z_]+),\s*version=/);
  return match?.[1] || null;
};
var extractRevertError = (message) => {
  const match = message.match(/"reason":"([^"]+)"/);
  return match?.[1] || null;
};
var handleErrorsArray = (errors) => {
  if (typeof errors[0] === "object" && (errors[0].msg || errors[0].message)) {
    return errors.map((error) => {
      const message = error.message || error.msg;
      return error.path && error.path !== "" ? `${error.path}: ${message}` : message;
    }).join("\n");
  }
  const errorMessage = String(errors[0]);
  return extractFailedOpError(errorMessage) || extractGasLimitError(errorMessage) || extractRevertError(errorMessage) || errorMessage;
};
var cleanErrorMessage = (message) => {
  return message.replace(/^(Error|Details|Message):\s*/i, "").replace(/^error$/i, "").trim();
};
var parseErrorMessage = (error) => {
  if (typeof error !== "object" || error === null) {
    const cleanedMessage2 = cleanErrorMessage(String(error));
    return extractFailedOpError(cleanedMessage2) || extractGasLimitError(cleanedMessage2) || extractRevertError(cleanedMessage2) || cleanedMessage2;
  }
  const errorObj = error;
  if (errorObj?.type === "AcrossApiError") {
    return [errorObj?.type, errorObj?.message].join(": ");
  }
  if (error instanceof Error) {
    const message2 = String(error.message);
    const errorMessage = extractFailedOpError(message2) || extractGasLimitError(message2) || extractRevertError(message2) || message2;
    if (errorMessage !== message2) {
      error.message = errorMessage;
    }
    return cleanErrorMessage(errorMessage);
  }
  if (Array.isArray(errorObj.errors) && errorObj.errors.length > 0) {
    return cleanErrorMessage(handleErrorsArray(errorObj.errors));
  }
  const message = String(errorObj.message || errorObj.statusText || error);
  const cleanedMessage = cleanErrorMessage(message);
  return extractFailedOpError(cleanedMessage) || extractGasLimitError(cleanedMessage) || extractRevertError(cleanedMessage) || cleanedMessage;
};

// node_modules/@biconomy/abstractjs/dist/_esm/clients/createHttpClient.js
var createHttpClient = (url, apiKey) => {
  const request = async (requesParams) => {
    const { path, method = "POST", body, params, headers } = requesParams;
    const urlParams = params ? `?${new URLSearchParams(params)}` : "";
    const fullPath = `${url}/${path}${urlParams}`;
    const result = await fetch(fullPath, {
      method,
      headers: {
        "Content-Type": "application/json",
        ...apiKey ? { "x-api-key": apiKey } : {},
        ...headers ? { ...headers } : {}
      },
      ...body ? { body: stringify(body) } : {}
    });
    const json = await result.json();
    if (!result.ok) {
      const error = json?.error ?? json ?? result?.statusText ?? result;
      console.error({ error });
      throw new Error(parseErrorMessage(error));
    }
    return json;
  };
  const client = { request };
  function extend2(base3) {
    return (extendFn) => {
      const extended = extendFn(base3);
      for (const key in client)
        delete extended[key];
      const combined = { ...base3, ...extended };
      return Object.assign(combined, { extend: extend2(combined) });
    };
  }
  return Object.assign(client, { extend: extend2(client) });
};
var createHttpClient_default = createHttpClient;

// node_modules/@biconomy/abstractjs/dist/_esm/account/utils/toAcrossPlugin.js
var TESTNET_IDS = [
  sepolia.id,
  baseSepolia.id,
  optimismSepolia.id,
  arbitrumSepolia.id
];
var acrossClient = createHttpClient("https://app.across.to/api");
var testnetAcrossClient = createHttpClient("https://testnet.across.to/api");
var acrossGetSuggestedFees = async ({ inputToken, outputToken, originChainId, destinationChainId, amount }) => {
  const client = TESTNET_IDS.includes(originChainId) ? testnetAcrossClient : acrossClient;
  return client.request({
    path: "suggested-fees",
    method: "GET",
    params: {
      inputToken,
      outputToken,
      originChainId: originChainId.toString(),
      destinationChainId: destinationChainId.toString(),
      amount: amount.toString()
    }
  });
};
var acrossEncodeBridgingUserOp = async (params) => {
  const { bridgingAmount, fromChainId, depositor, recipient, toChainId, tokenMapping } = params;
  const inputToken = tokenMapping.on(fromChainId);
  const outputToken = tokenMapping.on(toChainId);
  const suggestedFees = await acrossGetSuggestedFees({
    amount: bridgingAmount,
    destinationChainId: toChainId,
    inputToken,
    outputToken,
    originChainId: fromChainId
  });
  const depositV3abi = parseAbi([
    "function depositV3(address depositor, address recipient, address inputToken, address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 destinationChainId, address exclusiveRelayer, uint32 quoteTimestamp, uint32 fillDeadline, uint32 exclusivityDeadline, bytes message) external"
  ]);
  const outputAmount = BigInt(bridgingAmount) - BigInt(suggestedFees.totalRelayFee.total);
  const fillDeadlineBuffer = 18e3;
  const fillDeadline = Math.round(Date.now() / 1e3) + fillDeadlineBuffer;
  const approveCall = {
    to: inputToken,
    gasLimit: 100000n,
    data: encodeFunctionData({
      abi: erc20Abi,
      functionName: "approve",
      args: [suggestedFees.spokePoolAddress, bridgingAmount]
    })
  };
  const depositCall = {
    to: suggestedFees.spokePoolAddress,
    gasLimit: 1500n,
    data: encodeFunctionData({
      abi: depositV3abi,
      args: [
        depositor,
        recipient,
        inputToken,
        outputToken,
        bridgingAmount,
        outputAmount,
        BigInt(toChainId),
        suggestedFees.exclusiveRelayer,
        Number.parseInt(suggestedFees.timestamp),
        fillDeadline,
        Number.parseInt(suggestedFees.exclusivityDeadline),
        "0x"
        // message
      ]
    })
  };
  const userOp = {
    calls: [approveCall, depositCall],
    chainId: fromChainId,
    metadata: [
      {
        type: "BRIDGE",
        fromAddress: depositor,
        toAddress: recipient,
        fromTokenAddress: inputToken,
        toTokenAddress: outputToken,
        amount: bridgingAmount,
        fromChainId,
        toChainId,
        protocolNames: ["Across"]
      }
    ]
  };
  return {
    userOp,
    receivedAtDestination: outputAmount,
    bridgingDurationExpectedMs: void 0
  };
};
var toAcrossPlugin = () => ({
  encodeBridgeUserOp: async (params) => {
    return await acrossEncodeBridgingUserOp(params);
  }
});

// node_modules/@biconomy/abstractjs/dist/_esm/account/decorators/queryBridge.js
var queryBridge = async (params) => {
  const { depositor, recipient, fromChainId, toChainId, plugin = toAcrossPlugin(), amount, tokenMapping } = params;
  const result = await plugin.encodeBridgeUserOp({
    depositor,
    recipient,
    fromChainId,
    toChainId,
    tokenMapping,
    bridgingAmount: amount
  });
  if (!result.receivedAtDestination)
    return null;
  return {
    fromChainId,
    amount,
    receivedAtDestination: result.receivedAtDestination,
    plugin,
    userOp: result.userOp,
    bridgingDurationExpectedMs: result.bridgingDurationExpectedMs
  };
};

// node_modules/@biconomy/abstractjs/dist/_esm/account/decorators/buildBridgeInstructions.js
var buildBridgeInstructions = async (params) => {
  const { depositor, recipient, amount: targetAmount, toChainId, unifiedBalance, bridgingPlugins = [toAcrossPlugin()], feeData, mode: mode2 = "DEBIT", metadata } = params;
  const tokenMapping = {
    on: (chainId) => unifiedBalance.mcToken.deployments.get(chainId) || "0x",
    deployments: Array.from(unifiedBalance.mcToken.deployments.entries(), ([chainId, address]) => ({
      chainId,
      address
    }))
  };
  const destinationBalance = unifiedBalance.breakdown.find((b) => b.chainId === toChainId)?.balance || 0n;
  if (destinationBalance >= targetAmount) {
    return {
      instructions: [],
      meta: {
        bridgingInstructions: [],
        totalAvailableOnDestination: destinationBalance
      }
    };
  }
  const amountToBridge = targetAmount - destinationBalance;
  const sourceBalances = unifiedBalance.breakdown.filter((balance) => balance.chainId !== toChainId).map((balance_) => {
    const balancePerChain = mode2 === "DEBIT" ? balance_ : { ...balance_, balance: targetAmount };
    const isFeeChain = feeData && feeData.txFeeChainId === balancePerChain.chainId;
    const availableBalance = isFeeChain && "txFeeAmount" in feeData ? balancePerChain.balance > feeData.txFeeAmount ? balancePerChain.balance - feeData.txFeeAmount : 0n : balancePerChain.balance;
    return {
      chainId: balancePerChain.chainId,
      balance: availableBalance
    };
  }).filter((balance) => balance.balance > 0n);
  const bridgeQueries = sourceBalances.flatMap((source) => {
    return bridgingPlugins.map((plugin) => queryBridge({
      depositor,
      recipient,
      fromChainId: source.chainId,
      toChainId,
      plugin,
      amount: source.balance,
      tokenMapping
    }));
  });
  const bridgeResults = (await Promise.all(bridgeQueries)).filter((result) => result !== null).sort((a, b) => Number(b.receivedAtDestination * 10000n / b.amount) - Number(a.receivedAtDestination * 10000n / a.amount));
  const { bridgingInstructions, instructions, totalBridged, remainingNeeded } = bridgeResults.reduce((acc, result) => {
    if (acc.remainingNeeded <= 0n)
      return acc;
    const amountToTake = result.amount >= acc.remainingNeeded ? acc.remainingNeeded : result.amount;
    const receivedFromRoute = result.receivedAtDestination * amountToTake / result.amount;
    const customMetadata = [
      {
        type: "CUSTOM",
        chainId: result.userOp.chainId,
        description: "Custom Bridging on-chain action"
      }
    ];
    const instruction = {
      ...result.userOp,
      metadata: metadata || result.userOp.metadata || customMetadata
    };
    return {
      bridgingInstructions: [
        ...acc.bridgingInstructions,
        {
          userOp: instruction,
          receivedAtDestination: receivedFromRoute,
          bridgingDurationExpectedMs: result.bridgingDurationExpectedMs
        }
      ],
      instructions: [...acc.instructions, instruction],
      totalBridged: acc.totalBridged + receivedFromRoute,
      remainingNeeded: acc.remainingNeeded - amountToTake
    };
  }, {
    bridgingInstructions: [],
    instructions: [],
    totalBridged: 0n,
    remainingNeeded: amountToBridge
  });
  if (remainingNeeded > 0n) {
    throw new Error(`Insufficient balance for bridging:
         Required: ${targetAmount.toString()}
         Available to bridge: ${totalBridged.toString()}
         Shortfall: ${remainingNeeded.toString()}`);
  }
  return {
    instructions,
    meta: {
      bridgingInstructions,
      totalAvailableOnDestination: destinationBalance + totalBridged
    }
  };
};
var buildBridgeInstructions_default = buildBridgeInstructions;

// node_modules/@biconomy/abstractjs/dist/_esm/account/decorators/instructions/buildIntent.js
var buildIntent = async (baseParams, parameters) => {
  const { currentInstructions = [] } = baseParams;
  const { amount, token: { unifiedBalance }, toChainId, depositor, recipient, mode: mode2, metadata } = parameters;
  const { instructions } = await buildBridgeInstructions_default({
    depositor,
    recipient,
    amount,
    toChainId,
    unifiedBalance,
    mode: mode2,
    metadata
  });
  return [...currentInstructions, ...instructions];
};

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/erc7579/getActiveHook.js
var abi16 = [
  {
    inputs: [],
    name: "getActiveHook",
    outputs: [
      {
        internalType: "address",
        name: "hook",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var toGetActiveHookReads = async (account) => [
  {
    address: account.address,
    abi: abi16,
    functionName: "getActiveHook"
  }
];

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/erc7579/getFallbackBySelector.js
var abi17 = [
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "selector",
        type: "bytes4"
      }
    ],
    name: "getFallbackHandlerBySelector",
    outputs: [
      {
        internalType: "CallType",
        name: "",
        type: "bytes1"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var toGetFallbackBySelectorReads = async (account, selector) => [
  {
    address: account.address,
    abi: abi17,
    functionName: "getFallbackHandlerBySelector",
    args: [selector]
  }
];

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/erc7579/getInstalledExecutors.js
var abi18 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "cursor",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "size",
        type: "uint256"
      }
    ],
    name: "getExecutorsPaginated",
    outputs: [
      {
        internalType: "address[]",
        name: "array",
        type: "address[]"
      },
      {
        internalType: "address",
        name: "next",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var toGetInstalledExecutorsReads = async (account, { pageSize = 100n, cursor = SENTINEL_ADDRESS }) => [
  {
    address: account.address,
    abi: abi18,
    functionName: "getExecutorsPaginated",
    args: [cursor, pageSize]
  }
];

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/erc7579/getInstalledValidators.js
var abi19 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "cursor",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "size",
        type: "uint256"
      }
    ],
    name: "getValidatorsPaginated",
    outputs: [
      {
        internalType: "address[]",
        name: "array",
        type: "address[]"
      },
      {
        internalType: "address",
        name: "next",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var toGetInstalledValidatorsReads = async (account, { pageSize = 100n, cursor = SENTINEL_ADDRESS }) => [
  {
    address: account.address,
    abi: abi19,
    functionName: "getValidatorsPaginated",
    args: [cursor, pageSize]
  }
];

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/erc7579/supportsModule.js
var abi20 = [
  {
    name: "supportsModule",
    type: "function",
    stateMutability: "view",
    inputs: [
      {
        type: "uint256",
        name: "moduleTypeId"
      }
    ],
    outputs: [
      {
        type: "bool"
      }
    ]
  }
];
function parseModuleTypeId(type) {
  switch (type) {
    case "validator":
      return BigInt(1);
    case "executor":
      return BigInt(2);
    case "fallback":
      return BigInt(3);
    case "hook":
      return BigInt(4);
    default:
      throw new Error(`Invalid module type: ${type}`);
  }
}
var toSupportsModuleReads = async (account, { type }) => [
  {
    abi: abi20,
    functionName: "supportsModule",
    args: [parseModuleTypeId(type)],
    address: account.address
  }
];

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/erc7579/installModule.js
var toSafeSenderCalls = async (smartAccount, { address }) => {
  const meeValidatorAddress = smartAccount.version.validatorAddress;
  return addressEquals(address, SMART_SESSIONS_ADDRESS2) ? [
    {
      to: meeValidatorAddress,
      value: BigInt(0),
      data: encodeFunctionData({
        abi: [
          {
            name: "addSafeSender",
            type: "function",
            stateMutability: "nonpayable",
            inputs: [{ type: "address", name: "sender" }],
            outputs: []
          }
        ],
        functionName: "addSafeSender",
        args: [address]
      })
    }
  ] : [];
};
var toInstallModuleCalls = async (account, { address, initData, type }) => [
  {
    to: account.address,
    value: BigInt(0),
    data: encodeFunctionData({
      abi: [
        {
          name: "installModule",
          type: "function",
          stateMutability: "nonpayable",
          inputs: [
            {
              type: "uint256",
              name: "moduleTypeId"
            },
            {
              type: "address",
              name: "module"
            },
            {
              type: "bytes",
              name: "initData"
            }
          ],
          outputs: []
        }
      ],
      functionName: "installModule",
      args: [parseModuleTypeId(type), getAddress(address), initData ?? "0x"]
    })
  }
];
var toInstallWithSafeSenderCalls = async (account, { address, initData, type }) => [
  ...await toInstallModuleCalls(account, { address, initData, type }),
  ...await toSafeSenderCalls(account, { address, type })
];

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/erc7579/isModuleInstalled.js
var abi21 = [
  {
    name: "isModuleInstalled",
    type: "function",
    stateMutability: "view",
    inputs: [
      {
        type: "uint256",
        name: "moduleTypeId"
      },
      {
        type: "address",
        name: "module"
      },
      {
        type: "bytes",
        name: "additionalContext"
      }
    ],
    outputs: [
      {
        type: "bool"
      }
    ]
  }
];
var toIsModuleInstalledReads = async (account, { address, initData, type }) => [
  {
    abi: abi21,
    functionName: "isModuleInstalled",
    args: [parseModuleTypeId(type), getAddress(address), initData ?? "0x"],
    address: account.address
  }
];

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/erc7579/supportsExecutionMode.js
var abi22 = [
  {
    name: "supportsExecutionMode",
    type: "function",
    stateMutability: "view",
    inputs: [
      {
        type: "bytes32",
        name: "encodedMode"
      }
    ],
    outputs: [
      {
        type: "bool"
      }
    ]
  }
];
function parseCallType(callType) {
  switch (callType) {
    case "call":
      return "0x00";
    case "batchcall":
      return "0x01";
    case "delegatecall":
      return "0xff";
  }
}
function encodeExecutionMode({ type, revertOnError, selector, data }) {
  return encodePacked(["bytes1", "bytes1", "bytes4", "bytes4", "bytes22"], [
    toHex(toBytes(parseCallType(type), { size: 1 })),
    toHex(toBytes(revertOnError ? "0x01" : "0x00", { size: 1 })),
    toHex(toBytes("0x0", { size: 4 })),
    toHex(toBytes(selector ?? "0x", { size: 4 })),
    toHex(toBytes(data ?? "0x", { size: 22 }))
  ]);
}
var toSupportsExecutionModeReads = async (account, { type, revertOnError, selector, data }) => [
  {
    abi: abi22,
    functionName: "supportsExecutionMode",
    args: [encodeExecutionMode({ type, revertOnError, selector, data })],
    address: account.address
  }
];

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/erc7579/uninstallFallback.js
var toUninstallFallbackCalls = async (account, { address, initData, type }) => [
  {
    to: account.address,
    value: BigInt(0),
    data: encodeFunctionData({
      abi: [
        {
          name: "uninstallFallback",
          type: "function",
          stateMutability: "nonpayable",
          inputs: [
            {
              type: "uint256",
              name: "moduleTypeId"
            },
            {
              type: "address",
              name: "module"
            },
            {
              type: "bytes",
              name: "deInitData"
            }
          ],
          outputs: []
        }
      ],
      functionName: "uninstallFallback",
      args: [parseModuleTypeId(type), getAddress(address), initData ?? "0x"]
    })
  }
];

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/erc7579/uninstallModule.js
var toUninstallModuleCalls = async (account, { address, deInitData = "0x", type }) => [
  {
    to: account.address,
    value: BigInt(0),
    data: encodeFunctionData({
      abi: [
        {
          name: "uninstallModule",
          type: "function",
          stateMutability: "nonpayable",
          inputs: [
            {
              type: "uint256",
              name: "moduleTypeId"
            },
            {
              type: "address",
              name: "module"
            },
            {
              type: "bytes",
              name: "deInitData"
            }
          ],
          outputs: []
        }
      ],
      functionName: "uninstallModule",
      args: [parseModuleTypeId(type), getAddress(address), deInitData]
    })
  }
];

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/erc7579/index.js
var erc7579Calls = {
  toInstallModuleCalls,
  toUninstallModuleCalls,
  toInstallWithSafeSenderCalls,
  toSafeSenderCalls,
  toUninstallFallbackCalls
};
var erc7579Reads = {
  toIsModuleInstalledReads,
  toGetActiveHookReads,
  toGetFallbackBySelectorReads,
  toGetInstalledExecutorsReads,
  toGetInstalledValidatorsReads,
  toSupportsExecutionModeReads,
  toSupportsModuleReads
};

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/smartAccount/upgradeSmartAccount.js
var toUpgradeSmartAccountCalls = async (account, { implementationAddress, initData }) => [
  {
    to: account.address,
    value: BigInt(0),
    data: encodeFunctionData({
      abi: [
        {
          name: "upgradeToAndCall",
          type: "function",
          stateMutability: "payable",
          inputs: [
            {
              type: "address",
              name: "newImplementation"
            },
            {
              type: "bytes",
              name: "data"
            }
          ],
          outputs: []
        }
      ],
      functionName: "upgradeToAndCall",
      args: [getAddress(implementationAddress), initData]
    })
  }
];

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/smartAccount/index.js
var smartAccountCalls = {
  toUpgradeSmartAccountCalls
};

// node_modules/@biconomy/abstractjs/dist/_esm/modules/validators/ownable/decorators/getAddOwnerTx.js
async function getAddOwnerTx(client, parameters) {
  const { account: account_ = client.account, owner } = parameters;
  if (!account_) {
    throw new AccountNotFoundError2({
      docsPath: "/nexus-client/methods#sendtransaction"
    });
  }
  const account = parseAccount(account_);
  const publicClient = account.client;
  if (!publicClient) {
    throw new Error("Public client not found");
  }
  const nexusAccount = getAccount({
    address: account.address,
    type: "nexus"
  });
  const action = await getAddOwnableValidatorOwnerAction({
    account: nexusAccount,
    client: publicClient,
    owner
  });
  if (!("callData" in action)) {
    throw new Error("Error getting set threshold actions");
  }
  return {
    to: action.target,
    value: BigInt(action.value.toString()),
    data: action.callData
  };
}
var toAddOwnerCalls = async (account, parameters) => {
  return [await getAddOwnerTx({}, { ...parameters, account })];
};

// node_modules/@biconomy/abstractjs/dist/_esm/modules/validators/ownable/decorators/getOwners.js
async function getOwners(client, parameters) {
  const { account: account_ = client.account } = parameters ?? {};
  if (!account_) {
    throw new AccountNotFoundError2({
      docsPath: "/nexus-client/methods#sendtransaction"
    });
  }
  const account = parseAccount(account_);
  const publicClient = account?.client;
  if (!publicClient) {
    throw new Error("Public client not found");
  }
  const nexusAccount = getAccount({
    address: account.address,
    type: "nexus"
  });
  return getOwnableValidatorOwners({
    account: nexusAccount,
    client: publicClient
  });
}

// node_modules/@biconomy/abstractjs/dist/_esm/modules/validators/ownable/decorators/getRemoveOwnerTx.js
async function getRemoveOwnerTx(client, parameters) {
  const { account: account_ = client.account, owner } = parameters;
  if (!account_) {
    throw new AccountNotFoundError2({
      docsPath: "/nexus-client/methods#sendtransaction"
    });
  }
  const account = parseAccount(account_);
  const publicClient = account.client;
  if (!publicClient) {
    throw new Error("Public client not found");
  }
  const action = await getRemoveOwnableValidatorOwnerAction({
    account: { address: account.address, deployedOnChains: [], type: "nexus" },
    client: publicClient,
    owner
  });
  if (!("callData" in action)) {
    throw new Error("Error getting remove owner action");
  }
  return {
    to: action.target,
    value: BigInt(action.value.toString()),
    data: action.callData
  };
}
var toRemoveOwnerCalls = async (account, parameters) => {
  return [await getRemoveOwnerTx({}, { ...parameters, account })];
};

// node_modules/@biconomy/abstractjs/dist/_esm/modules/validators/ownable/decorators/getSetThresholdTx.js
async function getSetThresholdTx(client, parameters) {
  const { account: account_ = client.account, threshold } = parameters;
  if (!account_) {
    throw new AccountNotFoundError2({
      docsPath: "/nexus-client/methods#sendtransaction"
    });
  }
  const account = parseAccount(account_);
  if (!account)
    throw new Error("Account not found");
  const action = getSetOwnableValidatorThresholdAction({ threshold });
  if (!("callData" in action)) {
    throw new Error("Error getting set threshold actions");
  }
  return {
    to: action.target,
    value: BigInt(action.value.toString()),
    data: action.callData
  };
}
var toSetThresholdCalls = async (account, parameters) => {
  return [await getSetThresholdTx({}, { ...parameters, account })];
};

// node_modules/@biconomy/abstractjs/dist/_esm/modules/validators/ownable/decorators/getThreshold.js
async function getThreshold(client, parameters) {
  const { account: account_ = client.account } = parameters ?? {};
  if (!account_) {
    throw new AccountNotFoundError2({
      docsPath: "/nexus-client/methods#sendtransaction"
    });
  }
  const account = parseAccount(account_);
  const publicClient = account?.client;
  if (!publicClient) {
    throw new Error("Public client not found");
  }
  const nexusAccount = getAccount({
    address: account.address,
    type: "nexus"
  });
  return await getOwnableValidatorThreshold({
    account: nexusAccount,
    client: publicClient
  });
}

// node_modules/@biconomy/abstractjs/dist/_esm/modules/validators/ownable/decorators/index.js
var ownableCalls = {
  toAddOwnerCalls,
  toSetThresholdCalls,
  toRemoveOwnerCalls
};
var ownableReads = {
  toGetOwnersReads: getOwners,
  toGetThresholdReads: getThreshold
};

// node_modules/@biconomy/abstractjs/dist/_esm/modules/validators/toValidator.js
var toValidator = (parameters) => {
  const { deInitData = "0x", type = "validator", signer, data = "0x", module, ...rest } = parameters;
  return {
    deInitData,
    data,
    module,
    address: module,
    signer,
    type,
    getStubSignature: async () => DUMMY_SIGNATURE,
    signUserOpHash: async (userOpHash) => await signer.signMessage({ message: { raw: userOpHash } }),
    signMessage: async (message) => await signer.signMessage({ message }),
    ...rest
  };
};

// node_modules/@biconomy/abstractjs/dist/_esm/modules/validators/smartSessions/Helpers.js
var DUMMY_SIGNATURE = "0x81d4b4981670cb18f99f0b4a66446df1bf5b204d24cfcb659bf38ba27a4359b5711649ec2423c5e1247245eba2964679b6a1dbb85c992ae40b9b00c6935b02ff1b";

// node_modules/@biconomy/abstractjs/dist/_esm/modules/validators/smartSessions/Types.js
var ParamCondition2;
(function(ParamCondition3) {
  ParamCondition3[ParamCondition3["EQUAL"] = 0] = "EQUAL";
  ParamCondition3[ParamCondition3["GREATER_THAN"] = 1] = "GREATER_THAN";
  ParamCondition3[ParamCondition3["LESS_THAN"] = 2] = "LESS_THAN";
  ParamCondition3[ParamCondition3["GREATER_THAN_OR_EQUAL"] = 3] = "GREATER_THAN_OR_EQUAL";
  ParamCondition3[ParamCondition3["LESS_THAN_OR_EQUAL"] = 4] = "LESS_THAN_OR_EQUAL";
  ParamCondition3[ParamCondition3["NOT_EQUAL"] = 5] = "NOT_EQUAL";
})(ParamCondition2 || (ParamCondition2 = {}));

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/mee/executeSignedQuote.js
var executeSignedQuote = async (client, params) => client.request({
  path: "exec",
  body: params.signedQuote
});
var executeSignedQuote_default = executeSignedQuote;

// node_modules/@biconomy/abstractjs/dist/_esm/account/utils/resolveInstructions.js
var resolveInstructions = async (instructions) => {
  return (await Promise.all(instructions.flatMap((iIs) => typeof iIs === "function" ? iIs() : iIs).filter(Boolean))).flat();
};

// node_modules/@biconomy/abstractjs/dist/_esm/account/utils/Helpers.js
var isDebugging = () => {
  try {
    return process?.env?.BICONOMY_SDK_DEBUG === "true" || process?.env?.REACT_APP_BICONOMY_SDK_DEBUG === "true" || process?.env?.NEXT_PUBLIC_BICONOMY_SDK_DEBUG === "true";
  } catch (e) {
    return false;
  }
};
var isTesting = () => {
  try {
    return "development"?.toString() === "test";
  } catch (e) {
    return false;
  }
};
var isStaging = () => {
  try {
    return process?.env?.STAGING?.toString() === "true";
  } catch (e) {
    return false;
  }
};

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/mee/getGasToken.js
var getGasToken = async (client, parameters) => {
  const gasToken = client.info.supportedGasTokens.find((gasToken2) => Number(gasToken2.chainId) === Number(parameters.chainId));
  if (!gasToken) {
    throw new Error(`Gas token not found for chain ${parameters.chainId}`);
  }
  return gasToken;
};

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/mee/getSupportedFeeToken.js
var getSupportedFeeToken = async (client, parameters) => {
  const gasToken = await getGasToken(client, {
    chainId: parameters.chainId,
    address: parameters.tokenAddress
  });
  const supportedFeeToken = gasToken.paymentTokens.find((supportedFeeToken2) => addressEquals(supportedFeeToken2.address, parameters.tokenAddress));
  return {
    isArbitraryFeeTokensSupported: gasToken.isArbitraryFeeTokensSupported,
    supportedFeeToken
  };
};

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/mee/getQuoteType.js
var isPermitTokenInfo = async (client, trigger) => {
  let permitEnabled = false;
  const supportedFeeTokenInfo = await getSupportedFeeToken(client, {
    tokenAddress: trigger.tokenAddress,
    chainId: trigger.chainId
  });
  if (supportedFeeTokenInfo.supportedFeeToken) {
    permitEnabled = supportedFeeTokenInfo.supportedFeeToken.permitEnabled || false;
  } else {
    const { walletClient } = client.account.deploymentOn(trigger.chainId, true);
    permitEnabled = await isPermitSupported(walletClient, trigger.tokenAddress);
  }
  return permitEnabled;
};
var isNormalQuote = (payload) => {
  const isTriggerAvailable = "trigger" in payload;
  return !isTriggerAvailable;
};
var isPermitQuote = async (client, payload) => {
  const isTriggerAvailable = "trigger" in payload;
  if (!isTriggerAvailable)
    return false;
  const trigger = payload.trigger;
  if ("call" in trigger) {
    return false;
  }
  const permitEnabled = await isPermitTokenInfo(
    client,
    trigger
    // trigger can only be of type TokenTrigger at this point
  );
  return permitEnabled;
};
var isOnChainQuote = async (client, payload) => {
  const isTriggerAvailable = "trigger" in payload;
  if (!isTriggerAvailable)
    return false;
  const trigger = payload.trigger;
  if ("call" in trigger) {
    return true;
  }
  const permitEnabled = await isPermitTokenInfo(
    client,
    trigger
    // trigger can only be of type TokenTrigger at this point
  );
  return !permitEnabled;
};
var getQuoteType = async (client, quoteParams) => {
  if (isNormalQuote(quoteParams)) {
    return "simple";
  }
  if (await isPermitQuote(client, quoteParams)) {
    return "permit";
  }
  if (await isOnChainQuote(client, quoteParams)) {
    return "onchain";
  }
  throw new Error("Invalid quote, can't determine quote type");
};

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/mee/signMmDtkQuote.js
var MM_DTK_PREFIX = "0x177eee03";
var signMMDtkQuote = async (client, parameters) => {
  const { companionAccount: account_ = client.account, delegatorSmartAccount, fusionQuote: { quote, trigger } } = parameters;
  if (trigger.call) {
    throw new Error("Custom triggers are not supported for fusion transactions");
  }
  if (!trigger.amount)
    throw new Error("Amount is required to sign a MM DTK quote");
  const environment = delegatorSmartAccount.environment;
  const caveatBuilder = createCaveatBuilder(environment);
  const approvedCallData = concatHex([
    encodeFunctionData({
      abi: erc20Abi,
      functionName: "approve",
      args: [
        account_.addressOn(trigger.chainId, true),
        // spender
        trigger.amount
        // amount
      ]
    }),
    quote.hash
    // SuperTxn Hash
  ]);
  const caveats = caveatBuilder.addCaveat("exactExecution", {
    target: trigger.tokenAddress,
    value: 0n,
    // 0 ETH
    callData: approvedCallData
  });
  const openRootDelegation = createOpenDelegation({
    from: delegatorSmartAccount.address,
    caveats
  });
  const signature = await delegatorSmartAccount.signDelegation({
    delegation: openRootDelegation
  });
  const delegationManager = getDelegationManager(trigger.chainId);
  const redeemDelegationErc7579ExecutionCalldata = encodePacked(["address", "uint256", "bytes"], [trigger.tokenAddress, 0n, approvedCallData]);
  const encodedSignature = encodeAbiParameters([
    { name: "delegationManager", type: "address" },
    {
      name: "delegation",
      type: "tuple",
      components: [
        { name: "delegate", type: "address" },
        { name: "delegator", type: "address" },
        { name: "authority", type: "bytes32" },
        {
          name: "caveats",
          type: "tuple[]",
          components: [
            { name: "enforcer", type: "address" },
            { name: "terms", type: "bytes" },
            { name: "args", type: "bytes" }
          ]
        },
        { name: "salt", type: "uint256" },
        { name: "signature", type: "bytes" }
      ]
    },
    { name: "redeemDelegationErc7579ExecutionCalldata", type: "bytes" }
  ], [
    delegationManager,
    {
      delegate: openRootDelegation.delegate,
      delegator: openRootDelegation.delegator,
      authority: openRootDelegation.authority,
      caveats: openRootDelegation.caveats.map((caveat) => ({
        enforcer: caveat.enforcer,
        terms: caveat.terms,
        args: caveat.args
      })),
      salt: openRootDelegation.salt === "0x" ? BigInt(0) : BigInt(openRootDelegation.salt),
      signature
    },
    redeemDelegationErc7579ExecutionCalldata
  ]);
  return { ...quote, signature: concatHex([MM_DTK_PREFIX, encodedSignature]) };
};
var getDelegationManager = (chainId) => {
  if (DELEGATOR_CONTRACTS["1.3.0"][chainId]?.DelegationManager) {
    return DELEGATOR_CONTRACTS["1.3.0"][chainId].DelegationManager;
  }
  if (DELEGATOR_CONTRACTS["1.1.0"][chainId]?.DelegationManager) {
    return DELEGATOR_CONTRACTS["1.1.0"][chainId].DelegationManager;
  }
  if (DELEGATOR_CONTRACTS["1.0.0"][chainId]?.DelegationManager) {
    return DELEGATOR_CONTRACTS["1.0.0"][chainId].DelegationManager;
  }
  throw new Error(`No delegation manager found for chainId ${chainId}. Supported chains are: ${Object.values(CHAIN_ID).join(", ")}`);
};

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/mee/signOnChainQuote.js
var FUSION_NATIVE_TRANSFER_PREFIX = "0x150b7a02";
var ON_CHAIN_PREFIX = "0x177eee01";
var generateTriggerCallFromTrigger = async ({ trigger, spender, recipient, version }) => {
  let triggerCall;
  if (trigger.call) {
    triggerCall = trigger.call;
  } else if (trigger.tokenAddress === zeroAddress) {
    const forwardCalldata = encodeFunctionData({
      abi: ForwarderAbi,
      functionName: "forward",
      args: [recipient]
    });
    const ethForwardCall = {
      to: version.ethForwarderAddress,
      data: forwardCalldata,
      value: trigger.amount
    };
    triggerCall = ethForwardCall;
  } else {
    if (trigger.approvalAmount && trigger.amount !== void 0 && trigger.approvalAmount < trigger.amount) {
      throw new Error(`Approval amount must be bigger or equal with the amount from the trigger (triggerAmount: ${trigger.amount} amount: ${trigger.approvalAmount})`);
    }
    const amount = trigger.approvalAmount ?? trigger.amount;
    if (!amount)
      throw new Error("Invalid trigger amount");
    const approveCall = {
      to: trigger.tokenAddress,
      data: encodeFunctionData({
        abi: erc20Abi,
        functionName: "approve",
        args: [spender, amount]
      })
    };
    triggerCall = approveCall;
  }
  return triggerCall;
};
var prepareExecutableOnChainQuotePayload = async (quoteParams, spender, recipient, version) => {
  const { quote, trigger } = quoteParams;
  const triggerCall = await generateTriggerCallFromTrigger({
    trigger,
    spender,
    recipient,
    version
  });
  const dataOrPrefix = triggerCall?.data ?? FUSION_NATIVE_TRANSFER_PREFIX;
  const call2 = { ...triggerCall, data: concatHex([dataOrPrefix, quote.hash]) };
  return {
    executablePayload: call2,
    metadata: {}
  };
};
var formatSignedOnChainQuotePayload = (quoteParams, _metadata, hash) => {
  const { quote, trigger } = quoteParams;
  const signature = concatHex([
    ON_CHAIN_PREFIX,
    encodeAbiParameters([{ type: "bytes32" }, { type: "uint256" }], [hash, BigInt(trigger.chainId)])
  ]);
  return {
    ...quote,
    signature
  };
};
var signOnChainQuote = async (client, params) => {
  const { confirmations = 2, companionAccount: account_ = client.account, fusionQuote: { trigger } } = params;
  const { walletClient, address: spender, version } = account_.deploymentOn(trigger.chainId, true);
  const recipient = trigger.recipientAddress || spender;
  const { executablePayload, metadata } = await prepareExecutableOnChainQuotePayload(
    params.fusionQuote,
    spender,
    // In terms of token approval. Spender will be used for approving for SCA
    recipient,
    // In terms of native token deposit, this recipient will be used for target deposit address
    version
  );
  const hash = await walletClient.sendTransaction(executablePayload);
  await walletClient.waitForTransactionReceipt({ hash, confirmations });
  return formatSignedOnChainQuotePayload(params.fusionQuote, metadata, hash);
};
var signOnChainQuote_default = signOnChainQuote;

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/mee/signPermitQuote.js
var PERMIT_PREFIX = "0x177eee02";
var prepareSignablePermitQuotePayload = async (quoteParams, owner, spender, publicClient) => {
  const { quote, trigger } = quoteParams;
  if (trigger.call) {
    throw new Error("Custom triggers are not supported for permit quotes");
  }
  if (!trigger.amount)
    throw new Error("Amount is required to sign a permit quote");
  if (trigger.approvalAmount && trigger.amount !== void 0 && trigger.approvalAmount < trigger.amount) {
    throw new Error(`Approval amount must be bigger or equal with the amount from the trigger (triggerAmount: ${trigger.amount} amount: ${trigger.approvalAmount})`);
  }
  const amount = trigger.approvalAmount ?? trigger.amount;
  const values = await multicall(publicClient, {
    contracts: [
      {
        address: trigger.tokenAddress,
        abi: TokenWithPermitAbi,
        functionName: "nonces",
        args: [owner]
      },
      {
        address: trigger.tokenAddress,
        abi: TokenWithPermitAbi,
        functionName: "name"
      },
      {
        address: trigger.tokenAddress,
        abi: TokenWithPermitAbi,
        functionName: "version"
      },
      {
        address: trigger.tokenAddress,
        abi: TokenWithPermitAbi,
        functionName: "DOMAIN_SEPARATOR"
      },
      {
        address: trigger.tokenAddress,
        abi: TokenWithPermitAbi,
        functionName: "eip712Domain"
      }
    ]
  });
  const [nonce, name, version, domainSeparator2, eip712Domain] = values.map((value, i) => {
    const key = [
      "nonce",
      "name",
      "version",
      "domainSeparator",
      "eip712Domain"
    ][i];
    if (value.status === "success") {
      return value.result;
    }
    if (value.status === "failure") {
      if (key === "nonce") {
        throw new Error("Permit signing failed: Token does not implement nonces(). This function is required for EIP-2612 compliance.");
      }
      if (key === "domainSeparator") {
        throw new Error("Permit signing failed: Token does not implement DOMAIN_SEPARATOR(). This function is required for EIP-712 domain separation.");
      }
      if (key === "name" || key === "version") {
        return void 0;
      }
      if (key === "eip712Domain") {
        return [];
      }
    }
    return void 0;
  });
  const [, name_, version_] = eip712Domain;
  const defaultVersion = "1";
  if (version?.length >= 0 && version_?.length >= 0) {
    if (version !== version_)
      console.warn("Warning: Mismatch between token version() and eip712Domain().version. This may cause permit signature verification to fail.");
  }
  if (name?.length >= 0 && name_?.length >= 0) {
    if (name !== name_)
      console.warn("Warning: Mismatch between token name() and eip712Domain().name. This may cause permit signature verification to fail.");
  }
  if (name === void 0 && name_ === void 0) {
    throw new Error("Permit signing failed: Token name is missing. Neither name() nor eip712Domain().name is available.");
  }
  const signablePermitQuotePayload = {
    domain: {
      name: name_ ?? name,
      // name from eip712Domain is mostly safe and more priority is given
      version: version_ ?? version ?? defaultVersion,
      // version from eip712Domain is mostly safe and more priority is given
      chainId: trigger.chainId,
      verifyingContract: trigger.tokenAddress
    },
    types: {
      Permit: [
        { name: "owner", type: "address" },
        { name: "spender", type: "address" },
        { name: "value", type: "uint256" },
        { name: "nonce", type: "uint256" },
        { name: "deadline", type: "uint256" }
      ]
    },
    primaryType: "Permit",
    message: {
      owner,
      spender,
      value: amount,
      nonce,
      deadline: BigInt(quote.hash)
    }
  };
  return {
    signablePayload: signablePermitQuotePayload,
    metadata: {
      nonce,
      name: name_ ?? name,
      version: version_ ?? version ?? defaultVersion,
      domainSeparator: domainSeparator2,
      owner,
      spender,
      amount
    }
  };
};
var formatSignedPermitQuotePayload = (quoteParams, metadata, signature) => {
  const { quote, trigger } = quoteParams;
  const sigComponents = parseSignature(signature);
  const encodedSignature = encodeAbiParameters([
    { name: "token", type: "address" },
    { name: "spender", type: "address" },
    { name: "domainSeparator", type: "bytes32" },
    { name: "permitTypehash", type: "bytes32" },
    { name: "amount", type: "uint256" },
    { name: "chainId", type: "uint256" },
    { name: "nonce", type: "uint256" },
    { name: "v", type: "uint256" },
    { name: "r", type: "bytes32" },
    { name: "s", type: "bytes32" }
  ], [
    trigger.tokenAddress,
    metadata.spender,
    metadata.domainSeparator,
    PERMIT_TYPEHASH,
    metadata.amount,
    BigInt(trigger.chainId),
    metadata.nonce,
    sigComponents.v,
    sigComponents.r,
    sigComponents.s
  ]);
  return { ...quote, signature: concatHex([PERMIT_PREFIX, encodedSignature]) };
};
var signPermitQuote = async (client, parameters) => {
  const { companionAccount: account_ = client.account, fusionQuote: { trigger } } = parameters;
  const signer = account_.signer;
  const { walletClient, address: spender } = account_.deploymentOn(trigger.chainId, true);
  const owner = signer.address;
  const { signablePayload, metadata } = await prepareSignablePermitQuotePayload(parameters.fusionQuote, owner, spender, walletClient);
  const signature = await walletClient.signTypedData({
    ...signablePayload,
    account: walletClient.account
  });
  return formatSignedPermitQuotePayload(parameters.fusionQuote, metadata, signature);
};
var signPermitQuote_default = signPermitQuote;

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/mee/signFusionQuote.js
var signFusionQuote = async (client, parameters) => {
  if ("delegatorSmartAccount" in parameters) {
    return signMMDtkQuote(client, parameters);
  }
  const signatureType = parameters.fusionQuote.quote.quoteType || await getQuoteType(client, parameters.fusionQuote);
  switch (signatureType) {
    case "permit":
      return signPermitQuote(client, parameters);
    case "onchain":
      return signOnChainQuote_default(client, parameters);
    default:
      throw new Error("Invalid quote type for fusion quote");
  }
};
var signFusionQuote_default = signFusionQuote;

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/mee/executeFusionQuote.js
var executeFusionQuote = async (client, parameters) => {
  const signedFusionQuote = await signFusionQuote_default(client, parameters);
  let trigger = void 0;
  if (parameters.fusionQuote.trigger && !parameters.fusionQuote.trigger.call) {
    trigger = parameters.fusionQuote.trigger;
  }
  return executeSignedQuote_default(client, {
    signedQuote: {
      ...signedFusionQuote,
      trigger
    }
  });
};

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/mee/signQuote.js
var DEFAULT_PREFIX = "0x177eee00";
var prepareSignableQuotePayload = (quote) => {
  return {
    signablePayload: {
      message: { raw: quote.hash }
    },
    metadata: {}
  };
};
var formatSignedQuotePayload = (quote, _metadata, signature) => {
  return {
    ...quote,
    signature: concatHex([DEFAULT_PREFIX, signature])
  };
};
var signQuote = async (client, params) => {
  const { account: account_ = client.account, quote } = params;
  const signer = account_.signer;
  const { signablePayload, metadata } = prepareSignableQuotePayload(quote);
  const signedMessage = await signer.signMessage(signablePayload);
  return formatSignedQuotePayload(quote, metadata, signedMessage);
};
var signQuote_default = signQuote;

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/mee/executeQuote.js
var executeQuote2 = async (client, params) => {
  const signedQuote = await signQuote(client, params);
  return executeSignedQuote(client, { signedQuote });
};
var executeQuote_default = executeQuote2;

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/mee/getMmDtkQuote.js
var DEFAULT_VERIFICATION_GAS_LIMIT_FOR_MM_DTK = 200000n;
var getMmDtkQuote = async (client, parameters) => {
  const { account: account_ = client.account, trigger, cleanUps, instructions, batch = true, gasLimit, verificationGasLimit, delegatorSmartAccount, ...rest } = parameters;
  const resolvedInstructions = await resolveInstructions(instructions);
  const sender = delegatorSmartAccount.address;
  const spender = account_.addressOn(trigger.chainId, true);
  const recipient = trigger.recipientAddress || spender;
  const { triggerGasLimit, triggerAmount, batchedInstructions } = await prepareInstructions(client, {
    resolvedInstructions,
    trigger,
    owner: sender,
    spender,
    recipient,
    account: account_,
    batch
  });
  const triggerInfo = {
    tokenAddress: trigger.tokenAddress,
    chainId: trigger.chainId,
    gasLimit: triggerGasLimit,
    amount: triggerAmount,
    // Amount without fees and fees will be added below
    ...trigger.approvalAmount ? { approvalAmount: trigger.approvalAmount } : {},
    ...trigger.recipientAddress ? { recipientAddress: trigger.recipientAddress } : {}
  };
  const quote = await getQuote2(client, {
    path: "quote-permit",
    eoa: sender,
    // it is not an EOA, but a smart account in this case, however param is named `eoa` for backward compatibility, see `GetQuoteParams` type for more details
    instructions: batchedInstructions,
    gasLimit: gasLimit || triggerGasLimit,
    batch,
    verificationGasLimit: verificationGasLimit || DEFAULT_VERIFICATION_GAS_LIMIT_FOR_MM_DTK,
    ...cleanUps ? { cleanUps } : {},
    ...rest
  }, "mm-dtk", triggerInfo);
  let fees2 = trigger.useMaxAvailableFunds ? 0n : BigInt(quote.paymentInfo.tokenWeiAmount);
  if (rest.sponsorship) {
    fees2 = 0n;
  }
  triggerInfo.amount += fees2;
  return {
    quote,
    trigger: triggerInfo
  };
};
var getMmDtkQuote_default = getMmDtkQuote;

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/mee/getOnChainQuote.js
var getOnChainQuote = async (client, parameters) => {
  const { account: account_ = client.account, trigger, cleanUps, instructions, batch = true, gasLimit, ...rest } = parameters;
  const meeVersions = client.account.deployments.map(({ version, chain }) => ({
    chainId: chain.id,
    version
  }));
  const resolvedInstructions = await resolveInstructions(instructions);
  if (trigger.call) {
    const batchedInstructions2 = await batchInstructions({
      accountAddress: account_.signer.address,
      meeVersions,
      instructions: resolvedInstructions
    });
    const quote2 = await getQuote2(client, {
      path: "quote",
      eoa: account_.signer.address,
      batch,
      instructions: batchedInstructions2,
      gasLimit: gasLimit || DEFAULT_GAS_LIMIT,
      ...cleanUps ? { cleanUps } : {},
      ...rest
    });
    return {
      quote: quote2,
      trigger
    };
  }
  const owner = account_.signer.address;
  const spender = account_.addressOn(trigger.chainId, true);
  const recipient = trigger.recipientAddress || spender;
  const { triggerGasLimit, triggerAmount, batchedInstructions } = await prepareInstructions(client, {
    resolvedInstructions,
    trigger,
    owner,
    // EOA address
    spender,
    // For on chain quotes, the funds are directly deposited. So this param is not mostly used
    recipient,
    // Either the SCA takes amount for itself or transferred for custom recipient
    account: account_,
    batch
  });
  const triggerInfo = {
    tokenAddress: trigger.tokenAddress,
    chainId: trigger.chainId,
    gasLimit: triggerGasLimit,
    amount: triggerAmount,
    // Amount without fees and fees will be added below
    ...trigger.approvalAmount ? { approvalAmount: trigger.approvalAmount } : {},
    ...trigger.recipientAddress ? { recipientAddress: trigger.recipientAddress } : {}
  };
  const quote = await getQuote2(client, {
    path: "quote-permit",
    eoa: account_.signer.address,
    instructions: batchedInstructions,
    batch,
    gasLimit: gasLimit || triggerGasLimit,
    ...cleanUps ? { cleanUps } : {},
    ...rest
  }, "onchain", triggerInfo);
  let fees2 = trigger.useMaxAvailableFunds ? 0n : BigInt(quote.paymentInfo.tokenWeiAmount);
  if (rest.sponsorship) {
    fees2 = 0n;
  }
  triggerInfo.amount += fees2;
  return {
    quote,
    trigger: triggerInfo
  };
};
var getOnChainQuote_default = getOnChainQuote;

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/mee/getPermitQuote.js
var getPermitQuote = async (client, parameters) => {
  const { account: account_ = client.account, trigger, cleanUps, instructions, batch = true, gasLimit, ...rest } = parameters;
  if (trigger.call) {
    throw new Error("Custom call trigger is not supported for permit quotes");
  }
  const owner = account_.signer.address;
  const spender = account_.addressOn(trigger.chainId, true);
  const recipient = trigger.recipientAddress || spender;
  const resolvedInstructions = await resolveInstructions(instructions);
  const { triggerGasLimit, triggerAmount, batchedInstructions } = await prepareInstructions(client, {
    resolvedInstructions,
    trigger,
    owner,
    // EOA address
    spender,
    // SCA address who gets the approval for spend initiation
    recipient,
    // Either the SCA takes amount for itself or transferred for custom recipient
    account: account_,
    batch
  });
  const eoa = account_.signer.address;
  const triggerInfo = {
    tokenAddress: trigger.tokenAddress,
    chainId: trigger.chainId,
    gasLimit: triggerGasLimit,
    amount: triggerAmount,
    // Amount without fees and fees will be added below
    ...trigger.approvalAmount ? { approvalAmount: trigger.approvalAmount } : {},
    ...trigger.recipientAddress ? { recipientAddress: trigger.recipientAddress } : {}
  };
  const quote = await getQuote2(client, {
    path: "quote-permit",
    // Use different endpoint for permit enabled tokens
    eoa,
    batch,
    instructions: batchedInstructions,
    gasLimit: gasLimit || triggerGasLimit,
    ...cleanUps ? { cleanUps } : {},
    ...rest
  }, "permit", triggerInfo);
  let fees2 = trigger.useMaxAvailableFunds ? 0n : BigInt(quote.paymentInfo.tokenWeiAmount);
  if (rest.sponsorship) {
    fees2 = 0n;
  }
  triggerInfo.amount += fees2;
  return {
    quote,
    trigger: triggerInfo
  };
};
var getPermitQuote_default = getPermitQuote;

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/mee/getFusionQuote.js
var getFusionQuote = async (client, parameters) => {
  if (parameters.delegatorSmartAccount) {
    return getMmDtkQuote_default(client, parameters);
  }
  const signatureType = await getQuoteType(client, parameters);
  switch (signatureType) {
    case "permit":
      return getPermitQuote_default(client, parameters);
    case "onchain":
      return getOnChainQuote_default(client, parameters);
    default:
      throw new Error("Invalid quote type for fusion quote");
  }
};
var prepareInstructions = async (client, parameters) => {
  const { resolvedInstructions, trigger, owner, spender, recipient, account, batch = true } = parameters;
  const meeVersions = client.account.deployments.map(({ version, chain }) => ({
    chainId: chain.id,
    version
  }));
  let triggerAmount = 0n;
  if (trigger.useMaxAvailableFunds) {
    const { publicClient } = client.account.deploymentOn(trigger.chainId, true);
    if (trigger.tokenAddress === zeroAddress) {
      const { version } = account.deploymentOn(trigger.chainId, true);
      const forwardCalldata = encodeFunctionData({
        abi: ForwarderAbi,
        functionName: "forward",
        args: [recipient]
      });
      const [balance, gasPrice, gasLimit] = await Promise.all([
        publicClient.getBalance({ address: owner }),
        publicClient.getGasPrice(),
        publicClient.estimateGas({
          account: owner,
          to: version.ethForwarderAddress,
          data: forwardCalldata,
          value: 100n
          // Dummy amount
        })
      ]);
      const gasLimitWithBuffer = gasLimit * 200n / 100n;
      const gasBuffer = 2;
      const baseCost = gasLimitWithBuffer * gasPrice;
      const gasReserve = BigInt(Math.ceil(Number(baseCost) * gasBuffer));
      if (balance <= gasReserve) {
        throw new Error("Not enough native token to transfer");
      }
      triggerAmount = balance - gasReserve;
    } else {
      triggerAmount = await publicClient.readContract({
        address: trigger.tokenAddress,
        abi: erc20Abi,
        functionName: "balanceOf",
        args: [owner]
      });
    }
  } else {
    if (!trigger.amount)
      throw new Error("Trigger amount field is required");
    triggerAmount = trigger.amount;
  }
  let isComposable = resolvedInstructions.some(({ isComposable: isComposable2 }) => isComposable2);
  let transferFromAmount = 0n;
  if (trigger.useMaxAvailableFunds && trigger.tokenAddress !== zeroAddress) {
    transferFromAmount = runtimeERC20AllowanceOf({
      owner,
      spender,
      tokenAddress: trigger.tokenAddress,
      constraints: [greaterThanOrEqualTo(1n)]
    });
    isComposable = true;
  } else {
    transferFromAmount = triggerAmount;
  }
  const triggerGasLimit = trigger.gasLimit ? trigger.gasLimit : DEFAULT_GAS_LIMIT;
  if (trigger.tokenAddress === zeroAddress) {
    let batchedInstructions2 = [];
    if (batch) {
      batchedInstructions2 = await batchInstructions({
        accountAddress: account.signer.address,
        meeVersions,
        instructions: resolvedInstructions
      });
    } else {
      batchedInstructions2 = resolvedInstructions;
    }
    return { triggerGasLimit, triggerAmount, batchedInstructions: batchedInstructions2 };
  }
  const params = {
    type: "transferFrom",
    data: {
      tokenAddress: trigger.tokenAddress,
      chainId: trigger.chainId,
      amount: transferFromAmount,
      recipient,
      sender: owner,
      gasLimit: triggerGasLimit
    }
  };
  const triggerTransfer = await (isComposable ? account.buildComposable(params) : account.build(params));
  let batchedInstructions = [];
  if (batch) {
    batchedInstructions = await batchInstructions({
      accountAddress: account.signer.address,
      meeVersions,
      instructions: [...triggerTransfer, ...resolvedInstructions]
    });
  } else {
    batchedInstructions = [...triggerTransfer, ...resolvedInstructions];
  }
  return { triggerGasLimit, triggerAmount, batchedInstructions };
};
var getFusionQuote_default = getFusionQuote;

// node_modules/@biconomy/abstractjs/dist/_esm/account/utils/parseTransactionStatus.js
var parseTransactionStatus = async (userOps, mode2 = "default") => {
  if (!userOps || userOps.length === 0) {
    return {
      status: "PENDING",
      isFinalised: false,
      message: ""
    };
  }
  const userOpsWithoutPaymentAndCleanup = userOps.filter((usop) => !usop.isCleanUpUserOp);
  const statusMap = {
    // If there is a cleanup user op failue ? Ignore it
    hasFailedOps: userOpsWithoutPaymentAndCleanup.some((userOp) => userOp.executionStatus === "FAILED"),
    // If there is a cleanup user op mining failue ? Ignore it
    hasMinedFailOps: userOpsWithoutPaymentAndCleanup.some((userOp) => {
      if (mode2 === "default") {
        return userOp.executionStatus === "MINED_FAIL" && userOp.isConfirmed;
      }
      return userOp.executionStatus === "MINED_FAIL";
    }),
    hasPendingOps: userOpsWithoutPaymentAndCleanup.some((userOp) => userOp.executionStatus === "PENDING"),
    hasMiningOps: userOpsWithoutPaymentAndCleanup.some((userOp) => userOp.executionStatus === "MINING"),
    // If there is a cleanup user op failue / mining failure ? Ignore it and mark the sprTx successful.
    allMinedSuccess: userOpsWithoutPaymentAndCleanup.every((userOp) => {
      if (mode2 === "default") {
        return userOp.executionStatus === "MINED_SUCCESS" && userOp.isConfirmed;
      }
      return userOp.executionStatus === "MINED_SUCCESS";
    }),
    // Check if all userOps have a final state
    allFinalised: userOpsWithoutPaymentAndCleanup.every((userOp) => {
      if (mode2 === "default") {
        return userOp.executionStatus === "FAILED" || userOp.executionStatus === "MINED_FAIL" && userOp.isConfirmed || userOp.executionStatus === "MINED_SUCCESS" && userOp.isConfirmed;
      }
      return userOp.executionStatus === "FAILED" || userOp.executionStatus === "MINED_FAIL" || userOp.executionStatus === "MINED_SUCCESS";
    })
  };
  let status = "PENDING";
  let message = "";
  if (statusMap.hasFailedOps) {
    status = "FAILED";
    const failedUserOpIndex = userOpsWithoutPaymentAndCleanup.findIndex((userOp) => userOp.executionStatus === status);
    const failedUserOp = userOpsWithoutPaymentAndCleanup[failedUserOpIndex];
    message = `[${failedUserOpIndex}] ${failedUserOp?.executionError || "Transaction failed off-chain"}`;
  } else if (statusMap.hasMinedFailOps) {
    status = "MINED_FAIL";
    const minedFailUserOpIndex = userOpsWithoutPaymentAndCleanup.findIndex((userOp) => userOp.executionStatus === status);
    const minedFailUserOp = userOpsWithoutPaymentAndCleanup[minedFailUserOpIndex];
    message = `[${minedFailUserOpIndex}] ${minedFailUserOp?.executionError || "Transaction failed on-chain"}`;
  } else if (statusMap.hasMiningOps) {
    status = "MINING";
    const pendingUserOpIndex = userOpsWithoutPaymentAndCleanup.findIndex((userOp) => userOp.executionStatus === status);
    message = `[${pendingUserOpIndex}] Transaction is mining, waiting for blockchain confirmation`;
  } else if (statusMap.hasPendingOps) {
    status = "PENDING";
    const pendingUserOpIndex = userOpsWithoutPaymentAndCleanup.findIndex((userOp) => userOp.executionStatus === status);
    const pendingUserOp = userOpsWithoutPaymentAndCleanup[pendingUserOpIndex];
    message = `[${pendingUserOpIndex}] ${pendingUserOp?.executionError || "Transaction is pending, waiting for conditions to be met"}`;
  } else if (statusMap.allMinedSuccess) {
    status = "MINED_SUCCESS";
    const minedSuccessUserOpIndex = userOpsWithoutPaymentAndCleanup.findIndex((userOp) => userOp.executionStatus === status);
    message = `[${minedSuccessUserOpIndex}] Transaction executed successfully`;
  }
  const isFinalised = statusMap.allFinalised || statusMap.hasFailedOps || statusMap.hasMinedFailOps;
  return {
    status,
    isFinalised,
    message
  };
};

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/mee/getSupertransactionReceipt.js
async function getSupertransactionReceipt(client, parameters) {
  const { confirmations = 2, waitForReceipts = true, ...params } = parameters;
  const account = parameters.account ?? client.account;
  let receipts = null;
  const explorerResponse = await client.request({
    path: `explorer/${params.hash}`,
    method: "GET"
  });
  const userOpsWithoutPayment = explorerResponse.userOps.slice(1);
  const metaStatus = await parseTransactionStatus(userOpsWithoutPayment);
  switch (metaStatus.status) {
    case "FAILED": {
      console.log({ metaStatus, explorerResponse, hash: params.hash });
      throw new Error(parseErrorMessage(metaStatus.message));
    }
    case "MINED_FAIL": {
      console.log({ metaStatus, explorerResponse, hash: params.hash });
      throw new Error(parseErrorMessage(metaStatus.message));
    }
    case "PENDING": {
      break;
    }
    case "MINING": {
      break;
    }
    case "MINED_SUCCESS": {
      if (waitForReceipts) {
        receipts = await Promise.all(userOpsWithoutPayment.filter((userOp) => {
          if (userOp.isCleanUpUserOp && userOp.executionStatus !== "MINED_SUCCESS") {
            return false;
          }
          return true;
        }).map(async ({ chainId, executionData }) => {
          return getTransactionReceipt(account.deploymentOn(Number(chainId), true).publicClient, {
            confirmations,
            ...parameters,
            hash: executionData
          });
        }));
      }
      break;
    }
    default: {
      throw new Error("Unknown transaction status");
    }
  }
  const explorerLinks = userOpsWithoutPayment.reduce((acc, userOp) => {
    acc.push(getExplorerTxLink(userOp.executionData, userOp.chainId), getJiffyScanLink(userOp.userOpHash));
    return acc;
  }, [getMeeScanLink(params.hash)]);
  return {
    ...explorerResponse,
    userOps: userOpsWithoutPayment,
    explorerLinks,
    receipts,
    transactionStatus: metaStatus.status
  };
}
var getSupertransactionReceipt_default = getSupertransactionReceipt;

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/mee/waitForSupertransactionReceipt.js
var DEFAULT_POLLING_INTERVAL = 1e3;
var txHashMapByMeeUserOpHash = /* @__PURE__ */ new Map();
var waitForSupertransactionReceipt = async (client, parameters) => {
  const pollingInterval = client.pollingInterval ?? DEFAULT_POLLING_INTERVAL;
  const paramsWithWait = { ...parameters, waitForReceipts: true };
  const explorerResponse = await getSupertransactionReceipt_default(client, paramsWithWait);
  const userOps = explorerResponse.userOps || [];
  for (const userOp of userOps) {
    const meeUserOpHash = userOp.meeUserOpHash.toLowerCase();
    if (userOp.executionData) {
      const latestTxHash = userOp.executionData.toLowerCase();
      const prevTxHash = txHashMapByMeeUserOpHash.get(meeUserOpHash);
      if (prevTxHash) {
        if (prevTxHash.toLowerCase() !== latestTxHash) {
          parameters?.onTransactionReplaced?.({
            meeUserOpHash,
            txHash: latestTxHash
          });
          txHashMapByMeeUserOpHash.set(meeUserOpHash, latestTxHash);
        }
      } else {
        txHashMapByMeeUserOpHash.set(meeUserOpHash, latestTxHash);
      }
    }
  }
  const statusResult = await parseTransactionStatus(userOps, parameters.mode);
  explorerResponse.transactionStatus = statusResult.status;
  if (statusResult.status === "FAILED" || statusResult.status === "MINED_FAIL") {
    throw new Error(statusResult.message || "Transaction failed");
  }
  if (!statusResult.isFinalised) {
    await new Promise((resolve) => setTimeout(resolve, pollingInterval));
    return await waitForSupertransactionReceipt(client, parameters);
  }
  return explorerResponse;
};
var waitForSupertransactionReceipt_default = waitForSupertransactionReceipt;

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/mee/getInfo.js
var getInfo = async (client) => client.request({
  path: "info",
  method: "GET"
});

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/mee/index.js
var meeActions = (meeClient) => {
  return {
    getGasToken: (params) => getGasToken(meeClient, params),
    getSupportedFeeToken: (params) => getSupportedFeeToken(meeClient, params),
    getOnChainQuote: (params) => getOnChainQuote_default(meeClient, params),
    getQuote: (params) => getQuote2(meeClient, params),
    signQuote: (params) => signQuote_default(meeClient, params),
    executeSignedQuote: (params) => executeSignedQuote_default(meeClient, params),
    execute: (params) => execute_default(meeClient, params),
    executeQuote: (params) => executeQuote_default(meeClient, params),
    waitForSupertransactionReceipt: (params) => waitForSupertransactionReceipt_default(meeClient, params),
    signOnChainQuote: (params) => signOnChainQuote_default(meeClient, params),
    signPermitQuote: (params) => signPermitQuote_default(meeClient, params),
    getPermitQuote: (params) => getPermitQuote_default(meeClient, params),
    getFusionQuote: (params) => getFusionQuote_default(meeClient, params),
    signFusionQuote: (params) => signFusionQuote_default(meeClient, params),
    executeFusionQuote: (params) => executeFusionQuote(meeClient, params),
    getSupertransactionReceipt: (params) => getSupertransactionReceipt_default(meeClient, params)
  };
};

// node_modules/@biconomy/abstractjs/dist/_esm/clients/createMeeClient.js
var isStagingOrTesting = isStaging() || isTesting();
var getDefaultMEENetworkUrl = (isStaging2 = false) => {
  if (isStaging2) {
    return "https://staging-network.biconomy.io/v1";
  }
  return "https://network.biconomy.io/v1";
};
var getDefaultMEENetworkApiKey = (isStaging2 = false) => {
  if (isStaging2) {
    return "mee_3ZhZhHx3hmKrBQxacr283dHt";
  }
  return "mee_3ZZmXCSod4xVXDRCZ5k5LTHg";
};
var DEFAULT_PATHFINDER_URL = getDefaultMEENetworkUrl(isStagingOrTesting);
var DEFAULT_PATHFINDER_API_KEY = getDefaultMEENetworkApiKey(isStagingOrTesting);
var DEFAULT_MEE_SPONSORSHIP_PAYMASTER_ACCOUNT = "0x18eAc826f3dD77d065E75E285d3456B751AC80d5";
var DEFAULT_MEE_SPONSORSHIP_CHAIN_ID = 8453;
var DEFAULT_MEE_SPONSORSHIP_TOKEN_ADDRESS = "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913";
var createMeeClient = async (params) => {
  const { account, pollingInterval = 1e3, url = DEFAULT_PATHFINDER_URL, apiKey = DEFAULT_PATHFINDER_API_KEY } = params;
  const httpClient = createHttpClient_default(url, apiKey);
  const info = await getInfo(httpClient);
  const baseMeeClient = Object.assign(httpClient, {
    pollingInterval,
    account,
    info
  });
  const supportedChains2 = info.supportedChains.map(({ chainId }) => Number(chainId));
  const supported = account.deployments.every(({ chain }) => supportedChains2.includes(chain.id));
  if (!supported) {
    throw new Error(`Some account chains are not supported by the MEE node. Please check the supported chains and try again. ${supportedChains2.join(", ")}`);
  }
  return baseMeeClient.extend(meeActions);
};

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/mee/getQuote.js
var USEROP_MIN_EXEC_WINDOW_DURATION = 180;
var CLEANUP_USEROP_EXTENDED_EXEC_WINDOW_DURATION = USEROP_MIN_EXEC_WINDOW_DURATION / 2;
var DEFAULT_GAS_LIMIT = 75000n;
var DEFAULT_VERIFICATION_GAS_LIMIT = 150000n;
var getQuote2 = async (client, parameters, quoteType = "simple", trigger) => {
  const { account: account_ = client.account, instructions, cleanUps, feePayer, path = "quote", lowerBoundTimestamp: lowerBoundTimestamp_ = Math.floor(Date.now() / 1e3), upperBoundTimestamp: upperBoundTimestamp_ = lowerBoundTimestamp_ + USEROP_MIN_EXEC_WINDOW_DURATION, delegate = false, authorizations = [], multichain7702Auth = false, moduleAddress, batch = true, simulation, verificationGasLimit, shortEncodingSuperTxn = false, sponsorship = false, sponsorshipOptions, feeToken, sessionDetails, smartSessionMode } = parameters;
  const mode2 = smartSessionMode === "ENABLE_AND_USE" ? SmartSessionMode.UNSAFE_ENABLE : SmartSessionMode.USE;
  let resolvedInstructions = await resolveInstructions(instructions);
  resolvedInstructions = resolvedInstructions.map((instruction) => {
    if (!instruction.metadata || instruction.metadata.length === 0) {
      return {
        ...instruction,
        metadata: [
          {
            type: "CUSTOM",
            description: "Custom on-chain action",
            chainId: instruction.chainId
          }
        ]
      };
    }
    return instruction;
  });
  let finalInstructions = resolvedInstructions;
  const meeVersions = account_.deployments.map(({ version, chain }) => ({
    chainId: chain.id,
    version
  }));
  if (batch) {
    finalInstructions = await batchInstructions({
      accountAddress: account_.signer.address,
      instructions: [...resolvedInstructions],
      meeVersions
    });
  }
  let pathToQuery = path;
  if (feePayer) {
    pathToQuery = "/quote-permit";
  }
  const validUserOps = finalInstructions.every((userOp) => account_.deploymentOn(userOp.chainId) && client.info.supportedChains.map(({ chainId }) => +chainId).includes(userOp.chainId));
  if (!validUserOps) {
    throw Error(`User operation chain(s) not supported by the node: ${finalInstructions.map((x) => x.chainId).join(", ")}`);
  }
  const hasProcessedInitData = [];
  const hasProcessedSessionDetails = /* @__PURE__ */ new Set();
  const initDataTypeByChainId = /* @__PURE__ */ new Map();
  const sprtxChainIdsSet = /* @__PURE__ */ new Set([]);
  if (feeToken)
    sprtxChainIdsSet.add(feeToken.chainId);
  for (const inx of finalInstructions) {
    sprtxChainIdsSet.add(inx.chainId);
  }
  const sprtxChainIds = [...sprtxChainIdsSet];
  if (delegate) {
    if (multichain7702Auth) {
      if (sprtxChainIds.length > 1) {
        const noncesAndChainIds = await Promise.all(sprtxChainIds.map(async (chainId) => {
          const { publicClient, walletClient: { account: { address } } } = account_.deploymentOn(chainId, true);
          return {
            chainId,
            nonce: await publicClient.getTransactionCount({ address })
          };
        }));
        const nonceCountMap = noncesAndChainIds.reduce((map, { nonce }) => {
          map.set(nonce, (map.get(nonce) || 0) + 1);
          return map;
        }, /* @__PURE__ */ new Map());
        const noncesAndChainIdsWithUniqueNonces = noncesAndChainIds.filter((info) => nonceCountMap.get(info.nonce) === 1);
        const noncesAndChainIdsWithSameNonces = noncesAndChainIds.filter((info) => nonceCountMap.get(info.nonce) > 1);
        if (authorizations.length > 0) {
          if (noncesAndChainIdsWithUniqueNonces.length === 0 && authorizations.length > 1) {
            throw new Error("Invalid authorizations: The nonce for all the chains are zero and only one multichain authorization is expected");
          }
          if (noncesAndChainIdsWithUniqueNonces.length > 0) {
            const missingAuthsByChainId = [];
            for (const { chainId } of noncesAndChainIdsWithUniqueNonces) {
              const isAuthProvided = authorizations.some((auth) => {
                return auth.chainId === chainId;
              });
              if (!isAuthProvided)
                missingAuthsByChainId.push(chainId);
            }
            if (missingAuthsByChainId.length > 0) {
              throw new Error(`Invalid authorizations: The nonce for all the chains are not same. You need to pass specific authorizations for the following chains: ${missingAuthsByChainId.join(", ")}`);
            }
          }
          if (noncesAndChainIdsWithSameNonces.length > 0) {
            const isAuthProvided = authorizations.some((auth) => {
              return auth.chainId === 0;
            });
            if (!isAuthProvided) {
              const chainIds = noncesAndChainIdsWithSameNonces.map((auth) => auth.chainId);
              throw new Error(`Invalid authorizations: The nonce for some of the chains are same. Missing multichain authorization for the following chains: ${chainIds.join(", ")}`);
            }
          }
        }
        for (const chainId of sprtxChainIds) {
          const [isMultichainAuth] = noncesAndChainIdsWithSameNonces.filter((info) => info.chainId === chainId);
          initDataTypeByChainId.set(chainId, isMultichainAuth ? "MULTI_CHAIN_AUTH" : "SINGLE_CHAIN_AUTH");
        }
      } else {
        if (authorizations.length > 1) {
          throw new Error("Invalid authorizations: The nonce for all the chains are zero and only one multichain authorization is expected");
        }
        if (authorizations.length === 1 && authorizations[0].chainId !== 0) {
          throw new Error("Invalid authorizations: Multichain authorization should be signed with chain ID zero");
        }
        for (const chainId of sprtxChainIds) {
          initDataTypeByChainId.set(chainId, "MULTI_CHAIN_AUTH");
        }
      }
    } else {
      if (authorizations.length > 0) {
        const missingAuthsByChainId = [];
        for (const chainId of sprtxChainIds) {
          const isAuthProvided = authorizations.some((auth) => {
            return auth.chainId === chainId;
          });
          if (!isAuthProvided)
            missingAuthsByChainId.push(chainId);
        }
        if (missingAuthsByChainId.length > 0) {
          throw new Error(`Authorizations are missing for the following chains: ${missingAuthsByChainId.join(", ")}`);
        }
      }
      for (const chainId of sprtxChainIds) {
        initDataTypeByChainId.set(chainId, "SINGLE_CHAIN_AUTH");
      }
    }
  } else {
    for (const chainId of sprtxChainIds) {
      initDataTypeByChainId.set(chainId, "INIT_CODE");
    }
  }
  const { paymentInfo, isInitDataProcessed, isSessionDetailsProcessed } = await preparePaymentInfo(client, {
    ...parameters,
    initDataTypeByChainId
  });
  let multichainEIP7702Auth = void 0;
  const paymentAuthType = initDataTypeByChainId.get(Number(paymentInfo.chainId));
  if (paymentInfo.eip7702Auth && paymentAuthType === "MULTI_CHAIN_AUTH") {
    multichainEIP7702Auth = paymentInfo.eip7702Auth;
  }
  if (isInitDataProcessed)
    hasProcessedInitData.push(Number(paymentInfo.chainId));
  if (isSessionDetailsProcessed)
    hasProcessedSessionDetails.add(paymentInfo.chainId);
  const preparedUserOps = await prepareUserOps(account_, finalInstructions, false, moduleAddress);
  if (cleanUps && cleanUps.length > 0) {
    const userOpsNonceInfo = preparedUserOps.map(([, { nonceKey, nonce }]) => ({ nonce, nonceKey }));
    const cleanUpUserOps = await prepareCleanUpUserOps(account_, userOpsNonceInfo, cleanUps, moduleAddress);
    preparedUserOps.push(...cleanUpUserOps);
  }
  const indexPerChainId = /* @__PURE__ */ new Map();
  const userOps = await Promise.all(preparedUserOps.map(async ([callData, { nonce }, isAccountDeployed, initCode, sender, callGasLimit, chainId, isCleanUpUserOp, nexusAccount, shortEncoding, metadata]) => {
    let initDataOrUndefined = void 0;
    if (!indexPerChainId.has(chainId)) {
      indexPerChainId.set(chainId, 0);
    }
    if (!isAccountDeployed && !hasProcessedInitData.includes(Number(chainId))) {
      hasProcessedInitData.push(Number(chainId));
      const authType = initDataTypeByChainId.get(Number(chainId));
      if (authType === "MULTI_CHAIN_AUTH") {
        if (multichainEIP7702Auth) {
          initDataOrUndefined = {
            eip7702Auth: multichainEIP7702Auth
          };
        } else {
          multichainEIP7702Auth = await prepare7702Auth(nexusAccount, Number(chainId), initDataTypeByChainId, authorizations);
          initDataOrUndefined = {
            eip7702Auth: multichainEIP7702Auth
          };
        }
      } else if (authType === "SINGLE_CHAIN_AUTH") {
        initDataOrUndefined = {
          eip7702Auth: await prepare7702Auth(nexusAccount, Number(chainId), initDataTypeByChainId, authorizations)
        };
      } else {
        initDataOrUndefined = { initCode };
      }
    }
    const resolvedVerificationGasLimit = resolveVerificationGasLimit({
      moduleAddress,
      verificationGasLimit,
      sponsorship,
      index: indexPerChainId.get(chainId),
      paymentChainId: paymentInfo.chainId,
      currentChainId: chainId
    });
    indexPerChainId.set(chainId, indexPerChainId.get(chainId) + 1);
    let sessionDetail = void 0;
    if (sessionDetails) {
      const relevantIndex = sessionDetails.findIndex(({ enableSessionData }) => enableSessionData?.enableSession?.sessionToEnable?.chainId === BigInt(chainId));
      if (relevantIndex === -1) {
        throw new Error(`No session details found for chainId ${chainId}`);
      }
      const isFirstTimeForChain = !hasProcessedSessionDetails.has(chainId);
      const dynamicMode = isFirstTimeForChain ? mode2 : SmartSessionMode.USE;
      sessionDetail = {
        ...sessionDetails[relevantIndex],
        mode: dynamicMode
      };
      hasProcessedSessionDetails.add(chainId);
    }
    return {
      lowerBoundTimestamp: lowerBoundTimestamp_,
      upperBoundTimestamp: isCleanUpUserOp ? upperBoundTimestamp_ + CLEANUP_USEROP_EXTENDED_EXEC_WINDOW_DURATION : upperBoundTimestamp_,
      sender,
      callData,
      callGasLimit,
      nonce: nonce.toString(),
      chainId,
      isCleanUpUserOp,
      ...initDataOrUndefined,
      ...resolvedVerificationGasLimit,
      shortEncoding: shortEncodingSuperTxn || shortEncoding,
      sessionDetails: sessionDetail,
      metadata
    };
  }));
  const quoteRequest = {
    quoteType,
    userOps,
    paymentInfo,
    simulation,
    trigger,
    tags: parameters.tags
  };
  let quote = await client.request({
    path: pathToQuery,
    body: quoteRequest
  });
  if (sponsorship && sponsorshipOptions) {
    const isSelfHostedSponsorship = ![
      getDefaultMEENetworkUrl(false),
      // Prod
      getDefaultMEENetworkUrl(true)
      // Staging
    ].includes(sponsorshipOptions.url);
    if (isSelfHostedSponsorship) {
      const selfHostedClient = createHttpClient_default(sponsorshipOptions.url);
      quote = await selfHostedClient.request({
        path: `sponsorship/sign/${sponsorshipOptions.gasTank.chainId}/${sponsorshipOptions.gasTank.address}`,
        method: "POST",
        body: quote,
        ...sponsorshipOptions.customHeaders ? { headers: sponsorshipOptions.customHeaders } : {}
      });
    }
  }
  return quote;
};
var preparePaymentInfo = async (client, parameters) => {
  const { account: account_ = client.account, eoa, feeToken, feePayer, gasLimit, authorizations = [], sponsorship, sponsorshipOptions, shortEncodingSuperTxn, moduleAddress, sessionDetails, smartSessionMode = "USE", verificationGasLimit } = parameters;
  let paymentInfo = void 0;
  let isInitDataProcessed = false;
  let isSessionDetailsProcessed = false;
  const eoaOrFeePayer = feePayer || eoa;
  if (sponsorship) {
    let sender = DEFAULT_MEE_SPONSORSHIP_PAYMASTER_ACCOUNT;
    let token = DEFAULT_MEE_SPONSORSHIP_TOKEN_ADDRESS;
    let chainId = DEFAULT_MEE_SPONSORSHIP_CHAIN_ID;
    let sponsorshipUrl = DEFAULT_PATHFINDER_URL;
    if (sponsorshipOptions) {
      sender = sponsorshipOptions.gasTank.address;
      token = sponsorshipOptions.gasTank.token;
      chainId = sponsorshipOptions.gasTank.chainId;
      sponsorshipUrl = sponsorshipOptions.url;
    }
    const sponsorshipClient = createHttpClient_default(sponsorshipUrl);
    const { nonce } = await sponsorshipClient.request({
      path: `sponsorship/nonce/${chainId}/${sender}`,
      method: "GET",
      ...sponsorshipOptions?.customHeaders ? { headers: sponsorshipOptions.customHeaders } : {}
    });
    paymentInfo = {
      sponsored: true,
      sender,
      token,
      nonce,
      callGasLimit: gasLimit || DEFAULT_GAS_LIMIT,
      verificationGasLimit: DEFAULT_VERIFICATION_GAS_LIMIT,
      // when sponsored, this will be set by the node
      chainId: chainId.toString(),
      sponsorshipUrl,
      ...eoaOrFeePayer ? { eoa: eoaOrFeePayer } : {},
      // For sponsorship, the sponsorship paymaster EOA is always assumed to be deployed and funded already
      // So initCode will be always undefined
      initCode: void 0
      // no short encodings
    };
    isInitDataProcessed = false;
  } else {
    if (!feeToken)
      throw Error("Fee token should be configured");
    const validPaymentAccount = account_.deploymentOn(feeToken.chainId);
    if (!validPaymentAccount) {
      throw Error(`Account is not deployed on necessary chain(s) ${feeToken.chainId}`);
    }
    const validFeeToken = validPaymentAccount && client.info.supportedGasTokens.map(({ chainId }) => +chainId).includes(feeToken.chainId);
    if (!validFeeToken) {
      throw Error(`Fee token ${feeToken.address} is not supported on this chain: ${feeToken.chainId}`);
    }
    const [nonce, isAccountDeployed, initCode] = await Promise.all([
      validPaymentAccount.getNonceWithKey(validPaymentAccount.address, {
        moduleAddress
      }),
      validPaymentAccount.isDeployed(),
      validPaymentAccount.getInitCode()
    ]);
    let initData = void 0;
    if (!isAccountDeployed) {
      const initDataType = parameters.initDataTypeByChainId.get(feeToken.chainId);
      if (initDataType === "INIT_CODE") {
        initData = { initCode };
      } else {
        initData = {
          eip7702Auth: await prepare7702Auth(validPaymentAccount, feeToken.chainId, parameters.initDataTypeByChainId, authorizations)
        };
      }
    }
    const paymentVerificationGasLimit = resolvePaymentUserOpVerificationGasLimitNonSponsored(moduleAddress, verificationGasLimit);
    let sessionDetail = void 0;
    if (sessionDetails) {
      const relevantIndex = sessionDetails.findIndex(({ enableSessionData }) => enableSessionData?.enableSession?.sessionToEnable?.chainId === BigInt(feeToken.chainId));
      if (relevantIndex === -1) {
        throw new Error(`No session details found for chainId ${feeToken.chainId}`);
      }
      if (!smartSessionMode) {
        throw new Error("smartSessionMode is required for smart sessions flow");
      }
      const mode2 = smartSessionMode === "ENABLE_AND_USE" ? SmartSessionMode.UNSAFE_ENABLE : SmartSessionMode.USE;
      sessionDetail = {
        ...sessionDetails[relevantIndex],
        mode: mode2
      };
    }
    paymentInfo = {
      sponsored: false,
      sender: validPaymentAccount.address,
      token: feeToken.address,
      nonce: nonce.nonce.toString(),
      callGasLimit: gasLimit || DEFAULT_GAS_LIMIT,
      verificationGasLimit: paymentVerificationGasLimit?.verificationGasLimit || DEFAULT_VERIFICATION_GAS_LIMIT,
      chainId: feeToken.chainId.toString(),
      ...feeToken.gasRefundAddress ? { gasRefundAddress: feeToken.gasRefundAddress } : {},
      ...eoaOrFeePayer ? { eoa: eoaOrFeePayer } : {},
      ...initData,
      shortEncoding: shortEncodingSuperTxn,
      sessionDetails: sessionDetail
    };
    isInitDataProcessed = true;
    isSessionDetailsProcessed = true;
  }
  if (!paymentInfo)
    throw new Error("Failed to generate payment info");
  return { paymentInfo, isInitDataProcessed, isSessionDetailsProcessed };
};
var prepare7702Auth = async (smartAccount, chainId, initDataTypeByChainId, customAuthorizations = []) => {
  let eip7702Auth;
  const authType = initDataTypeByChainId.get(chainId);
  if (authType === "MULTI_CHAIN_AUTH") {
    const [authorization] = customAuthorizations.filter((auth) => auth.chainId === 0);
    eip7702Auth = await smartAccount.toDelegation(authorization ? { authorization } : { multiChain: true });
  } else if (authType === "SINGLE_CHAIN_AUTH") {
    const [authorization] = customAuthorizations.filter((auth) => {
      return auth.chainId === Number(chainId);
    });
    eip7702Auth = await smartAccount.toDelegation(authorization ? { authorization } : { chainId });
  } else {
    throw new Error("Invalid authorization type");
  }
  return eip7702Auth;
};
var prepareUserOps = async (account, instructions, isCleanUpUserOps = false, validatorAddress) => {
  return await Promise.all(instructions.map((instruction) => {
    const deployment = account.deploymentOn(instruction.chainId, true);
    const accountAddress = account.addressOn(instruction.chainId, true);
    let callsPromise;
    if (instruction.isComposable) {
      callsPromise = deployment.encodeExecuteComposable(instruction.calls);
    } else {
      callsPromise = instruction.calls.length > 1 ? deployment.encodeExecuteBatch(instruction.calls) : deployment.encodeExecute(instruction.calls[0]);
    }
    const shortEncoding = false;
    return Promise.all([
      callsPromise,
      deployment.getNonceWithKey(accountAddress, {
        moduleAddress: validatorAddress
      }),
      deployment.isDeployed(),
      deployment.getInitCode(),
      deployment.address,
      instruction.calls.map((uo) => uo?.gasLimit ?? LARGE_DEFAULT_GAS_LIMIT).reduce((curr, acc) => curr + acc, 0n).toString(),
      instruction.chainId.toString(),
      isCleanUpUserOps,
      deployment,
      shortEncoding,
      instruction.metadata
    ]);
  }));
};
var prepareCleanUpUserOps = async (account, userOpsNonceInfo, cleanUps, moduleAddress) => {
  const meeVersions = account.deployments.map(({ version, chain }) => ({
    chainId: chain.id,
    version
  }));
  const cleanUpInstructions = await Promise.all(cleanUps.map(async (cleanUp) => {
    let cleanUpInstruction;
    const { version } = account.deploymentOn(cleanUp.chainId, true);
    const composabilityVersion = version.composabilityVersion;
    if (isNativeToken(cleanUp.tokenAddress)) {
      if (!isBigInt(cleanUp.amount) || cleanUp.amount === 0n) {
        if (composabilityVersion === ComposabilityVersion.V1_0_0) {
          throw new Error("Native token cleanup with runtime-injected amount is not supported for Composability v1.0.0");
        }
        let amount;
        if (cleanUp.amount === void 0 || cleanUp.amount === 0n) {
          amount = runtimeNativeBalanceOf({
            targetAddress: account.addressOn(cleanUp.chainId, true)
          });
        } else {
          amount = cleanUp.amount;
        }
        const [cleanUpNativeTransferInstruction] = await buildComposable({
          accountAddress: account.signer.address,
          currentInstructions: [],
          meeVersions
        }, {
          type: "nativeTokenTransfer",
          data: {
            to: cleanUp.recipientAddress,
            value: amount,
            chainId: cleanUp.chainId,
            ...cleanUp.gasLimit ? { gasLimit: cleanUp.gasLimit } : {}
          }
        }, composabilityVersion);
        cleanUpInstruction = cleanUpNativeTransferInstruction;
      } else {
        const amount = cleanUp.amount;
        const [cleanUpNativeTransferInstruction] = await buildComposable({
          accountAddress: account.signer.address,
          currentInstructions: [],
          meeVersions
        }, {
          type: "rawCalldata",
          data: {
            to: cleanUp.recipientAddress,
            calldata: "0x00000000",
            chainId: cleanUp.chainId,
            value: amount
          }
        }, composabilityVersion);
        cleanUpInstruction = cleanUpNativeTransferInstruction;
      }
    } else {
      let amount = cleanUp.amount ?? 0n;
      if (amount === 0n) {
        amount = runtimeERC20BalanceOf({
          targetAddress: account.addressOn(cleanUp.chainId, true),
          tokenAddress: cleanUp.tokenAddress
        });
      }
      const [cleanUpERC20TransferInstruction] = await buildComposable({
        accountAddress: account.signer.address,
        currentInstructions: [],
        meeVersions
      }, {
        type: "transfer",
        data: {
          recipient: cleanUp.recipientAddress,
          tokenAddress: cleanUp.tokenAddress,
          amount,
          chainId: cleanUp.chainId,
          ...cleanUp.gasLimit ? { gasLimit: cleanUp.gasLimit } : {}
        }
      }, composabilityVersion);
      cleanUpInstruction = cleanUpERC20TransferInstruction;
    }
    const nonceDependencies = [];
    if (cleanUp.dependsOn && cleanUp.dependsOn.length > 0) {
      for (const userOpIndex of cleanUp.dependsOn) {
        const userOpNonceInfo = userOpsNonceInfo[userOpIndex];
        if (!userOpNonceInfo)
          throw new Error("Invalid UserOp dependency, please check the dependsOn configuration");
        const { nonce, nonceKey } = userOpNonceInfo;
        const nonceOf = runtimeNonceOf({
          smartAccountAddress: account.addressOn(cleanUp.chainId, true),
          nonceKey,
          constraints: [greaterThanOrEqualTo(nonce + 1n)]
        });
        nonceDependencies.push(nonceOf);
      }
    } else {
      if (userOpsNonceInfo.length === 0) {
        throw new Error("At least one instruction should be configured to use cleanups.");
      }
      const lastUserOp = userOpsNonceInfo[userOpsNonceInfo.length - 1];
      const { nonce, nonceKey } = lastUserOp;
      const nonceOf = runtimeNonceOf({
        smartAccountAddress: account.addressOn(cleanUp.chainId, true),
        nonceKey,
        constraints: [greaterThanOrEqualTo(nonce + 1n)]
      });
      nonceDependencies.push(nonceOf);
    }
    const nonceDependencyInputParams = nonceDependencies.flatMap((dep) => dep.inputParams);
    const formattedNonceDependencyInputParams = formatCallDataInputParamsWithVersion(composabilityVersion, false, nonceDependencyInputParams);
    cleanUpInstruction.calls = cleanUpInstruction.calls.map((call2) => {
      call2.inputParams.push(...formattedNonceDependencyInputParams);
      return call2;
    });
    return cleanUpInstruction;
  }));
  const cleanUpUserOps = await prepareUserOps(account, cleanUpInstructions, true, moduleAddress);
  return cleanUpUserOps;
};
var resolveVerificationGasLimit = (parameters) => {
  const { moduleAddress, verificationGasLimit, sponsorship, index, paymentChainId, currentChainId } = parameters;
  if (currentChainId === paymentChainId) {
    return resolveVerificationGasLimitForPaymentChain({
      moduleAddress,
      verificationGasLimit,
      sponsorship,
      index
    });
  }
  return resolveVerificationGasLimitForNonPaymentChain({
    moduleAddress,
    verificationGasLimit,
    index
  });
};
var resolveVerificationGasLimitForPaymentChain = (parameters) => {
  const { moduleAddress, verificationGasLimit, sponsorship, index } = parameters;
  if (!moduleAddress && !verificationGasLimit) {
    return void 0;
  }
  if (!moduleAddress && verificationGasLimit) {
    return { verificationGasLimit };
  }
  if (addressEquals(moduleAddress, SMART_SESSIONS_ADDRESS2)) {
    if (sponsorship) {
      if (index === 0) {
        return {
          verificationGasLimit: verificationGasLimit || 1000000n
        };
      }
    }
    return { verificationGasLimit: 250000n };
  }
  if (verificationGasLimit) {
    return { verificationGasLimit };
  }
  return void 0;
};
var resolveVerificationGasLimitForNonPaymentChain = (parameters) => {
  const { moduleAddress, verificationGasLimit, index } = parameters;
  if (!moduleAddress && !verificationGasLimit) {
    return void 0;
  }
  if (!moduleAddress && verificationGasLimit) {
    return { verificationGasLimit };
  }
  if (addressEquals(moduleAddress, SMART_SESSIONS_ADDRESS2)) {
    if (index === 0) {
      return { verificationGasLimit: verificationGasLimit || 1000000n };
    }
    return { verificationGasLimit: 250000n };
  }
  if (verificationGasLimit) {
    return { verificationGasLimit };
  }
  return void 0;
};
var resolvePaymentUserOpVerificationGasLimitNonSponsored = (moduleAddress, verificationGasLimit) => {
  if (!moduleAddress && !verificationGasLimit) {
    return void 0;
  }
  if (!moduleAddress && verificationGasLimit) {
    return { verificationGasLimit };
  }
  if (addressEquals(moduleAddress, SMART_SESSIONS_ADDRESS2)) {
    return { verificationGasLimit: verificationGasLimit || 1000000n };
  }
  if (verificationGasLimit) {
    return { verificationGasLimit };
  }
  return void 0;
};
var getQuote_default = getQuote2;

// node_modules/@biconomy/abstractjs/dist/_esm/clients/decorators/mee/execute.js
var execute = async (client, params) => {
  const quote = await getQuote_default(client, params);
  const signedQuote = await signQuote(client, { quote });
  return executeSignedQuote(client, { signedQuote });
};
var execute_default = execute;

// node_modules/@biconomy/abstractjs/dist/_esm/modules/validators/smartSessions/decorators/toDisableActionPoliciesCalls.js
var toDisableActionPoliciesCalls = async (_, parameters) => {
  const action = getDisableActionPoliciesAction({
    permissionId: parameters.permissionId,
    actionId: parameters.actionId,
    policies: parameters.policies
  });
  return [
    {
      to: action.target,
      value: BigInt(action.value.toString()),
      data: action.callData
    }
  ];
};

// node_modules/@biconomy/abstractjs/dist/_esm/modules/validators/smartSessions/decorators/toDisableERC1271PoliciesCalls.js
var toDisableERC1271PoliciesCalls = async (_, parameters) => {
  const action = getDisableERC1271PoliciesAction({
    permissionId: parameters.permissionId,
    policies: parameters.policies,
    contents: parameters.contents
  });
  return [
    {
      to: action.target,
      value: BigInt(action.value.toString()),
      data: action.callData
    }
  ];
};

// node_modules/@biconomy/abstractjs/dist/_esm/modules/validators/smartSessions/decorators/toDisableUserOpPoliciesCalls.js
var toDisableUserOpPoliciesCalls = async (_, parameters) => {
  const action = getDisableUserOpPoliciesAction({
    permissionId: parameters.permissionId,
    userOpPolicies: parameters.userOpPolicies
  });
  return [
    {
      to: action.target,
      value: BigInt(action.value.toString()),
      data: action.callData
    }
  ];
};

// node_modules/@biconomy/abstractjs/dist/_esm/modules/validators/smartSessions/decorators/toEnableActionPoliciesCalls.js
var toEnableActionPoliciesCalls = async (_, parameters) => {
  const action = getEnableActionPoliciesAction({
    permissionId: parameters.permissionId,
    actionPolicies: parameters.actionPolicies
  });
  return [
    {
      to: action.target,
      value: BigInt(action.value.toString()),
      data: action.callData
    }
  ];
};

// node_modules/@biconomy/abstractjs/dist/_esm/modules/validators/smartSessions/decorators/toEnableERC1271PoliciesCalls.js
var toEnableERC1271PoliciesCalls = async (_, parameters) => {
  const action = getEnableERC1271PoliciesAction({
    permissionId: parameters.permissionId,
    erc1271Policies: parameters.erc1271Policies
  });
  return [
    {
      to: action.target,
      value: BigInt(action.value.toString()),
      data: action.callData
    }
  ];
};

// node_modules/@biconomy/abstractjs/dist/_esm/modules/validators/smartSessions/decorators/toEnableSessionsCalls.js
var toEnableSessionsCalls = async (_, parameters) => {
  const action = getEnableSessionsAction({ sessions: parameters.sessions });
  return [
    {
      to: action.target,
      value: BigInt(action.value.toString()),
      data: action.callData
    }
  ];
};

// node_modules/@biconomy/abstractjs/dist/_esm/modules/validators/smartSessions/decorators/toEnableUserOpPoliciesCalls.js
var toEnableUserOpPoliciesCalls = async (_, parameters) => {
  const action = getEnableUserOpPoliciesAction({
    permissionId: parameters.permissionId,
    userOpPolicies: parameters.userOpPolicies
  });
  return [
    {
      to: action.target,
      value: BigInt(action.value.toString()),
      data: action.callData
    }
  ];
};

// node_modules/@biconomy/abstractjs/dist/_esm/modules/validators/smartSessions/decorators/toRemoveSessionCalls.js
var toRemoveSessionCalls = async (_, parameters) => {
  const action = getRemoveSessionAction({
    permissionId: parameters.permissionId
  });
  return [
    {
      to: action.target,
      value: BigInt(action.value.toString()),
      data: action.callData
    }
  ];
};

// node_modules/@biconomy/abstractjs/dist/_esm/modules/validators/smartSessions/index.js
var smartSessionCalls = {
  toDisableActionPoliciesCalls,
  toDisableERC1271PoliciesCalls,
  toDisableUserOpPoliciesCalls,
  toEnableActionPoliciesCalls,
  toEnableERC1271PoliciesCalls,
  toEnableUserOpPoliciesCalls,
  toRemoveSessionCalls,
  toEnableSessionsCalls
};

// node_modules/@biconomy/abstractjs/dist/_esm/modules/validators/default/toDefaultModule.js
var MOCK_SUPERTXN_HASH_AND_TIMESTAMPS = "0x9e1cce57126e9205fe085888ed6b5ca0033f168e26b8927adb1c6da566cf7c5100000000000000000000000000000000000000000000000000000000642622800000000000000000000000000000000000000000000000000000000064262668";
var toDefaultModule = (parameters) => {
  const { signatureType = "simple", superTxEntriesCount = 3 } = parameters;
  return toValidator({
    initData: parameters.signer.address,
    data: parameters.signer.address,
    deInitData: "0x",
    ...parameters,
    address: zeroAddress,
    module: zeroAddress,
    type: "validator",
    getStubSignature: async () => getMeeK1ModuleStubSignature(signatureType, superTxEntriesCount)
  });
};
var getMeeK1ModuleStubSignature = (signatureType, superTxEntriesCount) => {
  const leafCount = superTxEntriesCount + 1;
  const proofSize = Math.ceil(Math.log2(leafCount));
  let prefix = "0x";
  let mockModePayload = "0x";
  if (signatureType === "no-mee") {
    return DUMMY_SIGNATURE;
  }
  if (signatureType === "simple") {
    prefix = "0x177eee00";
    mockModePayload = concatHex([
      MOCK_SUPERTXN_HASH_AND_TIMESTAMPS,
      "0x00000000000000000000000000000000000000000000000000000000000000a0",
      "0x0000000000000000000000000000000000000000000000000000000000000100"
    ]);
  }
  if (signatureType === "permit") {
    prefix = "0x177eee01";
    mockModePayload = concatHex([
      "0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000001d1499e622d69689cdf9004d05ec547d650ff211000000000000000000000000a0cb889707d426a7a386870a03bc70d1b0697598fe8244a8453f6a5a1623e38a7117cfcadf84d670fe741a32e447cd5f5671a68b0000000000000000000000000000000000000000000000003782dace9d9000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000027d5730e3c64852e56f4f10c0c27a8d96651193fd13663c1dd652b5f18677458",
      MOCK_SUPERTXN_HASH_AND_TIMESTAMPS,
      "0x00000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000250e2ad6bd90d6121dc5166dc6968f23ba43497594de5c7ca655f58e96d31775d"
    ]);
  }
  if (signatureType === "on-chain") {
    prefix = "0x177eee02";
    mockModePayload = concatHex([
      "0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000001d1499e622d69689cdf9004d05ec547d650ff211000000000000000000000000a0cb889707d426a7a386870a03bc70d1b0697598fe8244a8453f6a5a1623e38a7117cfcadf84d670fe741a32e447cd5f5671a68b000000000000000000000000000000000000000000000001158e460913d0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      MOCK_SUPERTXN_HASH_AND_TIMESTAMPS,
      "0x000000000000000000000000000000000000000000000000000000000000000568f7d0137aa459fc3d87c0405f9df08008c9b97b3da85ef4f663b0e4fc910b518146837426fd3167918049cae2bc9fdf90aabc1e9db16244b56a12463711c2d500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
    ]);
  }
  if (signatureType === "mm-dtk") {
    prefix = "0x177eee03";
    mockModePayload = concatHex([
      "0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000001d1499e622d69689cdf9004d05ec547d650ff211000000000000000000000000a0cb889707d426a7a386870a03bc70d1b0697598fe8244a8453f6a5a1623e38a7117cfcadf84d670fe741a32e447cd5f5671a68b0000000000000000000000000000000000000000000000003782dace9d9000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000027d5730e3c64852e56f4f10c0c27a8d96651193fd13663c1dd652b5f18677458",
      MOCK_SUPERTXN_HASH_AND_TIMESTAMPS,
      "0x00000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000250e2ad6bd90d6121dc5166dc6968f23ba43497594de5c7ca655f58e96d31775d"
    ]);
  }
  const leaves = Array.from({ length: proofSize }, () => "0x3239aa7c79368121ae1a0e73b662a9fd8f0c7f6aa1a7dfdc2eebdbeb2f9b070c");
  const proofPayload = concatHex([
    `0x${proofSize.toString(16).padStart(64, "0")}`,
    ...leaves
  ]);
  return concatHex([
    prefix,
    mockModePayload,
    proofPayload,
    "0x0000000000000000000000000000000000000000000000000000000000000041",
    // length
    DUMMY_SIGNATURE
  ]);
};

// node_modules/@biconomy/abstractjs/dist/_esm/modules/toComposableExecutor.js
var toComposableExecutor = (composableAddress) => ({
  module: composableAddress,
  data: "0x"
});

// node_modules/@biconomy/abstractjs/dist/_esm/modules/toComposableFallback.js
var toComposableFallback = (composableAddress) => ({
  module: composableAddress,
  data: "0xea5a6d9100"
});

// node_modules/@biconomy/abstractjs/dist/_esm/modules/toEmptyHook.js
var toEmptyHook = () => ({
  module: zeroAddress,
  data: zeroHash
});

// node_modules/@biconomy/abstractjs/dist/_esm/modules/validators/meeK1/toMeeK1Module.js
var toMeeK1Module = (parameters) => {
  const { signatureType = "simple", superTxEntriesCount = 3 } = parameters;
  return toValidator({
    initData: parameters.signer.address,
    data: parameters.signer.address,
    deInitData: "0x",
    ...parameters,
    address: parameters.module,
    module: parameters.module,
    type: "validator",
    getStubSignature: async () => getMeeK1ModuleStubSignature(signatureType, superTxEntriesCount)
  });
};

// node_modules/@biconomy/abstractjs/dist/_esm/account/decorators/instructions/buildMultichainInstructions.js
var GLOBAL_COMPOSABLE_CALLS = {
  ...erc7579Calls,
  ...smartAccountCalls,
  ...ownableCalls,
  ...smartSessionCalls
};
var buildMultichainInstructions = async (baseParams, parameters) => {
  const { currentInstructions = [] } = baseParams;
  const { calls: calls_, type, parameters: parametersForType, account, metadata: metadataOverride } = parameters;
  const instructions = await Promise.all(account.deployments.map(async (account2) => {
    let callsPerChain = [];
    const chainId = account2.client.chain?.id;
    if (!chainId) {
      throw new Error("Chain ID is not set");
    }
    let metadata = [];
    if (calls_) {
      metadata = [
        {
          type: "CUSTOM",
          chainId,
          description: "Custom on-chain action"
        }
      ];
      callsPerChain = calls_;
    } else if (type) {
      metadata = [
        {
          type: "CUSTOM",
          chainId,
          description: `${functionNameToLabel(type)} on-chain action`
        }
      ];
      callsPerChain = await GLOBAL_COMPOSABLE_CALLS[type](account2, parametersForType);
    }
    return {
      calls: callsPerChain,
      chainId,
      metadata: metadataOverride || metadata
    };
  }));
  return [...currentInstructions, ...instructions];
};

// node_modules/@biconomy/abstractjs/dist/_esm/account/decorators/instructions/buildNativeTokenTransfer.js
var buildNativeTokenTransfer = async (baseParams, parameters, composabilityParams) => {
  const { currentInstructions = [], accountAddress, meeVersions } = baseParams;
  const { chainId, value, gasLimit, to, metadata: metadataOverride } = parameters;
  const { forceComposableEncoding } = composabilityParams ?? {
    forceComposableEncoding: false
  };
  const [meeVersionInfo] = meeVersions.filter((meeVersion2) => meeVersion2.chainId === chainId);
  if (!meeVersionInfo) {
    throw new Error("MEE version is required to build a native token transfer");
  }
  const meeVersion = meeVersionInfo.version;
  const isRuntimeValues = [value, to].some((val) => isRuntimeComposableValue(val));
  const isComposableCall = forceComposableEncoding ? true : isRuntimeValues;
  let instructions;
  if (isComposableCall) {
    if (!composabilityParams?.composabilityVersion) {
      throw new Error("Composability version is required to build a composable native token transfer instruction");
    }
    if (isRuntimeValues && composabilityParams.composabilityVersion === ComposabilityVersion.V1_0_0) {
      throw new Error("Runtime values for Native tokens are not supported for Composability v1.0.0");
    }
    const metadata = [
      {
        type: "TRANSFER",
        tokenAddress: zeroAddress,
        fromAddress: accountAddress,
        toAddress: isRuntimeComposableValue(to) ? "RUNTIME_VALUE" : to,
        amount: isRuntimeComposableValue(value) ? "RUNTIME_VALUE" : value,
        chainId
      }
    ];
    instructions = await buildComposable_default(baseParams, {
      to: meeVersion.ethForwarderAddress,
      abi: ForwarderAbi,
      functionName: "forward",
      gasLimit,
      value,
      args: [to],
      chainId,
      metadata: metadataOverride || metadata
    }, composabilityParams);
  } else {
    const metadata = [
      {
        type: "TRANSFER",
        tokenAddress: zeroAddress,
        fromAddress: accountAddress,
        toAddress: to,
        amount: value,
        chainId
      }
    ];
    instructions = [
      {
        calls: [
          {
            to,
            value,
            data: "0x"
            // No calldata for native token transfer
          }
        ],
        metadata: metadataOverride || metadata,
        isComposable: false,
        chainId
      }
    ];
  }
  return [...currentInstructions, ...instructions];
};
var buildNativeTokenTransfer_default = buildNativeTokenTransfer;

// node_modules/@biconomy/abstractjs/dist/_esm/account/decorators/instructions/buildRawComposable.js
var buildRawComposable = async (baseParams, parameters, composabilityParameters) => {
  const { currentInstructions = [] } = baseParams;
  const { to, calldata, gasLimit, value, chainId, metadata } = parameters;
  const { composabilityVersion } = composabilityParameters;
  if (calldata.length < 10 || !calldata.startsWith("0x")) {
    throw new Error("Invalid calldata");
  }
  const functionSig = calldata.slice(0, 10);
  const callDataEncodedArgs = `0x${calldata.slice(10)}`;
  let versionAgnosticComposableParams = [];
  if (callDataEncodedArgs.length !== 0) {
    versionAgnosticComposableParams = prepareRawComposableParams(callDataEncodedArgs);
  }
  const composableCall = formatComposableCallWithVersion(
    composabilityVersion,
    false,
    // efficientMode is false for raw composable calls
    versionAgnosticComposableParams,
    functionSig,
    to,
    value,
    gasLimit
  );
  const defaultMetadata = [
    {
      type: "CUSTOM",
      description: "Custom composable on-chain action",
      chainId
    }
  ];
  return [
    ...currentInstructions,
    {
      calls: [composableCall],
      chainId,
      isComposable: true,
      metadata: metadata || defaultMetadata
    }
  ];
};
var buildRawComposable_default = buildRawComposable;

// node_modules/@biconomy/abstractjs/dist/_esm/account/decorators/instructions/buildTransferFrom.js
var buildTransferFrom = async (baseParams, parameters, composabilityParams) => {
  const { currentInstructions = [] } = baseParams;
  const { chainId, tokenAddress, amount, gasLimit, sender, recipient, metadata } = parameters;
  const { forceComposableEncoding } = composabilityParams ?? {
    forceComposableEncoding: false
  };
  const abi23 = erc20Abi;
  const functionSig = "transferFrom";
  const args = [
    sender,
    recipient,
    amount
  ];
  const functionContext = getFunctionContextFromAbi(functionSig, abi23);
  const isComposableCall = forceComposableEncoding ? true : isComposableCallRequired(functionContext, args);
  let transferFromCall;
  if (isComposableCall) {
    if (!composabilityParams) {
      throw new Error("Composability params are required to build a composable call");
    }
    const composableCallParams = {
      to: tokenAddress,
      functionName: functionSig,
      args,
      abi: abi23,
      chainId,
      ...gasLimit ? { gasLimit } : {}
    };
    transferFromCall = await buildComposableCall(composableCallParams, composabilityParams);
  } else {
    transferFromCall = [
      {
        to: tokenAddress,
        data: encodeFunctionData({
          abi: abi23,
          functionName: functionSig,
          args
        }),
        ...gasLimit ? { gasLimit } : {}
      }
    ];
  }
  const defaultMetadata = [
    {
      type: "TRANSFER",
      tokenAddress: isRuntimeComposableValue(tokenAddress) ? "RUNTIME_VALUE" : tokenAddress,
      fromAddress: sender,
      toAddress: recipient,
      amount: isRuntimeComposableValue(amount) ? "RUNTIME_VALUE" : amount,
      chainId
    }
  ];
  return [
    ...currentInstructions,
    {
      calls: transferFromCall,
      chainId,
      isComposable: isComposableCall,
      metadata: metadata || defaultMetadata
    }
  ];
};

// node_modules/@biconomy/abstractjs/dist/_esm/account/decorators/instructions/buildWithdrawal.js
var buildWithdrawal = async (baseParams, parameters, composabilityParams) => {
  const { currentInstructions = [], accountAddress, meeVersions } = baseParams;
  const {
    chainId,
    tokenAddress,
    amount,
    gasLimit,
    recipient = accountAddress,
    // EOA or owner account address
    metadata: metadataOverride
  } = parameters;
  const [meeVersionInfo] = meeVersions.filter((meeVersion2) => meeVersion2.chainId === chainId);
  if (!meeVersionInfo) {
    throw new Error("MEE version is required to build a native token transfer");
  }
  const meeVersion = meeVersionInfo.version;
  const { forceComposableEncoding = false } = composabilityParams ?? {
    forceComposableEncoding: false
  };
  const metadata = metadataOverride || [
    {
      type: "WITHDRAW",
      tokenAddress: isRuntimeComposableValue(tokenAddress) ? "RUNTIME_VALUE" : tokenAddress,
      fromAddress: accountAddress,
      toAddress: recipient,
      amount: isRuntimeComposableValue(amount) ? "RUNTIME_VALUE" : amount,
      chainId
    }
  ];
  let withdrawalCall;
  if (isNativeToken(tokenAddress)) {
    if (isRuntimeComposableValue(amount) || forceComposableEncoding) {
      if (!composabilityParams?.composabilityVersion) {
        throw new Error("Composability version is required to build a call with the runtime injected param");
      }
      const { composabilityVersion } = composabilityParams;
      if (composabilityVersion === ComposabilityVersion.V1_0_0) {
        throw new Error("Runtime values for Native tokens are not supported for Composability v1.0.0");
      }
      return buildComposable_default(baseParams, {
        to: meeVersion.ethForwarderAddress,
        abi: ForwarderAbi,
        functionName: "forward",
        value: amount,
        gasLimit,
        args: [recipient],
        chainId,
        metadata: metadataOverride || metadata
      }, composabilityParams);
    }
    withdrawalCall = [
      {
        to: recipient,
        value: amount,
        ...gasLimit ? { gasLimit } : {}
      }
    ];
  } else {
    const abi23 = TokenWithPermitAbi;
    const functionSig = "transfer";
    const args = [
      recipient,
      amount
    ];
    const functionContext = getFunctionContextFromAbi(functionSig, abi23);
    const isComposableCall = forceComposableEncoding ? true : isComposableCallRequired(functionContext, args);
    if (isComposableCall) {
      if (!composabilityParams) {
        throw new Error("Composability params are required to build a call with the runtime injected param");
      }
      const composableCallParams = {
        to: tokenAddress,
        functionName: functionSig,
        args,
        abi: abi23,
        chainId,
        ...gasLimit ? { gasLimit } : {}
      };
      withdrawalCall = await buildComposableCall(composableCallParams, composabilityParams);
      return [
        ...currentInstructions,
        {
          calls: withdrawalCall,
          chainId,
          isComposable: true,
          metadata
        }
      ];
    }
    withdrawalCall = [
      {
        to: tokenAddress,
        data: encodeFunctionData({
          abi: abi23,
          functionName: functionSig,
          args
        }),
        ...gasLimit ? { gasLimit } : {}
      }
    ];
  }
  return [
    ...currentInstructions,
    {
      calls: withdrawalCall,
      chainId,
      metadata
    }
  ];
};
var buildWithdrawal_default = buildWithdrawal;

// node_modules/@biconomy/abstractjs/dist/_esm/account/decorators/build.js
var build = async (baseParams, parameters) => {
  const { type, data } = parameters;
  const containsRuntimeValues = Object.values(data).some((value) => isRuntimeComposableValue(value));
  if (containsRuntimeValues) {
    throw new Error("Runtime values are not supported for `build` action. Use `buildComposable` instead.");
  }
  switch (type) {
    case "intent": {
      return buildIntent(baseParams, data);
    }
    case "default": {
      return buildDefaultInstructions(baseParams, data);
    }
    case "transferFrom": {
      return buildTransferFrom(baseParams, data);
    }
    case "transfer": {
      return buildTransfer(baseParams, data);
    }
    case "nativeTokenTransfer": {
      return buildNativeTokenTransfer_default(baseParams, data);
    }
    case "approve": {
      return buildApprove(baseParams, data);
    }
    case "withdrawal": {
      return buildWithdrawal_default(baseParams, data);
    }
    case "batch": {
      return buildBatch_default(baseParams, data);
    }
    case "multichain": {
      return buildMultichainInstructions(baseParams, data);
    }
    default: {
      throw new Error(`Unknown build action type: ${type}`);
    }
  }
};
var buildComposable = async (baseParams, parameters, composabilityVersion) => {
  const { type, data, efficientMode } = parameters;
  if (type !== "batch" && !composabilityVersion) {
    throw new Error(`Composability version param is required for composable type: ${type}`);
  }
  switch (type) {
    case "default": {
      return buildComposableUtil(baseParams, data, {
        composabilityVersion,
        efficientMode
      });
    }
    case "rawCalldata": {
      return buildRawComposable_default(baseParams, data, {
        composabilityVersion
      });
    }
    case "transferFrom": {
      return buildTransferFrom(baseParams, data, {
        forceComposableEncoding: true,
        efficientMode,
        composabilityVersion
      });
    }
    case "transfer": {
      return buildTransfer(baseParams, data, {
        forceComposableEncoding: true,
        efficientMode,
        composabilityVersion
      });
    }
    case "nativeTokenTransfer": {
      return buildNativeTokenTransfer_default(baseParams, data, {
        forceComposableEncoding: true,
        efficientMode,
        composabilityVersion
      });
    }
    case "approve": {
      return buildApprove(baseParams, data, {
        forceComposableEncoding: true,
        efficientMode,
        composabilityVersion
      });
    }
    case "withdrawal": {
      return buildWithdrawal_default(baseParams, data, {
        forceComposableEncoding: true,
        efficientMode,
        composabilityVersion
      });
    }
    case "batch": {
      return buildBatch_default(baseParams, data);
    }
    case "acrossIntent": {
      return buildAcrossIntentComposable_default(baseParams, data, {
        composabilityVersion,
        efficientMode: false,
        // nothing to group in this case
        forceComposableEncoding: true
        // both subactions are composable
      });
    }
    default: {
      throw new Error(`Unknown build action type: ${type}`);
    }
  }
};

// node_modules/@biconomy/abstractjs/dist/_esm/account/decorators/getUnifiedERC20Balance.js
async function getUnifiedERC20Balance(parameters) {
  const { mcToken, account: account_ } = parameters;
  const relevantTokensByChain = Array.from(mcToken.deployments).filter(([chainId]) => account_.deployments.some((account) => account.client.chain?.id === chainId));
  const balances = await Promise.all(relevantTokensByChain.map(async ([chainId, address]) => {
    const { publicClient, address: accountAddress } = account_.deploymentOn(chainId, true);
    const tokenContract = getContract({
      abi: erc20Abi,
      address,
      client: publicClient
    });
    const [balance, decimals] = await Promise.all([
      tokenContract.read.balanceOf([accountAddress]),
      tokenContract.read.decimals()
    ]);
    return {
      balance,
      decimals,
      chainId
    };
  }));
  return {
    ...balances.map((balance) => {
      return {
        balance: balance.balance,
        decimals: balance.decimals
      };
    }).reduce((curr, acc) => {
      if (curr.decimals !== acc.decimals) {
        throw Error(`
          Error while trying to fetch a unified ERC20 balance. The addresses provided
          in the mapping don't have the same number of decimals across all chains. 
          The function can't fetch a unified balance for token mappings with differing 
          decimals.
        `);
      }
      return {
        balance: curr.balance + acc.balance,
        decimals: curr.decimals
      };
    }),
    breakdown: balances,
    mcToken
  };
}

// node_modules/@biconomy/abstractjs/dist/_esm/constants/abi/NexusLegacyBootstrapAbi.js
var NexusLegacyBootstrapAbi = [
  { type: "fallback", stateMutability: "payable" },
  { type: "receive", stateMutability: "payable" },
  {
    type: "function",
    name: "eip712Domain",
    inputs: [],
    outputs: [
      { name: "fields", type: "bytes1", internalType: "bytes1" },
      { name: "name", type: "string", internalType: "string" },
      { name: "version", type: "string", internalType: "string" },
      { name: "chainId", type: "uint256", internalType: "uint256" },
      { name: "verifyingContract", type: "address", internalType: "address" },
      { name: "salt", type: "bytes32", internalType: "bytes32" },
      { name: "extensions", type: "uint256[]", internalType: "uint256[]" }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getActiveHook",
    inputs: [],
    outputs: [{ name: "hook", type: "address", internalType: "address" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getExecutorsPaginated",
    inputs: [
      { name: "cursor", type: "address", internalType: "address" },
      { name: "size", type: "uint256", internalType: "uint256" }
    ],
    outputs: [
      { name: "array", type: "address[]", internalType: "address[]" },
      { name: "next", type: "address", internalType: "address" }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getFallbackHandlerBySelector",
    inputs: [{ name: "selector", type: "bytes4", internalType: "bytes4" }],
    outputs: [
      { name: "", type: "bytes1", internalType: "CallType" },
      { name: "", type: "address", internalType: "address" }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getInitNexusCalldata",
    inputs: [
      {
        name: "validators",
        type: "tuple[]",
        internalType: "struct BootstrapConfig[]",
        components: [
          { name: "module", type: "address", internalType: "address" },
          { name: "data", type: "bytes", internalType: "bytes" }
        ]
      },
      {
        name: "executors",
        type: "tuple[]",
        internalType: "struct BootstrapConfig[]",
        components: [
          { name: "module", type: "address", internalType: "address" },
          { name: "data", type: "bytes", internalType: "bytes" }
        ]
      },
      {
        name: "hook",
        type: "tuple",
        internalType: "struct BootstrapConfig",
        components: [
          { name: "module", type: "address", internalType: "address" },
          { name: "data", type: "bytes", internalType: "bytes" }
        ]
      },
      {
        name: "fallbacks",
        type: "tuple[]",
        internalType: "struct BootstrapConfig[]",
        components: [
          { name: "module", type: "address", internalType: "address" },
          { name: "data", type: "bytes", internalType: "bytes" }
        ]
      },
      { name: "registry", type: "address", internalType: "contract IERC7484" },
      { name: "attesters", type: "address[]", internalType: "address[]" },
      { name: "threshold", type: "uint8", internalType: "uint8" }
    ],
    outputs: [{ name: "init", type: "bytes", internalType: "bytes" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getInitNexusScopedCalldata",
    inputs: [
      {
        name: "validators",
        type: "tuple[]",
        internalType: "struct BootstrapConfig[]",
        components: [
          { name: "module", type: "address", internalType: "address" },
          { name: "data", type: "bytes", internalType: "bytes" }
        ]
      },
      {
        name: "hook",
        type: "tuple",
        internalType: "struct BootstrapConfig",
        components: [
          { name: "module", type: "address", internalType: "address" },
          { name: "data", type: "bytes", internalType: "bytes" }
        ]
      },
      { name: "registry", type: "address", internalType: "contract IERC7484" },
      { name: "attesters", type: "address[]", internalType: "address[]" },
      { name: "threshold", type: "uint8", internalType: "uint8" }
    ],
    outputs: [{ name: "init", type: "bytes", internalType: "bytes" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getInitNexusWithSingleValidatorCalldata",
    inputs: [
      {
        name: "validator",
        type: "tuple",
        internalType: "struct BootstrapConfig",
        components: [
          { name: "module", type: "address", internalType: "address" },
          { name: "data", type: "bytes", internalType: "bytes" }
        ]
      },
      { name: "registry", type: "address", internalType: "contract IERC7484" },
      { name: "attesters", type: "address[]", internalType: "address[]" },
      { name: "threshold", type: "uint8", internalType: "uint8" }
    ],
    outputs: [{ name: "init", type: "bytes", internalType: "bytes" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getValidatorsPaginated",
    inputs: [
      { name: "cursor", type: "address", internalType: "address" },
      { name: "size", type: "uint256", internalType: "uint256" }
    ],
    outputs: [
      { name: "array", type: "address[]", internalType: "address[]" },
      { name: "next", type: "address", internalType: "address" }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "initNexus",
    inputs: [
      {
        name: "validators",
        type: "tuple[]",
        internalType: "struct BootstrapConfig[]",
        components: [
          { name: "module", type: "address", internalType: "address" },
          { name: "data", type: "bytes", internalType: "bytes" }
        ]
      },
      {
        name: "executors",
        type: "tuple[]",
        internalType: "struct BootstrapConfig[]",
        components: [
          { name: "module", type: "address", internalType: "address" },
          { name: "data", type: "bytes", internalType: "bytes" }
        ]
      },
      {
        name: "hook",
        type: "tuple",
        internalType: "struct BootstrapConfig",
        components: [
          { name: "module", type: "address", internalType: "address" },
          { name: "data", type: "bytes", internalType: "bytes" }
        ]
      },
      {
        name: "fallbacks",
        type: "tuple[]",
        internalType: "struct BootstrapConfig[]",
        components: [
          { name: "module", type: "address", internalType: "address" },
          { name: "data", type: "bytes", internalType: "bytes" }
        ]
      },
      { name: "registry", type: "address", internalType: "contract IERC7484" },
      { name: "attesters", type: "address[]", internalType: "address[]" },
      { name: "threshold", type: "uint8", internalType: "uint8" }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "initNexusScoped",
    inputs: [
      {
        name: "validators",
        type: "tuple[]",
        internalType: "struct BootstrapConfig[]",
        components: [
          { name: "module", type: "address", internalType: "address" },
          { name: "data", type: "bytes", internalType: "bytes" }
        ]
      },
      {
        name: "hook",
        type: "tuple",
        internalType: "struct BootstrapConfig",
        components: [
          { name: "module", type: "address", internalType: "address" },
          { name: "data", type: "bytes", internalType: "bytes" }
        ]
      },
      { name: "registry", type: "address", internalType: "contract IERC7484" },
      { name: "attesters", type: "address[]", internalType: "address[]" },
      { name: "threshold", type: "uint8", internalType: "uint8" }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "initNexusWithSingleValidator",
    inputs: [
      { name: "validator", type: "address", internalType: "contract IModule" },
      { name: "data", type: "bytes", internalType: "bytes" },
      { name: "registry", type: "address", internalType: "contract IERC7484" },
      { name: "attesters", type: "address[]", internalType: "address[]" },
      { name: "threshold", type: "uint8", internalType: "uint8" }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registry",
    inputs: [],
    outputs: [{ name: "", type: "address", internalType: "contract IERC7484" }],
    stateMutability: "view"
  },
  {
    type: "event",
    name: "ERC7484RegistryConfigured",
    inputs: [
      {
        name: "registry",
        type: "address",
        indexed: true,
        internalType: "contract IERC7484"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "ModuleInstalled",
    inputs: [
      {
        name: "moduleTypeId",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "module",
        type: "address",
        indexed: false,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "ModuleUninstalled",
    inputs: [
      {
        name: "moduleTypeId",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      },
      {
        name: "module",
        type: "address",
        indexed: false,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  { type: "error", name: "CanNotRemoveLastValidator", inputs: [] },
  { type: "error", name: "EnableModeSigError", inputs: [] },
  {
    type: "error",
    name: "FallbackAlreadyInstalledForSelector",
    inputs: [{ name: "selector", type: "bytes4", internalType: "bytes4" }]
  },
  { type: "error", name: "FallbackCallTypeInvalid", inputs: [] },
  { type: "error", name: "FallbackHandlerUninstallFailed", inputs: [] },
  {
    type: "error",
    name: "FallbackNotInstalledForSelector",
    inputs: [{ name: "selector", type: "bytes4", internalType: "bytes4" }]
  },
  { type: "error", name: "FallbackSelectorForbidden", inputs: [] },
  {
    type: "error",
    name: "HookAlreadyInstalled",
    inputs: [{ name: "currentHook", type: "address", internalType: "address" }]
  },
  { type: "error", name: "HookPostCheckFailed", inputs: [] },
  { type: "error", name: "InvalidInput", inputs: [] },
  {
    type: "error",
    name: "InvalidModule",
    inputs: [{ name: "module", type: "address", internalType: "address" }]
  },
  {
    type: "error",
    name: "InvalidModuleTypeId",
    inputs: [{ name: "moduleTypeId", type: "uint256", internalType: "uint256" }]
  },
  {
    type: "error",
    name: "LinkedList_EntryAlreadyInList",
    inputs: [{ name: "entry", type: "address", internalType: "address" }]
  },
  {
    type: "error",
    name: "LinkedList_InvalidEntry",
    inputs: [{ name: "entry", type: "address", internalType: "address" }]
  },
  { type: "error", name: "LinkedList_InvalidPage", inputs: [] },
  {
    type: "error",
    name: "MismatchModuleTypeId",
    inputs: [{ name: "moduleTypeId", type: "uint256", internalType: "uint256" }]
  },
  {
    type: "error",
    name: "MissingFallbackHandler",
    inputs: [{ name: "selector", type: "bytes4", internalType: "bytes4" }]
  },
  { type: "error", name: "ModuleAddressCanNotBeZero", inputs: [] },
  {
    type: "error",
    name: "ModuleAlreadyInstalled",
    inputs: [
      { name: "moduleTypeId", type: "uint256", internalType: "uint256" },
      { name: "module", type: "address", internalType: "address" }
    ]
  },
  {
    type: "error",
    name: "ModuleNotInstalled",
    inputs: [
      { name: "moduleTypeId", type: "uint256", internalType: "uint256" },
      { name: "module", type: "address", internalType: "address" }
    ]
  },
  { type: "error", name: "NoValidatorInstalled", inputs: [] },
  {
    type: "error",
    name: "UnauthorizedOperation",
    inputs: [{ name: "operator", type: "address", internalType: "address" }]
  },
  {
    type: "error",
    name: "UnsupportedCallType",
    inputs: [{ name: "callType", type: "bytes1", internalType: "CallType" }]
  },
  {
    type: "error",
    name: "ValidatorNotInstalled",
    inputs: [{ name: "module", type: "address", internalType: "address" }]
  }
];

// node_modules/@biconomy/abstractjs/dist/_esm/account/decorators/getFactoryData.js
var getFactoryData = (parameters) => {
  const { index, initData } = parameters;
  const salt = pad(toHex(index), { size: 32 });
  return encodeFunctionData({
    abi: parseAbi([
      "function createAccount(bytes initData, bytes32 salt) external returns (address)"
    ]),
    functionName: "createAccount",
    args: [initData, salt]
  });
};
var getInitDataWithRegistry = (params) => {
  const bootstrapData = isVersionOlder(params.meeVersion, MEEVersion.V2_0_0) ? encodeFunctionData({
    abi: NexusLegacyBootstrapAbi,
    functionName: "initNexusWithSingleValidator",
    args: [
      params.validators[0].module,
      params.validators[0].data,
      params.registryAddress,
      params.attesters,
      params.attesterThreshold
    ]
  }) : encodeFunctionData({
    abi: NexusBootstrapAbi,
    functionName: "initNexusWithSingleValidator",
    args: [
      params.validators[0].module,
      params.validators[0].data,
      {
        registry: params.registryAddress,
        attesters: params.attesters,
        threshold: params.attesterThreshold
      }
    ]
  });
  return encodeAbiParameters([
    { name: "bootstrap", type: "address" },
    { name: "bootstrapData", type: "bytes" }
  ], [params.bootStrapAddress, bootstrapData]);
};
var getInitDataNoRegistry = (params) => {
  return encodeAbiParameters([
    { name: "bootstrap", type: "address" },
    { name: "bootstrapData", type: "bytes" }
  ], [
    params.bootStrapAddress,
    encodeFunctionData({
      abi: NexusBootstrapAbi,
      functionName: "initNexusWithDefaultValidatorAndOtherModulesNoRegistry",
      args: [
        params.defaultValidator.data,
        params.validators,
        params.executors,
        params.hook,
        params.fallbacks,
        params.prevalidationHooks
      ]
    })
  ]);
};

// node_modules/@biconomy/abstractjs/dist/_esm/account/decorators/isDelegated.js
var isDelegated = async (parameters) => (await Promise.all(parameters.account.deployments.map(({ isDelegated: isDelegated2 }) => isDelegated2()))).every(Boolean);

// node_modules/@biconomy/abstractjs/dist/_esm/account/decorators/waitForTransactionReceipts.js
var waitForTransactionReceipts = async (parameters) => {
  const receipts = await Promise.all(parameters.account.deployments.map(({ publicClient }, i) => publicClient.waitForTransactionReceipt({
    hash: parameters.hashes[i],
    confirmations: 5
  })));
  const failure = receipts.find((receipt) => receipt.status !== "success");
  return { receipts, status: failure ? failure.status : "success" };
};

// node_modules/@biconomy/abstractjs/dist/_esm/account/decorators/unDelegate.js
var unDelegate = async (parameters) => {
  const hashes = await Promise.all(parameters.account.deployments.map(({ unDelegate: unDelegate2 }) => unDelegate2()));
  return await waitForTransactionReceipts({
    account: parameters.account,
    hashes
  });
};

// node_modules/@biconomy/abstractjs/dist/_esm/account/utils/composableReads.js
var GLOBAL_COMPOSABLE_READS = {
  ...erc7579Reads,
  ...ownableReads
};

// node_modules/@biconomy/abstractjs/dist/_esm/account/decorators/multichainRead.js
var multichainRead = async (account, parameters) => {
  const { type, parameters: parametersForType } = parameters;
  const readFunctions = GLOBAL_COMPOSABLE_READS;
  const results = await Promise.all(account.deployments.map(async (account2) => {
    const chainId = account2.client.chain?.id;
    if (!chainId) {
      throw new Error("Chain ID is not set");
    }
    const [readData] = await readFunctions[type](account2, parametersForType);
    return await readContract(account2.client, readData);
  }));
  return results;
};
var multichainRead_default = multichainRead;

// node_modules/@biconomy/abstractjs/dist/_esm/account/decorators/getNonceWithKey.js
var NonceManager = class _NonceManager {
  constructor() {
    Object.defineProperty(this, "isNonceKeyBeingCalculated", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /* @__PURE__ */ new Map()
    });
  }
  static getInstance() {
    if (!_NonceManager.instance) {
      _NonceManager.instance = new _NonceManager();
    }
    return _NonceManager.instance;
  }
  buildNonceStoreKey(accountAddress, chainId) {
    return `${accountAddress.toLowerCase()}::${chainId}`;
  }
  // This function always make sure to provide a unique nonce key with respect to timestamps.
  // This is helpful to reduce nonce collusion
  async getDefaultNonceKey(accountAddress, chainId) {
    const storeKey = this.buildNonceStoreKey(accountAddress, chainId);
    while (this.isNonceKeyBeingCalculated.get(storeKey)) {
      await new Promise((resolve) => setTimeout(resolve, 1));
    }
    this.isNonceKeyBeingCalculated.set(storeKey, true);
    const key = BigInt(Date.now());
    await new Promise((resolve) => setTimeout(resolve, 1));
    this.isNonceKeyBeingCalculated.set(storeKey, false);
    return key;
  }
  async getNonceWithKey(client, accountAddress, parameters) {
    const TIMESTAMP_ADJUSTMENT = 16777215n;
    const { key: key_, validationMode, moduleAddress } = parameters;
    try {
      const adjustedKey = BigInt(key_) % TIMESTAMP_ADJUSTMENT;
      const key = concat([
        toHex(adjustedKey, { size: 3 }),
        validationMode,
        moduleAddress
      ]);
      const entryPointContract = getContract({
        address: ENTRY_POINT_ADDRESS,
        abi: EntrypointAbi,
        client
      });
      const nonce = await entryPointContract.read.getNonce([
        accountAddress,
        BigInt(key)
      ]);
      return { nonceKey: BigInt(key), nonce };
    } catch (error) {
      const errorMessage = error.message ?? "RPC issue";
      throw new Error(`Failed to fetch nonce due to the error: ${sanitizeUrl(errorMessage)}`);
    }
  }
};
var getDefaultNonceKey = async (accountAddress, chainId) => {
  const manager = NonceManager.getInstance();
  return manager.getDefaultNonceKey(accountAddress, chainId);
};
var getNonceWithKeyUtil = async (client, accountAddress, parameters) => {
  const manager = NonceManager.getInstance();
  return manager.getNonceWithKey(client, accountAddress, parameters);
};

// node_modules/@biconomy/abstractjs/dist/_esm/account/utils/Logger.js
var Logger = class _Logger {
  /**
   * \x1b[0m is an escape sequence to reset the color of the text
   * All color codes used - 31 - Red, 33 - Yellow, 34 - Blue, 35 - Magenta, 36 - Cyan
   * log -   Magenta[time]               Cyan[message]:  [value]
   * warn -  Magenta[time] Yellow[WARN]: Cyan[message]:  [value]
   * error - Magenta[time] Red[ERROR]:   Cyan[message]:  [value]
   */
  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
  static log(message, value = "") {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    const logMessage = `\x1B[35m[${timestamp}]\x1B[0m \x1B[36m${message}\x1B[0m:`;
    if (_Logger.isDebug) {
      console.log(logMessage, value === void 0 ? "" : value);
    }
  }
  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
  static warn(message, value = "") {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    const warnMessage = `\x1B[35m[${timestamp}]\x1B[0m \x1B[33mWARN\x1B[0m: \x1B[36m${message}\x1B[0m`;
    if (_Logger.isDebug) {
      console.warn(warnMessage, value === void 0 ? "" : value);
    }
  }
  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
  static error(message, value = "") {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    const errorMessage = `\x1B[35m[${timestamp}]\x1B[0m \x1B[31mERROR\x1B[0m: \x1B[36m${message}\x1B[0m`;
    if (_Logger.isDebug) {
      console.error(errorMessage, value === void 0 ? "" : value);
    }
  }
};
Object.defineProperty(Logger, "isDebug", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: isDebugging()
});

// node_modules/@biconomy/abstractjs/dist/_esm/account/utils/toInitData.js
var toInitData = (mod) => {
  const module = mod.module || mod.address;
  const data = mod.initData || mod.data;
  if (!module || !data) {
    throw new Error("Module or data is missing");
  }
  return { module, data };
};

// node_modules/@biconomy/abstractjs/dist/_esm/account/utils/toSigner.js
async function toSigner({ signer, address }) {
  if (!signer) {
    throw new Error("Signer is required");
  }
  if ("provider" in signer) {
    const wallet = signer;
    const address2 = await wallet.getAddress();
    return toAccount({
      address: getAddress(address2),
      async signMessage({ message }) {
        if (typeof message === "string") {
          return await wallet.signMessage(message);
        }
        if (typeof message?.raw === "string") {
          return await wallet.signMessage(hexToBytes(message.raw));
        }
        return await wallet.signMessage(message.raw);
      },
      async signTransaction(_) {
        throw new Error("Not supported");
      },
      async signTypedData(typedData) {
        return wallet.signTypedData(typedData.domain, typedData.types, typedData.message);
      }
    });
  }
  if ("type" in signer && signer.type === "local") {
    return signer;
  }
  let walletClient = void 0;
  if ("request" in signer) {
    if (!address) {
      try {
        ;
        [address] = await signer.request({
          method: "eth_requestAccounts"
        });
      } catch {
        ;
        [address] = await signer.request({
          method: "eth_accounts"
        });
      }
    }
    if (!address) {
      throw new Error("address is required");
    }
    walletClient = createWalletClient({
      account: address,
      transport: custom(signer)
    });
  }
  if (!walletClient) {
    walletClient = signer;
  }
  const addressFromWalletClient = walletClient?.account?.address ?? (await walletClient?.getAddresses())?.[0];
  if (!addressFromWalletClient) {
    throw new Error("address not found in wallet client");
  }
  return toAccount({
    address: addressFromWalletClient,
    async signMessage({ message }) {
      return walletClient.signMessage({ message });
    },
    async signTypedData(typedData) {
      return getAction(walletClient, signTypedData, "signTypedData")(typedData);
    },
    async signTransaction(_) {
      throw new Error("Not supported");
    }
  });
}

// node_modules/@biconomy/abstractjs/dist/_esm/account/utils/toWalletClient.js
var toWalletClient = ({ unresolvedSigner, resolvedSigner, chain, transport }) => {
  const browserSigner = unresolvedSigner?.transport?.key === "custom";
  return createWalletClient(browserSigner ? {
    account: resolvedSigner.address,
    chain,
    // @ts-ignore
    transport: custom(window?.ethereum)
  } : {
    account: resolvedSigner,
    chain,
    transport
  }).extend(publicActions);
};

// node_modules/@biconomy/abstractjs/dist/_esm/account/toNexusAccount.js
var prepareValidators = async (signer, meeConfig, customValidators) => {
  let validators3 = [];
  if (customValidators && customValidators.length > 0) {
    return customValidators;
  }
  if (isVersionOlder(meeConfig.version, MEEVersion.V2_0_0)) {
    validators3 = [
      toMeeK1Module({
        signer: await toSigner({ signer }),
        module: meeConfig.defaultValidatorAddress
      })
    ];
  } else {
    validators3 = [];
  }
  return validators3;
};
var prepareExecutors = (meeConfig, customExecutors) => {
  let executors = [];
  if (isVersionOlder(meeConfig.version, MEEVersion.V2_0_0)) {
    if (!meeConfig.composableModuleAddress) {
      throw new Error("Composable module address is missing");
    }
    const composableExecutor = toComposableExecutor(meeConfig.composableModuleAddress);
    executors = [composableExecutor];
    for (const executor of customExecutors || []) {
      if (!addressEquals(executor.module, composableExecutor.module)) {
        executors.push(executor);
      }
    }
  } else {
    executors = customExecutors || [];
  }
  return executors;
};
var prepareFallbacks = (meeConfig, customFallbacks) => {
  let fallbacks = [];
  if (isVersionOlder(meeConfig.version, MEEVersion.V2_0_0)) {
    if (!meeConfig.composableModuleAddress) {
      throw new Error("Composable module address is missing");
    }
    const composableFallback = toComposableFallback(meeConfig.composableModuleAddress);
    fallbacks = [composableFallback];
    for (const fallback2 of customFallbacks || []) {
      if (!addressEquals(fallback2.module, composableFallback.module)) {
        fallbacks.push(fallback2);
      }
    }
  } else {
    fallbacks = customFallbacks || [];
  }
  return fallbacks;
};
var prepareFactoryData = (meeConfig, initDataParams) => {
  let factoryData = "0x";
  let initData = "0x";
  switch (meeConfig.version) {
    case MEEVersion.V1_0_0:
    case MEEVersion.V1_1_0: {
      if (!meeConfig.moduleRegistry) {
        throw new Error("Module registry not found in nexus config");
      }
      initData = initDataParams.customInitData || getInitDataWithRegistry({
        bootStrapAddress: meeConfig.bootStrapAddress,
        validators: initDataParams.validators,
        registryAddress: meeConfig.moduleRegistry.registryAddress,
        attesters: meeConfig.moduleRegistry.attesters,
        attesterThreshold: meeConfig.moduleRegistry.attesterThreshold,
        meeVersion: meeConfig.version
      });
      factoryData = getFactoryData({
        initData,
        index: initDataParams.accountIndex
      });
      break;
    }
    default: {
      initData = initDataParams.customInitData || getInitDataNoRegistry({
        defaultValidator: initDataParams.defaultValidator,
        prevalidationHooks: initDataParams.prevalidationHooks,
        validators: initDataParams.validators,
        executors: initDataParams.executors,
        hook: initDataParams.hook,
        fallbacks: initDataParams.fallbacks,
        bootStrapAddress: meeConfig.bootStrapAddress
      });
      factoryData = getFactoryData({
        initData,
        index: initDataParams.accountIndex
      });
      break;
    }
  }
  return { initData, factoryData };
};
var toNexusAccount = async (parameters) => {
  const { signer: _signer, chainConfiguration: { chain, version: meeConfig, transport: transportConfig, versionCheck = true }, index = 0n, validators: customValidators, executors: customExecutors, hook: customHook, fallbacks: customFallbacks, prevalidationHooks: customPrevalidationHooks, accountAddress: accountAddress_, initData: customInitData } = parameters;
  if (!isVersionOlder(meeConfig.version, MEEVersion.V2_0_0)) {
    const hasCancun = await supportsCancun({
      chain,
      transport: transportConfig
    });
    if (!hasCancun) {
      throw new Error(`MEE version (${meeConfig.version}) is not supported for the ${chain.name} chain. Please use a version earlier than 2.0.0 or a chain that supports Cancun.`);
    }
  }
  const publicClient = createPublicClient({ chain, transport: transportConfig });
  if (versionCheck) {
    const addressesToDeploymentSet = /* @__PURE__ */ new Set([
      meeConfig.bootStrapAddress,
      meeConfig.defaultValidatorAddress,
      meeConfig.validatorAddress,
      meeConfig.factoryAddress,
      meeConfig.implementationAddress
    ]);
    if (meeConfig.moduleRegistry) {
      addressesToDeploymentSet.add(meeConfig.moduleRegistry.registryAddress);
    }
    if (meeConfig.composableModuleAddress) {
      addressesToDeploymentSet.add(meeConfig.composableModuleAddress);
    }
    const addressesToDeploymentCheck = [...addressesToDeploymentSet].filter((address) => address !== zeroAddress);
    await Promise.all(addressesToDeploymentCheck.map(async (address) => {
      const bytecode = await publicClient.getCode({
        address
      });
      if (!bytecode || bytecode === "0x") {
        console.debug(`MEE version (${meeConfig.version}) is not supported for the ${chain.name} chain. Contract address (${address}) is not deployed`);
        throw new Error(`MEE version (${meeConfig.version}) is not supported for the ${chain.name} chain.`);
      }
    }));
  }
  const signer = await toSigner({ signer: _signer });
  const walletClient = toWalletClient({
    unresolvedSigner: _signer,
    resolvedSigner: signer,
    chain,
    transport: transportConfig
  });
  const validators3 = await prepareValidators(signer, meeConfig, customValidators);
  const defaultValidator = toDefaultModule({ signer });
  let module = validators3[0] || defaultValidator;
  const executors = prepareExecutors(meeConfig, customExecutors);
  const hook = customHook || toEmptyHook();
  const fallbacks = prepareFallbacks(meeConfig, customFallbacks);
  const prevalidationHooks = customPrevalidationHooks || [];
  const { initData, factoryData } = prepareFactoryData(meeConfig, {
    accountIndex: index,
    defaultValidator: toInitData(defaultValidator),
    prevalidationHooks,
    validators: validators3.map(toInitData),
    executors: executors.map(toInitData),
    hook: toInitData(hook),
    fallbacks: fallbacks.map(toInitData),
    customInitData
  });
  const getInitCode = () => concatHex([meeConfig.factoryAddress, factoryData]);
  let _accountAddress = accountAddress_;
  const accountId2 = await publicClient.readContract({
    address: meeConfig.implementationAddress,
    abi: parseAbi(["function accountId() public view returns (string)"]),
    functionName: "accountId",
    args: []
  });
  const getAddress2 = async () => {
    if (!isNullOrUndefined(_accountAddress))
      return _accountAddress;
    const addressFromFactory = await getNexusAddress({
      factoryAddress: meeConfig.factoryAddress,
      index,
      initData,
      publicClient
    });
    if (!addressEquals(addressFromFactory, zeroAddress)) {
      _accountAddress = addressFromFactory;
      return addressFromFactory;
    }
    throw new Error("Failed to get account address");
  };
  const getUserOpHash = (userOp) => getUserOperationHash({
    chainId: chain.id,
    entryPointAddress: entryPoint07Address,
    entryPointVersion: "0.7",
    userOperation: userOp
  });
  const encodeExecuteBatch = async (calls, mode2 = EXECUTE_BATCH) => {
    const executionAbiParams = {
      type: "tuple[]",
      components: [
        { name: "target", type: "address" },
        { name: "value", type: "uint256" },
        { name: "callData", type: "bytes" }
      ]
    };
    const executions = calls.map((tx) => ({
      target: tx.to,
      callData: tx.data ?? "0x",
      value: BigInt(tx.value ?? 0n)
    }));
    const executionCalldataPrep = encodeAbiParameters([executionAbiParams], [executions]);
    return encodeFunctionData({
      abi: parseAbi([
        "function execute(bytes32 mode, bytes calldata executionCalldata) external"
      ]),
      functionName: "execute",
      args: [mode2, executionCalldataPrep]
    });
  };
  const encodeExecute = async (call2, mode2 = EXECUTE_SINGLE) => {
    const executionCalldata = encodePacked(["address", "uint256", "bytes"], [call2.to, BigInt(call2.value ?? 0n), call2.data ?? "0x"]);
    return encodeFunctionData({
      abi: parseAbi([
        "function execute(bytes32 mode, bytes calldata executionCalldata) external"
      ]),
      functionName: "execute",
      args: [mode2, executionCalldata]
    });
  };
  const encodeExecuteComposable = async (calls) => {
    const isComposability_v1_0_0 = calls.every((call2) => !!call2.to) && !calls.every((call2) => call2.inputParams.some((param) => param.paramType === InputParamType.TARGET));
    const composableCallsFormattedByVersion = calls.map((call2) => {
      return isComposability_v1_0_0 ? {
        to: call2.to,
        value: call2.value ?? 0n,
        functionSig: call2.functionSig,
        inputParams: call2.inputParams,
        outputParams: call2.outputParams
      } : {
        functionSig: call2.functionSig,
        inputParams: call2.inputParams,
        outputParams: call2.outputParams
      };
    });
    return encodeFunctionData({
      abi: isComposability_v1_0_0 ? COMPOSABILITY_MODULE_ABI_V1_0_0 : COMPOSABILITY_MODULE_ABI_V1_1_0,
      functionName: "executeComposable",
      // Function selector in Composability feature which executes the composable calls.
      args: [composableCallsFormattedByVersion]
      // Multiple composable calls can be batched here.
    });
  };
  const getNonceWithKey = async (accountAddress, parameters2) => {
    const defaultNonceKey = await getDefaultNonceKey(accountAddress, chain.id);
    const { key = defaultNonceKey, validationMode = "0x00", moduleAddress = module.module } = parameters2 ?? {};
    return getNonceWithKeyUtil(publicClient, accountAddress, {
      key,
      validationMode,
      moduleAddress
    });
  };
  const getNonce = async (parameters2) => {
    const accountAddress = await getAddress2();
    const { nonce } = await getNonceWithKey(accountAddress, parameters2);
    return nonce;
  };
  async function signTypedData3(parameters2) {
    const { message, primaryType, types: _types, domain } = parameters2;
    if (!domain)
      throw new Error("Missing domain");
    if (!message)
      throw new Error("Missing message");
    const types = {
      EIP712Domain: getTypesForEIP712Domain({ domain }),
      ..._types
    };
    const messageStuff = message.stuff;
    validateTypedData({
      domain,
      message,
      primaryType,
      types
    });
    const appDomainSeparator = domainSeparator({ domain });
    const accountDomainStructFields = await getAccountDomainStructFields(publicClient, await getAddress2());
    const parentStructHash = keccak256(encodePacked(["bytes", "bytes"], [
      encodeAbiParameters(parseAbiParameters(["bytes32, bytes32"]), [
        keccak256(toBytes(PARENT_TYPEHASH)),
        messageStuff
      ]),
      accountDomainStructFields
    ]));
    const wrappedTypedHash = eip712WrapHash(parentStructHash, appDomainSeparator);
    let signature = await module.signMessage({ raw: toBytes(wrappedTypedHash) });
    const contentsType = toBytes(typeToString(types)[1]);
    const signatureData = concatHex([
      signature,
      appDomainSeparator,
      messageStuff,
      toHex(contentsType),
      toHex(contentsType.length, { size: 2 })
    ]);
    signature = encodePacked(["address", "bytes"], [module.module, signatureData]);
    return signature;
  }
  const setModule = (validationModule) => {
    module = validationModule;
  };
  async function toDelegation(params) {
    const { authorization: authorization_, multiChain, delegatedContract, chainId } = params || {};
    const contractAddress = delegatedContract || meeConfig.implementationAddress;
    const authorization = authorization_ || await walletClient.signAuthorization({
      contractAddress,
      chainId: multiChain ? 0 : chainId
    });
    const eip7702Auth = {
      chainId: `0x${authorization.chainId.toString(16)}`,
      address: authorization.address,
      nonce: `0x${authorization.nonce.toString(16)}`,
      r: authorization.r,
      s: authorization.s,
      yParity: `0x${authorization.yParity.toString(16)}`
    };
    return eip7702Auth;
  }
  async function isDelegated2() {
    const code = await publicClient.getCode({ address: signer.address });
    return !!code && code?.toLowerCase().includes(meeConfig.implementationAddress.substring(2).toLowerCase());
  }
  async function unDelegate2(params) {
    const { authorization } = params || {};
    const deAuthorization = authorization || await walletClient.signAuthorization({
      address: zeroAddress,
      executor: "self"
    });
    return await walletClient.sendTransaction({
      to: signer.address,
      data: "0xdeadbeef",
      type: "eip7702",
      authorizationList: [deAuthorization]
    });
  }
  return toSmartAccount({
    client: publicClient,
    entryPoint: {
      abi: EntrypointAbi,
      address: ENTRY_POINT_ADDRESS,
      version: "0.7"
    },
    getAddress: getAddress2,
    encodeCalls: (calls) => {
      return calls.length === 1 ? encodeExecute(calls[0]) : encodeExecuteBatch(calls);
    },
    getFactoryArgs: async () => ({
      factory: meeConfig.factoryAddress,
      factoryData
    }),
    getStubSignature: async () => module.getStubSignature(),
    /**
     * @description Signs a message
     * @param params - The parameters for signing
     * @param params.message - The message to sign
     * @returns The signature
     */
    async signMessage({ message }) {
      const tempSignature = await module.signMessage(message);
      return encodePacked(["address", "bytes"], [module.module, tempSignature]);
    },
    signTypedData: signTypedData3,
    signUserOperation: async (parameters2) => {
      const { chainId = publicClient.chain.id, ...userOpWithoutSender } = parameters2;
      const address = await getAddress2();
      const userOperation = {
        ...userOpWithoutSender,
        sender: address
      };
      const hash = getUserOperationHash({
        chainId,
        entryPointAddress: entryPoint07Address,
        entryPointVersion: "0.7",
        userOperation
      });
      return await module.signUserOpHash(hash);
    },
    getNonce,
    extend: {
      isDelegated: isDelegated2,
      toDelegation,
      unDelegate: unDelegate2,
      entryPointAddress: entryPoint07Address,
      getAddress: getAddress2,
      accountId: accountId2,
      getInitCode,
      getNonceWithKey,
      encodeExecute,
      encodeExecuteBatch,
      encodeExecuteComposable,
      getUserOpHash,
      factoryData,
      factoryAddress: meeConfig.factoryAddress,
      registryAddress: meeConfig.moduleRegistry?.registryAddress || zeroAddress,
      signer,
      walletClient,
      publicClient,
      chain,
      setModule,
      getModule: () => module,
      version: meeConfig
    }
  });
};

// node_modules/@biconomy/abstractjs/dist/_esm/account/toMultiChainNexusAccount.js
async function toMultichainNexusAccount(multiChainNexusParams) {
  const { signer: unresolvedSigner, chainConfigurations, ...accountParameters } = multiChainNexusParams;
  if (chainConfigurations.length === 0) {
    throw new Error("No chain configuration provided");
  }
  const deployments = await Promise.all(chainConfigurations.map((chainConfiguration) => toNexusAccount({
    signer: unresolvedSigner,
    chainConfiguration,
    ...accountParameters
  })));
  function deploymentOn(chainId, strictMode) {
    const deployment = deployments.find((dep) => dep.client.chain?.id === chainId);
    if (!deployment && strictMode) {
      throw new Error(`Deployment not found for chainId: ${chainId}`);
    }
    return deployment;
  }
  function addressOn(chainId, strictMode) {
    const deployment = deploymentOn(chainId, strictMode);
    return deployment?.address;
  }
  const meeVersions = deployments.map(({ version, chain }) => ({
    chainId: chain.id,
    version
  }));
  const baseAccount = {
    signer: deployments[0].signer,
    // This signer is resolved
    deployments,
    deploymentOn,
    addressOn
  };
  const getUnifiedERC20Balance2 = (mcToken) => getUnifiedERC20Balance({ mcToken, account: baseAccount });
  const build2 = (params, currentInstructions) => build({
    currentInstructions,
    accountAddress: baseAccount.signer.address,
    meeVersions
  }, params);
  const buildComposable2 = (params, currentInstructions) => {
    let composabilityVersion = void 0;
    let chainId = void 0;
    const type = params.type;
    if (type === "acrossIntent") {
      chainId = params.data.originChainId;
    } else if (type !== "batch") {
      chainId = params.data.chainId;
    }
    if (chainId) {
      composabilityVersion = getComposabilityVersion(chainId);
    }
    return buildComposable({
      currentInstructions,
      accountAddress: baseAccount.signer.address,
      meeVersions
    }, params, composabilityVersion);
  };
  const buildBridgeInstructions2 = (params) => buildBridgeInstructions({ ...params });
  const queryBridge2 = (params) => queryBridge({ ...params });
  const isDelegated2 = (parameters) => isDelegated({ ...parameters, account: baseAccount });
  const unDelegate2 = (parameters) => unDelegate({ ...parameters, account: baseAccount });
  const waitForTransactionReceipts2 = (parameters) => waitForTransactionReceipts({ ...parameters, account: baseAccount });
  const getComposabilityVersion = (chainId) => {
    const chainConfiguration = chainConfigurations.find((chainConfiguration2) => chainConfiguration2.chain.id === chainId);
    if (!chainConfiguration) {
      throw new Error(`Chain configuration not found in mc account for chainId: ${chainId} that is used in the instruction params`);
    }
    return chainConfiguration.version.composabilityVersion;
  };
  const read = (params) => multichainRead_default(baseAccount, params);
  const toDelegation = async () => await deployments[0].toDelegation({ multiChain: true });
  return {
    ...baseAccount,
    getUnifiedERC20Balance: getUnifiedERC20Balance2,
    build: build2,
    buildComposable: buildComposable2,
    buildBridgeInstructions: buildBridgeInstructions2,
    queryBridge: queryBridge2,
    isDelegated: isDelegated2,
    getComposabilityVersion,
    unDelegate: unDelegate2,
    waitForTransactionReceipts: waitForTransactionReceipts2,
    read,
    toDelegation
  };
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/beam/common.js
var ACROSS_ABI = parseAbi([
  "function deposit(bytes32 depositor, bytes32 recipient, bytes32 inputToken, bytes32 outputToken, uint256 inputAmount, uint256 outputAmount, uint256 destinationChainId, bytes32 exclusiveRelayer, uint32 quoteTimestamp, uint32 fillDeadline, uint32 exclusivityParameter, bytes message)",
  "function depositV3(address depositor,address recipient,address inputToken,address outputToken,uint256 inputAmount,uint256 outputAmount,uint256 destinationChainId,address exclusiveRelayer,uint32 quoteTimestamp,uint32 fillDeadline,uint32 exclusivityParameter,bytes message)"
]);
var WRAP_ABI = parseAbi(["function deposit()"]);
var MEE_CLIENT_API_KEY = "mee_3ZkX3T823ZDfwsNiFsqj5oZS";
var ACROSS_INTEGRATOR_ID = "0x008e";
var findMarketToken = (environments, chainId, underlyingTokenAddress) => {
  const originEnvironment = environments.find((env) => chainId === env.chainId);
  if (originEnvironment) {
    const underlyingTokenConfig = Object.keys(originEnvironment.config.tokens).map((token) => {
      const marketToken = originEnvironment.config.tokens[token];
      return {
        ...marketToken,
        key: token
      };
    }).find((token) => token.address === underlyingTokenAddress);
    if (underlyingTokenConfig) {
      const originMarket = Object.values(originEnvironment.config.markets).find((market) => market.underlyingToken === underlyingTokenConfig.key);
      if (originMarket) {
        return {
          underlyingToken: originEnvironment.config.tokens[originMarket.underlyingToken],
          marketToken: originEnvironment.config.tokens[originMarket.marketToken]
        };
      }
    }
  }
  return void 0;
};
var findIsolatedMarketToken = (environments, chainId, underlyingTokenAddress) => {
  const originEnvironment = environments.find((env) => chainId === env.chainId);
  if (originEnvironment) {
    const underlyingTokenConfig = Object.keys(originEnvironment.config.tokens).map((token) => {
      const marketToken = originEnvironment.config.tokens[token];
      return {
        ...marketToken,
        key: token
      };
    }).find((token) => token.address === underlyingTokenAddress);
    if (underlyingTokenConfig) {
      const originMarket = Object.values(originEnvironment.config.morphoMarkets).find((market) => market.collateralToken === underlyingTokenConfig.key);
      if (originMarket) {
        return {
          underlyingToken: originEnvironment.config.tokens[originMarket.collateralToken],
          marketToken: originEnvironment.config.tokens[originMarket.loanToken]
        };
      }
    }
  }
  return void 0;
};
var findVaultToken = (environments, chainId, underlyingTokenAddress) => {
  const originEnvironment = environments.find((env) => chainId === env.chainId);
  if (originEnvironment) {
    const underlyingTokenConfig = Object.keys(originEnvironment.config.tokens).map((token) => {
      const marketToken = originEnvironment.config.tokens[token];
      return {
        ...marketToken,
        key: token
      };
    }).find((token) => token.address === underlyingTokenAddress);
    if (underlyingTokenConfig) {
      const originMarket = Object.values(originEnvironment.config.vaults).find((market) => market.underlyingToken === underlyingTokenConfig.key);
      if (originMarket) {
        return {
          underlyingToken: originEnvironment.config.tokens[originMarket.underlyingToken],
          marketToken: originEnvironment.config.tokens[originMarket.vaultToken]
        };
      }
    }
  }
  return void 0;
};
async function getQuote3(client, args) {
  const envs = getEnvironmentsFromArgs(client, void 0, false).filter((env) => env.chainId !== moonbeam.id && env.chainId !== moonriver.id);
  const chains = Object.values(envs).map((env) => env.chain);
  const transports = chains.map((chain) => http(chain.rpcUrls.default.http[0]));
  const smartAccount = await toMultichainNexusAccount({
    signer: args.wallet,
    chains,
    transports
  });
  const meeClient = await createMeeClient({
    account: smartAccount,
    apiKey: MEE_CLIENT_API_KEY
  });
  const accrossClient = createAcrossClient({
    integratorId: ACROSS_INTEGRATOR_ID,
    // 2-byte hex string
    chains,
    useTestnet: false
  });
  if (args.type === "supply" || args.type === "morpho-supply" || args.type === "vault-deposit") {
    const tokenConfig = args.type === "supply" ? findMarketToken(envs, args.destination.chainId, args.destination.address) : args.type === "morpho-supply" ? findIsolatedMarketToken(envs, args.destination.chainId, args.destination.address) : findVaultToken(envs, args.destination.chainId, args.destination.address);
    if (tokenConfig) {
      const quotes = [];
      const instructions = [];
      const approvals = [];
      const transfers = [];
      let totalOutput = 0n;
      const nativeAmounts = [];
      const cleanUps = [];
      for (const source of args.sources) {
        const sourceChain = chains.find((r) => r.id === source.chainId);
        const publicClient = createPublicClient({
          chain: sourceChain,
          transport: http(sourceChain.rpcUrls.default.http[0])
        });
        const nativeBalance = await publicClient.getBalance({
          address: args.wallet.account?.address
        });
        nativeAmounts.push({
          chainId: source.chainId,
          amount: nativeBalance
        });
        if (source.address === zeroAddress) {
          const nativeBalanceSmartAccount = await publicClient.getBalance({
            address: smartAccount.addressOn(source.chainId)
          });
          if (nativeBalanceSmartAccount < source.amount) {
            transfers.push({
              amount: source.amount - nativeBalanceSmartAccount,
              chainId: source.chainId,
              to: smartAccount.addressOn(source.chainId)
            });
          }
          cleanUps.push({
            tokenAddress: source.address,
            chainId: source.chainId,
            recipientAddress: args.wallet.account.address
          });
        } else {
          const erc20Abi2 = parseAbi([
            "function allowance(address owner, address spender) view returns (uint256)"
          ]);
          const erc20Contract = getContract({
            address: source.routeTokenAddress,
            abi: erc20Abi2,
            client: publicClient
          });
          const allowance = await erc20Contract.read.allowance([
            args.wallet.account?.address,
            smartAccount.addressOn(source.chainId)
          ]);
          if (allowance < source.amount) {
            approvals.push({
              spender: smartAccount.addressOn(source.chainId),
              tokenAddress: source.routeTokenAddress,
              chainId: source.chainId,
              amount: source.amount
            });
          }
        }
        let transferOrWrapInstruction = [];
        if (source.address === zeroAddress) {
          const wrapData = encodeFunctionData({
            abi: WRAP_ABI,
            functionName: "deposit",
            args: []
          });
          transferOrWrapInstruction = await smartAccount.buildComposable({
            type: "rawCalldata",
            data: {
              calldata: wrapData,
              to: source.routeTokenAddress,
              chainId: source.chainId,
              value: source.amount
            }
          });
        } else {
          transferOrWrapInstruction = await smartAccount.buildComposable({
            type: "transferFrom",
            data: {
              sender: args.wallet.account?.address,
              recipient: smartAccount.addressOn(source.chainId),
              tokenAddress: source.routeTokenAddress,
              amount: source.amount,
              chainId: source.chainId
            }
          });
        }
        if (source.chainId !== args.destination.chainId) {
          const acrossQuote = await accrossClient.getQuote({
            route: {
              originChainId: source.chainId,
              inputToken: source.routeTokenAddress,
              destinationChainId: args.destination.chainId,
              outputToken: args.destination.routeTokenAddress
            },
            inputAmount: source.amount.toString(),
            recipient: smartAccount.addressOn(args.destination.chainId)
          });
          const acrossChainInfo = await accrossClient.getChainInfo(source.chainId);
          const approveAcrossSpendInstructions = await smartAccount.buildComposable({
            type: "approve",
            data: {
              tokenAddress: source.routeTokenAddress,
              amount: source.amount,
              chainId: source.chainId,
              spender: acrossChainInfo.spokePool
            }
          });
          const bridgeData = encodeFunctionData({
            abi: ACROSS_ABI,
            functionName: "depositV3",
            args: [
              smartAccount.addressOn(source.chainId),
              smartAccount.addressOn(args.destination.chainId),
              acrossQuote.deposit.inputToken,
              acrossQuote.deposit.outputToken,
              acrossQuote.deposit.inputAmount,
              acrossQuote.deposit.outputAmount,
              acrossQuote.deposit.destinationChainId,
              acrossQuote.deposit.exclusiveRelayer,
              acrossQuote.deposit.quoteTimestamp,
              acrossQuote.deposit.fillDeadline,
              acrossQuote.deposit.exclusivityDeadline,
              acrossQuote.deposit.message
            ]
          });
          totalOutput += acrossQuote.deposit.outputAmount;
          const bridgeInstructions = await smartAccount.buildComposable({
            type: "rawCalldata",
            data: {
              calldata: bridgeData,
              to: acrossChainInfo.spokePool,
              chainId: source.chainId
            }
          });
          quotes.push(acrossQuote);
          instructions.push(await smartAccount.buildComposable({
            type: "batch",
            data: {
              instructions: [
                transferOrWrapInstruction,
                approveAcrossSpendInstructions,
                bridgeInstructions
              ]
            }
          }));
        } else {
          totalOutput += source.amount;
          instructions.push(transferOrWrapInstruction);
        }
      }
      const approveSupplyInstructions = await smartAccount.buildComposable({
        type: "approve",
        data: {
          tokenAddress: args.destination.routeTokenAddress,
          amount: runtimeERC20BalanceOf({
            tokenAddress: args.destination.routeTokenAddress,
            targetAddress: smartAccount.addressOn(args.destination.chainId, true),
            constraints: [greaterThanOrEqualTo(totalOutput)]
          }),
          chainId: args.destination.chainId,
          spender: args.type === "morpho-supply" ? args.destination.morphoBlue : tokenConfig.marketToken.address
        }
      });
      if (args.type === "supply") {
        const supplyInstructions = await smartAccount.buildComposable({
          type: "default",
          data: {
            to: tokenConfig.marketToken.address,
            abi: marketTokenAbi_default,
            functionName: "mint",
            args: [
              runtimeEncodeAbiParameters([{ name: "amount", type: "uint256" }], [
                runtimeERC20BalanceOf({
                  targetAddress: smartAccount.addressOn(args.destination.chainId, true),
                  tokenAddress: args.destination.routeTokenAddress,
                  constraints: [greaterThanOrEqualTo(totalOutput)]
                })
              ])
            ],
            // Pass as a single bytes parameter
            chainId: args.destination.chainId
          }
        });
        const transferBack = await smartAccount.buildComposable({
          type: "transfer",
          data: {
            amount: runtimeERC20BalanceOf({
              tokenAddress: tokenConfig.marketToken.address,
              targetAddress: smartAccount.addressOn(args.destination.chainId, true),
              constraints: [greaterThanOrEqualTo(1n)]
            }),
            chainId: args.destination.chainId,
            recipient: args.wallet.account.address,
            tokenAddress: tokenConfig.marketToken.address
          }
        });
        const batchedInstructions = await smartAccount.buildComposable({
          type: "batch",
          data: {
            instructions: [
              approveSupplyInstructions,
              supplyInstructions,
              transferBack
            ]
          }
        });
        instructions.push(batchedInstructions);
      } else if (args.type === "morpho-supply") {
        const supplyCollateralData = encodeFunctionData({
          abi: morphoBlueAbi_default,
          functionName: "supplyCollateral",
          args: [
            {
              loanToken: args.destination.marketParams?.loanToken,
              collateralToken: args.destination.marketParams?.collateralToken,
              oracle: args.destination.marketParams?.oracle,
              irm: args.destination.marketParams?.irm,
              lltv: args.destination.marketParams?.lltv
            },
            totalOutput,
            args.wallet.account.address,
            "0x"
          ]
        });
        const supplyInstructions = await smartAccount.buildComposable({
          type: "rawCalldata",
          data: {
            calldata: supplyCollateralData,
            to: args.destination.morphoBlue,
            chainId: args.destination.chainId,
            value: 0n
          }
        });
        const batchedInstructions = await smartAccount.buildComposable({
          type: "batch",
          data: {
            instructions: [approveSupplyInstructions, supplyInstructions]
          }
        });
        instructions.push(batchedInstructions);
      } else if (args.type === "vault-deposit") {
        const depositData = encodeFunctionData({
          abi: morphoVaultAbi_default,
          functionName: "deposit",
          args: [totalOutput, args.wallet.account.address]
        });
        const depositInstructions = await smartAccount.buildComposable({
          type: "rawCalldata",
          data: {
            calldata: depositData,
            to: tokenConfig.marketToken.address,
            chainId: args.destination.chainId,
            value: 0n
          }
        });
        const batchedInstructions = await smartAccount.buildComposable({
          type: "batch",
          data: {
            instructions: [approveSupplyInstructions, depositInstructions]
          }
        });
        instructions.push(batchedInstructions);
      }
      const fusionQuote = await meeClient.getFusionQuote({
        trigger: {
          tokenAddress: zeroAddress,
          chainId: args.destination.chainId,
          amount: 1n
        },
        feeToken: {
          address: zeroAddress,
          chainId: args.destination.chainId
        },
        instructions,
        cleanUps: [
          ...cleanUps,
          {
            tokenAddress: args.destination.routeTokenAddress,
            chainId: args.destination.chainId,
            recipientAddress: args.wallet.account.address
          }
        ]
      });
      return {
        status: "success",
        checks: {
          approvals,
          transfers
        },
        account: args.wallet.account,
        instructions,
        quote: {
          hash: fusionQuote.quote.hash,
          node: fusionQuote.quote.node,
          commitment: fusionQuote.quote.commitment,
          fee: {
            tokenAmount: fusionQuote.quote.paymentInfo.tokenAmount,
            tokenWeiAmount: fusionQuote.quote.paymentInfo.tokenWeiAmount,
            tokenValue: fusionQuote.quote.paymentInfo.tokenValue
          },
          userOps: fusionQuote.quote.userOps.map((operation) => ({
            sender: operation.userOp.sender,
            nonce: operation.userOp.nonce,
            initCode: operation.userOp.initCode,
            callData: operation.userOp.callData
          })),
          fusionQuote
        },
        execute: async () => {
          try {
            const superTx = await meeClient.executeFusionQuote({
              fusionQuote
            });
            return {
              hash: superTx.hash,
              wait: async (confirmations) => {
                await meeClient.waitForSupertransactionReceipt({
                  hash: superTx.hash,
                  confirmations
                });
                return;
              },
              status: async () => {
                const receipt = await meeClient.getSupertransactionReceipt({
                  hash: superTx.hash
                });
                if (args.type === "supply" || args.type === "morpho-supply" || args.type === "vault-deposit") {
                  try {
                    receipt.userOps.splice(receipt.userOps.length - (1 + cleanUps.length));
                    const supplyOp = receipt.userOps.splice(receipt.userOps.length - 1);
                    const acrossOps = [...receipt.userOps];
                    const acrossOpsPending = acrossOps.filter((op) => op.executionStatus === "MINING" || op.executionStatus === "PENDING").length > 0;
                    const acrossOpsFailed = acrossOps.filter((op) => op.executionStatus === "FAILED" || op.executionStatus === "MINED_FAIL").length > 0;
                    const acrossOpsSucceed = acrossOps.filter((op) => op.executionStatus === "MINED_SUCCESS" || op.executionStatus === "SUCCESS").length === acrossOps.length;
                    const supplyOpPending = supplyOp.filter((op) => op.executionStatus === "MINING" || op.executionStatus === "PENDING").length > 0;
                    const supplyOpFailed = supplyOp.filter((op) => op.executionStatus === "FAILED" || op.executionStatus === "MINED_FAIL").length > 0;
                    const supplyOpSucceed = supplyOp.filter((op) => op.executionStatus === "MINED_SUCCESS" || op.executionStatus === "SUCCESS").length === supplyOp.length;
                    if (acrossOpsFailed || supplyOpFailed) {
                      return "reverted";
                    }
                    if (acrossOpsPending || supplyOpPending) {
                      return "processing";
                    }
                    if (acrossOpsSucceed || supplyOpSucceed) {
                      return "success";
                    }
                  } catch (ex) {
                    return "pending";
                  }
                }
                return "pending";
              }
            };
          } catch (ex) {
            console.log(ex);
            throw ex;
          }
        }
      };
    }
  }
  return {
    status: "error",
    error: "Token not found"
  };
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/beam/getBeamQuote.js
async function getBeamQuote(client, args) {
  const quote = await getQuote3(client, args);
  return quote;
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/common/fetch-headers.js
var sdkVersion = "1.0.0";
try {
  sdkVersion = require_package().version || "1.0.0";
} catch (e) {
}
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
var MOONWELL_FETCH_JSON_HEADERS = {
  Accept: "application/json",
  "Content-Type": "application/json",
  ...isBrowser ? {} : { "User-Agent": `moonwell-sdk/${sdkVersion}` }
};

// node_modules/@moonwell-fi/moonwell-sdk/_esm/environments/utils/index.js
var findMarketByAddress = (environment, address) => {
  const marketKey = Object.keys(environment.markets || {}).find((key) => {
    return environment.markets[key]?.address.toLowerCase() === address.toLowerCase();
  });
  if (marketKey) {
    const marketConfig = environment.config.markets?.[marketKey];
    const marketToken = environment.config.tokens[marketConfig.marketToken];
    const underlyingToken = environment.config.tokens[marketConfig.underlyingToken];
    return {
      marketKey,
      marketConfig,
      marketToken,
      underlyingToken
    };
  } else {
    return;
  }
};
var findTokenByAddress = (environment, token) => Object.values(environment.config.tokens).find((r) => r.address.toLowerCase() === token.toLowerCase());

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/core/markets/common.js
var getMarketsData = async (environment) => {
  const homeEnvironment = Object.values(publicEnvironments).find((e) => e.custom?.governance?.chainIds?.includes(environment.chainId)) || environment;
  const viewsContract = environment.contracts.views;
  const homeViewsContract = homeEnvironment.contracts.views;
  const marketData = await Promise.all([
    viewsContract?.read.getProtocolInfo(),
    viewsContract?.read.getAllMarketsInfo(),
    homeViewsContract?.read.getNativeTokenPrice(),
    homeViewsContract?.read.getGovernanceTokenPrice()
  ]);
  const { seizePaused, transferPaused } = marketData[0];
  const allMarketsInfo = marketData[1];
  const nativeTokenPriceRaw = marketData[2];
  const governanceTokenPriceRaw = marketData[3];
  const governanceTokenPrice = new Amount(governanceTokenPriceRaw, 18);
  const nativeTokenPrice = new Amount(nativeTokenPriceRaw, 18);
  const markets5 = [];
  const tokenPrices = allMarketsInfo.map((marketInfo) => {
    const marketFound = findMarketByAddress(environment, marketInfo.market);
    if (marketFound) {
      return {
        token: marketFound.underlyingToken,
        tokenPrice: new Amount(marketInfo.underlyingPrice, 36 - marketFound.underlyingToken.decimals)
      };
    } else {
      return;
    }
  }).filter((token) => !!token);
  for (const marketInfo of allMarketsInfo) {
    const marketFound = findMarketByAddress(environment, marketInfo.market);
    if (marketFound) {
      const { marketConfig, marketToken, underlyingToken, marketKey } = marketFound;
      let badDebt = new Amount(0n, underlyingToken.decimals);
      if (marketConfig.badDebt === true) {
        try {
          const badDebtResult = await environment.markets[marketKey]?.read.badDebt();
          badDebt = new Amount(badDebtResult, underlyingToken.decimals);
        } catch (error) {
        }
      }
      const supplyCaps = new Amount(marketInfo.supplyCap, underlyingToken.decimals);
      const borrowCaps = new Amount(marketInfo.borrowCap, underlyingToken.decimals);
      const collateralFactor = new Amount(marketInfo.collateralFactor, 18).value;
      const underlyingPrice = new Amount(marketInfo.underlyingPrice, 36 - underlyingToken.decimals).value;
      const marketTotalSupply = new Amount(marketInfo.totalSupply, marketToken.decimals);
      const totalBorrows = new Amount(marketInfo.totalBorrows, underlyingToken.decimals);
      const totalReserves = new Amount(marketInfo.totalReserves, underlyingToken.decimals);
      const cash = new Amount(marketInfo.cash, underlyingToken.decimals);
      const exchangeRate = new Amount(marketInfo.exchangeRate, 10 + underlyingToken.decimals).value;
      const reserveFactor = new Amount(marketInfo.reserveFactor, 18).value;
      const borrowRate = new Amount(marketInfo.borrowRate, 18);
      const supplyRate = new Amount(marketInfo.supplyRate, 18);
      const totalSupply = new Amount(marketTotalSupply.value * exchangeRate, underlyingToken.decimals);
      const badDebtUsd = badDebt.value * underlyingPrice;
      const totalSupplyUsd = totalSupply.value * underlyingPrice;
      const totalBorrowsUsd = totalBorrows.value * underlyingPrice;
      const totalReservesUsd = totalReserves.value * underlyingPrice;
      const supplyCapsUsd = supplyCaps.value * underlyingPrice;
      const borrowCapsUsd = borrowCaps.value * underlyingPrice;
      const baseSupplyApy = calculateApy(supplyRate.value);
      const baseBorrowApy = calculateApy(borrowRate.value);
      const market = {
        marketKey,
        chainId: environment.chainId,
        seizePaused,
        transferPaused,
        mintPaused: marketInfo.mintPaused,
        borrowPaused: marketInfo.borrowPaused,
        deprecated: marketConfig.deprecated === true,
        borrowCaps,
        borrowCapsUsd,
        cash,
        collateralFactor,
        exchangeRate,
        marketToken,
        reserveFactor,
        supplyCaps,
        supplyCapsUsd,
        badDebt,
        badDebtUsd,
        totalBorrows,
        totalBorrowsUsd,
        totalReserves,
        totalReservesUsd,
        totalSupply,
        totalSupplyUsd,
        underlyingPrice,
        underlyingToken,
        baseBorrowApy,
        baseSupplyApy,
        totalBorrowApr: 0,
        totalSupplyApr: 0,
        rewards: []
      };
      for (const incentive of marketInfo.incentives) {
        let { borrowIncentivesPerSec, supplyIncentivesPerSec, token: tokenAddress } = incentive;
        const token = findTokenByAddress(environment, tokenAddress);
        if (token) {
          const isGovernanceToken = token.symbol === environment.custom?.governance?.token;
          const isNativeToken2 = token.address === zeroAddress;
          const tokenPrice = tokenPrices.find((r) => r?.token.address === incentive.token)?.tokenPrice.value;
          const price = isNativeToken2 ? nativeTokenPrice.value : isGovernanceToken ? governanceTokenPrice.value : tokenPrice;
          if (price) {
            if (token.symbol === "USDC" && borrowIncentivesPerSec === 1n) {
              borrowIncentivesPerSec = 0n;
            }
            const supplyRewardsPerDayUsd = perDay(new Amount(supplyIncentivesPerSec, token.decimals).value) * price;
            const borrowRewardsPerDayUsd = perDay(new Amount(borrowIncentivesPerSec, token.decimals).value) * price;
            const supplyApr = totalSupplyUsd === 0 ? 0 : supplyRewardsPerDayUsd / totalSupplyUsd * DAYS_PER_YEAR * 100;
            const borrowApr = totalBorrowsUsd === 0 ? 0 : borrowRewardsPerDayUsd / totalBorrowsUsd * DAYS_PER_YEAR * 100 * -1;
            market.rewards.push({
              liquidStakingApr: 0,
              borrowApr,
              supplyApr,
              token
            });
          }
        }
      }
      market.totalSupplyApr = market.rewards.reduce((prev, curr) => prev + curr.supplyApr, market.baseSupplyApy);
      market.totalBorrowApr = market.rewards.reduce((prev, curr) => prev + curr.borrowApr, market.baseBorrowApy);
      markets5.push(market);
    }
  }
  return markets5;
};
var fetchFromGenericCacheApi = async (uri) => {
  const response = await fetch("https://generic-api-cache.moonwell.workers.dev/", {
    method: "POST",
    body: `{"uri":"${uri}","cacheDuration":"300"}`,
    headers: {
      ...MOONWELL_FETCH_JSON_HEADERS,
      "Content-Type": "text/plain"
    }
  });
  return response.json();
};
var fetchLiquidStakingRewards = async () => {
  const result = {
    cbETH: 0,
    rETH: 0,
    wstETH: 0
  };
  try {
    const cbETH = await fetchFromGenericCacheApi("https://api.exchange.coinbase.com/wrapped-assets/CBETH");
    result.cbETH = Number(cbETH.apy) * 100;
  } catch (error) {
    result.cbETH = 0;
  }
  try {
    const rETH = await fetchFromGenericCacheApi("https://rocketpool.net/api/mainnet/payload");
    result.rETH = Number(rETH.rethAPR);
  } catch (error) {
    result.rETH = 0;
  }
  try {
    const stETH = await fetchFromGenericCacheApi("https://eth-api.lido.fi/v1/protocol/steth/apr/last");
    result.wstETH = stETH.data.apr;
  } catch (error) {
    result.wstETH = 0;
  }
  return result;
};

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/core/markets/getMarket.js
async function getMarket(client, args) {
  let { marketAddress, market } = args;
  const environment = getEnvironmentFromArgs(client, args);
  if (!environment) {
    return void 0;
  }
  if (!marketAddress) {
    marketAddress = environment.markets[market].address;
  }
  const markets5 = await getMarketsData(environment);
  return markets5.find((m) => m.marketToken.address === marketAddress);
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/logger/console.js
var import_lodash = __toESM(require_lodash(), 1);
var { uniqueId } = import_lodash.default;
var messages = {};
function start(action, message) {
  if (typeof window !== "undefined") {
    const id = uniqueId();
    messages[id] = {
      id,
      start: /* @__PURE__ */ new Date(),
      action,
      message
    };
    window.dispatchEvent(new CustomEvent("moonwell-sdk", {
      detail: messages[id]
    }));
    return id;
  }
  return void 0;
}
function end(id) {
  if (typeof window !== "undefined" && id) {
    const message = messages[id];
    if (message) {
      message.end = /* @__PURE__ */ new Date();
      message.duration = message.end.getTime() - message.start.getTime();
      window.dispatchEvent(new CustomEvent("moonwell-sdk", {
        detail: message
      }));
    }
  }
  return void 0;
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/core/markets/getMarkets.js
async function getMarkets(client, args) {
  const environments = getEnvironmentsFromArgs(client, args);
  const logId = start("getMarkets", "Starting to get markets...");
  const settlements = await Promise.allSettled(environments.map((environment) => getMarketsData(environment)));
  const result = settlements.filter((s) => s.status === "fulfilled").map((s) => s.value);
  if (args?.includeLiquidStakingRewards === true) {
    const liquidStakingRewards = await fetchLiquidStakingRewards();
    for (const item of result.flat()) {
      if (item.underlyingToken.symbol.toLowerCase() === "cbeth") {
        item.rewards.push({
          token: item.underlyingToken,
          supplyApr: 0,
          borrowApr: 0,
          liquidStakingApr: liquidStakingRewards.cbETH
        });
      }
      if (item.underlyingToken.symbol.toLowerCase() === "reth") {
        item.rewards.push({
          token: item.underlyingToken,
          supplyApr: 0,
          borrowApr: 0,
          liquidStakingApr: liquidStakingRewards.rETH
        });
      }
      if (item.underlyingToken.symbol.toLowerCase() === "wsteth") {
        item.rewards.push({
          token: item.underlyingToken,
          supplyApr: 0,
          borrowApr: 0,
          liquidStakingApr: liquidStakingRewards.wstETH
        });
      }
      item.totalSupplyApr = item.baseSupplyApy + item.rewards.reduce((acc, reward) => acc + reward.supplyApr + reward.liquidStakingApr, 0);
    }
  }
  end(logId);
  return result.flat();
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/beam/getBeamTokenLimits.js
async function getBeamTokenLimits(args) {
  const { direction, route } = args;
  const limits = [];
  for (const path of args.route.routes) {
    const inputToken = direction === "withdraw" ? route.routeTokenAddress : path.routeTokenAddress;
    const outputToken = direction === "withdraw" ? path.routeTokenAddress : route.routeTokenAddress;
    const inputChainId = direction === "withdraw" ? route.chainId : path.chainId;
    const outputChainId = direction === "withdraw" ? path.chainId : route.chainId;
    try {
      const acrossLimitsResponse = await axios_default.get(`https://app.across.to/api/limits?inputToken=${inputToken}&outputToken=${outputToken}&originChainId=${inputChainId}&destinationChainId=${outputChainId}`);
      limits.push({
        from: {
          address: direction === "withdraw" ? route.address : path.address,
          chainId: direction === "withdraw" ? route.chainId : path.chainId,
          decimals: direction === "withdraw" ? route.decimals : path.decimals,
          name: direction === "withdraw" ? route.name : path.name,
          routeTokenAddress: direction === "withdraw" ? route.routeTokenAddress : path.routeTokenAddress,
          symbol: direction === "withdraw" ? route.symbol : path.symbol
        },
        to: {
          address: direction === "withdraw" ? path.address : route.address,
          chainId: direction === "withdraw" ? path.chainId : route.chainId,
          decimals: direction === "withdraw" ? path.decimals : route.decimals,
          name: direction === "withdraw" ? path.name : route.name,
          routeTokenAddress: direction === "withdraw" ? path.routeTokenAddress : route.routeTokenAddress,
          symbol: direction === "withdraw" ? path.symbol : route.symbol
        },
        max: new Amount(BigInt(acrossLimitsResponse.data.maxDepositInstant), route.decimals),
        min: new Amount(BigInt(acrossLimitsResponse.data.minDeposit), route.decimals)
      });
    } catch (ex) {
      console.log({
        error: ex
      });
    }
  }
  return limits;
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/core/getUserBalances.js
var getTokenBalance = async (environment, userAddress, tokenAddress) => {
  try {
    if (tokenAddress === zeroAddress) {
      return new Promise((resolve) => {
        environment.publicClient.getBalance({
          address: userAddress
        }).then((balance) => {
          resolve({ amount: BigInt(balance), token: tokenAddress });
        }).catch(() => {
          resolve({ amount: 0n, token: tokenAddress });
        });
      });
    }
    const erc20Abi2 = parseAbi([
      "function balanceOf(address owner) view returns (uint256)"
    ]);
    const erc20Contract = getContract({
      address: tokenAddress,
      abi: erc20Abi2,
      client: environment.publicClient
    });
    const result = new Promise((resolve) => {
      erc20Contract.read.balanceOf([userAddress]).then((balance) => {
        resolve({ amount: BigInt(balance), token: tokenAddress });
      }).catch(() => {
        resolve({ amount: 0n, token: tokenAddress });
      });
    });
    return result;
  } catch (error) {
    console.error("getTokenBalance error", error);
    return { amount: 0n, token: tokenAddress };
  }
};
async function getTokenBalancesFromEnvironment(environment, userAddress) {
  try {
    if (environment.contracts.views) {
      const tokenBalancesFromView = await environment.contracts.views.read.getTokensBalances([
        Object.values(environment.config.tokens).map((token) => token.address),
        userAddress
      ]);
      return [...tokenBalancesFromView];
    }
    const tokenBalancesSettled = await Promise.allSettled(Object.values(environment.config.tokens).map((token) => getTokenBalance(environment, userAddress, token.address)));
    const res = tokenBalancesSettled.flatMap((s) => s.status === "fulfilled" ? s.value : []);
    return res;
  } catch (error) {
    console.error("getTokenBalancesFromEnvironment error", error);
    return [];
  }
}
async function getUserBalances(client, args) {
  const { userAddress } = args;
  const environments = getEnvironmentsFromArgs(client, args, false);
  const environmentsTokensBalancesSettled = await Promise.allSettled(environments.map((env) => getTokenBalancesFromEnvironment(env, userAddress)));
  const environmentsTokensBalances = environmentsTokensBalancesSettled.map((s) => s.status === "fulfilled" ? [...s.value] : []);
  await Promise.all(environments.map(async (env, index) => {
    if (!env.config.vaults)
      return;
    const vaultBalancesSettled = await Promise.allSettled(Object.values(env.config.vaults).filter((vault) => vault.multiReward).map((vault) => getTokenBalance(env, userAddress, vault.multiReward)));
    const vaultBalances = vaultBalancesSettled.flatMap((s) => s.status === "fulfilled" ? s.value : []);
    const envBalances = environmentsTokensBalances[index] || [];
    environmentsTokensBalances[index] = [...envBalances, ...vaultBalances];
  }));
  const result = environments.flatMap((env, index) => {
    const balances = environmentsTokensBalances[index] || [];
    const userBalances = balances.map((balance) => {
      const token = findTokenByAddress(env, balance.token);
      const vault = Object.values(env.config.vaults || {}).find((v) => v.multiReward === balance.token);
      if (token) {
        const result2 = {
          chainId: env.chainId,
          account: userAddress,
          token,
          tokenBalance: new Amount(balance.amount, token.decimals)
        };
        return result2;
      }
      if (vault?.multiReward) {
        const vaultToken = env.config.tokens[vault.vaultToken];
        const result2 = {
          chainId: env.chainId,
          account: userAddress,
          token: {
            address: vault.multiReward,
            decimals: vaultToken.decimals,
            name: `stk${vaultToken.symbol}`,
            symbol: `stk${vaultToken.symbol}`
          },
          tokenBalance: new Amount(balance.amount, vaultToken.decimals)
        };
        return result2;
      }
      return void 0;
    }).filter((balance) => balance !== void 0);
    return userBalances;
  });
  return result;
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/core/user-positions/common.js
var getUserPositionData = async (params) => {
  const viewsContract = params.environment.contracts.views;
  if (!viewsContract) {
    return [];
  }
  try {
    const [allMarkets, balances, borrows, memberships] = await Promise.all([
      viewsContract.read.getAllMarketsInfo(),
      viewsContract.read.getUserBalances([params.account]),
      viewsContract.read.getUserBorrowsBalances([params.account]),
      viewsContract.read.getUserMarketsMemberships([params.account])
    ]);
    const markets5 = allMarkets?.map((marketInfo) => {
      const market = findMarketByAddress(params.environment, marketInfo.market);
      if (market) {
        const { marketToken, underlyingToken } = market;
        const underlyingPrice = new Amount(marketInfo.underlyingPrice, 36 - underlyingToken.decimals).value;
        const collateralFactor = new Amount(marketInfo.collateralFactor, 18).value;
        const exchangeRate = new Amount(marketInfo.exchangeRate, 10 + underlyingToken.decimals).value;
        const marketCollateralEnabled = memberships?.find((r) => r.token === marketInfo.market)?.membership === true;
        const marketBorrowedRaw = borrows?.find((r) => r.token === marketInfo.market)?.amount || 0n;
        const marketSuppliedRaw = balances?.find((r) => r.token === marketInfo.market)?.amount || 0n;
        const borrowed = new Amount(marketBorrowedRaw, market.underlyingToken.decimals);
        const borrowedUsd = borrowed.value * underlyingPrice;
        const marketSupplied = new Amount(marketSuppliedRaw, marketToken.decimals);
        const supplied = new Amount(marketSupplied.value * exchangeRate, underlyingToken.decimals);
        const suppliedUsd = supplied.value * underlyingPrice;
        const collateral = marketCollateralEnabled ? new Amount(supplied.value * collateralFactor, underlyingToken.decimals) : new Amount(0n, underlyingToken.decimals);
        const collateralUsd = collateral.value * underlyingPrice;
        const result = {
          chainId: params.environment.chainId,
          account: params.account,
          market: market.marketToken,
          collateralEnabled: marketCollateralEnabled,
          borrowed,
          borrowedUsd,
          collateral,
          collateralUsd,
          supplied,
          suppliedUsd
        };
        return result;
      } else {
        return;
      }
    }).filter((r) => r !== void 0).filter((r) => params.markets ? params.markets.includes(r.market.address) : true);
    return markets5;
  } catch {
    return [];
  }
};

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/core/user-positions/getUserPosition.js
async function getUserPosition(client, args) {
  let { marketAddress, userAddress } = args;
  const environment = getEnvironmentFromArgs(client, args);
  if (!environment) {
    return void 0;
  }
  if (!marketAddress) {
    const { market } = args;
    marketAddress = environment.markets[market].address;
  }
  const userPosition = await getUserPositionData({
    environment,
    account: userAddress,
    markets: [marketAddress]
  });
  return userPosition?.length > 0 ? userPosition[0] : void 0;
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/core/user-positions/getUserPositionSnapshots.js
var import_dayjs2 = __toESM(require_dayjs_min(), 1);
var import_utc = __toESM(require_utc(), 1);
import_dayjs2.default.extend(import_utc.default);
async function getUserPositionSnapshots(client, args) {
  const environment = getEnvironmentFromArgs(client, args);
  if (!environment) {
    return [];
  }
  return fetchUserPositionSnapshots(args.userAddress, environment);
}
async function fetchUserPositionSnapshots(userAddress, environment) {
  const dailyData = [];
  let hasNextPage = true;
  let endCursor;
  while (hasNextPage) {
    const result = await axios_default.post(environment.indexerUrl, {
      query: `
          query {
            accountDailySnapshots(
              limit: 365,
              orderDirection: "desc",
              orderBy: "timestamp",
              where: { accountAddress: "${userAddress.toLowerCase()}", chainId: ${environment.chainId} }
              ${endCursor ? `after: "${endCursor}"` : ""}
            ) {
              items {
                timestamp,
                totalBorrowsUSD,
                totalSuppliesUSD,
                totalCollateralUSD,
              }
              pageInfo {
                hasNextPage
                endCursor
              }
            }
          }
        `
    });
    dailyData.push(...result.data.data.accountDailySnapshots.items.filter((f) => isStartOfDay(f.timestamp)));
    hasNextPage = result.data.data.accountDailySnapshots.pageInfo.hasNextPage;
    endCursor = result.data.data.accountDailySnapshots.pageInfo.endCursor;
  }
  if (dailyData.length > 0) {
    return dailyData.map((point) => {
      const borrowUsd = Number(point.totalBorrowsUSD);
      const suppliedUsd = Number(point.totalSuppliesUSD);
      const collateralUsd = Number(point.totalCollateralUSD);
      const result = {
        chainId: environment.chainId,
        timestamp: point.timestamp * 1e3,
        totalSupplyUsd: suppliedUsd,
        totalBorrowsUsd: borrowUsd,
        totalCollateralUsd: collateralUsd
      };
      return result;
    });
  } else {
    return [];
  }
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/core/user-positions/getUserPositions.js
async function getUserPositions(client, args) {
  const { userAddress } = args;
  const environments = getEnvironmentsFromArgs(client, args);
  const settled = await Promise.allSettled(environments.map((environment) => getUserPositionData({
    environment,
    account: userAddress
  })));
  const result = settled.flatMap((s) => s.status === "fulfilled" ? s.value : []);
  return result;
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/core/user-rewards/common.js
var getUserRewardsData = async (params) => {
  const homeEnvironment = Object.values(publicEnvironments).find((e) => e.custom?.governance?.chainIds?.includes(params.environment.chainId)) || params.environment;
  const viewsContract = params.environment.contracts.views;
  const homeViewsContract = homeEnvironment.contracts.views;
  const [m0, r0, n0, g0] = await Promise.allSettled([
    viewsContract?.read.getAllMarketsInfo(),
    viewsContract?.read.getUserRewards([params.account]),
    homeViewsContract?.read.getNativeTokenPrice(),
    homeViewsContract?.read.getGovernanceTokenPrice()
  ]);
  const allMarkets = m0.status === "fulfilled" ? m0.value : void 0;
  const userRewards = r0.status === "fulfilled" ? r0.value : void 0;
  const nativeTokenPriceRaw = n0.status === "fulfilled" ? n0.value : void 0;
  const governanceTokenPriceRaw = g0.status === "fulfilled" ? g0.value : void 0;
  if (!allMarkets || !userRewards || !nativeTokenPriceRaw || !governanceTokenPriceRaw) {
    return [];
  }
  const governanceTokenPrice = new Amount(governanceTokenPriceRaw || 0n, 18);
  const nativeTokenPrice = new Amount(nativeTokenPriceRaw || 0n, 18);
  let tokenPrices = allMarkets?.map((marketInfo) => {
    const marketFound = findMarketByAddress(params.environment, marketInfo.market);
    if (marketFound) {
      return {
        token: marketFound.underlyingToken,
        tokenPrice: new Amount(marketInfo.underlyingPrice, 36 - marketFound.underlyingToken.decimals)
      };
    } else {
      return;
    }
  }).filter((token) => !!token) || [];
  if (params.environment.custom?.governance?.token) {
    tokenPrices = [
      ...tokenPrices,
      {
        token: params.environment.config.tokens[params.environment.custom.governance.token],
        tokenPrice: governanceTokenPrice
      }
    ];
  }
  tokenPrices = [
    ...tokenPrices,
    {
      token: findTokenByAddress(params.environment, zeroAddress),
      tokenPrice: nativeTokenPrice
    }
  ];
  const markets5 = (allMarkets || []).filter((r) => params.markets ? params.markets.includes(r.market) : true);
  const rewards = markets5.flatMap((marketInfo) => {
    const market = findMarketByAddress(params.environment, marketInfo.market);
    if (market) {
      const marketRewards = userRewards?.filter((r) => r.market === marketInfo.market) || [];
      return marketRewards.filter((reward) => {
        const token = findTokenByAddress(params.environment, reward.rewardToken);
        return token !== void 0;
      }).map((reward) => {
        const token = findTokenByAddress(params.environment, reward.rewardToken);
        const isGovernanceToken = token.symbol === params.environment.custom?.governance?.token;
        const isNativeToken2 = token.address === zeroAddress;
        const tokenPrice = tokenPrices?.find((r) => r?.token.address === reward.rewardToken)?.tokenPrice.value;
        const price = (isNativeToken2 ? nativeTokenPrice.value : isGovernanceToken ? governanceTokenPrice.value : tokenPrice) || 0;
        const supplyRewards = new Amount(reward.supplyRewardsAmount, token.decimals);
        const borrowRewards = new Amount(reward.borrowRewardsAmount, token.decimals);
        const result = {
          chainId: params.environment.chainId,
          account: params.account,
          market: market.marketToken,
          rewardToken: token,
          supplyRewards,
          supplyRewardsUsd: supplyRewards.value * price,
          borrowRewards,
          borrowRewardsUsd: borrowRewards.value * price
        };
        return result;
      });
    } else {
      return [];
    }
  });
  return rewards;
};

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/core/user-rewards/getUserReward.js
async function getUserReward(client, args) {
  let { marketAddress, userAddress } = args;
  const environment = getEnvironmentFromArgs(client, args);
  if (!environment) {
    return void 0;
  }
  if (!marketAddress) {
    const { market } = args;
    marketAddress = environment.markets[market].address;
  }
  const userRewards = await getUserRewardsData({
    environment,
    account: userAddress,
    markets: [marketAddress]
  });
  return userRewards?.length > 0 ? userRewards[0] : void 0;
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/core/user-rewards/getUserRewards.js
async function getUserRewards(client, args) {
  const { userAddress } = args;
  const environments = getEnvironmentsFromArgs(client, args);
  const settled = await Promise.allSettled(environments.map((environment) => getUserRewardsData({
    environment,
    account: userAddress
  })));
  const result = settled.flatMap((s) => s.status === "fulfilled" ? s.value : []);
  return result;
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/governance/getCirculatingSupplySnapshots.js
async function getCirculatingSupplySnapshots(client, args) {
  const environment = getEnvironmentFromArgs(client, args);
  if (!environment) {
    return [];
  }
  try {
    const response = await axios_default.post(environment.indexerUrl, {
      query: `
          {
            circulatingSupplyDailySnapshots(
              where: { chainId: ${environment.chainId} }
              orderBy: "timestamp"
              orderDirection: "desc"
              limit: 1000
            ) {
              items {
                chainId
                tokenAddress
                circulatingSupply
                timestamp
              }
            }
          }
        `
    });
    if (response.status === 200 && response.data?.data?.circulatingSupplyDailySnapshots) {
      return response.data?.data?.circulatingSupplyDailySnapshots.items.map((item) => ({
        chainId: item.chainId,
        token: Object.values(environment.config.tokens).find((token) => token.address.toLowerCase() === item.tokenAddress.toLowerCase()),
        circulatingSupply: item.circulatingSupply,
        timestamp: item.timestamp
      }));
    } else {
      return [];
    }
  } catch (ex) {
    console.error("An error occured while fetching getStakingSnapshots...", ex);
    return [];
  }
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/governance/getDelegates.js
async function getDelegates(client) {
  let users = [];
  const logId = start("getDelegates", "Starting to get delegates...");
  const getUsersPaginated = async (page = 0) => {
    const response = await axios_default.get(`https://forum.moonwell.fi/directory_items.json?period=all&order=Delegate+Wallet+Address&user_field_ids=2%7C1%7C3&page=${page}`);
    if (response.status !== 200 || !response.data) {
      throw new HttpRequestError(response.statusText);
    }
    const results = response.data.directory_items.filter((item) => item.user.user_fields["1"] !== void 0 && item.user.user_fields["1"].value !== void 0 && item.user.user_fields["1"].value[0] !== void 0 && isAddress(item.user.user_fields["1"].value[0]) && item.user.user_fields["2"] !== void 0 && item.user.user_fields["2"].value !== void 0 && item.user.user_fields["2"].value[0] !== void 0).map((item) => {
      const avatar = item.user.avatar_template.replace("{size}", "160");
      const result = {
        avatar: avatar.startsWith("/user_avatar") ? `https://dub1.discourse-cdn.com/flex017${avatar}` : avatar,
        name: item.user.username,
        wallet: item.user.user_fields["1"].value[0],
        pitch: {
          intro: item.user.user_fields["2"].value[0],
          url: item.user.user_fields["3"]?.value[0]
        }
      };
      return result;
    });
    users = users.concat(results);
    const loadMore = response.data.directory_items.length > 0;
    if (loadMore) {
      await getUsersPaginated(page + 1);
    }
  };
  await getUsersPaginated();
  const proposals = await getDelegatesExtendedData({
    users: users.map((r) => r.wallet)
  });
  const envs = Object.values(client.environments).filter((env) => env.contracts.views !== void 0);
  const votingPowers = await Promise.all(users.map(async (user) => Promise.all(envs.map((environment) => environment.contracts.views?.read.getUserVotingPower([
    user.wallet
  ])))));
  end(logId);
  users = users.map((user, index) => {
    let votingPower = {};
    const userVotingPowers = votingPowers[index];
    if (userVotingPowers) {
      votingPower = envs.reduce((prev, curr, reduceIndex) => {
        const { claimsVotes, stakingVotes, tokenVotes } = userVotingPowers[reduceIndex];
        const totalVotes = claimsVotes.delegatedVotingPower + stakingVotes.delegatedVotingPower + tokenVotes.delegatedVotingPower;
        return {
          ...prev,
          [curr.chainId]: Number(totalVotes / BigInt(10 ** 18))
        };
      }, {});
    }
    const extended = {
      ...user,
      proposals: proposals[user.wallet.toLowerCase()],
      votingPower
    };
    return extended;
  });
  return users;
}
var getDelegatesExtendedData = async (params) => {
  const response = await axios_default.post(publicEnvironments.moonbeam.governanceIndexerUrl, {
    query: `
      query {
        proposers(where: {id_in: [${params.users.map((r) => `"${r.toLowerCase()}"`).join(",")}]}) {
          items {
            id
            proposals(limit: 1000) {
              items {
                chainId
                proposalId
              }
            }
          }
        }
        voters(where: {id_in: [${params.users.map((r) => `"${r.toLowerCase()}"`).join(",")}]}) {
          items {
            id
            votes(limit: 1000) {
              items {
                voter
                proposal {
                  chainId
                }
              }
            }
          }
        }
      }
    `
  });
  if (response.status === 200 && response.data?.data?.voters) {
    const voters = response?.data?.data?.voters?.items.reduce((prev, curr) => {
      return {
        ...prev,
        [curr.id.toLowerCase()]: curr.votes.items.reduce((prevVotes, currVotes) => {
          const previousVotes = prevVotes[currVotes.proposal.chainId] || 0;
          return {
            ...prevVotes,
            [currVotes.proposal.chainId]: previousVotes + 1
          };
        }, {})
      };
    }, {});
    const proposers = response?.data?.data?.proposers?.items.reduce((prev, curr) => {
      return {
        ...prev,
        [curr.id.toLowerCase()]: curr.proposals.items.reduce((prevVotes, currVotes) => {
          const previousProposed = prevVotes[currVotes.chainId] || 0;
          return {
            ...prevVotes,
            [currVotes.chainId]: previousProposed + 1
          };
        }, {})
      };
    }, {});
    return params.users.reduce((prev, curr) => {
      const proposalsCreated = proposers[curr.toLowerCase()];
      const proposalsVoted = voters[curr.toLowerCase()];
      const chains = [
        ...Object.keys(proposalsCreated || {}),
        ...Object.keys(proposalsVoted || {})
      ];
      return {
        ...prev,
        [curr.toLowerCase()]: chains.reduce((prevChain, currChain) => {
          return {
            ...prevChain,
            [currChain]: {
              created: proposalsCreated?.[currChain] || 0,
              voted: proposalsVoted?.[currChain] || 0
            }
          };
        }, {})
      };
    }, {});
  }
  return {};
};

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/governance/getDiscussions.js
var import_lodash2 = __toESM(require_lodash(), 1);
var { isEqual, uniqWith } = import_lodash2.default;
async function getDiscussions(_client) {
  const logId = start("getDiscussions", "Starting to get discussions...");
  const moonwellProposalsResult = await axios_default.get("https://forum.moonwell.fi/c/proposals/moonwell-improvement-proposals/9/l/latest.json");
  if (moonwellProposalsResult.status !== 200 || !moonwellProposalsResult.data) {
    throw new HttpRequestError(moonwellProposalsResult.statusText);
  }
  const communityProposalsResult = await axios_default.get("https://forum.moonwell.fi/c/proposals/community-proposal/19/l/latest.json");
  if (communityProposalsResult.status !== 200 || !communityProposalsResult.data) {
    throw new HttpRequestError(communityProposalsResult.statusText);
  }
  end(logId);
  const toType = (item) => {
    return item.topic_list.topics.map((topic) => {
      const result = {
        title: topic.title,
        views: topic.views,
        replies: topic.posts_count - 1,
        createdAt: new Date(topic.created_at).getTime(),
        tags: topic.tags,
        link: `https://forum.moonwell.fi/t/${topic.id}`
      };
      return result;
    });
  };
  const topics = [
    ...toType(moonwellProposalsResult.data),
    ...toType(communityProposalsResult.data)
  ];
  return uniqWith(topics, isEqual).sort((a, b) => b.createdAt - a.createdAt);
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/governance/getGovernanceTokenInfo.js
async function getGovernanceTokenInfo(_client, args) {
  const logId = start("getGovernanceTokenInfo", "Starting to get governance token info...");
  if (args.governanceToken === "WELL") {
    const totalSupply = await publicEnvironments.moonbeam.contracts.governanceToken.read.totalSupply();
    end(logId);
    return {
      totalSupply: new Amount(totalSupply || 0n, 18)
    };
  } else {
    const totalSupply = await publicEnvironments.moonriver.contracts.governanceToken.read.totalSupply();
    end(logId);
    return {
      totalSupply: new Amount(totalSupply || 0n, 18)
    };
  }
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/governance/common.js
async function getMerklRewardsData(campaignId, chainId, account) {
  try {
    const response = await fetch(`https://api.merkl.xyz/v4/users/${account}/rewards?chainId=${chainId}&test=false&breakdownPage=0&reloadChainId=${chainId}`, {
      headers: MOONWELL_FETCH_JSON_HEADERS
    });
    if (!response.ok) {
      console.warn(`Merkl API request failed: ${response.status} ${response.statusText}`);
      return [];
    }
    const data = await response.json();
    return data.filter((reward) => reward.rewards.some((r) => r.breakdowns.some((b) => campaignId.includes(b.campaignId)))).flatMap((reward) => reward.rewards.filter((r) => r.breakdowns.some((b) => campaignId.includes(b.campaignId))).flatMap((r) => r.breakdowns.filter((b) => campaignId.includes(b.campaignId)).map((b) => ({
      chain: reward.chain.id,
      token: r.token,
      amount: b.amount,
      claimed: b.claimed,
      pending: b.pending
    }))));
  } catch (error) {
    console.error("Error in getMerklRewardsData:", error);
    return [];
  }
}
async function getMerklStakingApr(campaignId) {
  try {
    const response = await fetch(`https://api.merkl.xyz/v4/campaigns?campaignId=${campaignId}`, {
      headers: MOONWELL_FETCH_JSON_HEADERS
    });
    if (!response.ok) {
      console.warn(`Merkl API request failed: ${response.status} ${response.statusText}`);
      return 0;
    }
    const data = await response.json();
    return data.reduce((acc, curr) => acc + Number(curr.apr), 0);
  } catch (error) {
    console.error("Error in getMerklStakingApr:", error);
    return 0;
  }
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/governance/getStakingInfo.js
async function getStakingInfo(client, args) {
  const environments = getEnvironmentsFromArgs(client, args);
  const envsWithStaking = environments.filter((env) => env.config.contracts.stakingToken);
  const envStakingInfoSettlements = await Promise.allSettled(envsWithStaking.map(async (environment) => {
    const homeEnvironment = Object.values(publicEnvironments).find((e) => e.custom?.governance?.chainIds?.includes(environment.chainId)) || environment;
    const isBase = environment.chainId === base.id;
    const promises = [
      environment.contracts.views?.read.getStakingInfo(),
      homeEnvironment.contracts.views?.read.getGovernanceTokenPrice(),
      ...isBase ? [
        environment.contracts.views?.read.getStakingInfo({
          blockNumber: BigInt(34149943)
        })
      ] : []
    ];
    const settlements = await Promise.allSettled(promises);
    return settlements.map((s) => s.status === "fulfilled" ? s.value : void 0);
  }));
  const envStakingInfo = envStakingInfoSettlements.filter((s) => s.status === "fulfilled").map((s) => s.value).filter((val) => val !== void 0);
  const baseStakingApr = await getMerklStakingApr("0xf2c5b7dd2d3416d3853bcf1e93c1cfdb7b5b5fda079d36408df02f731f7d1499");
  const result = envsWithStaking.flatMap((curr, index) => {
    const token = curr.config.tokens[curr.config.contracts.governanceToken];
    const stakingToken = curr.config.tokens[curr.config.contracts.stakingToken];
    const envStakingInfoData = envStakingInfo[index][0];
    const envGovernanceTokenPriceData = envStakingInfo[index][1];
    const envStakingInfoDataAfterX28Proposal = envStakingInfo[index][2];
    const isBase = curr.chainId === base.id;
    if (!envStakingInfoData || !envGovernanceTokenPriceData || isBase && !envStakingInfoDataAfterX28Proposal) {
      return [];
    }
    const { cooldown, distributionEnd, emissionPerSecond: emissionPerSecondRaw, totalSupply: totalSupplyRaw, unstakeWindow } = envStakingInfoData;
    const governanceTokenPriceRaw = envGovernanceTokenPriceData;
    const governanceTokenPrice = new Amount(governanceTokenPriceRaw, 18);
    const totalSupply = new Amount(totalSupplyRaw, 18);
    const emissionPerSecond = new Amount(emissionPerSecondRaw, 18);
    const emissionPerYear = emissionPerSecond.value * SECONDS_PER_DAY * DAYS_PER_YEAR;
    const apr = ((emissionPerYear + totalSupply.value) / totalSupply.value - 1) * 100;
    const stakingInfo = {
      apr: isBase ? baseStakingApr : apr,
      chainId: curr.chainId,
      cooldown: Number(cooldown),
      distributionEnd: Number(distributionEnd),
      token,
      tokenPrice: governanceTokenPrice.value,
      stakingToken,
      totalSupply,
      totalSupplyUSD: totalSupply.value * governanceTokenPrice.value,
      unstakeWindow: Number(unstakeWindow)
    };
    return stakingInfo;
  });
  return result;
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/governance/getStakingSnapshots.js
async function getStakingSnapshots(client, args) {
  const environment = getEnvironmentFromArgs(client, args);
  if (!environment) {
    return [];
  }
  try {
    const response = await axios_default.post(environment.indexerUrl, {
      query: `
          query {
            stakingDailySnapshots(
              limit: 365,
              orderBy: "timestamp"
              orderDirection: "desc"
              where: {chainId: ${environment.chainId}}
            ) {
              items {
                chainId
                totalStaked
                totalStakedUSD
                timestamp
              }
            }
          }
        `
    });
    if (response.status === 200 && response.data?.data?.stakingDailySnapshots) {
      return response.data?.data?.stakingDailySnapshots.items;
    } else {
      return [];
    }
  } catch (ex) {
    console.error("An error occured while fetching getStakingSnapshots...", ex);
    return [];
  }
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/governance/getUserStakingInfo.js
async function getUserStakingInfo(client, args) {
  const { userAddress } = args;
  const environments = getEnvironmentsFromArgs(client, args);
  const envsWithStaking = environments.filter((env) => env.contracts.stakingToken);
  const envStakingInfo = await Promise.all(envsWithStaking.map(async (environment) => {
    const homeEnvironment = Object.values(publicEnvironments).find((e) => e.custom?.governance?.chainIds?.includes(environment.chainId)) || environment;
    const settled = await Promise.allSettled([
      environment.contracts.views?.read.getUserStakingInfo([userAddress]),
      environment.contracts.governanceToken?.read.balanceOf([userAddress]),
      homeEnvironment.contracts.views?.read.getGovernanceTokenPrice(),
      environment.contracts.views?.read.getStakingInfo()
    ]);
    return settled.map((s) => s.status === "fulfilled" ? s.value : void 0);
  }));
  const merklRewards = await getMerklRewardsData([
    "0xcd60ff26dc0b43f14c995c494bc5650087eaae68b279bdbe85e0e8eaa11fd513",
    "0xf2c5b7dd2d3416d3853bcf1e93c1cfdb7b5b5fda079d36408df02f731f7d1499"
  ], base.id, userAddress);
  const result = envsWithStaking.flatMap((curr, index) => {
    const token = curr.config.tokens[curr.config.contracts.governanceToken];
    const stakingToken = curr.config.tokens[curr.config.contracts.stakingToken];
    const userStakingInfoData = envStakingInfo[index][0];
    const { cooldown, pendingRewards, totalStaked } = userStakingInfoData;
    const isBase = curr.chainId === base.id;
    const merklReward = merklRewards.reduce((acc, r) => {
      if (r.chain === curr.chainId) {
        return acc + BigInt(r.amount) - BigInt(r.claimed);
      }
      return acc;
    }, 0n);
    const merklPendingRewards = isBase ? merklReward : 0n;
    const tokenBalance = envStakingInfo[index][1];
    const governanceTokenPriceRaw = envStakingInfo[index]?.[2];
    const stakingInfoData = envStakingInfo[index]?.[3];
    const { cooldown: cooldownSeconds, unstakeWindow } = stakingInfoData;
    const cooldownEnding = cooldown > 0n ? cooldown + cooldownSeconds : 0n;
    const unstakingEnding = cooldown > 0n ? cooldown + cooldownSeconds + unstakeWindow : 0n;
    const governanceTokenPrice = new Amount(governanceTokenPriceRaw, 18);
    const userStakingInfo = {
      chainId: curr.chainId,
      cooldownActive: cooldown > 0n,
      cooldownStart: Number(cooldown),
      cooldownEnding: Number(cooldownEnding),
      unstakingStart: Number(cooldownEnding),
      unstakingEnding: Number(unstakingEnding),
      pendingRewards: isBase ? new Amount(merklPendingRewards, 18) : new Amount(pendingRewards, 18),
      token,
      tokenBalance: new Amount(tokenBalance, 18),
      tokenPrice: governanceTokenPrice.value,
      stakingToken,
      stakingTokenBalance: new Amount(totalStaked, 18)
    };
    return userStakingInfo;
  });
  return result;
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/governance/getUserVoteReceipt.js
async function getUserVoteReceipt(client, args) {
  const { proposalId, userAddress } = args;
  const environment = getEnvironmentFromArgs(client, args);
  if (!environment) {
    return [];
  }
  let isMultichain = false;
  let getReceiptProposalId = proposalId;
  if (environment.contracts.multichainGovernor) {
    if (environment.custom?.governance?.proposalIdOffset) {
      if (proposalId > environment.custom?.governance?.proposalIdOffset) {
        isMultichain = true;
        getReceiptProposalId = proposalId - environment.custom?.governance?.proposalIdOffset;
      }
    }
  }
  const result = [];
  if (isMultichain) {
    const governanceChainIds = environment.custom?.governance?.chainIds || [];
    const receipt = await environment.contracts.multichainGovernor?.read.getReceipt([
      BigInt(getReceiptProposalId),
      userAddress
    ]);
    const [hasVoted, voteValue, votes] = receipt || [false, 0, 0];
    result.push({
      chainId: environment.chainId,
      proposalId,
      account: userAddress,
      option: voteValue,
      voted: hasVoted,
      votes: new Amount(votes || 0, 18)
    });
    for (const chainId of governanceChainIds) {
      const multichainEnvironment = Object.values(publicEnvironments).find((r) => r.chainId === chainId);
      if (multichainEnvironment) {
        const receipt2 = await multichainEnvironment.contracts.voteCollector?.read.getReceipt([
          BigInt(getReceiptProposalId),
          userAddress
        ]);
        const [hasVoted2, voteValue2, votes2] = receipt2 || [false, 0, 0];
        result.push({
          chainId: multichainEnvironment.chainId,
          proposalId,
          account: userAddress,
          option: voteValue2,
          voted: hasVoted2,
          votes: new Amount(votes2 || 0, 18)
        });
      }
    }
  } else {
    const receipt = await environment.contracts.governor?.read.getReceipt([
      BigInt(getReceiptProposalId),
      userAddress
    ]);
    result.push({
      chainId: environment.chainId,
      proposalId,
      account: userAddress,
      option: receipt?.voteValue || 0,
      voted: receipt?.hasVoted || false,
      votes: new Amount(receipt?.votes || 0, 18)
    });
  }
  return result;
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/governance/getUserVotingPowers.js
async function getUserVotingPowers(client, args) {
  const { governanceToken, userAddress, blockNumber } = args;
  const environments = getEnvironmentsFromArgs(client, args);
  const tokenEnvironments = environments.filter((env) => env.custom?.governance?.token === governanceToken);
  const environmentsUserVotingPowers = await Promise.all(tokenEnvironments.map((environment) => environment.contracts.views?.read.getUserVotingPower([userAddress], {
    blockNumber
  })));
  return tokenEnvironments.map((environment, index) => {
    const votingPowers = environmentsUserVotingPowers[index];
    return {
      chainId: environment.chainId,
      //Claims balances
      claimsDelegates: votingPowers.claimsVotes.delegates,
      claimsBalance: new Amount(votingPowers.claimsVotes.votingPower, 18),
      claimsDelegated: new Amount(votingPowers.claimsVotes.delegatedVotingPower, 18),
      claimsDelegatedOthers: new Amount(votingPowers.claimsVotes.delegatedVotingPower - (votingPowers.claimsVotes.delegates === userAddress ? votingPowers.claimsVotes.votingPower : 0n), 18),
      claimsDelegatedSelf: new Amount(votingPowers.claimsVotes.delegates === userAddress ? votingPowers.claimsVotes.votingPower : 0n, 18),
      claimsUndelegated: new Amount(votingPowers.claimsVotes.delegates === zeroAddress ? votingPowers.claimsVotes.votingPower : 0n, 18),
      //Token balances
      tokenDelegates: votingPowers.tokenVotes.delegates,
      tokenBalance: new Amount(votingPowers.tokenVotes.votingPower, 18),
      tokenDelegated: new Amount(votingPowers.tokenVotes.delegatedVotingPower, 18),
      tokenDelegatedOthers: new Amount(votingPowers.tokenVotes.delegatedVotingPower - (votingPowers.tokenVotes.delegates === userAddress ? votingPowers.tokenVotes.votingPower : 0n), 18),
      tokenDelegatedSelf: new Amount(votingPowers.tokenVotes.delegates === userAddress ? votingPowers.tokenVotes.votingPower : 0n, 18),
      tokenUndelegated: new Amount(votingPowers.tokenVotes.delegates === zeroAddress ? votingPowers.tokenVotes.votingPower : 0n, 18),
      stakingDelegated: new Amount(votingPowers.stakingVotes.delegatedVotingPower, 18),
      totalDelegated: new Amount(votingPowers.claimsVotes.delegatedVotingPower + votingPowers.tokenVotes.delegatedVotingPower + votingPowers.stakingVotes.delegatedVotingPower, 18),
      totalDelegatedOthers: new Amount(votingPowers.claimsVotes.delegatedVotingPower - (votingPowers.claimsVotes.delegates === userAddress ? votingPowers.claimsVotes.votingPower : 0n) + (votingPowers.tokenVotes.delegatedVotingPower - (votingPowers.tokenVotes.delegates === userAddress ? votingPowers.tokenVotes.votingPower : 0n)), 18),
      totalDelegatedSelf: new Amount((votingPowers.claimsVotes.delegates === userAddress ? votingPowers.claimsVotes.votingPower : 0n) + (votingPowers.tokenVotes.delegates === userAddress ? votingPowers.tokenVotes.votingPower : 0n) + votingPowers.stakingVotes.delegatedVotingPower, 18)
    };
  });
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/governance/proposals/getProposal.js
var import_lodash4 = __toESM(require_lodash(), 1);

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/governance/proposals/common.js
var import_lodash3 = __toESM(require_lodash(), 1);

// node_modules/@moonwell-fi/moonwell-sdk/_esm/types/proposal.js
var ProposalState;
(function(ProposalState2) {
  ProposalState2[ProposalState2["Pending"] = 0] = "Pending";
  ProposalState2[ProposalState2["Active"] = 1] = "Active";
  ProposalState2[ProposalState2["Canceled"] = 2] = "Canceled";
  ProposalState2[ProposalState2["Defeated"] = 3] = "Defeated";
  ProposalState2[ProposalState2["Succeeded"] = 4] = "Succeeded";
  ProposalState2[ProposalState2["Queued"] = 5] = "Queued";
  ProposalState2[ProposalState2["Expired"] = 6] = "Expired";
  ProposalState2[ProposalState2["Executed"] = 7] = "Executed";
  ProposalState2[ProposalState2["MultichainQueued"] = 8] = "MultichainQueued";
  ProposalState2[ProposalState2["MultichainExecuted"] = 9] = "MultichainExecuted";
})(ProposalState || (ProposalState = {}));
var MultichainProposalState;
(function(MultichainProposalState2) {
  MultichainProposalState2[MultichainProposalState2["Active"] = 0] = "Active";
  MultichainProposalState2[MultichainProposalState2["MultichainVoteCollection"] = 1] = "MultichainVoteCollection";
  MultichainProposalState2[MultichainProposalState2["Canceled"] = 2] = "Canceled";
  MultichainProposalState2[MultichainProposalState2["Defeated"] = 3] = "Defeated";
  MultichainProposalState2[MultichainProposalState2["Succeeded"] = 4] = "Succeeded";
  MultichainProposalState2[MultichainProposalState2["Executed"] = 5] = "Executed";
})(MultichainProposalState || (MultichainProposalState = {}));
var MultichainProposalStateMapping = {
  [MultichainProposalState.Active]: ProposalState.Active,
  [MultichainProposalState.MultichainVoteCollection]: ProposalState.Queued,
  [MultichainProposalState.Canceled]: ProposalState.Canceled,
  [MultichainProposalState.Defeated]: ProposalState.Defeated,
  [MultichainProposalState.Succeeded]: ProposalState.Succeeded,
  [MultichainProposalState.Executed]: ProposalState.Executed
};

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/governance/proposals/common.js
var { last } = import_lodash3.default;
axios_default.defaults.timeout = 5e3;
var appendProposalExtendedData = (proposals, extendedDatas) => {
  proposals.forEach((proposal) => {
    const extendedData = extendedDatas.find((item) => item.id === proposal.id);
    if (extendedData) {
      proposal.title = extendedData.title;
      proposal.calldatas = extendedData.calldatas;
      proposal.description = extendedData.description;
      proposal.signatures = extendedData.signatures;
      proposal.stateChanges = extendedData.stateChanges;
      proposal.subtitle = extendedData.subtitle;
      proposal.targets = extendedData.targets;
    }
  });
};
var extractProposalSubtitle = (input) => {
  const lines = input.split("\n");
  const h1Line = lines.find((line) => line.startsWith("#"));
  if (!h1Line) {
    return input ? input.substring(0, 100) : "";
  }
  let result = h1Line.substring(1).trim();
  const h2Index = result.indexOf("##");
  if (h2Index !== -1) {
    result = result.substring(0, h2Index).trim();
  }
  result = result.replace(/\\n/g, "").trim();
  if (result.length > 80) {
    result = `${result.substring(0, 80)}...`;
  }
  if (result.includes("Moonbeam")) {
    result = result.replace("MIP-B", "MIP-M");
  }
  if (result.indexOf("MIP-B22: Gauntlet") >= 0) {
    result = result.replace("MIP-B22", "MIP-B24");
  }
  if (result.indexOf("MIP-O01: Gauntlet") >= 0) {
    result = result.replace("MIP-O01", "MIP-O03");
  }
  if (result.indexOf("MIP-M02: Upgrade") >= 0) {
    result = result.replace("MIP-M02", "MIP-M03");
  }
  if (result.indexOf("MIP-R02: Upgrade") >= 0) {
    result = result.replace("MIP-R02", "MIP-R03");
  }
  if (result.indexOf("Proposal: Onboard wstETH") >= 0) {
    result = result.replace("Proposal:", "MIP-B08");
  }
  if (result.indexOf("Gauntlet's Moonriver Recommendations (2024-01-09)") >= 0) {
    result = result.replace("Gauntlet", "MIP-R10: Gauntlet");
  }
  return result;
};
var getProposalData = async (params) => {
  if (params.environment.contracts.governor) {
    let count = 0n;
    let quorum = 0n;
    if (params.environment.chainId === moonriver.id) {
      [count, quorum] = await Promise.all([
        params.environment.contracts.governor.read.proposalCount(),
        params.environment.contracts.governor.read.getQuorum()
      ]);
    } else {
      [count, quorum] = await Promise.all([
        params.environment.contracts.governor.read.proposalCount(),
        params.environment.contracts.governor.read.quorumVotes()
      ]);
    }
    if (params.id) {
      if (BigInt(params.id) > count) {
        return [];
      }
    }
    const ids = params.id ? [BigInt(params.id)] : Array.from({ length: Number(count) }, (_, i) => count - BigInt(i));
    const proposalDataCall = Promise.all(ids.map((id) => params.environment.contracts.governor?.read.proposals([id])));
    const proposalStateCall = Promise.all(ids.map((id) => params.environment.contracts.governor?.read.state([id])));
    const [proposalsData, proposalsState] = await Promise.all([
      proposalDataCall,
      proposalStateCall
    ]);
    const proposals = proposalsData?.map((item, index) => {
      const state = proposalsState?.[index];
      const [id, proposer, eta, startTimestamp, endTimestamp, startBlock, forVotes, againstVotes, abstainVotes, totalVotes, canceled, executed] = item;
      const proposal = {
        chainId: params.environment.chainId,
        id: Number(id),
        proposalId: Number(id),
        proposer,
        eta: Number(eta),
        startTimestamp: Number(startTimestamp),
        endTimestamp: Number(endTimestamp),
        startBlock: Number(startBlock),
        forVotes: new Amount(forVotes, 18),
        againstVotes: new Amount(againstVotes, 18),
        abstainVotes: new Amount(abstainVotes, 18),
        totalVotes: new Amount(totalVotes, 18),
        canceled,
        executed,
        quorum: new Amount(quorum, 18),
        state
      };
      return proposal;
    });
    return proposals;
  } else {
    return [];
  }
};
var getCrossChainProposalData = async (params) => {
  if (params.environment.contracts.governor) {
    const xcGovernanceSettings = params.environment.custom.governance;
    if (params.environment.contracts.multichainGovernor && xcGovernanceSettings && xcGovernanceSettings.chainIds.length > 0) {
      const xcEnvironments = xcGovernanceSettings.chainIds.map((chainId) => Object.values(publicEnvironments).find((env) => env.chainId === chainId)).filter((xcEnvironment) => !!xcEnvironment).filter((xcEnvironment) => xcEnvironment.custom?.wormhole?.chainId && xcEnvironment.contracts.voteCollector);
      const [xcCount, xcQuorum] = await Promise.all([
        params.environment.contracts.multichainGovernor.read.proposalCount(),
        params.environment.contracts.multichainGovernor.read.quorum()
      ]);
      if (params.id) {
        params.id = Number(params.id) - (params.environment.custom?.governance?.proposalIdOffset || 0);
        if (params.id < 0) {
          return [];
        } else {
          if (BigInt(params.id) > xcCount) {
            return [];
          }
        }
      }
      const xcIds = params.id ? [BigInt(params.id)] : Array.from({ length: Number(xcCount) }, (_, i) => xcCount - BigInt(i));
      const xcProposalsDataCall = Promise.all(xcIds.map((id) => params.environment.contracts.multichainGovernor?.read.proposals([id])));
      const xcProposalsStateCall = Promise.all(xcIds.map((id) => params.environment.contracts.multichainGovernor?.read.state([id])));
      const xcProposalsCollectedVotes = xcEnvironments.map((xcEnvironment) => {
        return Promise.all(xcIds.map((id) => params.environment.contracts.multichainGovernor.read.chainVoteCollectorVotes([xcEnvironment.custom.wormhole.chainId, id])));
      });
      const xcProposalsVotes = xcEnvironments.map((xcEnvironment) => {
        return Promise.all(xcIds.map((id) => xcEnvironment.contracts.voteCollector.read.proposalVotes([id])));
      });
      const [xcProposalsData, xcProposalsState, xcCollectorVotes, xcVotes] = await Promise.all([
        xcProposalsDataCall,
        xcProposalsStateCall,
        Promise.all(xcProposalsCollectedVotes),
        Promise.all(xcProposalsVotes)
      ]);
      const proposals = xcIds.map((xcId, proposalIndex) => {
        const id = Number(xcId) + (params.environment.custom?.governance?.proposalIdOffset || 0);
        const state = xcProposalsState?.[proposalIndex];
        const votesCollected = xcCollectorVotes.reduce((prevCollected, currentCollected, i) => {
          const [votesFor, votesAgainst, votesAbstain] = currentCollected[proposalIndex];
          const collected = votesFor > 0n || votesAgainst > 0n || votesAbstain > 0n;
          return i === 0 ? collected : prevCollected === false ? false : collected;
        }, false);
        const votes = xcVotes.reduce((prevVotes, currVotes) => {
          const [totalVotes2, forVotes2, againstVotes2, abstainVotes2] = currVotes[proposalIndex];
          return {
            totalVotes: prevVotes.totalVotes + totalVotes2,
            forVotes: prevVotes.forVotes + forVotes2,
            againstVotes: prevVotes.againstVotes + againstVotes2,
            abstainVotes: prevVotes.abstainVotes + abstainVotes2
          };
        }, { totalVotes: 0n, forVotes: 0n, againstVotes: 0n, abstainVotes: 0n });
        const [proposer, _voteSnapshotTimestamp, votingStartTime, votingEndTime, crossChainVoteCollectionEndTimestamp, voteSnapshotBlock, forVotes, againstVotes, abstainVotes, totalVotes, canceled, executed] = xcProposalsData?.[proposalIndex];
        const multichainState = MultichainProposalStateMapping[state];
        const proposal = {
          chainId: params.environment.chainId,
          id,
          proposalId: Number(xcId),
          proposer,
          eta: Number(crossChainVoteCollectionEndTimestamp),
          startTimestamp: Number(votingStartTime),
          endTimestamp: Number(votingEndTime),
          startBlock: Number(voteSnapshotBlock),
          forVotes: new Amount(forVotes + votes.forVotes, 18),
          againstVotes: new Amount(againstVotes + votes.againstVotes, 18),
          abstainVotes: new Amount(abstainVotes + votes.abstainVotes, 18),
          totalVotes: new Amount(totalVotes + votes.totalVotes, 18),
          canceled,
          executed,
          quorum: new Amount(xcQuorum, 18),
          state: multichainState,
          multichain: {
            id: Number(xcId),
            votesCollected
          }
        };
        return proposal;
      });
      return proposals;
    } else {
      return [];
    }
  } else {
    return [];
  }
};
var getExtendedProposalData = async (params) => {
  let result = [];
  let lastId = -1;
  let shouldContinue = true;
  while (shouldContinue) {
    const response = await axios_default.post(params.environment.governanceIndexerUrl, {
      query: `
          query {
            proposals(
              limit: 1000, 
              orderDirection: "desc", 
              orderBy: "proposalId", 
              where: { 
                chainId: ${params.environment.chainId}
                ${params.id ? `, proposalId: ${params.id}` : lastId >= 0 ? `, proposalId_lt: ${lastId}` : ""} 
              }
            ) {
              items {
                id
                proposalId
                description
                targets
                calldatas
                signatures
                stateChanges(orderBy: "blockNumber") {
                  items {
                    txnHash
                    blockNumber
                    newState
                    chainId
                  }
                }
              }
            }
          }
        `
    });
    if (response.status === 200 && response.data?.data?.proposals) {
      const proposals = response.data.data.proposals.items.map((item) => {
        const extendedProposalData = {
          id: item.proposalId,
          //temp fix while ponder is outdated
          title: `Proposal #${item.proposalId}`,
          //temp fix while ponder is outdated
          subtitle: extractProposalSubtitle(item.description),
          description: item.description,
          calldatas: item.calldatas,
          signatures: item.signatures,
          stateChanges: item.stateChanges?.items?.map((change) => {
            return {
              blockNumber: change.blockNumber,
              state: change.newState,
              transactionHash: change.txnHash,
              chainId: change.chainId
            };
          }) ?? [],
          targets: item.targets
        };
        if (extendedProposalData.subtitle.includes("Moonbeam")) {
          extendedProposalData.subtitle = extendedProposalData.subtitle.replace("MIP-B", "MIP-M");
        }
        if (extendedProposalData.subtitle.indexOf("MIP-B22: Gauntlet") >= 0) {
          extendedProposalData.subtitle = extendedProposalData.subtitle.replace("MIP-B22", "MIP-B24");
        }
        if (extendedProposalData.subtitle.indexOf("MIP-O01: Gauntlet") >= 0) {
          extendedProposalData.subtitle = extendedProposalData.subtitle.replace("MIP-O01", "MIP-O03");
        }
        if (extendedProposalData.subtitle.indexOf("MIP-M02: Upgrade") >= 0) {
          extendedProposalData.subtitle = extendedProposalData.subtitle.replace("MIP-M02", "MIP-M03");
        }
        if (extendedProposalData.subtitle.indexOf("MIP-R02: Upgrade") >= 0) {
          extendedProposalData.subtitle = extendedProposalData.subtitle.replace("MIP-R02", "MIP-R03");
        }
        if (extendedProposalData.subtitle.indexOf("Proposal: Onboard wstETH") >= 0) {
          extendedProposalData.subtitle = extendedProposalData.subtitle.replace("Proposal:", "MIP-B08");
        }
        if (extendedProposalData.subtitle.indexOf("Gauntlet's Moonriver Recommendations (2024-01-09)") >= 0) {
          extendedProposalData.subtitle = extendedProposalData.subtitle.replace("Gauntlet", "MIP-R10: Gauntlet");
        }
        if (extendedProposalData.description.substring(0, 9).includes("MIP-MIP")) {
          extendedProposalData.description = extendedProposalData.description.replace("MIP-", "");
        }
        if (extendedProposalData.subtitle.substring(0, 7).includes("MIP-MIP")) {
          extendedProposalData.subtitle = extendedProposalData.subtitle.replace("MIP-", "");
        }
        return extendedProposalData;
      });
      if (proposals.length < 1e3 || proposals.length === 0) {
        shouldContinue = false;
      } else {
        lastId = last(proposals).id;
      }
      result = result.concat(proposals);
    }
  }
  return result;
};

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/governance/proposals/getProposal.js
var { first } = import_lodash4.default;
async function getProposal(client, args) {
  const { proposalId } = args;
  const environment = getEnvironmentFromArgs(client, args);
  if (!environment) {
    return void 0;
  }
  const [_proposals, _xcProposals, _extendedDatas] = await Promise.all([
    getProposalData({ environment, id: proposalId }),
    getCrossChainProposalData({ environment, id: proposalId }),
    getExtendedProposalData({ environment, id: proposalId })
  ]);
  const proposals = [..._proposals, ..._xcProposals];
  appendProposalExtendedData(proposals, _extendedDatas);
  return first(proposals);
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/governance/proposals/getProposals.js
async function getProposals(client, args) {
  const environments = getEnvironmentsFromArgs(client, args);
  const governanceEnvironments = environments.filter((environment) => environment.chainId === moonriver.id || environment.chainId === moonbeam.id);
  const logId = start("getProposals", "Starting to get proposals...");
  const environmentProposals = await Promise.all(governanceEnvironments.filter((environment) => environment.chainId === moonriver.id || environment.chainId === moonbeam.id).map((environment) => Promise.all([
    getProposalData({ environment }),
    getCrossChainProposalData({ environment }),
    getExtendedProposalData({ environment })
  ])));
  end(logId);
  const proposals = governanceEnvironments.flatMap((_item, index) => {
    const [_proposals, _xcProposals, _extendedDatas] = environmentProposals[index];
    const proposals2 = [..._proposals, ..._xcProposals];
    appendProposalExtendedData(proposals2, _extendedDatas);
    return proposals2;
  });
  return proposals;
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/governance/snapshot/getSnapshotProposal.js
var import_lodash5 = __toESM(require_lodash(), 1);

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/governance/snapshot/common.js
var getSnapshotProposalData = async (params) => {
  const environments = params.environments;
  const snapshotApiUrl = "https://hub.snapshot.org/graphql";
  const snapshotEnsNames = environments.map((env) => env.custom?.governance?.snapshotEnsName).filter((name) => !!name);
  const pageSize = params.pagination?.size ? params.pagination.size : 10;
  const response = await axios_default.post(snapshotApiUrl, {
    query: `{
          spaces(
            where: {
              id_in: [${snapshotEnsNames.map((name) => `"${name}"`).join(",")}]
            }
          ) {
            proposalsCount,
            activeProposals
          }
          proposals(
            first: ${pageSize},
            skip: ${params.pagination?.page ? params.pagination.page * pageSize : 0},
            orderBy: "created",
            where: {
              space_in: [${snapshotEnsNames.map((name) => `"${name}"`).join(",")}]
              ${params.filters?.onlyActive ? `, state: "active"` : ""}
              ${params.filters?.id ? `, id: "${params.filters.id}"` : ""}
            },
            orderDirection: desc
          ) {
            id
            title
            discussion
            start
            end
            created
            state
            choices
            scores
            network
          }
        }`
  });
  if (response.status === 200 && response.data?.data?.proposals) {
    const summary = response.data.data.spaces.reduce((total, space) => {
      return {
        proposalsCount: total.proposalsCount + space.proposalsCount,
        activeProposals: total.activeProposals + space.activeProposals
      };
    }, { proposalsCount: 0, activeProposals: 0 });
    const result = response.data.data.proposals.map((proposal) => {
      const networkId = Number.parseInt(proposal.network);
      let chain = Object.values(supportedChains).find((c) => c.id === networkId);
      if (proposal.title.toLowerCase().includes("base")) {
        chain = base2;
      }
      if (proposal.title.toLowerCase().includes("optimism")) {
        chain = optimism;
      }
      const votes = proposal.scores.reduce((a, b) => a + b, 0);
      const scores = proposal.choices.map((choice, index) => ({
        votes: votes === 0 ? 0 : proposal.scores[index] || 0,
        percent: votes === 0 ? 0 : (proposal.scores[index] || 0) / votes * 100,
        choice
      }));
      return {
        id: proposal.id,
        created: proposal.created,
        discussion: proposal.discussion,
        network: {
          id: chain?.id,
          name: chain?.name
        },
        end: proposal.end,
        scores,
        start: proposal.start,
        state: proposal.state,
        title: proposal.title,
        votes
      };
    });
    return {
      active: summary.activeProposals,
      proposals: result,
      total: summary.proposalsCount
    };
  } else {
    return {
      active: 0,
      proposals: [],
      total: 0
    };
  }
};

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/governance/snapshot/getSnapshotProposal.js
var { first: first2 } = import_lodash5.default;
async function getSnapshotProposal(client, args) {
  const { proposalId } = args;
  const environment = getEnvironmentFromArgs(client, args);
  if (!environment) {
    return void 0;
  }
  const result = await getSnapshotProposalData({
    environments: [environment],
    filters: {
      id: proposalId
    }
  });
  return first2(result.proposals);
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/governance/snapshot/getSnapshotProposals.js
async function getSnapshotProposals(client, args) {
  const { pagination, filters } = args ?? {};
  const environments = getEnvironmentsFromArgs(client, args);
  const logId = start("getSnapshotProposals", "Starting to get snapshot proposals...");
  const proposals = await getSnapshotProposalData({
    environments,
    filters,
    pagination
  });
  end(logId);
  return proposals;
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/morpho/getMorphoUserBalances.js
async function getMorphoUserBalances(client, args) {
  const environments = getEnvironmentsFromArgs(client, args);
  const environmentsTokensBalancesSettled = await Promise.allSettled(environments.map(async (environment) => {
    const viewsRead = environment.contracts.views?.read;
    if (!viewsRead || !viewsRead?.getTokensBalances) {
      return Promise.reject(new Error("No views read contract"));
    }
    const uniqueTokenAddresses = [
      .../* @__PURE__ */ new Set([
        ...Object.values(environment.config.vaults).map((vault) => environment.config.tokens[vault.underlyingToken].address),
        ...Object.values(environment.config.vaults).map((vault) => environment.config.tokens[vault.vaultToken].address),
        ...Object.values(environment.config.morphoMarkets).map((market) => environment.config.tokens[market.collateralToken].address),
        ...Object.values(environment.config.morphoMarkets).map((market) => environment.config.tokens[market.loanToken].address)
      ])
    ];
    try {
      return await viewsRead.getTokensBalances([
        [...uniqueTokenAddresses],
        args.userAddress
      ]);
    } catch (error) {
      return Promise.reject(error);
    }
  }));
  const environmentsTokensBalances = environmentsTokensBalancesSettled.map((s) => s.status === "fulfilled" ? [...s.value] : []);
  const tokensBalances = environments.flatMap((curr, index) => {
    const balances = environmentsTokensBalances[index];
    if (!balances) {
      return [];
    }
    const userBalances = balances.map((balance) => {
      const token = findTokenByAddress(curr, balance.token);
      if (token) {
        const result = {
          chainId: curr.chainId,
          account: args.userAddress,
          token,
          tokenBalance: new Amount(balance.amount, token.decimals)
        };
        return result;
      } else {
        return;
      }
    }).filter((item) => item !== void 0);
    return userBalances;
  });
  return tokensBalances;
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/morpho/markets/getMorphoMarket.js
var import_lodash6 = __toESM(require_lodash(), 1);

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/morpho/utils/graphql.js
async function getGraphQL(query, operationName, variables) {
  try {
    const response = await fetch("https://blue-api.morpho.org/graphql", {
      method: "POST",
      headers: MOONWELL_FETCH_JSON_HEADERS,
      body: JSON.stringify({ query, operationName, variables }),
      signal: AbortSignal.timeout(1e4)
    });
    const json = await response.json();
    if (response.status !== 200 || json.errors) {
      console.log(`Non-200 (${response.statusText}
        }) or other error from Morpho GraphQL! - ${JSON.stringify(response.statusText)}`);
      return void 0;
    }
    return json.data;
  } catch (error) {
    return void 0;
  }
}
async function getSubgraph(environment, query, operationName, variables) {
  const url = environment.custom.morpho?.subgraphUrl;
  const body = { query };
  if (operationName) {
    body.operationName = operationName;
  }
  if (variables) {
    body.variables = variables;
  }
  try {
    const response = await fetch(url, {
      method: "POST",
      headers: MOONWELL_FETCH_JSON_HEADERS,
      body: JSON.stringify(body),
      signal: AbortSignal.timeout(1e4)
    });
    const json = await response.json();
    if (response.status !== 200 || json.errors) {
      console.log(response);
      console.log(`Non-200 (${response.statusText}
        }) or other error from Morpho GraphQL! - ${JSON.stringify(response.statusText)}`);
      return void 0;
    }
    return json.data;
  } catch (error) {
    return void 0;
  }
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/morpho/markets/common.js
async function getMorphoMarketsData(params) {
  const { environments } = params;
  const environmentsWithMarkets = environments.filter((environment) => Object.keys(environment.config.morphoMarkets).length > 0 && environment.contracts.morphoViews);
  const marketInfoSettlements = await Promise.allSettled(environmentsWithMarkets.map((environment) => {
    const marketsIds = Object.values(environment.config.morphoMarkets).map((item) => item.id).filter((id) => params.markets ? params.markets.map((id2) => id2.toLowerCase()).includes(id.toLowerCase()) : true);
    try {
      return environment.contracts.morphoViews.read.getMorphoBlueMarketsInfo([marketsIds]);
    } catch (error) {
      return Promise.reject(error);
    }
  }));
  const fulfilledMarketsInfo = marketInfoSettlements.flatMap((s, i) => s.status === "fulfilled" ? [{ environment: environmentsWithMarkets[i], marketsInfo: s.value }] : []);
  const environmentPublicAllocatorSharedLiquiditySettlements = await Promise.allSettled(environmentsWithMarkets.map((environment) => {
    const marketsIds = Object.values(environment.config.morphoMarkets).map((item) => item.id).filter((id) => params.markets ? params.markets.map((id2) => id2.toLowerCase()).includes(id.toLowerCase()) : true);
    return getMorphoMarketPublicAllocatorSharedLiquidity(environment, marketsIds);
  }));
  const fulfilledPublicAllocatorSharedLiquidity = environmentPublicAllocatorSharedLiquiditySettlements.flatMap((s, i) => s.status === "fulfilled" ? [
    {
      environment: environmentsWithMarkets[i],
      sharedLiquidity: s.value
    }
  ] : []);
  const sharedLiquidityByChain = new Map(fulfilledPublicAllocatorSharedLiquidity.map((x) => [
    x.environment.chainId,
    x.sharedLiquidity
  ]));
  const result = fulfilledMarketsInfo.reduce((aggregator, { environment, marketsInfo }) => {
    const markets5 = marketsInfo.map((marketInfo) => {
      const marketKey = Object.keys(environment.config.morphoMarkets).find((item) => environment.config.morphoMarkets[item].id.toLowerCase() === marketInfo.marketId.toLowerCase());
      const marketConfig = Object.values(environment.config.morphoMarkets).find((item) => item.id.toLowerCase() === marketInfo.marketId.toLowerCase());
      const loanToken = environment.config.tokens[marketConfig.loanToken];
      const collateralToken = environment.config.tokens[marketConfig.collateralToken];
      const oraclePrice = new Amount(BigInt(marketInfo.oraclePrice), 36 + loanToken.decimals - collateralToken.decimals).value;
      let collateralTokenPrice = new Amount(marketInfo.collateralPrice, 18).value;
      let loanTokenPrice = new Amount(marketInfo.loanPrice, 18).value;
      if (collateralTokenPrice === 0 && loanTokenPrice > 0) {
        collateralTokenPrice = loanTokenPrice * oraclePrice;
      }
      if (loanTokenPrice === 0 && collateralTokenPrice > 0) {
        loanTokenPrice = collateralTokenPrice / oraclePrice;
      }
      if (collateralToken.symbol === "stkWELL") {
        const wellMarketInfo = marketsInfo.find((mi) => {
          const wellMarketConfig = Object.values(environment.config.morphoMarkets).find((item) => item.id.toLowerCase() === mi.marketId.toLowerCase() && (item.collateralToken === "WELL" || item.loanToken === "WELL"));
          return wellMarketConfig !== void 0;
        });
        if (wellMarketInfo) {
          const wellMarketConfig = Object.values(environment.config.morphoMarkets).find((item) => item.id.toLowerCase() === wellMarketInfo.marketId.toLowerCase());
          let wellPrice = 0;
          if (wellMarketConfig && wellMarketConfig.collateralToken === "WELL") {
            wellPrice = new Amount(wellMarketInfo.collateralPrice, 18).value;
            if (wellPrice === 0) {
              const wellLoanToken = environment.config.tokens[wellMarketConfig.loanToken];
              const wellLoanPrice = new Amount(wellMarketInfo.loanPrice, 18).value;
              const wellOraclePrice = new Amount(BigInt(wellMarketInfo.oraclePrice), 36 + wellLoanToken.decimals - 18).value;
              wellPrice = wellLoanPrice * wellOraclePrice;
            }
          } else if (wellMarketConfig && wellMarketConfig.loanToken === "WELL") {
            wellPrice = new Amount(wellMarketInfo.loanPrice, 18).value;
            if (wellPrice === 0) {
              const wellCollateralToken = environment.config.tokens[wellMarketConfig.collateralToken];
              const wellCollateralPrice = new Amount(wellMarketInfo.collateralPrice, 18).value;
              const wellOraclePrice = new Amount(BigInt(wellMarketInfo.oraclePrice), 36 + 18 - wellCollateralToken.decimals).value;
              wellPrice = wellCollateralPrice / wellOraclePrice;
            }
          }
          if (wellPrice > 0) {
            collateralTokenPrice = wellPrice;
          }
        }
      }
      const envSharedLiquidity = sharedLiquidityByChain.get(environment.chainId);
      const publicAllocatorSharedLiquidity = envSharedLiquidity?.find((item) => item.marketId === marketInfo.marketId);
      const performanceFee = new Amount(marketInfo.fee, 18).value;
      const loanToValue = new Amount(marketInfo.lltv, 18).value;
      const totalSupplyInLoanToken = new Amount(BigInt(marketInfo.totalSupplyAssets), loanToken.decimals);
      const totalSupply = new Amount(Number(totalSupplyInLoanToken.value / oraclePrice), collateralToken.decimals);
      const totalBorrows = new Amount(marketInfo.totalBorrowAssets, loanToken.decimals);
      const borrowApy = new Amount(marketInfo.borrowApy, 18).value * 100;
      const availableLiquidity = publicAllocatorSharedLiquidity?.reallocatableLiquidityAssets || new Amount(0, 18);
      const availableLiquidityUsd = availableLiquidity?.value * loanTokenPrice;
      const collateralAssets = publicAllocatorSharedLiquidity?.collateralAssets || new Amount(0, 18);
      const mapping = {
        chainId: environment.chainId,
        marketId: marketInfo.marketId,
        marketKey,
        deprecated: marketConfig.deprecated === true,
        loanToValue,
        performanceFee,
        loanToken,
        loanTokenPrice,
        collateralToken,
        collateralTokenPrice,
        collateralAssets,
        totalSupply,
        totalSupplyUsd: totalSupply.value * collateralTokenPrice,
        totalSupplyInLoanToken,
        totalBorrows,
        totalBorrowsUsd: totalBorrows.value * loanTokenPrice,
        baseBorrowApy: borrowApy,
        totalBorrowApr: borrowApy,
        baseSupplyApy: 0,
        //supplyApy,
        totalSupplyApr: 0,
        //supplyApy,
        rewardsSupplyApy: 0,
        rewardsBorrowApy: 0,
        availableLiquidity,
        availableLiquidityUsd,
        marketParams: {
          loanToken: marketInfo.loanToken,
          collateralToken: marketInfo.collateralToken,
          irm: marketInfo.irm,
          lltv: marketInfo.lltv,
          oracle: marketInfo.oracle
        },
        rewards: [],
        publicAllocatorSharedLiquidity: publicAllocatorSharedLiquidity?.publicAllocatorSharedLiquidity || []
      };
      return mapping;
    });
    return {
      ...aggregator,
      [environment.chainId]: markets5
    };
  }, {});
  if (params.includeRewards) {
    const markets5 = Object.values(result).flat().filter((market) => {
      const environment = params.environments.find((environment2) => environment2.chainId === market.chainId);
      return environment?.custom.morpho?.minimalDeployment === false;
    });
    const rewards = await getMorphoMarketRewards(markets5);
    markets5.forEach((market) => {
      const marketReward = rewards.find((reward) => reward.marketId === market.marketId && reward.chainId === market.chainId);
      if (marketReward) {
        market.rewards = marketReward.rewards;
      }
      market.rewardsSupplyApy = market.rewards.reduce((acc, curr) => acc + curr.supplyApr, 0);
      market.rewardsBorrowApy = market.rewards.reduce((acc, curr) => acc + curr.borrowApr, 0);
      market.totalSupplyApr = market.rewardsSupplyApy + market.baseSupplyApy;
      market.totalBorrowApr = market.rewardsBorrowApy + market.baseBorrowApy;
    });
  }
  return environments.flatMap((environment) => {
    return result[environment.chainId] || [];
  });
}
async function getMorphoMarketPublicAllocatorSharedLiquidity(environment, markets5) {
  if (markets5.length === 0) {
    return [];
  }
  const query = `
  {
    metaMorphos(
      where: {hasPublicAllocator: true, markets_: {market_in: [${markets5.map((market) => `"${market.toLowerCase()}"`).join(",")}]}}
    ) {
      id
      name
      lastTotalAssets
      markets {
        market {
          id
        }
        enabled
        cap
      }
      publicAllocator {
        id
        fee
        markets {
          id
          flowCapIn
          flowCapOut
          market {
            market {
              id
              oracle {
                oracleAddress
              }
              irm
              lltv
              totalBorrow
              totalSupply
              totalCollateral
              inputToken {
                symbol
                decimals
                id
              }
              borrowedToken {
                symbol
                decimals
                id
              }
            }
          }
        }
      }    
      account {
        positions(where:{side:SUPPLIER}) {
          market {
            id
          }
          balance
        }
      }
    }
  }
  `;
  const result = await getSubgraph(environment, query);
  if (result) {
    const returnValue = [];
    for (const market of markets5) {
      let inputTokenDecimals = 0;
      let outputTokenDecimals = 0;
      let collateralAssets = 0;
      let reallocatableLiquidityAssets = 0;
      const r = [];
      const marketRemainingLiquidity = {};
      const vaults3 = result.metaMorphos.filter((item) => item.publicAllocator.markets.some((vaultMarket) => vaultMarket.market.market.id.toLowerCase() === market.toLowerCase()) && item.account.positions.some((position) => position.market.id.toLowerCase() === market.toLowerCase() && Number(position.balance) > 0));
      for (const vault of vaults3) {
        const otherMarkets = vault.publicAllocator.markets.filter((publicAllocatorMarket) => publicAllocatorMarket.market.market.id.toLowerCase() !== market.toLowerCase());
        const thisMarket = vault.publicAllocator.markets.find((publicAllocatorMarket) => publicAllocatorMarket.market.market.id.toLowerCase() === market.toLowerCase());
        const thisMarketCaps = vault.markets.find((marketCaps) => marketCaps.market.id.toLowerCase() === market.toLowerCase());
        const thisMarketCap = Number(thisMarketCaps?.cap || 0);
        const suppliedToMarket = vault.account.positions.find((position) => position.market.id.toLowerCase() === market.toLowerCase());
        const suppliedToMarketAmount = Number(suppliedToMarket?.balance || 0);
        const thisMarketCapRemaining = thisMarketCap - suppliedToMarketAmount;
        let maxIn = Math.min(Number(thisMarket?.flowCapIn), thisMarketCapRemaining);
        collateralAssets = Number(thisMarket?.market.market.totalCollateral || 0);
        inputTokenDecimals = thisMarket?.market.market.inputToken.decimals || 0;
        outputTokenDecimals = thisMarket?.market.market.borrowedToken.decimals || 0;
        const otherMarketsLiquidity = [];
        for (const otherMarket of otherMarkets) {
          const vaultSuppliedToMarket = vault.account.positions.find((position) => position.market.id.toLowerCase() === otherMarket.market.market.id.toLowerCase());
          if (vaultSuppliedToMarket) {
            const vaultSuppliedAmount = Number(vaultSuppliedToMarket.balance);
            const maxOut = Number(otherMarket.flowCapOut);
            const liquidity = Number(otherMarket.market.market.totalSupply) - Number(otherMarket.market.market.totalBorrow);
            if (vaultSuppliedAmount > 0 && maxOut > 0 && liquidity > 0) {
              otherMarketsLiquidity.push({
                marketId: otherMarket.market.market.id,
                amount: Math.min(liquidity, vaultSuppliedAmount, maxOut),
                liquidity,
                vault: {
                  address: vault.id,
                  name: vault.name,
                  publicAllocatorConfig: {
                    fee: Number(vault.publicAllocator.fee),
                    flowCaps: vault.publicAllocator.markets.map((publicAllocatorMarket) => ({
                      maxIn: Number(publicAllocatorMarket.flowCapIn),
                      maxOut: Number(publicAllocatorMarket.flowCapOut),
                      market: {
                        uniqueKey: publicAllocatorMarket.market.market.id
                      }
                    }))
                  }
                },
                allocationMarket: {
                  uniqueKey: otherMarket.market.market.id,
                  loanAsset: {
                    address: otherMarket.market.market.borrowedToken.id
                  },
                  collateralAsset: {
                    address: otherMarket.market.market.inputToken.id
                  },
                  oracleAddress: otherMarket.market.market.oracle.oracleAddress,
                  irmAddress: otherMarket.market.market.irm,
                  lltv: otherMarket.market.market.lltv
                }
              });
            }
          }
        }
        for (const otherMarket of otherMarketsLiquidity.filter((item) => item.amount > 0).sort((a, b) => b.amount - a.amount)) {
          const marketLiquidity = marketRemainingLiquidity[otherMarket.marketId] || otherMarket.liquidity;
          if (maxIn > 0 && marketLiquidity > 0) {
            const assets = Math.min(marketLiquidity, otherMarket.amount, maxIn);
            maxIn = maxIn - assets;
            marketRemainingLiquidity[otherMarket.marketId] = marketLiquidity - assets;
            reallocatableLiquidityAssets += assets;
            r.push({
              assets,
              vault: otherMarket.vault,
              allocationMarket: otherMarket.allocationMarket
            });
          }
        }
      }
      returnValue.push({
        chainId: environment.chainId,
        marketId: market.toLowerCase(),
        collateralAssets: new Amount(BigInt(collateralAssets), inputTokenDecimals),
        reallocatableLiquidityAssets: new Amount(BigInt(reallocatableLiquidityAssets), outputTokenDecimals),
        publicAllocatorSharedLiquidity: r
      });
    }
    return returnValue;
  } else {
    return [];
  }
}
async function getMorphoMarketRewards(markets5) {
  if (markets5.length === 0) {
    return [];
  }
  const query = `
  {
    markets(where: { uniqueKey_in: [${markets5.map((market) => `"${market.marketId.toLowerCase()}"`).join(",")}], chainId_in: [${markets5.map((market) => market.chainId).join(",")}] }) 
    {
      items {
        morphoBlue {
          chain {
            id
          }
        }
        reallocatableLiquidityAssets
        publicAllocatorSharedLiquidity {
          assets
          vault {
            address
            name
            publicAllocatorConfig {
              fee
              flowCaps {
                maxIn
                maxOut
                market {
                  uniqueKey
                }
              }
            }
          }
          allocationMarket {
            uniqueKey
            loanAsset {
              address
            }
            collateralAsset {
              address
            }
            oracleAddress
            irmAddress
            lltv
          }
        }
        collateralAsset {
          decimals
        }
        loanAsset {
          decimals
          priceUsd
        }
        state {
          collateralAssets
          rewards {
            asset {
              address
              symbol
              decimals
              name
            }
            supplyApr
            borrowApr
            amountPerBorrowedToken
            amountPerSuppliedToken
          }
        }
        uniqueKey
      }
    }
  } `;
  const result = await getGraphQL(query);
  if (result) {
    const markets6 = result.markets.items.map((item) => {
      const mapping = {
        chainId: item.morphoBlue.chain.id,
        marketId: item.uniqueKey,
        reallocatableLiquidityAssets: new Amount(BigInt(item.reallocatableLiquidityAssets), item.loanAsset.decimals),
        collateralAssets: new Amount(BigInt(item.state.collateralAssets), item.collateralAsset.decimals),
        publicAllocatorSharedLiquidity: item.publicAllocatorSharedLiquidity.map((item2) => ({
          assets: Number(item2.assets),
          vault: {
            address: item2.vault.address,
            name: item2.vault.name,
            publicAllocatorConfig: item2.vault.publicAllocatorConfig
          },
          allocationMarket: item2.allocationMarket
        })),
        rewards: item.state?.rewards.map((reward) => {
          const tokenDecimals = 10 ** reward.asset.decimals;
          const borrowTokenAmountPer1000 = Number.parseFloat(reward.amountPerBorrowedToken) / item.loanAsset.priceUsd * 1e3;
          const borrowAmount = borrowTokenAmountPer1000 / tokenDecimals;
          return {
            marketId: item.uniqueKey,
            asset: reward.asset,
            supplyApr: 0,
            //(reward.supplyApr || 0) * 100,
            supplyAmount: 0,
            //amount,
            borrowApr: (reward.borrowApr || 0) * 100 * -1,
            borrowAmount
          };
        })
      };
      return mapping;
    });
    return markets6;
  } else {
    return [];
  }
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/morpho/markets/getMorphoMarket.js
var { first: first3 } = import_lodash6.default;
async function getMorphoMarket(client, args) {
  const environment = getEnvironmentFromArgs(client, args);
  if (!environment) {
    return void 0;
  }
  let { marketId, market } = args;
  if (!marketId) {
    marketId = environment.config.morphoMarkets[market].id;
  }
  const markets5 = await getMorphoMarketsData({
    environments: [environment],
    markets: [marketId],
    includeRewards: args.includeRewards
  });
  return first3(markets5);
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/morpho/markets/getMorphoMarkets.js
async function getMorphoMarkets(client, args) {
  const environments = getEnvironmentsFromArgs(client, args);
  const logId = start("getMorphoMarkets", "Starting to get morpho markets...");
  const result = await getMorphoMarketsData({
    environments,
    includeRewards: args?.includeRewards
  });
  end(logId);
  return result;
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/morpho/user-positions/getMorphoMarketUserPosition.js
var import_lodash7 = __toESM(require_lodash(), 1);

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/morpho/user-positions/common.js
async function getMorphoVaultUserPositionsData(params) {
  const vaults3 = Object.values(params.environment.vaults).filter((vault) => params.vaults ? params.vaults.includes(vault.address) : true);
  const userVaultsShares = await Promise.all(vaults3.map((vaultContract) => vaultContract.read.balanceOf([params.account])));
  const userVaultBalances = await Promise.all(vaults3.map((vaultContract, index) => vaultContract.read.convertToAssets([userVaultsShares[index]])));
  return vaults3.map((vaultContract, index) => {
    const shares = userVaultsShares[index];
    const balance = userVaultBalances[index];
    const vaultToken = findTokenByAddress(params.environment, vaultContract.address);
    const vaultConfig = Object.values(params.environment.config.vaults).find((vault) => vault.vaultToken === vaultToken.symbol);
    const underlyingToken = params.environment.config.tokens[vaultConfig.underlyingToken];
    const result = {
      chainId: params.environment.chainId,
      account: params.account,
      vaultToken,
      underlyingToken,
      supplied: new Amount(balance, underlyingToken.decimals),
      suppliedShares: new Amount(shares, vaultToken.decimals)
    };
    return result;
  });
}
async function getMorphoMarketUserPositionsData(params) {
  const markets5 = Object.values(params.environment.config.morphoMarkets).filter((market) => params.markets ? params.markets.includes(market.id) : true);
  try {
    const userMarketPositions = await params.environment.contracts.morphoViews.read.getMorphoBlueUserBalances([markets5.map((market) => market.id), params.account]);
    return markets5.map((market, index) => {
      const position = userMarketPositions[index];
      const loanToken = params.environment.config.tokens[market.loanToken];
      const collateralToken = params.environment.config.tokens[market.collateralToken];
      const supplied = new Amount(position.collateralAssets, collateralToken.decimals);
      const borrowed = new Amount(position.loanAssets, loanToken.decimals);
      const borrowedShares = new Amount(position.loanShares, loanToken.decimals + 6);
      const result = {
        chainId: params.environment.chainId,
        account: params.account,
        marketId: market.id,
        loanToken,
        collateralToken,
        supplied,
        borrowed,
        borrowedShares
      };
      return result;
    });
  } catch (error) {
    return [];
  }
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/morpho/user-positions/getMorphoMarketUserPosition.js
var { first: first4 } = import_lodash7.default;
async function getMorphoMarketUserPosition(client, args) {
  const environment = getEnvironmentFromArgs(client, args);
  if (!environment) {
    return void 0;
  }
  let { marketId, market } = args;
  if (!marketId) {
    marketId = environment.config.morphoMarkets[market].id;
  }
  const userPositions = await getMorphoMarketUserPositionsData({
    environment,
    account: args.userAddress,
    markets: [marketId]
  });
  return first4(userPositions);
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/morpho/user-positions/getMorphoMarketUserPositions.js
async function getMorphoMarketUserPositions(client, args) {
  const environments = getEnvironmentsFromArgs(client, args);
  const settled = await Promise.allSettled(environments.filter((environment) => environment.contracts.morphoViews !== void 0).map((environment) => {
    return getMorphoMarketUserPositionsData({
      environment,
      account: args.userAddress
    });
  }));
  const result = settled.flatMap((s) => s.status === "fulfilled" ? s.value : []);
  return result;
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/morpho/user-positions/getMorphoVaultUserPosition.js
var import_lodash8 = __toESM(require_lodash(), 1);
var { first: first5 } = import_lodash8.default;
async function getMorphoVaultUserPosition(client, args) {
  const environment = getEnvironmentFromArgs(client, args);
  if (!environment) {
    return void 0;
  }
  let { vaultAddress, vault } = args;
  if (!vaultAddress) {
    vaultAddress = environment.vaults[vault].address;
  }
  const userPositions = await getMorphoVaultUserPositionsData({
    environment,
    account: args.userAddress,
    vaults: [vaultAddress]
  });
  return first5(userPositions);
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/morpho/user-positions/getMorphoVaultUserPositions.js
async function getMorphoVaultUserPositions(client, args) {
  const environments = getEnvironmentsFromArgs(client, args);
  const settled = await Promise.allSettled(environments.filter((environment) => environment.contracts.morphoViews !== void 0).map((environment) => {
    return getMorphoVaultUserPositionsData({
      environment,
      account: args.userAddress
    });
  }));
  const result = settled.flatMap((s) => s.status === "fulfilled" ? s.value : []);
  return result;
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/morpho/user-rewards/common.js
var import_lodash9 = __toESM(require_lodash(), 1);
var { uniq } = import_lodash9.default;
async function getUserMorphoRewardsData(params) {
  const merklRewards = await getMerklRewardsData2(params.environment, params.account);
  if (params.environment.custom.morpho?.minimalDeployment === false) {
    const morphoRewards = await getMorphoRewardsData(params.environment.chainId, params.account);
    const morphoAssets = await getMorphoAssetsData(morphoRewards.map((r) => r.asset.address));
    const morphoResult = morphoRewards.map((r) => {
      const asset = morphoAssets.find((a) => a.address.toLowerCase() === r.asset.address.toLowerCase());
      if (!asset) {
        return void 0;
      }
      const rewardToken = {
        address: asset.address,
        decimals: asset.decimals,
        symbol: asset.symbol,
        name: asset.name
      };
      switch (r.type) {
        case "uniform-reward": {
          const claimableNow = new Amount(BigInt(r.amount?.claimable_now || 0), rewardToken.decimals);
          const claimableNowUsd = claimableNow.value * (asset.priceUsd || 0);
          const claimableFuture = new Amount(BigInt(r.amount?.claimable_next || 0), rewardToken.decimals);
          const claimableFutureUsd = claimableFuture.value * (asset.priceUsd || 0);
          const uniformReward = {
            type: "uniform-reward",
            chainId: r.asset.chain_id,
            account: r.user,
            rewardToken,
            claimableNow,
            claimableNowUsd,
            claimableFuture,
            claimableFutureUsd
          };
          return uniformReward;
        }
        case "market-reward": {
          const claimableNow = new Amount(BigInt(r.for_supply?.claimable_now || 0), rewardToken.decimals);
          const claimableNowUsd = claimableNow.value * (asset.priceUsd || 0);
          const claimableFuture = new Amount(BigInt(r.for_supply?.claimable_next || 0), rewardToken.decimals);
          const claimableFutureUsd = claimableFuture.value * (asset.priceUsd || 0);
          const collateralClaimableNow = new Amount(BigInt(r.for_collateral?.claimable_now || 0), rewardToken.decimals);
          const collateralClaimableNowUsd = collateralClaimableNow.value * (asset.priceUsd || 0);
          const collateralClaimableFuture = new Amount(BigInt(r.for_collateral?.claimable_next || 0), rewardToken.decimals);
          const collateralClaimableFutureUsd = collateralClaimableFuture.value * (asset.priceUsd || 0);
          const borrowClaimableNow = new Amount(BigInt(r.for_borrow?.claimable_now || 0), rewardToken.decimals);
          const borrowClaimableNowUsd = borrowClaimableNow.value * (asset.priceUsd || 0);
          const borrowClaimableFuture = new Amount(BigInt(r.for_borrow?.claimable_next || 0), rewardToken.decimals);
          const borrowClaimableFutureUsd = borrowClaimableFuture.value * (asset.priceUsd || 0);
          if (r.reallocated_from) {
            const vaultReward = {
              type: "vault-reward",
              chainId: r.program.chain_id,
              account: r.user,
              vaultId: r.reallocated_from,
              rewardToken,
              claimableNow,
              claimableNowUsd,
              claimableFuture,
              claimableFutureUsd
            };
            return vaultReward;
          } else {
            const marketReward = {
              type: "market-reward",
              chainId: r.program.chain_id,
              account: r.user,
              marketId: r.program.market_id || "",
              rewardToken,
              collateralRewards: {
                claimableNow: collateralClaimableNow,
                claimableNowUsd: collateralClaimableNowUsd,
                claimableFuture: collateralClaimableFuture,
                claimableFutureUsd: collateralClaimableFutureUsd
              },
              borrowRewards: {
                claimableNow: borrowClaimableNow,
                claimableNowUsd: borrowClaimableNowUsd,
                claimableFuture: borrowClaimableFuture,
                claimableFutureUsd: borrowClaimableFutureUsd
              }
            };
            return marketReward;
          }
        }
        case "vault-reward": {
          const claimableNow = new Amount(BigInt(r.for_supply?.claimable_now || 0), rewardToken.decimals);
          const claimableNowUsd = claimableNow.value * (asset.priceUsd || 0);
          const claimableFuture = new Amount(BigInt(r.for_supply?.claimable_next || 0), rewardToken.decimals);
          const claimableFutureUsd = claimableFuture.value * (asset.priceUsd || 0);
          const vaultReward = {
            type: "vault-reward",
            chainId: r.program.chain_id,
            account: r.user,
            vaultId: r.program.vault,
            rewardToken,
            claimableNow,
            claimableNowUsd,
            claimableFuture,
            claimableFutureUsd
          };
          return vaultReward;
        }
      }
    });
    const merklResult2 = [];
    for (const chainData of merklRewards) {
      for (const reward of chainData.rewards) {
        const morphoAsset = morphoAssets.find((a) => a.address.toLowerCase() === reward.token.address.toLowerCase());
        const rewardToken = {
          address: reward.token.address,
          decimals: morphoAsset?.decimals ?? reward.token.decimals,
          symbol: morphoAsset?.symbol ?? reward.token.symbol,
          name: morphoAsset?.name ?? reward.token.symbol
        };
        const getVaultRewardAmount = (breakdowns, field) => {
          return breakdowns.reduce((acc, curr) => {
            const isVaultCampaign = Object.values(publicEnvironments).some((environment) => {
              if (environment.config.vaults && Object.keys(environment.config.vaults).length > 0) {
                return Object.values(environment.config.vaults).some((vault) => vault.campaignId === curr.campaignId);
              }
              return false;
            });
            return isVaultCampaign ? acc + BigInt(curr[field]) : acc;
          }, 0n);
        };
        const amount = getVaultRewardAmount(reward.breakdowns, "amount");
        const claimed = getVaultRewardAmount(reward.breakdowns, "claimed");
        const pending = getVaultRewardAmount(reward.breakdowns, "pending");
        const claimableNow = new Amount(amount - claimed, rewardToken.decimals);
        const claimableNowUsd = claimableNow.value * (morphoAsset?.priceUsd ?? reward.token.price ?? 0);
        const claimableFuture = new Amount(pending, rewardToken.decimals);
        const claimableFutureUsd = claimableFuture.value * (morphoAsset?.priceUsd ?? reward.token.price ?? 0);
        const merklReward = {
          type: "merkl-reward",
          chainId: chainData.chain.id,
          account: params.account,
          rewardToken,
          claimableNow,
          claimableNowUsd,
          claimableFuture,
          claimableFutureUsd
        };
        merklResult2.push(merklReward);
      }
    }
    const allResults = [
      ...morphoResult.filter((r) => r !== void 0),
      ...merklResult2
    ];
    return allResults;
  }
  const merklResult = [];
  for (const chainData of merklRewards) {
    for (const reward of chainData.rewards) {
      const rewardToken = {
        address: reward.token.address,
        decimals: reward.token.decimals,
        symbol: reward.token.symbol,
        name: reward.token.symbol
      };
      const claimableNow = new Amount(BigInt(reward.amount) - BigInt(reward.claimed), rewardToken.decimals);
      const claimableNowUsd = claimableNow.value * (reward.token.price ?? 0);
      const claimableFuture = new Amount(BigInt(reward.pending), rewardToken.decimals);
      const claimableFutureUsd = claimableFuture.value * (reward.token.price ?? 0);
      const merklReward = {
        type: "merkl-reward",
        chainId: chainData.chain.id,
        account: params.account,
        rewardToken,
        claimableNow,
        claimableNowUsd,
        claimableFuture,
        claimableFutureUsd
      };
      merklResult.push(merklReward);
    }
  }
  return merklResult;
}
async function getUserMorphoStakingRewardsData(params) {
  const vaultsWithStaking = Object.values(params.environment.config.vaults).filter((vault) => Boolean(vault.multiReward));
  if (!vaultsWithStaking.length) {
    return [];
  }
  const rewards = await Promise.all(vaultsWithStaking.map(async (vault) => {
    if (!vault.multiReward)
      return [];
    const vaultRewards = await getRewardsEarnedData(params.environment, params.account, vault.multiReward);
    const homeEnvironment = Object.values(publicEnvironments).find((e) => e.custom?.governance?.chainIds?.includes(params.environment.chainId)) || params.environment;
    const viewsContract = params.environment.contracts.views;
    const homeViewsContract = homeEnvironment.contracts.views;
    const userData = await Promise.all([
      viewsContract?.read.getAllMarketsInfo(),
      homeViewsContract?.read.getNativeTokenPrice(),
      homeViewsContract?.read.getGovernanceTokenPrice()
    ]);
    const [allMarkets, nativeTokenPriceRaw, governanceTokenPriceRaw] = userData;
    const governanceTokenPrice = new Amount(governanceTokenPriceRaw || 0n, 18);
    const nativeTokenPrice = new Amount(nativeTokenPriceRaw || 0n, 18);
    let tokenPrices = allMarkets?.map((marketInfo) => {
      const marketFound = findMarketByAddress(params.environment, marketInfo.market);
      if (marketFound) {
        return {
          token: marketFound.underlyingToken,
          tokenPrice: new Amount(marketInfo.underlyingPrice, 36 - marketFound.underlyingToken.decimals)
        };
      } else {
        return;
      }
    }).filter((token) => !!token) || [];
    if (params.environment.custom?.governance?.token) {
      tokenPrices = [
        ...tokenPrices,
        {
          token: params.environment.config.tokens[params.environment.custom.governance.token],
          tokenPrice: governanceTokenPrice
        }
      ];
    }
    tokenPrices = [
      ...tokenPrices,
      {
        token: findTokenByAddress(params.environment, zeroAddress),
        tokenPrice: nativeTokenPrice
      }
    ];
    return vaultRewards.filter((reward) => {
      return reward !== void 0 && reward.amount.value > 0;
    }).map((reward) => {
      const market = tokenPrices.find((m) => m?.token.address === reward.token.address);
      const priceUsd = market?.tokenPrice.value ?? 0;
      return {
        ...reward,
        chainId: params.environment.chainId,
        amountUsd: reward.amount.value * priceUsd
      };
    });
  }));
  return rewards.flat();
}
var getRewardsEarnedData = async (environment, userAddress, multiRewardsAddress) => {
  if (!environment.custom.multiRewarder) {
    return [];
  }
  const multiRewardAbi = parseAbi([
    "function earned(address account, address token) view returns (uint256)"
  ]);
  const multiRewardContract = getContract({
    address: multiRewardsAddress,
    abi: multiRewardAbi,
    client: environment.publicClient
  });
  const rewards = await Promise.all(environment.custom.multiRewarder.map(async (multiRewarder) => {
    const token = environment.config.tokens[multiRewarder.rewardToken];
    if (!token) {
      return;
    }
    try {
      const earned = await multiRewardContract.read.earned([
        userAddress,
        token.address
      ]);
      return { amount: new Amount(BigInt(earned), token.decimals), token };
    } catch {
      return { amount: new Amount(0n, token.decimals), token };
    }
  }));
  return rewards.filter(Boolean);
};
async function getMorphoRewardsData(chainId, account) {
  const rewardsRequest = await fetch(`https://rewards.morpho.org/v1/users/${account}/rewards?chain_id=${chainId}&trusted=true&exclude_merkl_programs=true`, {
    headers: MOONWELL_FETCH_JSON_HEADERS
  });
  const rewards = await rewardsRequest.json();
  return rewards.data || [];
}
async function getMorphoAssetsData(addresses) {
  const rewardsRequest = await getGraphQL(`
    query {
      assets(where: { address_in:[${uniq(addresses).map((a) => `"${a.toLowerCase()}"`).join(",")}]}) {
        items {
          address     
          symbol
          priceUsd
          name
          decimals
        }
      }
    }
  `);
  if (rewardsRequest) {
    return rewardsRequest.assets.items;
  }
  return [];
}
async function getMerklRewardsData2(environment, account) {
  try {
    const chainIdsPromises = Object.values(environment.config.vaults).map(async (vault) => {
      try {
        const response = await fetch(`https://api.merkl.xyz/v4/opportunities?identifier=${environment.config.tokens[vault.vaultToken]?.address}&chainId=${environment.chainId}&status=LIVE`, {
          headers: MOONWELL_FETCH_JSON_HEADERS
        });
        if (!response.ok) {
          console.warn(`Failed to fetch opportunities: ${response.status} ${response.statusText}`);
          return [];
        }
        const data = await response.json();
        return data.flatMap((opportunity) => opportunity.rewardsRecord.breakdowns.map((breakdown) => breakdown.token.chainId));
      } catch (error) {
        console.warn(`Error fetching opportunities for vault ${vault.vaultToken}:`, error);
        return [];
      }
    });
    const chainIds = [...new Set((await Promise.all(chainIdsPromises)).flat())];
    const rewardsPromises = chainIds.map(async (chainId) => {
      try {
        const response = await fetch(`https://api.merkl.xyz/v4/users/${account}/rewards?chainId=${chainId}&test=false&breakdownPage=0&reloadChainId=${chainId}`, {
          headers: MOONWELL_FETCH_JSON_HEADERS
        });
        if (!response.ok) {
          console.warn(`Merkl API request failed: ${response.status} ${response.statusText}`);
          return [];
        }
        return await response.json();
      } catch (error) {
        console.warn(`Error fetching Merkl rewards for chain ${chainId}:`, error);
        return [];
      }
    });
    const allRewards = await Promise.all(rewardsPromises);
    return allRewards.flat();
  } catch (error) {
    console.error("Error in getMerklRewardsData:", error);
    return [];
  }
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/morpho/user-rewards/getMorphoUserRewards.js
async function getMorphoUserRewards(client, args) {
  const environments = getEnvironmentsFromArgs(client, args);
  const environmentsUserRewards = await Promise.all(environments.filter((environment) => environment.contracts.morphoViews !== void 0).map((environment) => {
    return getUserMorphoRewardsData({
      environment,
      account: args.userAddress
    });
  }));
  return environmentsUserRewards.flat();
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/morpho/user-rewards/getMorphoUserStakingRewards.js
async function getMorphoUserStakingRewards(client, args) {
  const environments = getEnvironmentsFromArgs(client, args);
  const settled = await Promise.allSettled(environments.filter((environment) => environment.contracts.morphoViews !== void 0).map((environment) => {
    return getUserMorphoStakingRewardsData({
      environment,
      account: args.userAddress
    });
  }));
  const result = settled.flatMap((s) => s.status === "fulfilled" ? s.value : []);
  return result;
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/morpho/vaults/getMorphoVault.js
var import_lodash10 = __toESM(require_lodash(), 1);

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/morpho/vaults/common.js
var import_dayjs3 = __toESM(require_dayjs_min(), 1);
var import_utc2 = __toESM(require_utc(), 1);

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/morpho/utils/math.js
var pow10 = (exponant) => 10n ** BigInt(exponant);
var ORACLE_PRICE_SCALE = pow10(36);
var WAD = pow10(18);
var SECONDS_PER_YEAR = 3600 * 24 * 365;
var VIRTUAL_ASSETS = 1n;
var VIRTUAL_SHARES = 10n ** 6n;
var MAX_UINT256 = BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF");
var wMulDown = (x, y) => mulDivDown(x, y, WAD);
var mulDivDown = (x, y, d) => BigInt(x) * BigInt(y) / BigInt(d);
var toAssetsDown = (shares, totalAssets, totalShares) => {
  return mulDivDown(shares, totalAssets + VIRTUAL_ASSETS, totalShares + VIRTUAL_SHARES);
};

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/morpho/vaults/common.js
import_dayjs3.default.extend(import_utc2.default);
async function getMorphoVaultsData(params) {
  const { environments } = params;
  const environmentsWithVaults = environments.filter((environment) => Object.keys(environment.vaults).length > 0 && environment.contracts.morphoViews);
  const environmentsVaultsInfoSettlements = await Promise.allSettled(environmentsWithVaults.map(async (environment) => {
    const vaultsAddresses = Object.values(environment.vaults).map((v) => v.address).filter((address) => params.vaults ? params.vaults.map((id) => id.toLowerCase()).includes(address.toLowerCase()) : true);
    try {
      console.log("environment.contracts.morphoViews?.read.getVaultsInfo before invocation", environment.contracts.morphoViews);
      const vaultInfo = await environment.contracts.morphoViews?.read.getVaultsInfo([
        vaultsAddresses
      ]);
      console.log("environment.contracts.morphoViews?.read.getVaultsInfo vaultInfo", environment.chainId, vaultInfo);
      return vaultInfo;
    } catch (error) {
      console.log("environment.contracts.morphoViews?.read.getVaultsInfo error", environment.chainId, error);
      return Promise.reject([]);
    }
  }));
  const environmentsVaultsInfo = environmentsVaultsInfoSettlements.filter((s) => s.status === "fulfilled").map((s) => s.value);
  const result = await environmentsWithVaults.reduce(async (aggregatorPromise, environment, environmentIndex) => {
    const aggregator = await aggregatorPromise;
    const environmentVaultsInfo = environmentsVaultsInfo[environmentIndex];
    if (!environmentVaultsInfo) {
      return aggregator;
    }
    const settled = await Promise.allSettled(environmentVaultsInfo.map(async (vaultInfo) => {
      const vaultKey = Object.keys(environment.config.tokens).find((key) => {
        return environment.config.tokens[key].address.toLowerCase() === vaultInfo.vault.toLowerCase();
      });
      const vaultToken = environment.config.tokens[vaultKey];
      const vaultConfig = environment.config.vaults[vaultKey];
      const underlyingToken = environment.config.tokens[vaultConfig.underlyingToken];
      const underlyingPrice = new Amount(vaultInfo.underlyingPrice, 18);
      const vaultSupply = new Amount(vaultInfo.totalSupply, vaultToken.decimals);
      const totalSupply = new Amount(vaultInfo.totalAssets, underlyingToken.decimals);
      const totalSupplyUsd = totalSupply.value * underlyingPrice.value;
      const performanceFee = new Amount(vaultInfo.fee, 18).value;
      const timelock = Number(vaultInfo.timelock) / (60 * 60);
      let ratio = 0n;
      const markets5 = vaultInfo.markets.map((vaultMarket) => {
        ratio += wMulDown(vaultMarket.marketApy, vaultMarket.vaultSupplied);
        const totalSupplied = new Amount(vaultMarket.vaultSupplied, underlyingToken.decimals);
        const totalSuppliedUsd = totalSupplied.value * underlyingPrice.value;
        const allocation = totalSupplied.value / totalSupply.value;
        const marketLoanToValue = new Amount(vaultMarket.marketLltv, 18).value * 100;
        const marketApy = new Amount(vaultMarket.marketApy, 18).value * 100;
        let marketLiquidity = new Amount(vaultMarket.marketLiquidity, underlyingToken.decimals);
        let marketLiquidityUsd = marketLiquidity.value * underlyingPrice.value;
        if (vaultMarket.marketCollateral === zeroAddress) {
          marketLiquidity = totalSupplied;
          marketLiquidityUsd = totalSuppliedUsd;
        }
        const mapping2 = {
          marketId: vaultMarket.marketId,
          allocation,
          marketApy,
          marketCollateral: {
            address: vaultMarket.marketCollateral,
            decimals: 0,
            name: vaultMarket.marketCollateralName,
            symbol: vaultMarket.marketCollateralSymbol
          },
          marketLiquidity,
          marketLiquidityUsd,
          marketLoanToValue,
          totalSupplied,
          totalSuppliedUsd,
          rewards: []
        };
        return mapping2;
      });
      const avgSupplyApy = mulDivDown(ratio, WAD - vaultInfo.fee, vaultInfo.totalAssets === 0n ? 1n : vaultInfo.totalAssets);
      const baseApy = new Amount(avgSupplyApy, 18).value * 100;
      let totalLiquidity = new Amount(markets5.reduce((acc, curr) => acc + curr.marketLiquidity.exponential, 0n), underlyingToken.decimals);
      let totalLiquidityUsd = markets5.reduce((acc, curr) => acc + curr.marketLiquidityUsd, 0);
      if (totalLiquidity.value > totalSupply.value) {
        totalLiquidity = totalSupply;
        totalLiquidityUsd = totalSupplyUsd;
      }
      let totalStaked = new Amount(0n, underlyingToken.decimals);
      let totalStakedUsd = 0;
      if (vaultConfig.multiReward) {
        const [distributorTotalSupply, vaultTotalSupply, vaultTotalAssets] = await Promise.all([
          getTotalSupplyData(environment, vaultConfig.multiReward),
          getTotalSupplyData(environment, vaultToken.address),
          getTotalAssetsData(environment, vaultToken.address)
        ]);
        const stakedAssets = toAssetsDown(distributorTotalSupply, vaultTotalAssets, vaultTotalSupply);
        totalStaked = new Amount(stakedAssets, underlyingToken.decimals);
        totalStakedUsd = totalStaked.value * underlyingPrice.value;
      }
      const mapping = {
        chainId: environment.chainId,
        vaultKey,
        vaultToken,
        underlyingToken,
        underlyingPrice: underlyingPrice.value,
        baseApy,
        totalApy: baseApy,
        rewardsApy: 0,
        stakingRewardsApr: 0,
        totalStakingApr: baseApy,
        curators: [],
        performanceFee,
        timelock,
        totalLiquidity,
        totalLiquidityUsd,
        totalSupplyUsd,
        totalSupply,
        vaultSupply,
        totalStaked,
        totalStakedUsd,
        markets: markets5,
        rewards: [],
        stakingRewards: []
      };
      return mapping;
    }));
    const vaults3 = settled.flatMap((s) => s.status === "fulfilled" ? s.value : []);
    return {
      ...await aggregator,
      [environment.chainId]: vaults3
    };
  }, Promise.resolve({}));
  if (params.includeRewards === true) {
    const flatList = Object.values(result).flat();
    for (const vault of flatList) {
      const environment = params.environments.find((environment2) => environment2.chainId === vault.chainId);
      if (!environment) {
        continue;
      }
      const homeEnvironment = Object.values(publicEnvironments).find((e) => e.custom?.governance?.chainIds?.includes(environment.chainId)) || environment;
      const viewsContract = environment.contracts.views;
      const homeViewsContract = homeEnvironment.contracts.views;
      const data = await Promise.all([
        viewsContract?.read.getAllMarketsInfo(),
        homeViewsContract?.read.getNativeTokenPrice(),
        homeViewsContract?.read.getGovernanceTokenPrice()
      ]);
      const [allMarkets, nativeTokenPriceRaw, governanceTokenPriceRaw] = data;
      const governanceTokenPrice = new Amount(governanceTokenPriceRaw || 0n, 18);
      const nativeTokenPrice = new Amount(nativeTokenPriceRaw || 0n, 18);
      let tokenPrices = allMarkets?.map((marketInfo) => {
        const marketFound = findMarketByAddress(environment, marketInfo.market);
        if (marketFound) {
          return {
            token: marketFound.underlyingToken,
            tokenPrice: new Amount(marketInfo.underlyingPrice, 36 - marketFound.underlyingToken.decimals)
          };
        } else {
          return;
        }
      }).filter((token) => !!token) || [];
      if (environment.custom?.governance?.token) {
        tokenPrices = [
          ...tokenPrices,
          {
            token: environment.config.tokens[environment.custom.governance.token],
            tokenPrice: governanceTokenPrice
          }
        ];
      }
      tokenPrices = [
        ...tokenPrices,
        {
          token: findTokenByAddress(environment, zeroAddress),
          tokenPrice: nativeTokenPrice
        }
      ];
      const vaultConfig = environment?.config.vaults[vault.vaultKey];
      if (!environment || !vaultConfig || !vaultConfig.multiReward) {
        continue;
      }
      const rewards2 = await getRewardsData(environment, vaultConfig.multiReward);
      const distributorTotalSupply = await getTotalSupplyData(environment, vaultConfig.multiReward);
      rewards2.filter((reward) => reward?.periodFinish && import_dayjs3.default.utc().isBefore(import_dayjs3.default.unix(Number(reward.periodFinish)))).forEach((reward) => {
        const token = Object.values(environment.config.tokens).find((token2) => token2.address === reward?.token);
        if (!token || !reward?.rewardRate)
          return;
        const market = tokenPrices.find((m) => m?.token.address === reward.token);
        const rewardPriceUsd = market?.tokenPrice.value ?? 0;
        const rewardsPerYear = new Amount(reward.rewardRate, market?.token.decimals ?? 18).value * SECONDS_PER_YEAR * rewardPriceUsd;
        vault.stakingRewards.push({
          apr: rewardsPerYear / (new Amount(distributorTotalSupply, vault.vaultToken.decimals).value * vault.underlyingPrice) * 100,
          token
        });
      });
      vault.stakingRewardsApr = vault.stakingRewards.reduce((acc, curr) => acc + curr.apr, 0);
      vault.totalStakingApr = vault.stakingRewardsApr + vault.baseApy;
    }
    const vaults3 = Object.values(result).flat().filter((vault) => {
      const environment = params.environments.find((environment2) => environment2.chainId === vault.chainId);
      return environment?.custom.morpho?.minimalDeployment === false;
    });
    const rewards = await getMorphoVaultsRewards(vaults3, params.currentChainRewardsOnly);
    vaults3.forEach((vault) => {
      const vaultRewards = rewards.find((reward) => reward.vaultToken.address === vault.vaultToken.address && reward.chainId === vault.chainId);
      vault.rewards = vaultRewards?.rewards.filter((reward) => reward.marketId === void 0).map((reward) => ({
        asset: reward.asset,
        supplyApr: reward.supplyApr,
        supplyAmount: reward.supplyAmount,
        borrowApr: reward.borrowApr,
        borrowAmount: reward.borrowAmount
      })) || [];
      vault.markets.forEach((market) => {
        const marketRewards = vaultRewards?.rewards.filter((reward) => reward.marketId === market.marketId).map((reward) => ({
          asset: reward.asset,
          supplyApr: reward.supplyApr,
          supplyAmount: reward.supplyAmount,
          borrowApr: reward.borrowApr,
          borrowAmount: reward.borrowAmount
        })) || [];
        market.rewards = marketRewards;
        market.rewards.forEach((reward) => {
          const supplyApr = reward.supplyApr * market.allocation;
          const supplyAmount = reward.supplyAmount * market.allocation;
          const vaultReward = vault.rewards.find((r) => r.asset.address === reward.asset.address);
          if (vaultReward) {
            vaultReward.supplyApr += supplyApr;
            vaultReward.supplyAmount += supplyAmount;
          } else {
            vault.rewards.push({
              asset: reward.asset,
              supplyApr,
              supplyAmount,
              borrowApr: 0,
              borrowAmount: 0
            });
          }
        });
      });
      vault.rewardsApy = vault.rewards.reduce((acc, curr) => acc + curr.supplyApr, 0);
      vault.totalApy = vault.rewardsApy + vault.baseApy;
    });
  }
  return environments.flatMap((environment) => {
    return result[environment.chainId] || [];
  });
}
var getRewardsData = async (environment, multiRewardsAddress) => {
  if (!environment.custom.multiRewarder) {
    return [];
  }
  const multiRewardAbi = parseAbi([
    "function rewardData(address token) view returns (address, uint256, uint256, uint256, uint256, uint256)"
  ]);
  const multiRewardContract = getContract({
    address: multiRewardsAddress,
    abi: multiRewardAbi,
    client: environment.publicClient
  });
  const rewards = await Promise.all(environment.custom.multiRewarder.map(async (multiRewarder) => {
    const tokenAddress = environment.tokens[multiRewarder.rewardToken].address;
    if (!tokenAddress) {
      return;
    }
    try {
      const rewardData = await multiRewardContract.read.rewardData([
        tokenAddress
      ]);
      return {
        rewardRate: BigInt(rewardData[3]),
        token: tokenAddress,
        periodFinish: BigInt(rewardData[2])
      };
    } catch {
      return { rewardRate: 0n, token: tokenAddress };
    }
  }));
  return rewards.filter(Boolean);
};
var getTotalSupplyData = async (environment, multiRewardsAddress) => {
  if (!environment.custom.multiRewarder) {
    return 0n;
  }
  const multiRewardAbi = parseAbi([
    "function totalSupply() view returns (uint256)"
  ]);
  const multiRewardContract = getContract({
    address: multiRewardsAddress,
    abi: multiRewardAbi,
    client: environment.publicClient
  });
  try {
    const totalSupply = await multiRewardContract.read.totalSupply();
    return BigInt(totalSupply);
  } catch {
    return 0n;
  }
};
var getTotalAssetsData = async (environment, multiRewardsAddress) => {
  if (!environment.custom.multiRewarder) {
    return 0n;
  }
  const multiRewardAbi = parseAbi([
    "function totalAssets() view returns (uint256)"
  ]);
  const multiRewardContract = getContract({
    address: multiRewardsAddress,
    abi: multiRewardAbi,
    client: environment.publicClient
  });
  try {
    const totalAssets = await multiRewardContract.read.totalAssets();
    return BigInt(totalAssets);
  } catch {
    return 0n;
  }
};
async function getMorphoVaultsRewards(vaults3, currentChainRewardsOnly) {
  const query = `
  {
    vaults(
      where: { address_in: [${vaults3.map((vault) => `"${vault.vaultToken.address}"`).join(",")}], chainId_in: [${vaults3.map((vault) => vault.chainId).join(",")}] }
    ) {
      items {
        chain {
          id
        }
        id
        address
        asset {
          priceUsd
        }
        state {
          rewards {
            asset {
              address
              symbol
              decimals
              name
              chain {
                id
              }
            }
            supplyApr
            amountPerSuppliedToken
          }
        }
      }
    }
    marketPositions(
      where: { userAddress_in: [${vaults3.map((vault) => `"${vault.vaultToken.address}"`).join(",")}], chainId_in: [${vaults3.map((vault) => vault.chainId).join(",")}] }
    ) {
      items {
        user {
          address
        }
        market {
          morphoBlue {
            chain {
              id
            }
          }
          uniqueKey
          loanAsset {
            priceUsd
          }
          state {
            rewards {
              asset {
                address
                symbol
                decimals
                name
                chain {
                  id
                }
              }
              supplyApr
              amountPerSuppliedToken
            }
          }
        }
      }
    }
  } `;
  const result = await getGraphQL(query);
  if (result) {
    try {
      const marketsRewards = result.marketPositions.items.flatMap((item) => {
        const rewards2 = (item.market.state?.rewards || []).map((reward) => {
          const tokenAmountPer1000 = Number.parseFloat(reward.amountPerSuppliedToken) / item.market.loanAsset.priceUsd * 1e3;
          const tokenDecimals = 10 ** reward.asset.decimals;
          const amount = Number(tokenAmountPer1000) / tokenDecimals;
          return {
            chainId: reward.asset.chain.id,
            vaultId: item.user.address,
            marketId: item.market.uniqueKey,
            asset: reward.asset,
            supplyApr: (reward.supplyApr || 0) * 100,
            supplyAmount: amount,
            borrowApr: 0,
            borrowAmount: 0
          };
        });
        return rewards2;
      });
      const vaultsRewards = result.vaults.items.flatMap((item) => {
        return (item.state?.rewards || []).map((reward) => {
          const tokenAmountPer1000 = Number.parseFloat(reward.amountPerSuppliedToken) / item.asset.priceUsd * 1e3;
          const tokenDecimals = 10 ** reward.asset.decimals;
          const amount = Number(tokenAmountPer1000) / tokenDecimals;
          return {
            chainId: reward.asset.chain.id,
            vaultId: item.address,
            marketId: void 0,
            asset: reward.asset,
            supplyApr: (reward.supplyApr || 0) * 100,
            supplyAmount: amount,
            borrowApr: 0,
            borrowAmount: 0
          };
        });
      });
      const rewards = [...marketsRewards, ...vaultsRewards];
      return vaults3.map((vault) => {
        return {
          chainId: vault.chainId,
          vaultToken: vault.vaultToken,
          rewards: rewards.filter((reward) => reward.vaultId === vault.vaultToken.address && (reward.chainId === vault.chainId || !currentChainRewardsOnly)).map((reward) => {
            return {
              marketId: reward.marketId,
              asset: reward.asset,
              supplyApr: reward.supplyApr,
              supplyAmount: reward.supplyAmount,
              borrowApr: reward.borrowApr,
              borrowAmount: reward.borrowAmount
            };
          })
        };
      });
    } catch (ex) {
      return vaults3.map((vault) => {
        return {
          chainId: vault.chainId,
          vaultToken: vault.vaultToken,
          rewards: []
        };
      });
    }
  } else {
    return vaults3.map((vault) => {
      return {
        chainId: vault.chainId,
        vaultToken: vault.vaultToken,
        rewards: []
      };
    });
  }
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/morpho/vaults/getMorphoVault.js
var { first: first6 } = import_lodash10.default;
async function getMorphoVault(client, args) {
  const environment = getEnvironmentFromArgs(client, args);
  if (!environment) {
    return void 0;
  }
  let { vaultAddress, vault } = args;
  if (!vaultAddress) {
    vaultAddress = environment.vaults[vault].address;
  }
  const results = await getMorphoVaultsData({
    environments: [environment],
    vaults: [vaultAddress],
    includeRewards: args.includeRewards ?? false,
    currentChainRewardsOnly: args.currentChainRewardsOnly ?? false
  });
  return first6(results);
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/morpho/vaults/getMorphoVaults.js
async function getMorphoVaults(client, args) {
  const environments = getEnvironmentsFromArgs(client, args);
  const logId = start("getMorphoVaults", "Starting to get vaults...");
  const result = await getMorphoVaultsData({
    environments,
    includeRewards: args?.includeRewards ?? false,
    currentChainRewardsOnly: args?.currentChainRewardsOnly ?? false
  });
  end(logId);
  return result;
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/core/markets/getMarketSnapshots.js
var import_dayjs4 = __toESM(require_dayjs_min(), 1);
var import_utc3 = __toESM(require_utc(), 1);
import_dayjs4.default.extend(import_utc3.default);
async function getMarketSnapshots(client, args) {
  const environment = getEnvironmentFromArgs(client, args);
  if (!environment) {
    return [];
  }
  if (args?.type === "core") {
    return fetchCoreMarketSnapshots(args.marketId, environment);
  } else {
    if (environment.custom.morpho?.minimalDeployment === false) {
      return fetchIsolatedMarketSnapshots(args.marketId, environment);
    } else {
      return fetchIsolatedMarketSnapshotsSubgraph(args.marketId, environment);
    }
  }
}
async function fetchCoreMarketSnapshots(marketAddress, environment) {
  const dailyData = [];
  let hasNextPage = true;
  let endCursor;
  while (hasNextPage) {
    const result = await axios_default.post(environment.indexerUrl, {
      query: `
          query {
            marketDailySnapshots (        
              limit: 1000,
              orderBy: "timestamp"
              orderDirection: "desc"
              where: {marketAddress: "${marketAddress.toLowerCase()}", chainId: ${environment.chainId}}
              ${endCursor ? `after: "${endCursor}"` : ""}
            ) {
              items {
                totalBorrows
                totalBorrowsUSD
                totalSupplies
                totalSuppliesUSD
                totalLiquidity
                totalLiquidityUSD
                baseSupplyApy
                baseBorrowApy
                timestamp
              }
              pageInfo {
                hasNextPage
                endCursor
              }
            }
          }
        `
    });
    dailyData.push(...result.data.data.marketDailySnapshots.items.filter((f) => isStartOfDay(f.timestamp)));
    hasNextPage = result.data.data.marketDailySnapshots.pageInfo.hasNextPage;
    endCursor = result.data.data.marketDailySnapshots.pageInfo.endCursor;
  }
  if (dailyData.length > 0) {
    return dailyData.map((point) => {
      const supplied = Number(point.totalSupplies);
      const borrow = Number(point.totalBorrows);
      const borrowUsd = Number(point.totalBorrowsUSD);
      const suppliedUsd = Number(point.totalSuppliesUSD);
      const liquidity = Math.max(point.totalLiquidity, 0);
      const liquidityUsd = Math.max(point.totalLiquidityUSD, 0);
      const price = suppliedUsd / supplied;
      const result = {
        marketId: marketAddress.toLowerCase(),
        chainId: environment.chainId,
        timestamp: point.timestamp * 1e3,
        totalSupply: supplied,
        totalSupplyUsd: suppliedUsd,
        totalBorrows: borrow,
        totalBorrowsUsd: borrowUsd,
        totalLiquidity: liquidity,
        totalLiquidityUsd: liquidityUsd,
        baseSupplyApy: point.baseSupplyApy,
        baseBorrowApy: point.baseBorrowApy,
        collateralTokenPrice: price,
        loanTokenPrice: price
      };
      return result;
    });
  } else {
    return [];
  }
}
async function fetchMorphoGraphQL(query, operationName, variables) {
  try {
    const response = await axios_default.post("https://blue-api.morpho.org/graphql", { query, operationName, variables }, { timeout: 5e3 });
    if (response.status !== 200 || response.data.errors) {
      console.log(`Non-200 (${response.statusText}
        }) or other error from Morpho GraphQL! - ${JSON.stringify(response.data)}`);
      return void 0;
    }
    return response.data.data;
  } catch (error) {
    return void 0;
  }
}
async function fetchIsolatedMarketSnapshots(marketAddress, environment) {
  const marketConfig = Object.values(environment.config.morphoMarkets).find((market) => market.id.toLowerCase() === marketAddress.toLowerCase());
  const isStkWellMarket = marketConfig && environment.config.tokens[marketConfig.collateralToken]?.symbol === "stkWELL";
  let wellPrice = null;
  if (isStkWellMarket) {
    const wellMarketConfig = Object.values(environment.config.morphoMarkets).find((market) => market.collateralToken === "WELL" || market.loanToken === "WELL");
    if (wellMarketConfig) {
      const wellQuery = `    
        query getWellPrice {
          wellMarket: marketByUniqueKey(
            chainId: ${environment.chainId}
            uniqueKey: "${wellMarketConfig.id.toLowerCase()}"
          ) {
            loanAsset {
              priceUsd
            }
            collateralAsset {
              priceUsd
            }
          }
        }`;
      const wellResult = await fetchMorphoGraphQL(wellQuery, "getWellPrice");
      if (wellResult?.wellMarket) {
        wellPrice = wellMarketConfig.collateralToken === "WELL" ? wellResult.wellMarket.collateralAsset.priceUsd : wellResult.wellMarket.loanAsset.priceUsd;
      }
    }
  }
  const operationName = "getMarketTotalTimeseries";
  const variables = {
    options: {
      startTimestamp: import_dayjs4.default.utc().subtract(1, "year").unix(),
      interval: "DAY"
    }
  };
  const query = `    
    query getMarketTotalTimeseries($options: TimeseriesOptions) {
      marketTotalTimeseries: marketByUniqueKey(
        chainId: ${environment.chainId}
        uniqueKey: "${marketAddress.toLowerCase()}"
      ) {
        uniqueKey
        loanAsset {
          priceUsd
          decimals
        }
        collateralAsset {
          priceUsd
          decimals
        }
        historicalState {
         supplyApy(options: $options) {
            x
            y
          }
          borrowApy(options: $options) {
            x
            y
          }
          borrowAssets(options: $options) {
            x
            y
          }
          borrowAssetsUsd(options: $options) {
            x
            y
          }
          supplyAssets(options: $options) {
            x
            y
          }
          supplyAssetsUsd(options: $options) {
            x
            y
          }
          liquidityAssets(options: $options) {
            x
            y
          }
          liquidityAssetsUsd(options: $options) {
            x
            y
          }
        }
      }
    }`;
  const result = await fetchMorphoGraphQL(query, operationName, variables);
  if (result) {
    try {
      const markets5 = result.marketTotalTimeseries.historicalState.borrowAssets.map((borrowAssets, index) => {
        const loanDecimals = result.marketTotalTimeseries.loanAsset.decimals;
        const borrowAssetsUsd = result.marketTotalTimeseries.historicalState.borrowAssetsUsd[index];
        const supplyAssets = result.marketTotalTimeseries.historicalState.supplyAssets[index];
        const supplyAssetsUsd = result.marketTotalTimeseries.historicalState.supplyAssetsUsd[index];
        const liquidityAssets = result.marketTotalTimeseries.historicalState.liquidityAssets[index];
        const liquidityAssetsUsd = result.marketTotalTimeseries.historicalState.liquidityAssetsUsd[index];
        const supplyApy = result.marketTotalTimeseries.historicalState.supplyApy[index];
        const borrowApy = result.marketTotalTimeseries.historicalState.borrowApy[index];
        let collateralTokenPrice = result.marketTotalTimeseries.collateralAsset.priceUsd;
        const loanTokenPrice = result.marketTotalTimeseries.loanAsset.priceUsd;
        if (isStkWellMarket && wellPrice !== null) {
          collateralTokenPrice = wellPrice;
        }
        const totalSupply = new Amount(BigInt(supplyAssets.y), Number(loanDecimals)).value * loanTokenPrice / collateralTokenPrice;
        const totalBorrows = new Amount(BigInt(borrowAssets.y), Number(loanDecimals)).value;
        const totalLiquidity = new Amount(BigInt(liquidityAssets.y), Number(loanDecimals)).value * loanTokenPrice / collateralTokenPrice;
        return {
          chainId: environment.chainId,
          timestamp: borrowAssets.x * 1e3,
          marketId: marketAddress.toLowerCase(),
          totalBorrows,
          totalBorrowsUsd: Number(borrowAssetsUsd.y),
          totalSupply,
          totalSupplyUsd: Number(supplyAssetsUsd.y),
          totalLiquidity,
          totalLiquidityUsd: Number(liquidityAssetsUsd.y),
          baseSupplyApy: supplyApy.y,
          baseBorrowApy: borrowApy.y,
          loanTokenPrice,
          collateralTokenPrice
        };
      });
      return markets5;
    } catch (ex) {
      return [];
    }
  } else {
    return [];
  }
}
async function fetchIsolatedMarketSnapshotsSubgraph(marketAddress, environment) {
  const marketConfig = Object.values(environment.config.morphoMarkets).find((market) => market.id.toLowerCase() === marketAddress.toLowerCase());
  const isStkWellMarket = marketConfig && environment.config.tokens[marketConfig.collateralToken]?.symbol === "stkWELL";
  let wellPrice = null;
  if (isStkWellMarket) {
    const wellMarketConfig = Object.values(environment.config.morphoMarkets).find((market) => market.collateralToken === "WELL" || market.loanToken === "WELL");
    if (wellMarketConfig) {
      const wellQuery = `    
        {
          marketDailySnapshots (where:{market:"${wellMarketConfig.id.toLowerCase()}"}, orderBy:timestamp, orderDirection:desc, first: 1) {
            inputTokenPriceUSD
            outputTokenPriceUSD
          }
        }
      `;
      const wellResult = await getSubgraph(environment, wellQuery);
      if (wellResult?.marketDailySnapshots?.[0]) {
        wellPrice = wellMarketConfig.collateralToken === "WELL" ? Number(wellResult.marketDailySnapshots[0].inputTokenPriceUSD) : Number(wellResult.marketDailySnapshots[0].outputTokenPriceUSD);
      }
    }
  }
  const query = `    
    {
      marketDailySnapshots (where:{market:"${marketAddress.toLowerCase()}"}, orderBy:timestamp, orderDirection:desc, first: 365) {
        market {
          maximumLTV
          inputToken {
            decimals
          }
          borrowedToken {
            decimals
          }
        }
        variableBorrowedTokenBalance
        outputTokenPriceUSD
        inputTokenPriceUSD
        inputTokenBalance
        timestamp      
      }
    }
`;
  const result = await getSubgraph(environment, query);
  if (result) {
    try {
      const markets5 = result.marketDailySnapshots.map((item) => {
        const supplyDecimals = item.market.borrowedToken.decimals;
        const supplyAssets = item.inputTokenBalance;
        const totalSupplyInLoanToken = new Amount(BigInt(supplyAssets), Number(supplyDecimals)).value;
        let collateralTokenPrice = Number(item.inputTokenPriceUSD);
        if (isStkWellMarket && wellPrice !== null) {
          collateralTokenPrice = wellPrice;
        }
        const totalSupply = totalSupplyInLoanToken / collateralTokenPrice;
        const borrowAssets = item.variableBorrowedTokenBalance;
        const totalBorrows = new Amount(BigInt(borrowAssets), Number(supplyDecimals)).value;
        const totalLiquidityInLoanToken = Math.max(totalSupplyInLoanToken - totalBorrows, 0);
        const totalLiquidity = totalLiquidityInLoanToken / collateralTokenPrice;
        return {
          chainId: environment.chainId,
          timestamp: item.timestamp * 1e3,
          marketId: marketAddress.toLowerCase(),
          totalBorrows,
          totalBorrowsUsd: Number(item.outputTokenPriceUSD) * totalBorrows,
          totalSupply,
          totalSupplyUsd: collateralTokenPrice * totalSupply,
          totalLiquidity,
          totalLiquidityUsd: Number(item.outputTokenPriceUSD) * totalLiquidityInLoanToken,
          baseSupplyApy: 0,
          baseBorrowApy: 0,
          loanTokenPrice: Number(item.outputTokenPriceUSD),
          collateralTokenPrice
        };
      });
      return markets5;
    } catch (ex) {
      return [];
    }
  } else {
    return [];
  }
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/morpho/vaults/getMorphoVaultSnapshots.js
var import_dayjs5 = __toESM(require_dayjs_min(), 1);
var import_utc4 = __toESM(require_utc(), 1);
import_dayjs5.default.extend(import_utc4.default);
async function getMorphoVaultSnapshots(client, args) {
  const environment = getEnvironmentFromArgs(client, args);
  if (!environment) {
    return [];
  }
  return fetchVaultSnapshots(args.vaultAddress, environment);
}
async function fetchVaultSnapshots(vaultAddress, environment) {
  const dailyData = [];
  let hasNextPage = true;
  let endCursor;
  while (hasNextPage) {
    const result = await axios_default.post(environment.indexerUrl, {
      query: `
          query {
            vaultDailySnapshots (        
              limit: 365,
              orderBy: "timestamp"
              orderDirection: "desc"
              where: {vaultAddress: "${vaultAddress.toLowerCase()}", chainId: ${environment.chainId}}
              ${endCursor ? `after: "${endCursor}"` : ""}
            ) {
              items {
                  totalBorrows
                  totalBorrowsUSD
                  totalSupplies
                  totalSuppliesUSD
                  totalLiquidity
                  totalLiquidityUSD
                  timestamp
              }
              pageInfo {
                hasNextPage
                endCursor
              }
            }
          }
        `
    });
    if (result.data.data.vaultDailySnapshots) {
      dailyData.push(...result.data.data.vaultDailySnapshots.items.filter((f) => isStartOfDay(f.timestamp)));
      hasNextPage = result.data.data.vaultDailySnapshots.pageInfo.hasNextPage;
      endCursor = result.data.data.vaultDailySnapshots.pageInfo.endCursor;
    }
  }
  if (dailyData.length > 0) {
    return dailyData.map((point) => {
      const supplied = Number(point.totalSupplies);
      const borrow = Number(point.totalBorrows);
      const borrowUsd = Number(point.totalBorrowsUSD);
      const suppliedUsd = Number(point.totalSuppliesUSD);
      const liquidity = Number(point.totalLiquidity);
      const liquidityUsd = Number(point.totalLiquidityUSD);
      const result = {
        vaultAddress: vaultAddress.toLowerCase(),
        chainId: environment.chainId,
        timestamp: point.timestamp * 1e3,
        totalSupply: supplied,
        totalSupplyUsd: suppliedUsd,
        totalBorrows: borrow,
        totalBorrowsUsd: borrowUsd,
        totalLiquidity: liquidity,
        totalLiquidityUsd: liquidityUsd
      };
      return result;
    });
  } else {
    return [];
  }
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/morpho/vaults/getMorphoVaultStakingSnapshots.js
var import_dayjs6 = __toESM(require_dayjs_min(), 1);
var import_utc5 = __toESM(require_utc(), 1);
import_dayjs6.default.extend(import_utc5.default);
async function getMorphoVaultStakingSnapshots(client, args) {
  const environment = getEnvironmentFromArgs(client, args);
  if (!environment) {
    return [];
  }
  return fetchVaultStakingSnapshots(args.vaultAddress, environment);
}
async function fetchVaultStakingSnapshots(vaultAddress, environment) {
  const dailyData = [];
  let hasNextPage = true;
  let endCursor;
  while (hasNextPage) {
    const result = await axios_default.post(environment.indexerUrl, {
      query: `
          query {
            vaultStakingDailySnapshots (        
              limit: 365,
              orderBy: "timestamp"
              orderDirection: "desc"
              where: {vaultAddress: "${vaultAddress.toLowerCase()}", chainId: ${environment.chainId}}
              ${endCursor ? `after: "${endCursor}"` : ""}
            ) {
              items {
                  totalStaked
                  totalStakedUSD
                  timestamp
              }
              pageInfo {
                hasNextPage
                endCursor
              }
            }
          }
        `
    });
    if (result.data.data.vaultStakingDailySnapshots) {
      dailyData.push(...result.data.data.vaultStakingDailySnapshots.items.filter((f) => isStartOfDay(f.timestamp)));
      hasNextPage = result.data.data.vaultStakingDailySnapshots.pageInfo.hasNextPage;
      endCursor = result.data.data.vaultStakingDailySnapshots.pageInfo.endCursor;
    }
  }
  if (dailyData.length > 0) {
    return dailyData.map((point) => {
      const staked = Number(point.totalStaked);
      const stakedUsd = Number(point.totalStakedUSD);
      const result = {
        vaultAddress: vaultAddress.toLowerCase(),
        chainId: environment.chainId,
        timestamp: point.timestamp * 1e3,
        totalStaked: staked,
        totalStakedUsd: stakedUsd
      };
      return result;
    });
  } else {
    return [];
  }
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/actions/morpho/user-positions/getMorphoVaultUserPositionSnapshots.js
var import_dayjs7 = __toESM(require_dayjs_min(), 1);
var import_utc6 = __toESM(require_utc(), 1);
import_dayjs7.default.extend(import_utc6.default);
async function getMorphoVaultUserPositionSnapshots(client, args) {
  const environment = getEnvironmentFromArgs(client, args);
  if (!environment) {
    return [];
  }
  let { vaultAddress, vault } = args;
  if (!vaultAddress) {
    vaultAddress = environment.vaults[vault].address;
  }
  return fetchUserPositionSnapshots2(args.userAddress, vaultAddress, environment);
}
async function fetchUserPositionSnapshots2(userAddress, vaultAddress, environment) {
  const dailyData = [];
  let hasNextPage = true;
  let endCursor;
  while (hasNextPage) {
    const result = await axios_default.post(environment.indexerUrl, {
      query: `
          query {
            accountVaultDailySnapshots(
              limit: 365,
              orderDirection: "desc",
              orderBy: "timestamp",
              where: { vaultAddress: "${vaultAddress.toLowerCase()}", accountAddress: "${userAddress.toLowerCase()}", chainId: ${environment.chainId} }
              ${endCursor ? `after: "${endCursor}"` : ""}
            ) {
              items {
                totalSuppliesUSD
                timestamp
              }
              pageInfo {
                hasNextPage
                endCursor
              }
            }
          }
        `
    });
    dailyData.push(...result.data.data.accountVaultDailySnapshots.items.filter((f) => isStartOfDay(f.timestamp)));
    hasNextPage = result.data.data.accountVaultDailySnapshots.pageInfo.hasNextPage;
    endCursor = result.data.data.accountVaultDailySnapshots.pageInfo.endCursor;
  }
  if (dailyData.length > 0) {
    return dailyData.map((point) => {
      const suppliedUsd = Number(point.totalSuppliesUSD);
      const result = {
        chainId: environment.chainId,
        timestamp: point.timestamp * 1e3,
        suppliedUsd,
        account: userAddress,
        vaultAddress
      };
      return result;
    });
  } else {
    return [];
  }
}

// node_modules/@moonwell-fi/moonwell-sdk/_esm/client/createActions.js
var actions = (client) => {
  return {
    getBeamTokenLimits: (args) => getBeamTokenLimits(args),
    getBeamQuote: (args) => getBeamQuote(client, args),
    getBeamTokenRoutes: () => getBeamTokenRoutes(client),
    getMarket: (args) => getMarket(client, args),
    getMarkets: (args) => getMarkets(client, args),
    getUserPosition: (args) => getUserPosition(client, args),
    getUserPositions: (args) => getUserPositions(client, args),
    getUserReward: (args) => getUserReward(client, args),
    getUserRewards: (args) => getUserRewards(client, args),
    getUserBalances: (args) => getUserBalances(client, args),
    getProposal: (args) => getProposal(client, args),
    getProposals: (args) => getProposals(client, args),
    getSnapshotProposal: (args) => getSnapshotProposal(client, args),
    getSnapshotProposals: (args) => getSnapshotProposals(client, args),
    getDelegates: () => getDelegates(client),
    getDiscussions: () => getDiscussions(client),
    getGovernanceTokenInfo: (args) => getGovernanceTokenInfo(client, args),
    getStakingInfo: (args) => getStakingInfo(client, args),
    getStakingSnapshots: (args) => getStakingSnapshots(client, args),
    getUserStakingInfo: (args) => getUserStakingInfo(client, args),
    getUserVoteReceipt: (args) => getUserVoteReceipt(client, args),
    getUserVotingPowers: (args) => getUserVotingPowers(client, args),
    getMorphoMarket: (args) => getMorphoMarket(client, args),
    getMorphoMarkets: (args) => getMorphoMarkets(client, args),
    getMorphoMarketUserPosition: (args) => getMorphoMarketUserPosition(client, args),
    getMorphoMarketUserPositions: (args) => getMorphoMarketUserPositions(client, args),
    getMorphoVaultUserPosition: (args) => getMorphoVaultUserPosition(client, args),
    getMorphoVaultUserPositions: (args) => getMorphoVaultUserPositions(client, args),
    getMorphoUserRewards: (args) => getMorphoUserRewards(client, args),
    getMorphoUserStakingRewards: (args) => getMorphoUserStakingRewards(client, args),
    getMorphoVault: (args) => getMorphoVault(client, args),
    getMorphoVaults: (args) => getMorphoVaults(client, args),
    getMorphoUserBalances: (args) => getMorphoUserBalances(client, args),
    getCirculatingSupplySnapshots: (args) => getCirculatingSupplySnapshots(client, args),
    getMarketSnapshots: (args) => getMarketSnapshots(client, args),
    getMorphoVaultSnapshots: (args) => getMorphoVaultSnapshots(client, args),
    getMorphoVaultStakingSnapshots: (args) => getMorphoVaultStakingSnapshots(client, args),
    getUserPositionSnapshots: (args) => getUserPositionSnapshots(client, args),
    getMorphoVaultUserPositionSnapshots: (args) => getMorphoVaultUserPositionSnapshots(client, args)
  };
};

// node_modules/@moonwell-fi/moonwell-sdk/_esm/client/createMoonwellClient.js
var createMoonwellClient = (config) => {
  const environments = Object.keys(config.networks).reduce((prev, curr) => {
    const key = curr;
    const networkConfig = config.networks[key];
    return {
      ...prev,
      [curr]: createEnvironment9({
        chain: curr === "base" ? base2 : curr === "optimism" ? optimism : curr === "moonbeam" ? moonbeam : curr === "moonriver" ? moonriver : curr === "ethereum" ? mainnet : curr === "avalanche" ? avalanche : curr === "arbitrum" ? arbitrum : polygon,
        rpcUrls: networkConfig.rpcUrls
      })
    };
  }, {});
  const client = {
    environments
  };
  return Object.assign(client, actions(client));
};
export {
  MultichainProposalState,
  ProposalState,
  createMoonwellClient
};
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
//# sourceMappingURL=@moonwell-fi_moonwell-sdk.js.map
