"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMorphoUserBalances = getMorphoUserBalances;
const index_js_1 = require("../../common/index.js");
const index_js_2 = require("../../environments/utils/index.js");
async function getMorphoUserBalances(client, args) {
    const environments = (0, index_js_1.getEnvironmentsFromArgs)(client, args);
    const environmentsTokensBalancesSettled = await Promise.allSettled(environments.map(async (environment) => {
        const viewsRead = environment.contracts.views?.read;
        if (!viewsRead || !viewsRead?.getTokensBalances) {
            return Promise.reject(new Error("No views read contract"));
        }
        const uniqueTokenAddresses = [
            ...new Set([
                ...Object.values(environment.config.vaults).map((vault) => environment.config.tokens[vault.underlyingToken].address),
                ...Object.values(environment.config.vaults).map((vault) => environment.config.tokens[vault.vaultToken].address),
                ...Object.values(environment.config.morphoMarkets).map((market) => environment.config.tokens[market.collateralToken].address),
                ...Object.values(environment.config.morphoMarkets).map((market) => environment.config.tokens[market.loanToken].address),
            ]),
        ];
        try {
            return await viewsRead.getTokensBalances([
                [...uniqueTokenAddresses],
                args.userAddress,
            ]);
        }
        catch (error) {
            return Promise.reject(error);
        }
    }));
    const environmentsTokensBalances = environmentsTokensBalancesSettled.map((s) => (s.status === "fulfilled" ? [...s.value] : []));
    const tokensBalances = environments.flatMap((curr, index) => {
        const balances = environmentsTokensBalances[index];
        if (!balances) {
            return [];
        }
        const userBalances = balances
            .map((balance) => {
            const token = (0, index_js_2.findTokenByAddress)(curr, balance.token);
            if (token) {
                const result = {
                    chainId: curr.chainId,
                    account: args.userAddress,
                    token,
                    tokenBalance: new index_js_1.Amount(balance.amount, token.decimals),
                };
                return result;
            }
            else {
                return;
            }
        })
            .filter((item) => item !== undefined);
        return userBalances;
    });
    return tokensBalances;
}
//# sourceMappingURL=getMorphoUserBalances.js.map