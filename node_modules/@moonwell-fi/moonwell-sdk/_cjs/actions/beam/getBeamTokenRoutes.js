"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBeamTokenRoutes = getBeamTokenRoutes;
const axios_1 = __importDefault(require("axios"));
const viem_1 = require("viem");
const index_js_1 = require("../../common/index.js");
async function getBeamTokenRoutes(client) {
    const environments = (0, index_js_1.getEnvironmentsFromArgs)(client, undefined, false);
    const acrossRoutesResponse = await axios_1.default.get("https://across.to/api/available-routes");
    const biconomyInfoResponse = await axios_1.default.get("https://network.biconomy.io/v1/info");
    const moonwellSupportedTokens = environments
        .flatMap((env) => {
        const tokens = Object.values(env.config.tokens).map((token) => {
            return {
                ...token,
                chainId: env.chainId,
            };
        });
        return tokens;
    })
        .filter((r) => r.symbol.toLowerCase() !== "usdbc" && r.symbol.toLowerCase() !== "weth");
    const biconomyChains = biconomyInfoResponse.data.supportedChains
        .filter((supportedChain) => supportedChain.healthCheck.status === "healthy")
        .map((chain) => {
        return {
            ...chain,
            chainId: Number.parseInt(chain.chainId),
        };
    });
    const supportedRoutes = acrossRoutesResponse.data.filter((route) => {
        const originChainSupported = biconomyChains.find((chain) => chain.chainId === route.originChainId);
        const destinationChainSupported = biconomyChains.find((chain) => chain.chainId === route.destinationChainId);
        const originTokenSupported = moonwellSupportedTokens.find((moonwellToken) => moonwellToken.chainId === route.originChainId &&
            (route.isNative
                ? moonwellToken.address.toLowerCase() === viem_1.zeroAddress &&
                    route.originTokenSymbol.toLowerCase() ===
                        moonwellToken.symbol.toLowerCase()
                : moonwellToken.address.toLowerCase() ===
                    route.originToken.toLowerCase()));
        const destinationTokenSupported = moonwellSupportedTokens.find((moonwellToken) => moonwellToken.chainId === route.destinationChainId &&
            (route.isNative
                ? moonwellToken.address.toLowerCase() === viem_1.zeroAddress &&
                    route.destinationTokenSymbol.toLowerCase() ===
                        moonwellToken.symbol.toLowerCase()
                : moonwellToken.address.toLowerCase() ===
                    route.destinationToken.toLowerCase()));
        return (originTokenSupported &&
            destinationTokenSupported &&
            originChainSupported &&
            destinationChainSupported);
    });
    const tokens = supportedRoutes.map((supportedRoute) => {
        const destinationRoutes = supportedRoutes.filter((route) => route.originChainId === supportedRoute.originChainId &&
            route.originToken.toLowerCase() ===
                supportedRoute.originToken.toLowerCase());
        const originTokenInfo = moonwellSupportedTokens.find((moonwellToken) => (supportedRoute.isNative
            ? moonwellToken.address.toLowerCase() === viem_1.zeroAddress &&
                supportedRoute.originTokenSymbol.toLowerCase() ===
                    moonwellToken.symbol.toLowerCase()
            : moonwellToken.address.toLowerCase() ===
                supportedRoute.originToken.toLowerCase()) &&
            moonwellToken.chainId === supportedRoute.originChainId);
        const originChainInfo = biconomyChains.find((chain) => chain.chainId === supportedRoute.originChainId);
        const originChainGasInfo = biconomyInfoResponse.data.supportedGasTokens
            .find((gas) => gas.chainId === supportedRoute.originChainId)
            ?.paymentTokens.find((gas) => gas.address.toLowerCase() ===
            supportedRoute.originToken.toLowerCase());
        if (destinationRoutes.length > 0 && originTokenInfo && originChainInfo) {
            const routesMap = destinationRoutes.map((destinationRoute) => {
                const destinationTokenInfo = moonwellSupportedTokens.find((moonwellToken) => (destinationRoute.isNative
                    ? moonwellToken.address.toLowerCase() === viem_1.zeroAddress &&
                        destinationRoute.destinationTokenSymbol.toLowerCase() ===
                            moonwellToken.symbol.toLowerCase()
                    : moonwellToken.address.toLowerCase() ===
                        destinationRoute.destinationToken.toLowerCase()) &&
                    moonwellToken.chainId === destinationRoute.destinationChainId);
                const destinationChainInfo = biconomyChains.find((chain) => chain.chainId === destinationRoute.destinationChainId);
                const destinationChainGasInfo = biconomyInfoResponse.data.supportedGasTokens
                    .find((gas) => gas.chainId === destinationRoute.destinationChainId)
                    ?.paymentTokens.find((gas) => gas.address.toLowerCase() ===
                    destinationRoute.destinationToken.toLowerCase());
                if (destinationChainInfo && destinationTokenInfo) {
                    return {
                        chainId: destinationChainInfo.chainId,
                        address: destinationTokenInfo.address,
                        routeTokenAddress: destinationRoute.destinationToken,
                        name: destinationTokenInfo.name,
                        symbol: destinationTokenInfo.symbol,
                        decimals: destinationTokenInfo.decimals,
                        isNative: destinationTokenInfo.address === viem_1.zeroAddress,
                        permitEnabled: destinationChainGasInfo?.permitEnabled === true || false,
                    };
                }
                return undefined;
            });
            const routes = routesMap.filter((route) => route !== undefined);
            const result = {
                chainId: supportedRoute.originChainId,
                address: originTokenInfo.address,
                routeTokenAddress: supportedRoute.originToken,
                name: originTokenInfo.name,
                symbol: originTokenInfo.symbol,
                decimals: originTokenInfo.decimals,
                isNative: originTokenInfo.address === viem_1.zeroAddress,
                permitEnabled: originChainGasInfo?.permitEnabled === true || false,
                routes: dedup(routes),
            };
            return result;
        }
        else {
            return undefined;
        }
    });
    const result = tokens.filter((t) => t !== undefined);
    return dedup(result);
}
function dedup(array) {
    return array.reduce((agg, current) => {
        const x = agg.find((item) => item.chainId === current.chainId &&
            item.routeTokenAddress === current.routeTokenAddress &&
            item.symbol === current.symbol);
        if (!x) {
            return agg.concat([current]);
        }
        else {
            return agg;
        }
    }, []);
}
//# sourceMappingURL=getBeamTokenRoutes.js.map