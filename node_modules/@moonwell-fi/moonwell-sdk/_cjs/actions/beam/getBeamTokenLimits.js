"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBeamTokenLimits = getBeamTokenLimits;
const axios_1 = __importDefault(require("axios"));
const index_js_1 = require("../../common/index.js");
async function getBeamTokenLimits(args) {
    const { direction, route } = args;
    const limits = [];
    for (const path of args.route.routes) {
        const inputToken = direction === "withdraw"
            ? route.routeTokenAddress
            : path.routeTokenAddress;
        const outputToken = direction === "withdraw"
            ? path.routeTokenAddress
            : route.routeTokenAddress;
        const inputChainId = direction === "withdraw" ? route.chainId : path.chainId;
        const outputChainId = direction === "withdraw" ? path.chainId : route.chainId;
        try {
            const acrossLimitsResponse = await axios_1.default.get(`https://app.across.to/api/limits?inputToken=${inputToken}&outputToken=${outputToken}&originChainId=${inputChainId}&destinationChainId=${outputChainId}`);
            limits.push({
                from: {
                    address: direction === "withdraw" ? route.address : path.address,
                    chainId: direction === "withdraw" ? route.chainId : path.chainId,
                    decimals: direction === "withdraw" ? route.decimals : path.decimals,
                    name: direction === "withdraw" ? route.name : path.name,
                    routeTokenAddress: direction === "withdraw"
                        ? route.routeTokenAddress
                        : path.routeTokenAddress,
                    symbol: direction === "withdraw" ? route.symbol : path.symbol,
                },
                to: {
                    address: direction === "withdraw" ? path.address : route.address,
                    chainId: direction === "withdraw" ? path.chainId : route.chainId,
                    decimals: direction === "withdraw" ? path.decimals : route.decimals,
                    name: direction === "withdraw" ? path.name : route.name,
                    routeTokenAddress: direction === "withdraw"
                        ? path.routeTokenAddress
                        : route.routeTokenAddress,
                    symbol: direction === "withdraw" ? path.symbol : route.symbol,
                },
                max: new index_js_1.Amount(BigInt(acrossLimitsResponse.data.maxDepositInstant), route.decimals),
                min: new index_js_1.Amount(BigInt(acrossLimitsResponse.data.minDeposit), route.decimals),
            });
        }
        catch (ex) {
            console.log({
                error: ex,
            });
        }
    }
    return limits;
}
//# sourceMappingURL=getBeamTokenLimits.js.map