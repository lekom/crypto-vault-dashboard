"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUserStakingInfo = getUserStakingInfo;
const chains_1 = require("viem/chains");
const index_js_1 = require("../../common/index.js");
const index_js_2 = require("../../environments/index.js");
const common_js_1 = require("./common.js");
async function getUserStakingInfo(client, args) {
    const { userAddress } = args;
    const environments = (0, index_js_1.getEnvironmentsFromArgs)(client, args);
    const envsWithStaking = environments.filter((env) => env.contracts.stakingToken);
    const envStakingInfo = await Promise.all(envsWithStaking.map(async (environment) => {
        const homeEnvironment = Object.values(index_js_2.publicEnvironments).find((e) => e.custom?.governance?.chainIds?.includes(environment.chainId)) || environment;
        const settled = await Promise.allSettled([
            environment.contracts.views?.read.getUserStakingInfo([userAddress]),
            environment.contracts.governanceToken?.read.balanceOf([userAddress]),
            homeEnvironment.contracts.views?.read.getGovernanceTokenPrice(),
            environment.contracts.views?.read.getStakingInfo(),
        ]);
        return settled.map((s) => s.status === "fulfilled" ? s.value : undefined);
    }));
    const merklRewards = await (0, common_js_1.getMerklRewardsData)([
        "0xcd60ff26dc0b43f14c995c494bc5650087eaae68b279bdbe85e0e8eaa11fd513",
        "0xf2c5b7dd2d3416d3853bcf1e93c1cfdb7b5b5fda079d36408df02f731f7d1499",
    ], chains_1.base.id, userAddress);
    const result = envsWithStaking.flatMap((curr, index) => {
        const token = curr.config.tokens[curr.config.contracts.governanceToken];
        const stakingToken = curr.config.tokens[curr.config.contracts.stakingToken];
        const userStakingInfoData = envStakingInfo[index][0];
        const { cooldown, pendingRewards, totalStaked } = userStakingInfoData;
        const isBase = curr.chainId === chains_1.base.id;
        const merklReward = merklRewards.reduce((acc, r) => {
            if (r.chain === curr.chainId) {
                return acc + BigInt(r.amount) - BigInt(r.claimed);
            }
            return acc;
        }, 0n);
        const merklPendingRewards = isBase ? merklReward : 0n;
        const tokenBalance = envStakingInfo[index][1];
        const governanceTokenPriceRaw = envStakingInfo[index]?.[2];
        const stakingInfoData = envStakingInfo[index]?.[3];
        const { cooldown: cooldownSeconds, unstakeWindow } = stakingInfoData;
        const cooldownEnding = cooldown > 0n ? cooldown + cooldownSeconds : 0n;
        const unstakingEnding = cooldown > 0n ? cooldown + cooldownSeconds + unstakeWindow : 0n;
        const governanceTokenPrice = new index_js_1.Amount(governanceTokenPriceRaw, 18);
        const userStakingInfo = {
            chainId: curr.chainId,
            cooldownActive: cooldown > 0n,
            cooldownStart: Number(cooldown),
            cooldownEnding: Number(cooldownEnding),
            unstakingStart: Number(cooldownEnding),
            unstakingEnding: Number(unstakingEnding),
            pendingRewards: isBase
                ? new index_js_1.Amount(merklPendingRewards, 18)
                : new index_js_1.Amount(pendingRewards, 18),
            token,
            tokenBalance: new index_js_1.Amount(tokenBalance, 18),
            tokenPrice: governanceTokenPrice.value,
            stakingToken,
            stakingTokenBalance: new index_js_1.Amount(totalStaked, 18),
        };
        return userStakingInfo;
    });
    return result;
}
//# sourceMappingURL=getUserStakingInfo.js.map