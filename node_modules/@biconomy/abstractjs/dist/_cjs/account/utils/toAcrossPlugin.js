"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toAcrossPlugin = exports.acrossEncodeBridgingUserOp = void 0;
const abitype_1 = require("abitype");
const viem_1 = require("viem");
const chains_1 = require("viem/chains");
const createHttpClient_1 = require("../../clients/createHttpClient.js");
const TESTNET_IDS = [
    chains_1.sepolia.id,
    chains_1.baseSepolia.id,
    chains_1.optimismSepolia.id,
    chains_1.arbitrumSepolia.id
];
const acrossClient = (0, createHttpClient_1.createHttpClient)("https://app.across.to/api");
const testnetAcrossClient = (0, createHttpClient_1.createHttpClient)("https://testnet.across.to/api");
const acrossGetSuggestedFees = async ({ inputToken, outputToken, originChainId, destinationChainId, amount }) => {
    const client = TESTNET_IDS.includes(originChainId)
        ? testnetAcrossClient
        : acrossClient;
    return client.request({
        path: "suggested-fees",
        method: "GET",
        params: {
            inputToken,
            outputToken,
            originChainId: originChainId.toString(),
            destinationChainId: destinationChainId.toString(),
            amount: amount.toString()
        }
    });
};
const acrossEncodeBridgingUserOp = async (params) => {
    const { bridgingAmount, fromChainId, depositor, recipient, toChainId, tokenMapping } = params;
    const inputToken = tokenMapping.on(fromChainId);
    const outputToken = tokenMapping.on(toChainId);
    const suggestedFees = await acrossGetSuggestedFees({
        amount: bridgingAmount,
        destinationChainId: toChainId,
        inputToken: inputToken,
        outputToken: outputToken,
        originChainId: fromChainId
    });
    const depositV3abi = (0, abitype_1.parseAbi)([
        "function depositV3(address depositor, address recipient, address inputToken, address outputToken, uint256 inputAmount, uint256 outputAmount, uint256 destinationChainId, address exclusiveRelayer, uint32 quoteTimestamp, uint32 fillDeadline, uint32 exclusivityDeadline, bytes message) external"
    ]);
    const outputAmount = BigInt(bridgingAmount) - BigInt(suggestedFees.totalRelayFee.total);
    const fillDeadlineBuffer = 18000;
    const fillDeadline = Math.round(Date.now() / 1000) + fillDeadlineBuffer;
    const approveCall = {
        to: inputToken,
        gasLimit: 100000n,
        data: (0, viem_1.encodeFunctionData)({
            abi: viem_1.erc20Abi,
            functionName: "approve",
            args: [suggestedFees.spokePoolAddress, bridgingAmount]
        })
    };
    const depositCall = {
        to: suggestedFees.spokePoolAddress,
        gasLimit: 1500n,
        data: (0, viem_1.encodeFunctionData)({
            abi: depositV3abi,
            args: [
                depositor,
                recipient,
                inputToken,
                outputToken,
                bridgingAmount,
                outputAmount,
                BigInt(toChainId),
                suggestedFees.exclusiveRelayer,
                Number.parseInt(suggestedFees.timestamp),
                fillDeadline,
                Number.parseInt(suggestedFees.exclusivityDeadline),
                "0x"
            ]
        })
    };
    const userOp = {
        calls: [approveCall, depositCall],
        chainId: fromChainId,
        metadata: [
            {
                type: "BRIDGE",
                fromAddress: depositor,
                toAddress: recipient,
                fromTokenAddress: inputToken,
                toTokenAddress: outputToken,
                amount: bridgingAmount,
                fromChainId: fromChainId,
                toChainId: toChainId,
                protocolNames: ["Across"]
            }
        ]
    };
    return {
        userOp,
        receivedAtDestination: outputAmount,
        bridgingDurationExpectedMs: undefined
    };
};
exports.acrossEncodeBridgingUserOp = acrossEncodeBridgingUserOp;
const toAcrossPlugin = () => ({
    encodeBridgeUserOp: async (params) => {
        return await (0, exports.acrossEncodeBridgingUserOp)(params);
    }
});
exports.toAcrossPlugin = toAcrossPlugin;
//# sourceMappingURL=toAcrossPlugin.js.map