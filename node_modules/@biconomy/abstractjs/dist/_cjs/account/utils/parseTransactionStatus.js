"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseTransactionStatus = exports.FINAL_STATUSES = void 0;
exports.FINAL_STATUSES = ["FAILED", "MINED_SUCCESS", "MINED_FAIL"];
const parseTransactionStatus = async (userOps, mode = "default") => {
    if (!userOps || userOps.length === 0) {
        return {
            status: "PENDING",
            isFinalised: false,
            message: ""
        };
    }
    const userOpsWithoutPaymentAndCleanup = userOps.filter((usop) => !usop.isCleanUpUserOp);
    const statusMap = {
        hasFailedOps: userOpsWithoutPaymentAndCleanup.some((userOp) => userOp.executionStatus === "FAILED"),
        hasMinedFailOps: userOpsWithoutPaymentAndCleanup.some((userOp) => {
            if (mode === "default") {
                return userOp.executionStatus === "MINED_FAIL" && userOp.isConfirmed;
            }
            return userOp.executionStatus === "MINED_FAIL";
        }),
        hasPendingOps: userOpsWithoutPaymentAndCleanup.some((userOp) => userOp.executionStatus === "PENDING"),
        hasMiningOps: userOpsWithoutPaymentAndCleanup.some((userOp) => userOp.executionStatus === "MINING"),
        allMinedSuccess: userOpsWithoutPaymentAndCleanup.every((userOp) => {
            if (mode === "default") {
                return userOp.executionStatus === "MINED_SUCCESS" && userOp.isConfirmed;
            }
            return userOp.executionStatus === "MINED_SUCCESS";
        }),
        allFinalised: userOpsWithoutPaymentAndCleanup.every((userOp) => {
            if (mode === "default") {
                return (userOp.executionStatus === "FAILED" ||
                    (userOp.executionStatus === "MINED_FAIL" && userOp.isConfirmed) ||
                    (userOp.executionStatus === "MINED_SUCCESS" && userOp.isConfirmed));
            }
            return (userOp.executionStatus === "FAILED" ||
                userOp.executionStatus === "MINED_FAIL" ||
                userOp.executionStatus === "MINED_SUCCESS");
        })
    };
    let status = "PENDING";
    let message = "";
    if (statusMap.hasFailedOps) {
        status = "FAILED";
        const failedUserOpIndex = userOpsWithoutPaymentAndCleanup.findIndex((userOp) => userOp.executionStatus === status);
        const failedUserOp = userOpsWithoutPaymentAndCleanup[failedUserOpIndex];
        message = `[${failedUserOpIndex}] ${failedUserOp?.executionError || "Transaction failed off-chain"}`;
    }
    else if (statusMap.hasMinedFailOps) {
        status = "MINED_FAIL";
        const minedFailUserOpIndex = userOpsWithoutPaymentAndCleanup.findIndex((userOp) => userOp.executionStatus === status);
        const minedFailUserOp = userOpsWithoutPaymentAndCleanup[minedFailUserOpIndex];
        message = `[${minedFailUserOpIndex}] ${minedFailUserOp?.executionError || "Transaction failed on-chain"}`;
    }
    else if (statusMap.hasMiningOps) {
        status = "MINING";
        const pendingUserOpIndex = userOpsWithoutPaymentAndCleanup.findIndex((userOp) => userOp.executionStatus === status);
        message = `[${pendingUserOpIndex}] Transaction is mining, waiting for blockchain confirmation`;
    }
    else if (statusMap.hasPendingOps) {
        status = "PENDING";
        const pendingUserOpIndex = userOpsWithoutPaymentAndCleanup.findIndex((userOp) => userOp.executionStatus === status);
        const pendingUserOp = userOpsWithoutPaymentAndCleanup[pendingUserOpIndex];
        message = `[${pendingUserOpIndex}] ${pendingUserOp?.executionError || "Transaction is pending, waiting for conditions to be met"}`;
    }
    else if (statusMap.allMinedSuccess) {
        status = "MINED_SUCCESS";
        const minedSuccessUserOpIndex = userOpsWithoutPaymentAndCleanup.findIndex((userOp) => userOp.executionStatus === status);
        message = `[${minedSuccessUserOpIndex}] Transaction executed successfully`;
    }
    const isFinalised = statusMap.allFinalised ||
        statusMap.hasFailedOps ||
        statusMap.hasMinedFailOps;
    return {
        status,
        isFinalised,
        message
    };
};
exports.parseTransactionStatus = parseTransactionStatus;
exports.default = exports.parseTransactionStatus;
//# sourceMappingURL=parseTransactionStatus.js.map