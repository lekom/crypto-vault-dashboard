"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LARGE_DEFAULT_GAS_LIMIT = void 0;
exports.getMultichainContract = getMultichainContract;
const viem_1 = require("viem");
exports.LARGE_DEFAULT_GAS_LIMIT = 700000n;
function createChainSpecificContract(abi, chainId, address) {
    return new Proxy({}, {
        get: (_, prop) => {
            if (!abi.some((item) => item.type === "function" && item.name === prop)) {
                throw new Error(`Function ${prop} not found in ABI`);
            }
            return ({ args, gasLimit = exports.LARGE_DEFAULT_GAS_LIMIT, value = 0n }) => {
                const params = {
                    abi,
                    functionName: prop,
                    args
                };
                const data = (0, viem_1.encodeFunctionData)(params);
                const call = {
                    to: address,
                    gasLimit,
                    value,
                    data
                };
                return {
                    calls: [call],
                    chainId
                };
            };
        }
    });
}
function getMultichainContract(config) {
    const deployments = new Map(config.deployments.map((deployment) => {
        const [address, chainId] = deployment;
        return [chainId, address];
    }));
    return {
        abi: config.abi,
        deployments,
        on: (chainId) => {
            const address = deployments.get(chainId);
            if (!address) {
                throw new Error(`No deployment found for chain ${chainId}`);
            }
            return createChainSpecificContract(config.abi, chainId, address);
        },
        build: async (params) => {
            const { data: { chainId, args: args_, gasLimit }, type: functionName } = params;
            const address = deployments.get(chainId);
            if (!address) {
                throw new Error(`No deployment found for chain ${chainId}`);
            }
            const result = createChainSpecificContract(config.abi, chainId, address)[functionName]({
                args: args_,
                ...(gasLimit ? { gasLimit } : {})
            });
            return {
                chainId: chainId,
                calls: result.calls
            };
        },
        addressOn: (chainId) => {
            const address = deployments.get(chainId);
            if (!address) {
                throw new Error(`No deployment found for chain ${chainId}`);
            }
            return address;
        },
        read: async (params) => {
            const abiFunction = config.abi.find((item) => item.type === "function" &&
                item.name === params.functionName &&
                (item.stateMutability === "view" || item.stateMutability === "pure"));
            if (!abiFunction) {
                throw new Error(`Function ${params.functionName} not found in ABI or is not a read function`);
            }
            const results = await Promise.all(params.onChains.map(async (chain) => {
                const address = deployments.get(chain.id);
                if (!address) {
                    throw new Error(`No deployment found for chain ${chain.id}`);
                }
                const deployment = params.account.deploymentOn(chain.id);
                if (!deployment) {
                    throw new Error(`No deployment found for chain ${chain.id}`);
                }
                const client = deployment.client;
                const result = await client.readContract({
                    address,
                    abi: config.abi,
                    functionName: params.functionName,
                    args: params.args
                });
                return {
                    chainId: chain.id,
                    result: result
                };
            }));
            return results;
        }
    };
}
//# sourceMappingURL=getMultichainContract.js.map