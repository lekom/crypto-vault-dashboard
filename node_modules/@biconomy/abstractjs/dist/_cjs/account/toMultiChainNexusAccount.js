"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toMultichainNexusAccount = toMultichainNexusAccount;
const toNexusAccount_1 = require("./toNexusAccount.js");
const build_1 = require("./decorators/build.js");
const buildBridgeInstructions_1 = require("./decorators/buildBridgeInstructions.js");
const getUnifiedERC20Balance_1 = require("./decorators/getUnifiedERC20Balance.js");
const isDelegated_1 = require("./decorators/isDelegated.js");
const multichainRead_1 = require("./decorators/multichainRead.js");
const queryBridge_1 = require("./decorators/queryBridge.js");
const unDelegate_1 = require("./decorators/unDelegate.js");
const waitForTransactionReceipts_1 = require("./decorators/waitForTransactionReceipts.js");
async function toMultichainNexusAccount(multiChainNexusParams) {
    const { signer: unresolvedSigner, chainConfigurations, ...accountParameters } = multiChainNexusParams;
    if (chainConfigurations.length === 0) {
        throw new Error("No chain configuration provided");
    }
    const deployments = await Promise.all(chainConfigurations.map((chainConfiguration) => (0, toNexusAccount_1.toNexusAccount)({
        signer: unresolvedSigner,
        chainConfiguration,
        ...accountParameters
    })));
    function deploymentOn(chainId, strictMode) {
        const deployment = deployments.find((dep) => dep.client.chain?.id === chainId);
        if (!deployment && strictMode) {
            throw new Error(`Deployment not found for chainId: ${chainId}`);
        }
        return deployment;
    }
    function addressOn(chainId, strictMode) {
        const deployment = deploymentOn(chainId, strictMode);
        return deployment?.address;
    }
    const meeVersions = deployments.map(({ version, chain }) => ({
        chainId: chain.id,
        version
    }));
    const baseAccount = {
        signer: deployments[0].signer,
        deployments,
        deploymentOn,
        addressOn
    };
    const getUnifiedERC20Balance = (mcToken) => (0, getUnifiedERC20Balance_1.getUnifiedERC20Balance)({ mcToken, account: baseAccount });
    const build = (params, currentInstructions) => (0, build_1.build)({
        currentInstructions,
        accountAddress: baseAccount.signer.address,
        meeVersions
    }, params);
    const buildComposable = (params, currentInstructions) => {
        let composabilityVersion = undefined;
        let chainId = undefined;
        const type = params.type;
        if (type === "acrossIntent") {
            chainId = params.data.originChainId;
        }
        else if (type !== "batch") {
            chainId = params.data.chainId;
        }
        if (chainId) {
            composabilityVersion = getComposabilityVersion(chainId);
        }
        return (0, build_1.buildComposable)({
            currentInstructions,
            accountAddress: baseAccount.signer.address,
            meeVersions
        }, params, composabilityVersion);
    };
    const buildBridgeInstructions = (params) => (0, buildBridgeInstructions_1.buildBridgeInstructions)({ ...params });
    const queryBridge = (params) => (0, queryBridge_1.queryBridge)({ ...params });
    const isDelegated = (parameters) => (0, isDelegated_1.isDelegated)({ ...parameters, account: baseAccount });
    const unDelegate = (parameters) => (0, unDelegate_1.unDelegate)({ ...parameters, account: baseAccount });
    const waitForTransactionReceipts = (parameters) => (0, waitForTransactionReceipts_1.waitForTransactionReceipts)({ ...parameters, account: baseAccount });
    const getComposabilityVersion = (chainId) => {
        const chainConfiguration = chainConfigurations.find((chainConfiguration) => chainConfiguration.chain.id === chainId);
        if (!chainConfiguration) {
            throw new Error(`Chain configuration not found in mc account for chainId: ${chainId} that is used in the instruction params`);
        }
        return chainConfiguration.version.composabilityVersion;
    };
    const read = (params) => (0, multichainRead_1.default)(baseAccount, params);
    const toDelegation = async () => await deployments[0].toDelegation({ multiChain: true });
    return {
        ...baseAccount,
        getUnifiedERC20Balance,
        build,
        buildComposable,
        buildBridgeInstructions,
        queryBridge,
        isDelegated,
        getComposabilityVersion,
        unDelegate,
        waitForTransactionReceipts,
        read,
        toDelegation
    };
}
//# sourceMappingURL=toMultiChainNexusAccount.js.map