"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildComposableUtil = exports.formatCallDataInputParamsWithVersion = exports.formatComposableCallWithVersion = exports.buildComposableCall = void 0;
const viem_1 = require("viem");
const utils_1 = require("../../../account/utils/index.js");
const constants_1 = require("../../../constants/index.js");
const Helpers_1 = require("../../../modules/utils/Helpers.js");
const composabilityCalls_1 = require("../../../modules/utils/composabilityCalls.js");
const composabilityCalls_2 = require("../../../modules/utils/composabilityCalls.js");
const conditions_1 = require("../../../modules/utils/conditions.js");
const runtimeAbiEncoding_1 = require("../../../modules/utils/runtimeAbiEncoding.js");
const runtimeAbiEncoding_2 = require("../../../modules/utils/runtimeAbiEncoding.js");
const buildComposableCall = async (parameters, composabilityParameters) => {
    const { to, gasLimit, value, functionName, args, abi, conditions } = parameters;
    const { efficientMode = true, composabilityVersion } = composabilityParameters;
    if (!composabilityVersion) {
        throw new Error(`Composability version is required to build a composable call.
      This error may be caused by using a non-composable .build decorator with a composable call.
      Please use buildComposable instead.`);
    }
    if (!functionName || !args) {
        throw new Error("Invalid params for composable call");
    }
    if (!abi) {
        throw new Error("Invalid ABI");
    }
    if (args.length <= 0) {
        throw new Error("Composable call is not required for a instruction which has zero args");
    }
    const functionContext = (0, runtimeAbiEncoding_1.getFunctionContextFromAbi)(functionName, abi);
    if (functionContext?.inputs?.length !== args?.length) {
        throw new Error(`Invalid arguments for the ${functionName} function`);
    }
    const versionAgnosticComposableInputParams = (0, composabilityCalls_1.prepareComposableInputCalldataParams)([...functionContext.inputs], args);
    const allInputParams = conditions?.length
        ? [
            ...versionAgnosticComposableInputParams,
            ...conditions.map(conditions_1.createConditionInputParam)
        ]
        : versionAgnosticComposableInputParams;
    const composableCall = (0, exports.formatComposableCallWithVersion)(composabilityVersion, efficientMode, allInputParams, functionContext.functionSig, to, value, gasLimit);
    return [composableCall];
};
exports.buildComposableCall = buildComposableCall;
const formatComposableCallWithVersion = (composabilityVersion, efficientMode, versionAgnosticComposableInputParams, functionSig, to, value, gasLimit) => {
    let composableCall;
    if (composabilityVersion === constants_1.ComposabilityVersion.V1_0_0) {
        if ((0, composabilityCalls_2.isRuntimeComposableValue)(to)) {
            throw new Error("Runtime injected target is not supported for Composability v1.0.0");
        }
        if (!(0, viem_1.isAddress)(to)) {
            throw new Error("Invalid target contract address");
        }
        if ((0, composabilityCalls_2.isRuntimeComposableValue)(value)) {
            throw new Error("Runtime injected value is not supported for Composability v1.0.0");
        }
        composableCall = {
            to: to,
            value: value ?? BigInt(0),
            functionSig,
            inputParams: (0, exports.formatCallDataInputParamsWithVersion)(composabilityVersion, efficientMode, versionAgnosticComposableInputParams),
            outputParams: [],
            ...(gasLimit ? { gasLimit } : {})
        };
    }
    else {
        const callDataInputParams = (0, exports.formatCallDataInputParamsWithVersion)(composabilityVersion, efficientMode, versionAgnosticComposableInputParams);
        const { targetInputParam, valueInputParam } = prepareTargetAndValueInputParams(to, value);
        const inputParams = [
            ...callDataInputParams,
            targetInputParam,
            ...(valueInputParam ? [valueInputParam] : [])
        ];
        composableCall = {
            functionSig,
            inputParams: inputParams,
            outputParams: [],
            ...(gasLimit ? { gasLimit } : {})
        };
    }
    return composableCall;
};
exports.formatComposableCallWithVersion = formatComposableCallWithVersion;
const formatCallDataInputParamsWithVersion = (composabilityVersion, efficientMode, versionAgnosticInputParams) => {
    const compressedVersionAgnosticInputParams = efficientMode
        ? compressCalldataInputParams(versionAgnosticInputParams)
        : versionAgnosticInputParams;
    if (composabilityVersion === constants_1.ComposabilityVersion.V1_0_0) {
        return compressedVersionAgnosticInputParams.map((param) => {
            if (param.fetcherType === composabilityCalls_1.InputParamFetcherType.BALANCE) {
                const tokenAddress = `0x${param.paramData.slice(2, 42)}`;
                const targetAddress = `0x${param.paramData.slice(42, 82)}`;
                if ((0, utils_1.isNativeToken)(tokenAddress)) {
                    throw new Error("Native token balance as a runtime value is not supported for Composability v1.0.0");
                }
                const encodedParam = (0, viem_1.encodeAbiParameters)([{ type: "address" }, { type: "bytes" }], [
                    tokenAddress,
                    (0, viem_1.encodeFunctionData)({
                        abi: viem_1.erc20Abi,
                        functionName: "balanceOf",
                        args: [targetAddress]
                    })
                ]);
                return (0, composabilityCalls_1.prepareInputParam)(composabilityCalls_1.InputParamFetcherType.STATIC_CALL, encodedParam, param.constraints);
            }
            return param;
        });
    }
    return compressedVersionAgnosticInputParams.map((param) => ({
        ...param,
        paramType: composabilityCalls_1.InputParamType.CALL_DATA
    }));
};
exports.formatCallDataInputParamsWithVersion = formatCallDataInputParamsWithVersion;
const buildComposableUtil = async (baseParams, parameters, composabilityParams) => {
    const { currentInstructions = [] } = baseParams;
    const { metadata } = parameters;
    const calls = await (0, exports.buildComposableCall)(parameters, composabilityParams);
    const defaultMetadata = [
        {
            type: "CUSTOM",
            description: `${(0, Helpers_1.functionNameToLabel)(parameters.functionName)} on-chain action`,
            chainId: parameters.chainId
        }
    ];
    return [
        ...currentInstructions,
        {
            calls: calls,
            chainId: parameters.chainId,
            isComposable: true,
            metadata: metadata || defaultMetadata
        }
    ];
};
exports.buildComposableUtil = buildComposableUtil;
exports.default = exports.buildComposableUtil;
const compressCalldataInputParams = (inputParams) => {
    const compressedParams = [];
    let currentParam = {
        fetcherType: composabilityCalls_1.InputParamFetcherType.RAW_BYTES,
        constraints: [],
        paramData: ""
    };
    for (const param of inputParams) {
        if (param.paramType === composabilityCalls_1.InputParamType.TARGET ||
            param.paramType === composabilityCalls_1.InputParamType.VALUE) {
            throw new Error("Target or value input params should not be compressed");
        }
        if (param.fetcherType === composabilityCalls_1.InputParamFetcherType.STATIC_CALL ||
            param.fetcherType === composabilityCalls_1.InputParamFetcherType.BALANCE ||
            param.constraints.length > 0) {
            if (currentParam.paramData.length > 0) {
                compressedParams.push(currentParam);
                currentParam = {
                    fetcherType: composabilityCalls_1.InputParamFetcherType.RAW_BYTES,
                    constraints: [],
                    paramData: ""
                };
            }
            compressedParams.push(param);
            continue;
        }
        currentParam.paramData = (0, viem_1.concatHex)([
            currentParam.paramData,
            param.paramData
        ]);
    }
    if (currentParam.paramData.length > 0) {
        compressedParams.push(currentParam);
    }
    return compressedParams;
};
const prepareTargetAndValueInputParams = (to, value) => {
    let targetInputParam;
    if ((0, viem_1.isAddress)(to)) {
        targetInputParam = {
            paramType: composabilityCalls_1.InputParamType.TARGET,
            fetcherType: composabilityCalls_1.InputParamFetcherType.RAW_BYTES,
            paramData: (0, runtimeAbiEncoding_2.encodeAddress)(to).data[0],
            constraints: []
        };
    }
    else {
        targetInputParam = {
            ...to.inputParams[0],
            paramType: composabilityCalls_1.InputParamType.TARGET
        };
    }
    let valueInputParam;
    if (!value) {
        valueInputParam = undefined;
    }
    else if (value.isRuntime &&
        value.inputParams.length > 0) {
        valueInputParam = {
            ...value.inputParams[0],
            paramType: composabilityCalls_1.InputParamType.VALUE
        };
    }
    else {
        if (value !== 0n) {
            valueInputParam = {
                paramType: composabilityCalls_1.InputParamType.VALUE,
                fetcherType: composabilityCalls_1.InputParamFetcherType.RAW_BYTES,
                paramData: value
                    .toString(16)
                    .padStart(64, "0"),
                constraints: []
            };
        }
    }
    return { targetInputParam, valueInputParam };
};
//# sourceMappingURL=buildComposable.js.map