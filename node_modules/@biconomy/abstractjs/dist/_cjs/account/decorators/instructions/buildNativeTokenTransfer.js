"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildNativeTokenTransfer = void 0;
const viem_1 = require("viem");
const constants_1 = require("../../../constants/index.js");
const modules_1 = require("../../../modules/index.js");
const buildComposable_1 = require("./buildComposable.js");
const buildNativeTokenTransfer = async (baseParams, parameters, composabilityParams) => {
    const { currentInstructions = [], accountAddress, meeVersions } = baseParams;
    const { chainId, value, gasLimit, to, metadata: metadataOverride } = parameters;
    const { forceComposableEncoding } = composabilityParams ?? {
        forceComposableEncoding: false
    };
    const [meeVersionInfo] = meeVersions.filter((meeVersion) => meeVersion.chainId === chainId);
    if (!meeVersionInfo) {
        throw new Error("MEE version is required to build a native token transfer");
    }
    const meeVersion = meeVersionInfo.version;
    const isRuntimeValues = [value, to].some((val) => (0, modules_1.isRuntimeComposableValue)(val));
    const isComposableCall = forceComposableEncoding ? true : isRuntimeValues;
    let instructions;
    if (isComposableCall) {
        if (!composabilityParams?.composabilityVersion) {
            throw new Error("Composability version is required to build a composable native token transfer instruction");
        }
        if (isRuntimeValues &&
            composabilityParams.composabilityVersion === constants_1.ComposabilityVersion.V1_0_0) {
            throw new Error("Runtime values for Native tokens are not supported for Composability v1.0.0");
        }
        const metadata = [
            {
                type: "TRANSFER",
                tokenAddress: viem_1.zeroAddress,
                fromAddress: accountAddress,
                toAddress: (0, modules_1.isRuntimeComposableValue)(to)
                    ? "RUNTIME_VALUE"
                    : to,
                amount: (0, modules_1.isRuntimeComposableValue)(value)
                    ? "RUNTIME_VALUE"
                    : value,
                chainId: chainId
            }
        ];
        instructions = await (0, buildComposable_1.default)(baseParams, {
            to: meeVersion.ethForwarderAddress,
            abi: constants_1.ForwarderAbi,
            functionName: "forward",
            gasLimit,
            value,
            args: [to],
            chainId,
            metadata: metadataOverride || metadata
        }, composabilityParams);
    }
    else {
        const metadata = [
            {
                type: "TRANSFER",
                tokenAddress: viem_1.zeroAddress,
                fromAddress: accountAddress,
                toAddress: to,
                amount: value,
                chainId: chainId
            }
        ];
        instructions = [
            {
                calls: [
                    {
                        to: to,
                        value: value,
                        data: "0x"
                    }
                ],
                metadata: metadataOverride || metadata,
                isComposable: false,
                chainId
            }
        ];
    }
    return [...currentInstructions, ...instructions];
};
exports.buildNativeTokenTransfer = buildNativeTokenTransfer;
exports.default = exports.buildNativeTokenTransfer;
//# sourceMappingURL=buildNativeTokenTransfer.js.map