"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildWithdrawal = void 0;
const viem_1 = require("viem");
const constants_1 = require("../../../constants/index.js");
const TokenWithPermitAbi_1 = require("../../../constants/abi/TokenWithPermitAbi.js");
const composabilityCalls_1 = require("../../../modules/utils/composabilityCalls.js");
const runtimeAbiEncoding_1 = require("../../../modules/utils/runtimeAbiEncoding.js");
const utils_1 = require("../../utils/index.js");
const buildComposable_1 = require("./buildComposable.js");
const buildWithdrawal = async (baseParams, parameters, composabilityParams) => {
    const { currentInstructions = [], accountAddress, meeVersions } = baseParams;
    const { chainId, tokenAddress, amount, gasLimit, recipient = accountAddress, metadata: metadataOverride } = parameters;
    const [meeVersionInfo] = meeVersions.filter((meeVersion) => meeVersion.chainId === chainId);
    if (!meeVersionInfo) {
        throw new Error("MEE version is required to build a native token transfer");
    }
    const meeVersion = meeVersionInfo.version;
    const { forceComposableEncoding = false } = composabilityParams ?? {
        forceComposableEncoding: false
    };
    const metadata = metadataOverride || [
        {
            type: "WITHDRAW",
            tokenAddress: (0, composabilityCalls_1.isRuntimeComposableValue)(tokenAddress)
                ? "RUNTIME_VALUE"
                : tokenAddress,
            fromAddress: accountAddress,
            toAddress: recipient,
            amount: (0, composabilityCalls_1.isRuntimeComposableValue)(amount)
                ? "RUNTIME_VALUE"
                : amount,
            chainId
        }
    ];
    let withdrawalCall;
    if ((0, utils_1.isNativeToken)(tokenAddress)) {
        if ((0, composabilityCalls_1.isRuntimeComposableValue)(amount) || forceComposableEncoding) {
            if (!composabilityParams?.composabilityVersion) {
                throw new Error("Composability version is required to build a call with the runtime injected param");
            }
            const { composabilityVersion } = composabilityParams;
            if (composabilityVersion === constants_1.ComposabilityVersion.V1_0_0) {
                throw new Error("Runtime values for Native tokens are not supported for Composability v1.0.0");
            }
            return (0, buildComposable_1.default)(baseParams, {
                to: meeVersion.ethForwarderAddress,
                abi: constants_1.ForwarderAbi,
                functionName: "forward",
                value: amount,
                gasLimit,
                args: [recipient],
                chainId,
                metadata: metadataOverride || metadata
            }, composabilityParams);
        }
        withdrawalCall = [
            {
                to: recipient,
                value: amount,
                ...(gasLimit ? { gasLimit } : {})
            }
        ];
    }
    else {
        const abi = TokenWithPermitAbi_1.TokenWithPermitAbi;
        const functionSig = "transfer";
        const args = [
            recipient,
            amount
        ];
        const functionContext = (0, runtimeAbiEncoding_1.getFunctionContextFromAbi)(functionSig, abi);
        const isComposableCall = forceComposableEncoding
            ? true
            : (0, composabilityCalls_1.isComposableCallRequired)(functionContext, args);
        if (isComposableCall) {
            if (!composabilityParams) {
                throw new Error("Composability params are required to build a call with the runtime injected param");
            }
            const composableCallParams = {
                to: tokenAddress,
                functionName: functionSig,
                args: args,
                abi,
                chainId,
                ...(gasLimit ? { gasLimit } : {})
            };
            withdrawalCall = await (0, buildComposable_1.buildComposableCall)(composableCallParams, composabilityParams);
            return [
                ...currentInstructions,
                {
                    calls: withdrawalCall,
                    chainId,
                    isComposable: true,
                    metadata
                }
            ];
        }
        withdrawalCall = [
            {
                to: tokenAddress,
                data: (0, viem_1.encodeFunctionData)({
                    abi,
                    functionName: functionSig,
                    args: args
                }),
                ...(gasLimit ? { gasLimit } : {})
            }
        ];
    }
    return [
        ...currentInstructions,
        {
            calls: withdrawalCall,
            chainId,
            metadata
        }
    ];
};
exports.buildWithdrawal = buildWithdrawal;
exports.default = exports.buildWithdrawal;
//# sourceMappingURL=buildWithdrawal.js.map