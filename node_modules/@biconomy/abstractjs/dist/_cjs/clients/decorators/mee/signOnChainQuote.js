"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signOnChainQuote = exports.formatSignedOnChainQuotePayload = exports.prepareExecutableOnChainQuotePayload = exports.ON_CHAIN_PREFIX = exports.FUSION_NATIVE_TRANSFER_PREFIX = void 0;
const viem_1 = require("viem");
const viem_2 = require("viem");
const ForwarderAbi_1 = require("../../../constants/abi/ForwarderAbi.js");
exports.FUSION_NATIVE_TRANSFER_PREFIX = "0x150b7a02";
exports.ON_CHAIN_PREFIX = "0x177eee01";
const generateTriggerCallFromTrigger = async ({ trigger, spender, recipient, version }) => {
    let triggerCall;
    if (trigger.call) {
        triggerCall = trigger.call;
    }
    else if (trigger.tokenAddress === viem_1.zeroAddress) {
        const forwardCalldata = (0, viem_2.encodeFunctionData)({
            abi: ForwarderAbi_1.ForwarderAbi,
            functionName: "forward",
            args: [recipient]
        });
        const ethForwardCall = {
            to: version.ethForwarderAddress,
            data: forwardCalldata,
            value: trigger.amount
        };
        triggerCall = ethForwardCall;
    }
    else {
        if (trigger.approvalAmount &&
            trigger.amount !== undefined &&
            trigger.approvalAmount < trigger.amount) {
            throw new Error(`Approval amount must be bigger or equal with the amount from the trigger (triggerAmount: ${trigger.amount} amount: ${trigger.approvalAmount})`);
        }
        const amount = trigger.approvalAmount ?? trigger.amount;
        if (!amount)
            throw new Error("Invalid trigger amount");
        const approveCall = {
            to: trigger.tokenAddress,
            data: (0, viem_2.encodeFunctionData)({
                abi: viem_1.erc20Abi,
                functionName: "approve",
                args: [spender, amount]
            })
        };
        triggerCall = approveCall;
    }
    return triggerCall;
};
const prepareExecutableOnChainQuotePayload = async (quoteParams, spender, recipient, version) => {
    const { quote, trigger } = quoteParams;
    const triggerCall = await generateTriggerCallFromTrigger({
        trigger,
        spender,
        recipient,
        version
    });
    const dataOrPrefix = triggerCall?.data ?? exports.FUSION_NATIVE_TRANSFER_PREFIX;
    const call = { ...triggerCall, data: (0, viem_1.concatHex)([dataOrPrefix, quote.hash]) };
    return {
        executablePayload: call,
        metadata: {}
    };
};
exports.prepareExecutableOnChainQuotePayload = prepareExecutableOnChainQuotePayload;
const formatSignedOnChainQuotePayload = (quoteParams, _metadata, hash) => {
    const { quote, trigger } = quoteParams;
    const signature = (0, viem_1.concatHex)([
        exports.ON_CHAIN_PREFIX,
        (0, viem_1.encodeAbiParameters)([{ type: "bytes32" }, { type: "uint256" }], [hash, BigInt(trigger.chainId)])
    ]);
    return {
        ...quote,
        signature
    };
};
exports.formatSignedOnChainQuotePayload = formatSignedOnChainQuotePayload;
const signOnChainQuote = async (client, params) => {
    const { confirmations = 2, companionAccount: account_ = client.account, fusionQuote: { trigger } } = params;
    const { walletClient, address: spender, version } = account_.deploymentOn(trigger.chainId, true);
    const recipient = trigger.recipientAddress || spender;
    const { executablePayload, metadata } = await (0, exports.prepareExecutableOnChainQuotePayload)(params.fusionQuote, spender, recipient, version);
    const hash = await walletClient.sendTransaction(executablePayload);
    await walletClient.waitForTransactionReceipt({ hash, confirmations });
    return (0, exports.formatSignedOnChainQuotePayload)(params.fusionQuote, metadata, hash);
};
exports.signOnChainQuote = signOnChainQuote;
exports.default = exports.signOnChainQuote;
//# sourceMappingURL=signOnChainQuote.js.map