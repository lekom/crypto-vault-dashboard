"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareInstructions = exports.getFusionQuote = void 0;
const viem_1 = require("viem");
const batchInstructions_1 = require("../../../account/utils/batchInstructions.js");
const ForwarderAbi_1 = require("../../../constants/abi/ForwarderAbi.js");
const composabilityCalls_1 = require("../../../modules/utils/composabilityCalls.js");
const getMmDtkQuote_1 = require("./getMmDtkQuote.js");
const getOnChainQuote_1 = require("./getOnChainQuote.js");
const getPermitQuote_1 = require("./getPermitQuote.js");
const getQuote_1 = require("./getQuote.js");
const getQuoteType_1 = require("./getQuoteType.js");
const getFusionQuote = async (client, parameters) => {
    if (parameters.delegatorSmartAccount) {
        return (0, getMmDtkQuote_1.default)(client, parameters);
    }
    const signatureType = await (0, getQuoteType_1.getQuoteType)(client, parameters);
    switch (signatureType) {
        case "permit":
            return (0, getPermitQuote_1.default)(client, parameters);
        case "onchain":
            return (0, getOnChainQuote_1.default)(client, parameters);
        default:
            throw new Error("Invalid quote type for fusion quote");
    }
};
exports.getFusionQuote = getFusionQuote;
const prepareInstructions = async (client, parameters) => {
    const { resolvedInstructions, trigger, owner, spender, recipient, account, batch = true } = parameters;
    const meeVersions = client.account.deployments.map(({ version, chain }) => ({
        chainId: chain.id,
        version
    }));
    let triggerAmount = 0n;
    if (trigger.useMaxAvailableFunds) {
        const { publicClient } = client.account.deploymentOn(trigger.chainId, true);
        if (trigger.tokenAddress === viem_1.zeroAddress) {
            const { version } = account.deploymentOn(trigger.chainId, true);
            const forwardCalldata = (0, viem_1.encodeFunctionData)({
                abi: ForwarderAbi_1.ForwarderAbi,
                functionName: "forward",
                args: [recipient]
            });
            const [balance, gasPrice, gasLimit] = await Promise.all([
                publicClient.getBalance({ address: owner }),
                publicClient.getGasPrice(),
                publicClient.estimateGas({
                    account: owner,
                    to: version.ethForwarderAddress,
                    data: forwardCalldata,
                    value: 100n
                })
            ]);
            const gasLimitWithBuffer = (gasLimit * 200n) / 100n;
            const gasBuffer = 2;
            const baseCost = gasLimitWithBuffer * gasPrice;
            const gasReserve = BigInt(Math.ceil(Number(baseCost) * gasBuffer));
            if (balance <= gasReserve) {
                throw new Error("Not enough native token to transfer");
            }
            triggerAmount = balance - gasReserve;
        }
        else {
            triggerAmount = await publicClient.readContract({
                address: trigger.tokenAddress,
                abi: viem_1.erc20Abi,
                functionName: "balanceOf",
                args: [owner]
            });
        }
    }
    else {
        if (!trigger.amount)
            throw new Error("Trigger amount field is required");
        triggerAmount = trigger.amount;
    }
    let isComposable = resolvedInstructions.some(({ isComposable }) => isComposable);
    let transferFromAmount = 0n;
    if (trigger.useMaxAvailableFunds && trigger.tokenAddress !== viem_1.zeroAddress) {
        transferFromAmount = (0, composabilityCalls_1.runtimeERC20AllowanceOf)({
            owner,
            spender,
            tokenAddress: trigger.tokenAddress,
            constraints: [(0, composabilityCalls_1.greaterThanOrEqualTo)(1n)]
        });
        isComposable = true;
    }
    else {
        transferFromAmount = triggerAmount;
    }
    const triggerGasLimit = trigger.gasLimit
        ? trigger.gasLimit
        : getQuote_1.DEFAULT_GAS_LIMIT;
    if (trigger.tokenAddress === viem_1.zeroAddress) {
        let batchedInstructions = [];
        if (batch) {
            batchedInstructions = await (0, batchInstructions_1.batchInstructions)({
                accountAddress: account.signer.address,
                meeVersions,
                instructions: resolvedInstructions
            });
        }
        else {
            batchedInstructions = resolvedInstructions;
        }
        return { triggerGasLimit, triggerAmount, batchedInstructions };
    }
    const params = {
        type: "transferFrom",
        data: {
            tokenAddress: trigger.tokenAddress,
            chainId: trigger.chainId,
            amount: transferFromAmount,
            recipient,
            sender: owner,
            gasLimit: triggerGasLimit
        }
    };
    const triggerTransfer = await (isComposable
        ? account.buildComposable(params)
        : account.build(params));
    let batchedInstructions = [];
    if (batch) {
        batchedInstructions = await (0, batchInstructions_1.batchInstructions)({
            accountAddress: account.signer.address,
            meeVersions,
            instructions: [...triggerTransfer, ...resolvedInstructions]
        });
    }
    else {
        batchedInstructions = [...triggerTransfer, ...resolvedInstructions];
    }
    return { triggerGasLimit, triggerAmount, batchedInstructions };
};
exports.prepareInstructions = prepareInstructions;
exports.default = exports.getFusionQuote;
//# sourceMappingURL=getFusionQuote.js.map