"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.userOp = exports.getQuote = exports.DEFAULT_VERIFICATION_GAS_LIMIT = exports.DEFAULT_GAS_LIMIT = exports.CLEANUP_USEROP_EXTENDED_EXEC_WINDOW_DURATION = exports.USEROP_MIN_EXEC_WINDOW_DURATION = void 0;
const account_1 = require("../../../account/index.js");
const decorators_1 = require("../../../account/decorators/index.js");
const Utils_1 = require("../../../account/utils/Utils.js");
const getMultichainContract_1 = require("../../../account/utils/getMultichainContract.js");
const resolveInstructions_1 = require("../../../account/utils/resolveInstructions.js");
const constants_1 = require("../../../constants/index.js");
const composabilityCalls_1 = require("../../../modules/utils/composabilityCalls.js");
const createHttpClient_1 = require("../../createHttpClient.js");
const createMeeClient_1 = require("../../createMeeClient.js");
exports.USEROP_MIN_EXEC_WINDOW_DURATION = 180;
exports.CLEANUP_USEROP_EXTENDED_EXEC_WINDOW_DURATION = exports.USEROP_MIN_EXEC_WINDOW_DURATION / 2;
exports.DEFAULT_GAS_LIMIT = 75000n;
exports.DEFAULT_VERIFICATION_GAS_LIMIT = 150000n;
const getQuote = async (client, parameters, quoteType = "simple", trigger) => {
    const { account: account_ = client.account, instructions, cleanUps, feePayer, path = "quote", lowerBoundTimestamp: lowerBoundTimestamp_ = Math.floor(Date.now() / 1000), upperBoundTimestamp: upperBoundTimestamp_ = lowerBoundTimestamp_ +
        exports.USEROP_MIN_EXEC_WINDOW_DURATION, delegate = false, authorizations = [], multichain7702Auth = false, moduleAddress, batch = true, simulation, verificationGasLimit, shortEncodingSuperTxn = false, sponsorship = false, sponsorshipOptions, feeToken, sessionDetails, smartSessionMode } = parameters;
    const mode = smartSessionMode === "ENABLE_AND_USE"
        ? constants_1.SmartSessionMode.UNSAFE_ENABLE
        : constants_1.SmartSessionMode.USE;
    let resolvedInstructions = await (0, resolveInstructions_1.resolveInstructions)(instructions);
    resolvedInstructions = resolvedInstructions.map((instruction) => {
        if (!instruction.metadata || instruction.metadata.length === 0) {
            return {
                ...instruction,
                metadata: [
                    {
                        type: "CUSTOM",
                        description: "Custom on-chain action",
                        chainId: instruction.chainId
                    }
                ]
            };
        }
        return instruction;
    });
    let finalInstructions = resolvedInstructions;
    const meeVersions = account_.deployments.map(({ version, chain }) => ({
        chainId: chain.id,
        version
    }));
    if (batch) {
        finalInstructions = await (0, account_1.batchInstructions)({
            accountAddress: account_.signer.address,
            instructions: [...resolvedInstructions],
            meeVersions
        });
    }
    let pathToQuery = path;
    if (feePayer) {
        pathToQuery = "/quote-permit";
    }
    const validUserOps = finalInstructions.every((userOp) => account_.deploymentOn(userOp.chainId) &&
        client.info.supportedChains
            .map(({ chainId }) => +chainId)
            .includes(userOp.chainId));
    if (!validUserOps) {
        throw Error(`User operation chain(s) not supported by the node: ${finalInstructions
            .map((x) => x.chainId)
            .join(", ")}`);
    }
    const hasProcessedInitData = [];
    const hasProcessedSessionDetails = new Set();
    const initDataTypeByChainId = new Map();
    const sprtxChainIdsSet = new Set([]);
    if (feeToken)
        sprtxChainIdsSet.add(feeToken.chainId);
    for (const inx of finalInstructions) {
        sprtxChainIdsSet.add(inx.chainId);
    }
    const sprtxChainIds = [...sprtxChainIdsSet];
    if (delegate) {
        if (multichain7702Auth) {
            if (sprtxChainIds.length > 1) {
                const noncesAndChainIds = await Promise.all(sprtxChainIds.map(async (chainId) => {
                    const { publicClient, walletClient: { account: { address } } } = account_.deploymentOn(chainId, true);
                    return {
                        chainId,
                        nonce: await publicClient.getTransactionCount({ address })
                    };
                }));
                const nonceCountMap = noncesAndChainIds.reduce((map, { nonce }) => {
                    map.set(nonce, (map.get(nonce) || 0) + 1);
                    return map;
                }, new Map());
                const noncesAndChainIdsWithUniqueNonces = noncesAndChainIds.filter((info) => nonceCountMap.get(info.nonce) === 1);
                const noncesAndChainIdsWithSameNonces = noncesAndChainIds.filter((info) => nonceCountMap.get(info.nonce) > 1);
                if (authorizations.length > 0) {
                    if (noncesAndChainIdsWithUniqueNonces.length === 0 &&
                        authorizations.length > 1) {
                        throw new Error("Invalid authorizations: The nonce for all the chains are zero and only one multichain authorization is expected");
                    }
                    if (noncesAndChainIdsWithUniqueNonces.length > 0) {
                        const missingAuthsByChainId = [];
                        for (const { chainId } of noncesAndChainIdsWithUniqueNonces) {
                            const isAuthProvided = authorizations.some((auth) => {
                                return auth.chainId === chainId;
                            });
                            if (!isAuthProvided)
                                missingAuthsByChainId.push(chainId);
                        }
                        if (missingAuthsByChainId.length > 0) {
                            throw new Error(`Invalid authorizations: The nonce for all the chains are not same. You need to pass specific authorizations for the following chains: ${missingAuthsByChainId.join(", ")}`);
                        }
                    }
                    if (noncesAndChainIdsWithSameNonces.length > 0) {
                        const isAuthProvided = authorizations.some((auth) => {
                            return auth.chainId === 0;
                        });
                        if (!isAuthProvided) {
                            const chainIds = noncesAndChainIdsWithSameNonces.map((auth) => auth.chainId);
                            throw new Error(`Invalid authorizations: The nonce for some of the chains are same. Missing multichain authorization for the following chains: ${chainIds.join(", ")}`);
                        }
                    }
                }
                for (const chainId of sprtxChainIds) {
                    const [isMultichainAuth] = noncesAndChainIdsWithSameNonces.filter((info) => info.chainId === chainId);
                    initDataTypeByChainId.set(chainId, isMultichainAuth ? "MULTI_CHAIN_AUTH" : "SINGLE_CHAIN_AUTH");
                }
            }
            else {
                if (authorizations.length > 1) {
                    throw new Error("Invalid authorizations: The nonce for all the chains are zero and only one multichain authorization is expected");
                }
                if (authorizations.length === 1 && authorizations[0].chainId !== 0) {
                    throw new Error("Invalid authorizations: Multichain authorization should be signed with chain ID zero");
                }
                for (const chainId of sprtxChainIds) {
                    initDataTypeByChainId.set(chainId, "MULTI_CHAIN_AUTH");
                }
            }
        }
        else {
            if (authorizations.length > 0) {
                const missingAuthsByChainId = [];
                for (const chainId of sprtxChainIds) {
                    const isAuthProvided = authorizations.some((auth) => {
                        return auth.chainId === chainId;
                    });
                    if (!isAuthProvided)
                        missingAuthsByChainId.push(chainId);
                }
                if (missingAuthsByChainId.length > 0) {
                    throw new Error(`Authorizations are missing for the following chains: ${missingAuthsByChainId.join(", ")}`);
                }
            }
            for (const chainId of sprtxChainIds) {
                initDataTypeByChainId.set(chainId, "SINGLE_CHAIN_AUTH");
            }
        }
    }
    else {
        for (const chainId of sprtxChainIds) {
            initDataTypeByChainId.set(chainId, "INIT_CODE");
        }
    }
    const { paymentInfo, isInitDataProcessed, isSessionDetailsProcessed } = await preparePaymentInfo(client, {
        ...parameters,
        initDataTypeByChainId
    });
    let multichainEIP7702Auth = undefined;
    const paymentAuthType = initDataTypeByChainId.get(Number(paymentInfo.chainId));
    if (paymentInfo.eip7702Auth && paymentAuthType === "MULTI_CHAIN_AUTH") {
        multichainEIP7702Auth = paymentInfo.eip7702Auth;
    }
    if (isInitDataProcessed)
        hasProcessedInitData.push(Number(paymentInfo.chainId));
    if (isSessionDetailsProcessed)
        hasProcessedSessionDetails.add(paymentInfo.chainId);
    const preparedUserOps = await prepareUserOps(account_, finalInstructions, false, moduleAddress);
    if (cleanUps && cleanUps.length > 0) {
        const userOpsNonceInfo = preparedUserOps.map(([, { nonceKey, nonce }]) => ({ nonce, nonceKey }));
        const cleanUpUserOps = await prepareCleanUpUserOps(account_, userOpsNonceInfo, cleanUps, moduleAddress);
        preparedUserOps.push(...cleanUpUserOps);
    }
    const indexPerChainId = new Map();
    const userOps = await Promise.all(preparedUserOps.map(async ([callData, { nonce }, isAccountDeployed, initCode, sender, callGasLimit, chainId, isCleanUpUserOp, nexusAccount, shortEncoding, metadata]) => {
        let initDataOrUndefined = undefined;
        if (!indexPerChainId.has(chainId)) {
            indexPerChainId.set(chainId, 0);
        }
        if (!isAccountDeployed &&
            !hasProcessedInitData.includes(Number(chainId))) {
            hasProcessedInitData.push(Number(chainId));
            const authType = initDataTypeByChainId.get(Number(chainId));
            if (authType === "MULTI_CHAIN_AUTH") {
                if (multichainEIP7702Auth) {
                    initDataOrUndefined = {
                        eip7702Auth: multichainEIP7702Auth
                    };
                }
                else {
                    multichainEIP7702Auth = await prepare7702Auth(nexusAccount, Number(chainId), initDataTypeByChainId, authorizations);
                    initDataOrUndefined = {
                        eip7702Auth: multichainEIP7702Auth
                    };
                }
            }
            else if (authType === "SINGLE_CHAIN_AUTH") {
                initDataOrUndefined = {
                    eip7702Auth: await prepare7702Auth(nexusAccount, Number(chainId), initDataTypeByChainId, authorizations)
                };
            }
            else {
                initDataOrUndefined = { initCode };
            }
        }
        const resolvedVerificationGasLimit = resolveVerificationGasLimit({
            moduleAddress,
            verificationGasLimit,
            sponsorship,
            index: indexPerChainId.get(chainId),
            paymentChainId: paymentInfo.chainId,
            currentChainId: chainId
        });
        indexPerChainId.set(chainId, indexPerChainId.get(chainId) + 1);
        let sessionDetail = undefined;
        if (sessionDetails) {
            const relevantIndex = sessionDetails.findIndex(({ enableSessionData }) => enableSessionData?.enableSession?.sessionToEnable?.chainId ===
                BigInt(chainId));
            if (relevantIndex === -1) {
                throw new Error(`No session details found for chainId ${chainId}`);
            }
            const isFirstTimeForChain = !hasProcessedSessionDetails.has(chainId);
            const dynamicMode = isFirstTimeForChain ? mode : constants_1.SmartSessionMode.USE;
            sessionDetail = {
                ...sessionDetails[relevantIndex],
                mode: dynamicMode
            };
            hasProcessedSessionDetails.add(chainId);
        }
        return {
            lowerBoundTimestamp: lowerBoundTimestamp_,
            upperBoundTimestamp: isCleanUpUserOp
                ? upperBoundTimestamp_ +
                    exports.CLEANUP_USEROP_EXTENDED_EXEC_WINDOW_DURATION
                : upperBoundTimestamp_,
            sender,
            callData,
            callGasLimit,
            nonce: nonce.toString(),
            chainId,
            isCleanUpUserOp,
            ...initDataOrUndefined,
            ...resolvedVerificationGasLimit,
            shortEncoding: shortEncodingSuperTxn || shortEncoding,
            sessionDetails: sessionDetail,
            metadata
        };
    }));
    const quoteRequest = {
        quoteType,
        userOps,
        paymentInfo,
        simulation,
        trigger,
        tags: parameters.tags
    };
    let quote = await client.request({
        path: pathToQuery,
        body: quoteRequest
    });
    if (sponsorship && sponsorshipOptions) {
        const isSelfHostedSponsorship = ![
            (0, createMeeClient_1.getDefaultMEENetworkUrl)(false),
            (0, createMeeClient_1.getDefaultMEENetworkUrl)(true)
        ].includes(sponsorshipOptions.url);
        if (isSelfHostedSponsorship) {
            const selfHostedClient = (0, createHttpClient_1.default)(sponsorshipOptions.url);
            quote = await selfHostedClient.request({
                path: `sponsorship/sign/${sponsorshipOptions.gasTank.chainId}/${sponsorshipOptions.gasTank.address}`,
                method: "POST",
                body: quote,
                ...(sponsorshipOptions.customHeaders
                    ? { headers: sponsorshipOptions.customHeaders }
                    : {})
            });
        }
    }
    return quote;
};
exports.getQuote = getQuote;
const preparePaymentInfo = async (client, parameters) => {
    const { account: account_ = client.account, eoa, feeToken, feePayer, gasLimit, authorizations = [], sponsorship, sponsorshipOptions, shortEncodingSuperTxn, moduleAddress, sessionDetails, smartSessionMode = "USE", verificationGasLimit } = parameters;
    let paymentInfo = undefined;
    let isInitDataProcessed = false;
    let isSessionDetailsProcessed = false;
    const eoaOrFeePayer = feePayer || eoa;
    if (sponsorship) {
        let sender = createMeeClient_1.DEFAULT_MEE_SPONSORSHIP_PAYMASTER_ACCOUNT;
        let token = createMeeClient_1.DEFAULT_MEE_SPONSORSHIP_TOKEN_ADDRESS;
        let chainId = createMeeClient_1.DEFAULT_MEE_SPONSORSHIP_CHAIN_ID;
        let sponsorshipUrl = createMeeClient_1.DEFAULT_PATHFINDER_URL;
        if (sponsorshipOptions) {
            sender = sponsorshipOptions.gasTank.address;
            token = sponsorshipOptions.gasTank.token;
            chainId = sponsorshipOptions.gasTank.chainId;
            sponsorshipUrl = sponsorshipOptions.url;
        }
        const sponsorshipClient = (0, createHttpClient_1.default)(sponsorshipUrl);
        const { nonce } = await sponsorshipClient.request({
            path: `sponsorship/nonce/${chainId}/${sender}`,
            method: "GET",
            ...(sponsorshipOptions?.customHeaders
                ? { headers: sponsorshipOptions.customHeaders }
                : {})
        });
        paymentInfo = {
            sponsored: true,
            sender,
            token,
            nonce,
            callGasLimit: gasLimit || exports.DEFAULT_GAS_LIMIT,
            verificationGasLimit: exports.DEFAULT_VERIFICATION_GAS_LIMIT,
            chainId: chainId.toString(),
            sponsorshipUrl,
            ...(eoaOrFeePayer ? { eoa: eoaOrFeePayer } : {}),
            initCode: undefined
        };
        isInitDataProcessed = false;
    }
    else {
        if (!feeToken)
            throw Error("Fee token should be configured");
        const validPaymentAccount = account_.deploymentOn(feeToken.chainId);
        if (!validPaymentAccount) {
            throw Error(`Account is not deployed on necessary chain(s) ${feeToken.chainId}`);
        }
        const validFeeToken = validPaymentAccount &&
            client.info.supportedGasTokens
                .map(({ chainId }) => +chainId)
                .includes(feeToken.chainId);
        if (!validFeeToken) {
            throw Error(`Fee token ${feeToken.address} is not supported on this chain: ${feeToken.chainId}`);
        }
        const [nonce, isAccountDeployed, initCode] = await Promise.all([
            validPaymentAccount.getNonceWithKey(validPaymentAccount.address, {
                moduleAddress
            }),
            validPaymentAccount.isDeployed(),
            validPaymentAccount.getInitCode()
        ]);
        let initData = undefined;
        if (!isAccountDeployed) {
            const initDataType = parameters.initDataTypeByChainId.get(feeToken.chainId);
            if (initDataType === "INIT_CODE") {
                initData = { initCode };
            }
            else {
                initData = {
                    eip7702Auth: await prepare7702Auth(validPaymentAccount, feeToken.chainId, parameters.initDataTypeByChainId, authorizations)
                };
            }
        }
        const paymentVerificationGasLimit = resolvePaymentUserOpVerificationGasLimitNonSponsored(moduleAddress, verificationGasLimit);
        let sessionDetail = undefined;
        if (sessionDetails) {
            const relevantIndex = sessionDetails.findIndex(({ enableSessionData }) => enableSessionData?.enableSession?.sessionToEnable?.chainId ===
                BigInt(feeToken.chainId));
            if (relevantIndex === -1) {
                throw new Error(`No session details found for chainId ${feeToken.chainId}`);
            }
            if (!smartSessionMode) {
                throw new Error("smartSessionMode is required for smart sessions flow");
            }
            const mode = smartSessionMode === "ENABLE_AND_USE"
                ? constants_1.SmartSessionMode.UNSAFE_ENABLE
                : constants_1.SmartSessionMode.USE;
            sessionDetail = {
                ...sessionDetails[relevantIndex],
                mode
            };
        }
        paymentInfo = {
            sponsored: false,
            sender: validPaymentAccount.address,
            token: feeToken.address,
            nonce: nonce.nonce.toString(),
            callGasLimit: gasLimit || exports.DEFAULT_GAS_LIMIT,
            verificationGasLimit: paymentVerificationGasLimit?.verificationGasLimit ||
                exports.DEFAULT_VERIFICATION_GAS_LIMIT,
            chainId: feeToken.chainId.toString(),
            ...(feeToken.gasRefundAddress
                ? { gasRefundAddress: feeToken.gasRefundAddress }
                : {}),
            ...(eoaOrFeePayer ? { eoa: eoaOrFeePayer } : {}),
            ...initData,
            shortEncoding: shortEncodingSuperTxn,
            sessionDetails: sessionDetail
        };
        isInitDataProcessed = true;
        isSessionDetailsProcessed = true;
    }
    if (!paymentInfo)
        throw new Error("Failed to generate payment info");
    return { paymentInfo, isInitDataProcessed, isSessionDetailsProcessed };
};
const prepare7702Auth = async (smartAccount, chainId, initDataTypeByChainId, customAuthorizations = []) => {
    let eip7702Auth;
    const authType = initDataTypeByChainId.get(chainId);
    if (authType === "MULTI_CHAIN_AUTH") {
        const [authorization] = customAuthorizations.filter((auth) => auth.chainId === 0);
        eip7702Auth = await smartAccount.toDelegation(authorization ? { authorization } : { multiChain: true });
    }
    else if (authType === "SINGLE_CHAIN_AUTH") {
        const [authorization] = customAuthorizations.filter((auth) => {
            return auth.chainId === Number(chainId);
        });
        eip7702Auth = await smartAccount.toDelegation(authorization ? { authorization } : { chainId });
    }
    else {
        throw new Error("Invalid authorization type");
    }
    return eip7702Auth;
};
const prepareUserOps = async (account, instructions, isCleanUpUserOps = false, validatorAddress) => {
    return await Promise.all(instructions.map((instruction) => {
        const deployment = account.deploymentOn(instruction.chainId, true);
        const accountAddress = account.addressOn(instruction.chainId, true);
        let callsPromise;
        if (instruction.isComposable) {
            callsPromise = deployment.encodeExecuteComposable(instruction.calls);
        }
        else {
            callsPromise =
                instruction.calls.length > 1
                    ? deployment.encodeExecuteBatch(instruction.calls)
                    : deployment.encodeExecute(instruction.calls[0]);
        }
        const shortEncoding = false;
        return Promise.all([
            callsPromise,
            deployment.getNonceWithKey(accountAddress, {
                moduleAddress: validatorAddress
            }),
            deployment.isDeployed(),
            deployment.getInitCode(),
            deployment.address,
            instruction.calls
                .map((uo) => uo?.gasLimit ?? getMultichainContract_1.LARGE_DEFAULT_GAS_LIMIT)
                .reduce((curr, acc) => curr + acc, 0n)
                .toString(),
            instruction.chainId.toString(),
            isCleanUpUserOps,
            deployment,
            shortEncoding,
            instruction.metadata
        ]);
    }));
};
const userOp = (userOpIndex) => {
    if (userOpIndex <= 0)
        throw new Error("UserOp index should be greater than zero");
    return userOpIndex - 1;
};
exports.userOp = userOp;
const prepareCleanUpUserOps = async (account, userOpsNonceInfo, cleanUps, moduleAddress) => {
    const meeVersions = account.deployments.map(({ version, chain }) => ({
        chainId: chain.id,
        version
    }));
    const cleanUpInstructions = await Promise.all(cleanUps.map(async (cleanUp) => {
        let cleanUpInstruction;
        const { version } = account.deploymentOn(cleanUp.chainId, true);
        const composabilityVersion = version.composabilityVersion;
        if ((0, Utils_1.isNativeToken)(cleanUp.tokenAddress)) {
            if (!(0, Utils_1.isBigInt)(cleanUp.amount) || cleanUp.amount === 0n) {
                if (composabilityVersion === constants_1.ComposabilityVersion.V1_0_0) {
                    throw new Error("Native token cleanup with runtime-injected amount is not supported for Composability v1.0.0");
                }
                let amount;
                if (cleanUp.amount === undefined || cleanUp.amount === 0n) {
                    amount = (0, composabilityCalls_1.runtimeNativeBalanceOf)({
                        targetAddress: account.addressOn(cleanUp.chainId, true)
                    });
                }
                else {
                    amount = cleanUp.amount;
                }
                const [cleanUpNativeTransferInstruction] = await (0, decorators_1.buildComposable)({
                    accountAddress: account.signer.address,
                    currentInstructions: [],
                    meeVersions
                }, {
                    type: "nativeTokenTransfer",
                    data: {
                        to: cleanUp.recipientAddress,
                        value: amount,
                        chainId: cleanUp.chainId,
                        ...(cleanUp.gasLimit ? { gasLimit: cleanUp.gasLimit } : {})
                    }
                }, composabilityVersion);
                cleanUpInstruction = cleanUpNativeTransferInstruction;
            }
            else {
                const amount = cleanUp.amount;
                const [cleanUpNativeTransferInstruction] = await (0, decorators_1.buildComposable)({
                    accountAddress: account.signer.address,
                    currentInstructions: [],
                    meeVersions
                }, {
                    type: "rawCalldata",
                    data: {
                        to: cleanUp.recipientAddress,
                        calldata: "0x00000000",
                        chainId: cleanUp.chainId,
                        value: amount
                    }
                }, composabilityVersion);
                cleanUpInstruction = cleanUpNativeTransferInstruction;
            }
        }
        else {
            let amount = cleanUp.amount ?? 0n;
            if (amount === 0n) {
                amount = (0, composabilityCalls_1.runtimeERC20BalanceOf)({
                    targetAddress: account.addressOn(cleanUp.chainId, true),
                    tokenAddress: cleanUp.tokenAddress
                });
            }
            const [cleanUpERC20TransferInstruction] = await (0, decorators_1.buildComposable)({
                accountAddress: account.signer.address,
                currentInstructions: [],
                meeVersions
            }, {
                type: "transfer",
                data: {
                    recipient: cleanUp.recipientAddress,
                    tokenAddress: cleanUp.tokenAddress,
                    amount,
                    chainId: cleanUp.chainId,
                    ...(cleanUp.gasLimit ? { gasLimit: cleanUp.gasLimit } : {})
                }
            }, composabilityVersion);
            cleanUpInstruction = cleanUpERC20TransferInstruction;
        }
        const nonceDependencies = [];
        if (cleanUp.dependsOn && cleanUp.dependsOn.length > 0) {
            for (const userOpIndex of cleanUp.dependsOn) {
                const userOpNonceInfo = userOpsNonceInfo[userOpIndex];
                if (!userOpNonceInfo)
                    throw new Error("Invalid UserOp dependency, please check the dependsOn configuration");
                const { nonce, nonceKey } = userOpNonceInfo;
                const nonceOf = (0, composabilityCalls_1.runtimeNonceOf)({
                    smartAccountAddress: account.addressOn(cleanUp.chainId, true),
                    nonceKey: nonceKey,
                    constraints: [(0, composabilityCalls_1.greaterThanOrEqualTo)(nonce + 1n)]
                });
                nonceDependencies.push(nonceOf);
            }
        }
        else {
            if (userOpsNonceInfo.length === 0) {
                throw new Error("At least one instruction should be configured to use cleanups.");
            }
            const lastUserOp = userOpsNonceInfo[userOpsNonceInfo.length - 1];
            const { nonce, nonceKey } = lastUserOp;
            const nonceOf = (0, composabilityCalls_1.runtimeNonceOf)({
                smartAccountAddress: account.addressOn(cleanUp.chainId, true),
                nonceKey: nonceKey,
                constraints: [(0, composabilityCalls_1.greaterThanOrEqualTo)(nonce + 1n)]
            });
            nonceDependencies.push(nonceOf);
        }
        const nonceDependencyInputParams = nonceDependencies.flatMap((dep) => dep.inputParams);
        const formattedNonceDependencyInputParams = (0, decorators_1.formatCallDataInputParamsWithVersion)(composabilityVersion, false, nonceDependencyInputParams);
        cleanUpInstruction.calls = cleanUpInstruction.calls.map((call) => {
            call.inputParams.push(...formattedNonceDependencyInputParams);
            return call;
        });
        return cleanUpInstruction;
    }));
    const cleanUpUserOps = await prepareUserOps(account, cleanUpInstructions, true, moduleAddress);
    return cleanUpUserOps;
};
const resolveVerificationGasLimit = (parameters) => {
    const { moduleAddress, verificationGasLimit, sponsorship, index, paymentChainId, currentChainId } = parameters;
    if (currentChainId === paymentChainId) {
        return resolveVerificationGasLimitForPaymentChain({
            moduleAddress,
            verificationGasLimit,
            sponsorship,
            index
        });
    }
    return resolveVerificationGasLimitForNonPaymentChain({
        moduleAddress,
        verificationGasLimit,
        index
    });
};
const resolveVerificationGasLimitForPaymentChain = (parameters) => {
    const { moduleAddress, verificationGasLimit, sponsorship, index } = parameters;
    if (!moduleAddress && !verificationGasLimit) {
        return undefined;
    }
    if (!moduleAddress && verificationGasLimit) {
        return { verificationGasLimit };
    }
    if ((0, Utils_1.addressEquals)(moduleAddress, constants_1.SMART_SESSIONS_ADDRESS)) {
        if (sponsorship) {
            if (index === 0) {
                return {
                    verificationGasLimit: verificationGasLimit || 1000000n
                };
            }
        }
        return { verificationGasLimit: 250000n };
    }
    if (verificationGasLimit) {
        return { verificationGasLimit };
    }
    return undefined;
};
const resolveVerificationGasLimitForNonPaymentChain = (parameters) => {
    const { moduleAddress, verificationGasLimit, index } = parameters;
    if (!moduleAddress && !verificationGasLimit) {
        return undefined;
    }
    if (!moduleAddress && verificationGasLimit) {
        return { verificationGasLimit };
    }
    if ((0, Utils_1.addressEquals)(moduleAddress, constants_1.SMART_SESSIONS_ADDRESS)) {
        if (index === 0) {
            return { verificationGasLimit: verificationGasLimit || 1000000n };
        }
        return { verificationGasLimit: 250000n };
    }
    if (verificationGasLimit) {
        return { verificationGasLimit };
    }
    return undefined;
};
const resolvePaymentUserOpVerificationGasLimitNonSponsored = (moduleAddress, verificationGasLimit) => {
    if (!moduleAddress && !verificationGasLimit) {
        return undefined;
    }
    if (!moduleAddress && verificationGasLimit) {
        return { verificationGasLimit };
    }
    if ((0, Utils_1.addressEquals)(moduleAddress, constants_1.SMART_SESSIONS_ADDRESS)) {
        return { verificationGasLimit: verificationGasLimit || 1000000n };
    }
    if (verificationGasLimit) {
        return { verificationGasLimit };
    }
    return undefined;
};
exports.default = exports.getQuote;
//# sourceMappingURL=getQuote.js.map