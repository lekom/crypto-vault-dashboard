"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSupertransactionReceipt = getSupertransactionReceipt;
const actions_1 = require("viem/actions");
const explorer_1 = require("../../../account/utils/explorer.js");
const parseErrorMessage_1 = require("../../../account/utils/parseErrorMessage.js");
const parseTransactionStatus_1 = require("../../../account/utils/parseTransactionStatus.js");
async function getSupertransactionReceipt(client, parameters) {
    const { confirmations = 2, waitForReceipts = true, ...params } = parameters;
    const account = parameters.account ?? client.account;
    let receipts = null;
    const explorerResponse = await client.request({
        path: `explorer/${params.hash}`,
        method: "GET"
    });
    const userOpsWithoutPayment = explorerResponse.userOps.slice(1);
    const metaStatus = await (0, parseTransactionStatus_1.parseTransactionStatus)(userOpsWithoutPayment);
    switch (metaStatus.status) {
        case "FAILED": {
            console.log({ metaStatus, explorerResponse, hash: params.hash });
            throw new Error((0, parseErrorMessage_1.parseErrorMessage)(metaStatus.message));
        }
        case "MINED_FAIL": {
            console.log({ metaStatus, explorerResponse, hash: params.hash });
            throw new Error((0, parseErrorMessage_1.parseErrorMessage)(metaStatus.message));
        }
        case "PENDING": {
            break;
        }
        case "MINING": {
            break;
        }
        case "MINED_SUCCESS": {
            if (waitForReceipts) {
                receipts = await Promise.all(userOpsWithoutPayment
                    .filter((userOp) => {
                    if (userOp.isCleanUpUserOp &&
                        userOp.executionStatus !== "MINED_SUCCESS") {
                        return false;
                    }
                    return true;
                })
                    .map(async ({ chainId, executionData }) => {
                    return (0, actions_1.getTransactionReceipt)(account.deploymentOn(Number(chainId), true).publicClient, {
                        confirmations,
                        ...parameters,
                        hash: executionData
                    });
                }));
            }
            break;
        }
        default: {
            throw new Error("Unknown transaction status");
        }
    }
    const explorerLinks = userOpsWithoutPayment.reduce((acc, userOp) => {
        acc.push((0, explorer_1.getExplorerTxLink)(userOp.executionData, userOp.chainId), (0, explorer_1.getJiffyScanLink)(userOp.userOpHash));
        return acc;
    }, [(0, explorer_1.getMeeScanLink)(params.hash)]);
    return {
        ...explorerResponse,
        userOps: userOpsWithoutPayment,
        explorerLinks,
        receipts,
        transactionStatus: metaStatus.status
    };
}
exports.default = getSupertransactionReceipt;
//# sourceMappingURL=getSupertransactionReceipt.js.map