"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.grantMeePermission = exports.grantMeePermissionTypedDataSign = exports.grantMeePermissionPersonalSign = void 0;
const viem_1 = require("viem");
const constants_1 = require("../../../../../constants/index.js");
const getMeeConfig_1 = require("../../../../utils/getMeeConfig.js");
const grantPermission_1 = require("../grantPermission.js");
const grantMeePermissionPersonalSign = async (baseMeeClient, params) => {
    return (0, exports.grantMeePermission)(baseMeeClient, params, "PERSONAL_SIGN");
};
exports.grantMeePermissionPersonalSign = grantMeePermissionPersonalSign;
const grantMeePermissionTypedDataSign = async (baseMeeClient, params) => {
    return (0, exports.grantMeePermission)(baseMeeClient, params, "TYPED_DATA_SIGN");
};
exports.grantMeePermissionTypedDataSign = grantMeePermissionTypedDataSign;
const grantMeePermission = async (baseMeeClient, { redeemer, actions, feeToken, maxPaymentAmount, account: _account }, mode) => {
    const account = baseMeeClient.account;
    if (feeToken && !maxPaymentAmount) {
        const deploymentOnPaymentChain = baseMeeClient.account.deploymentOn(feeToken.chainId, true);
        const paymentChainpublicClient = deploymentOnPaymentChain.client;
        const decimals = await paymentChainpublicClient.readContract({
            address: feeToken.address,
            abi: viem_1.erc20Abi,
            functionName: "decimals"
        });
        maxPaymentAmount = (0, viem_1.parseUnits)("5", decimals);
    }
    const uniqueChainIds = Array.from(new Set(actions.map((action) => action.chainId)));
    const grantPermissionParameters = uniqueChainIds.map((chainId) => {
        const deployment = account.deployments.find((deployment) => deployment?.client?.chain?.id === chainId);
        const actionsForChain = actions.filter((action) => action.chainId === chainId);
        const defaultVersionConfig = (0, getMeeConfig_1.getMEEVersion)(constants_1.DEFAULT_MEE_VERSION);
        const meeValidatorAddress = deployment?.version.validatorAddress ||
            defaultVersionConfig.validatorAddress;
        let paymentAction = undefined;
        if (feeToken && feeToken.chainId === chainId) {
            if (actionsForChain.some((action) => action.actionTargetSelector ===
                (0, viem_1.toFunctionSelector)((0, viem_1.getAbiItem)({ abi: viem_1.erc20Abi, name: "transfer" })) && action.actionTarget === feeToken.address)) {
                throw new Error(`You are defining the policy that prevents using ${feeToken.address} on chain ${chainId} as the fee token. 
                         Possible solutions:
                         1. Remove the 'transfer' method of ${feeToken.address} from the actions array.
                         2. Use a different fee token.
                         3. Use sponsored mode.`);
            }
            paymentAction = {
                actionTarget: feeToken.address,
                actionTargetSelector: "0xa9059cbb",
                actionPolicies: [
                    getPolicyForPayment(maxPaymentAmount, feeToken.address)
                ],
                chainId
            };
        }
        return {
            account: deployment,
            redeemer,
            actions: paymentAction
                ? [...actionsForChain, paymentAction]
                : actionsForChain,
            sessionValidator: meeValidatorAddress,
            sessionValidatorInitData: redeemer,
            permitERC4337Paymaster: true
        };
    });
    return mode === "PERSONAL_SIGN"
        ? (0, grantPermission_1.grantPermissionPersonalSign)(undefined, grantPermissionParameters)
        : (0, grantPermission_1.grantPermissionTypedDataSign)(undefined, grantPermissionParameters);
};
exports.grantMeePermission = grantMeePermission;
const getPolicyForPayment = (maxPaymentAmount, token) => {
    return (0, constants_1.getSpendingLimitsPolicy)([{ limit: maxPaymentAmount, token }]);
};
//# sourceMappingURL=grantMeePermission.js.map