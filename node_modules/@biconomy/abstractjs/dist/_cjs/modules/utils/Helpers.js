"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.functionNameToLabel = exports.isPermitSupported = exports.parseModule = void 0;
exports.parseReferenceValue = parseReferenceValue;
const viem_1 = require("viem");
const index_js_1 = require("../../account/index.js");
function parseReferenceValue(referenceValue) {
    let result;
    if ((0, viem_1.isHex)(referenceValue) && referenceValue.length === 42) {
        result = `0x${"0".repeat(24)}${referenceValue.slice(2)}`;
    }
    else if (referenceValue?.raw) {
        result = referenceValue?.raw;
    }
    else if (typeof referenceValue === "bigint") {
        result = (0, viem_1.pad)((0, viem_1.toHex)(referenceValue), { size: 32 });
    }
    else if (typeof referenceValue === "number") {
        result = (0, viem_1.pad)((0, viem_1.toHex)(BigInt(referenceValue)), { size: 32 });
    }
    else if (typeof referenceValue === "boolean") {
        result = (0, viem_1.pad)((0, viem_1.toHex)(referenceValue), { size: 32 });
    }
    else if ((0, viem_1.isHex)(referenceValue)) {
        result = referenceValue;
    }
    else if (typeof referenceValue === "string") {
        result = (0, viem_1.pad)(referenceValue, { size: 32 });
    }
    else {
        result = (0, viem_1.pad)((0, viem_1.toHex)(referenceValue), { size: 32 });
    }
    if (!(0, viem_1.isHex)(result) || result.length !== 66) {
        throw new Error(index_js_1.ERROR_MESSAGES.INVALID_HEX);
    }
    return result;
}
const parseModule = (client) => {
    const activeModule = client?.account?.getModule();
    if (!activeModule) {
        throw new Error(index_js_1.ERROR_MESSAGES.MODULE_NOT_ACTIVATED);
    }
    return activeModule;
};
exports.parseModule = parseModule;
const isPermitSupported = async (walletClient, tokenAddress) => {
    try {
        const client = walletClient.extend(viem_1.publicActions);
        const permitSelector = (0, viem_1.toFunctionSelector)("permit(address,address,uint256,uint256,uint8,bytes32,bytes32)");
        const domainSeparatorSelector = "0x3644e515";
        const noncesSelector = "0x7ecebe00";
        const checkPermitEnabled = async (selector, padding = "") => {
            return client
                .call({
                to: tokenAddress,
                data: `${selector}${padding}`
            })
                .then(() => true)
                .catch((error) => {
                if (selector === permitSelector) {
                    return (error.message.includes("revert") &&
                        !error.message.includes("function selector"));
                }
                return false;
            });
        };
        const [hasPermit, hasDomainSeparator, hasNonces] = await Promise.all([
            checkPermitEnabled(permitSelector, "0".repeat(64)),
            checkPermitEnabled(domainSeparatorSelector),
            checkPermitEnabled(noncesSelector, `000000000000000000000000${"0".repeat(40)}`)
        ]);
        return hasPermit && hasDomainSeparator && hasNonces;
    }
    catch (err) {
        console.error("Error checking permit support:", err);
        return false;
    }
};
exports.isPermitSupported = isPermitSupported;
const functionNameToLabel = (functionName) => {
    return (functionName
        .replace(/([a-z0-9])([A-Z])/g, "$1 $2")
        .replace(/[_\-:]+/g, " ")
        .trim()
        .replace(/\b\w/g, (char) => char.toUpperCase()));
};
exports.functionNameToLabel = functionNameToLabel;
//# sourceMappingURL=Helpers.js.map