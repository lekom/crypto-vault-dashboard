"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareRawComposableParams = exports.prepareComposableInputCalldataParams = exports.isComposableCallRequired = exports.runtimeEncodeAbiParameters = exports.runtimeERC20BalanceOf = exports.runtimeNativeBalanceOf = exports.runtimeERC20AllowanceOf = exports.runtimeParamViaCustomStaticCall = exports.runtimeNonceOf = exports.validateAndProcessConstraints = exports.equalTo = exports.lessThanOrEqualTo = exports.greaterThanOrEqualTo = exports.prepareConstraint = exports.prepareOutputParam = exports.prepareInputParam = exports.isRuntimeComposableValue = exports.ConstraintType = exports.OutputParamFetcherType = exports.InputParamFetcherType = exports.InputParamType = void 0;
const viem_1 = require("viem");
const constants_1 = require("../../constants/index.js");
const runtimeAbiEncoding_1 = require("./runtimeAbiEncoding.js");
exports.InputParamType = {
    TARGET: 0,
    VALUE: 1,
    CALL_DATA: 2
};
exports.InputParamFetcherType = {
    RAW_BYTES: 0,
    STATIC_CALL: 1,
    BALANCE: 2
};
exports.OutputParamFetcherType = {
    EXEC_RESULT: 0,
    STATIC_CALL: 1
};
exports.ConstraintType = {
    EQ: 0,
    GTE: 1,
    LTE: 2,
    IN: 3
};
const isRuntimeComposableValue = (value) => {
    if (value &&
        typeof value === "object" &&
        !Array.isArray(value) &&
        value.isRuntime) {
        return true;
    }
    return false;
};
exports.isRuntimeComposableValue = isRuntimeComposableValue;
const prepareInputParam = (fetcherType, paramData, constraints = []) => {
    return { fetcherType, paramData, constraints };
};
exports.prepareInputParam = prepareInputParam;
const prepareOutputParam = (fetcherType, paramData) => {
    return { fetcherType, paramData };
};
exports.prepareOutputParam = prepareOutputParam;
const prepareConstraint = (constraintType, referenceData) => {
    return { constraintType, referenceData };
};
exports.prepareConstraint = prepareConstraint;
const greaterThanOrEqualTo = (value) => {
    return { type: exports.ConstraintType.GTE, value };
};
exports.greaterThanOrEqualTo = greaterThanOrEqualTo;
const lessThanOrEqualTo = (value) => {
    return { type: exports.ConstraintType.LTE, value };
};
exports.lessThanOrEqualTo = lessThanOrEqualTo;
const equalTo = (value) => {
    return { type: exports.ConstraintType.EQ, value };
};
exports.equalTo = equalTo;
const validateAndProcessConstraints = (constraints) => {
    const constraintsToAdd = [];
    if (constraints.length > 0) {
        for (const constraint of constraints) {
            if (!Object.values(exports.ConstraintType).slice(0, 3).includes(constraint.type)) {
                throw new Error("Invalid constraint type");
            }
            if (typeof constraint.value !== "bigint" ||
                constraint.value < BigInt(0)) {
                throw new Error("Invalid constraint value");
            }
            const valueHex = `0x${constraint.value.toString(16).padStart(64, "0")}`;
            const encodedConstraintValue = (0, viem_1.encodeAbiParameters)([{ type: "bytes32" }], [valueHex]);
            constraintsToAdd.push((0, exports.prepareConstraint)(constraint.type, encodedConstraintValue));
        }
    }
    return constraintsToAdd;
};
exports.validateAndProcessConstraints = validateAndProcessConstraints;
const runtimeNonceOf = ({ smartAccountAddress, nonceKey, constraints = [] }) => {
    const defaultFunctionSig = "getNonce";
    const entryPointNonceAbi = (0, viem_1.parseAbi)([
        "function getNonce(address sender, uint192 key) public view returns (uint256)"
    ]);
    const encodedParam = (0, viem_1.encodeAbiParameters)([{ type: "address" }, { type: "bytes" }], [
        constants_1.ENTRY_POINT_ADDRESS,
        (0, viem_1.encodeFunctionData)({
            abi: entryPointNonceAbi,
            functionName: defaultFunctionSig,
            args: [smartAccountAddress, nonceKey]
        })
    ]);
    const constraintsToAdd = (0, exports.validateAndProcessConstraints)(constraints);
    return {
        isRuntime: true,
        inputParams: [
            (0, exports.prepareInputParam)(exports.InputParamFetcherType.STATIC_CALL, encodedParam, constraintsToAdd)
        ],
        outputParams: []
    };
};
exports.runtimeNonceOf = runtimeNonceOf;
const runtimeParamViaCustomStaticCall = ({ targetContractAddress, functionAbi, functionName, args, constraints = [] }) => {
    const encodedParam = (0, viem_1.encodeAbiParameters)([{ type: "address" }, { type: "bytes" }], [
        targetContractAddress,
        (0, viem_1.encodeFunctionData)({
            abi: functionAbi,
            functionName: functionName,
            args
        })
    ]);
    const constraintsToAdd = (0, exports.validateAndProcessConstraints)(constraints);
    return {
        isRuntime: true,
        inputParams: [
            (0, exports.prepareInputParam)(exports.InputParamFetcherType.STATIC_CALL, encodedParam, constraintsToAdd)
        ],
        outputParams: []
    };
};
exports.runtimeParamViaCustomStaticCall = runtimeParamViaCustomStaticCall;
const runtimeERC20AllowanceOf = ({ owner, spender, tokenAddress, constraints = [] }) => {
    const encodedParam = (0, viem_1.encodeAbiParameters)([{ type: "address" }, { type: "bytes" }], [
        tokenAddress,
        (0, viem_1.encodeFunctionData)({
            abi: viem_1.erc20Abi,
            functionName: "allowance",
            args: [owner, spender]
        })
    ]);
    const constraintsToAdd = (0, exports.validateAndProcessConstraints)(constraints);
    return {
        isRuntime: true,
        inputParams: [
            (0, exports.prepareInputParam)(exports.InputParamFetcherType.STATIC_CALL, encodedParam, constraintsToAdd)
        ],
        outputParams: []
    };
};
exports.runtimeERC20AllowanceOf = runtimeERC20AllowanceOf;
const runtimeNativeBalanceOf = ({ targetAddress, constraints = [] }) => {
    return getBalanceOf({
        targetAddress,
        tokenAddress: viem_1.zeroAddress,
        constraints
    });
};
exports.runtimeNativeBalanceOf = runtimeNativeBalanceOf;
const runtimeERC20BalanceOf = ({ targetAddress, tokenAddress, constraints = [] }) => {
    return getBalanceOf({
        targetAddress,
        tokenAddress,
        constraints
    });
};
exports.runtimeERC20BalanceOf = runtimeERC20BalanceOf;
const getBalanceOf = ({ targetAddress, tokenAddress, constraints = [] }) => {
    const constraintsToAdd = (0, exports.validateAndProcessConstraints)(constraints);
    const encodedInputParamData = (0, viem_1.encodePacked)(["address", "address"], [tokenAddress, targetAddress]);
    return {
        isRuntime: true,
        inputParams: [
            (0, exports.prepareInputParam)(exports.InputParamFetcherType.BALANCE, encodedInputParamData, constraintsToAdd)
        ],
        outputParams: []
    };
};
const runtimeEncodeAbiParameters = (inputs, args) => {
    const inputParams = (0, exports.prepareComposableInputCalldataParams)(inputs, args);
    return {
        isRuntime: true,
        inputParams: inputParams,
        outputParams: []
    };
};
exports.runtimeEncodeAbiParameters = runtimeEncodeAbiParameters;
const isComposableCallRequired = (functionContext, args) => {
    if (!functionContext.inputs || functionContext.inputs.length <= 0)
        return false;
    const isComposableCall = functionContext.inputs.some((input, inputIndex) => {
        if (input.type === "tuple") {
            const isComposableCallDetected = Object.values(args[inputIndex]).some((internalArg) => (0, exports.isRuntimeComposableValue)(internalArg));
            return isComposableCallDetected;
        }
        if (input.type.match(/^(.*)\[(\d+)?\]$/)) {
            const isComposableCallDetected = args[inputIndex].some((internalArg) => (0, exports.isRuntimeComposableValue)(internalArg));
            return isComposableCallDetected;
        }
        return (0, exports.isRuntimeComposableValue)(args[inputIndex]);
    });
    return isComposableCall;
};
exports.isComposableCallRequired = isComposableCallRequired;
const prepareComposableInputCalldataParams = (inputs, args) => {
    const composableParams = (0, runtimeAbiEncoding_1.encodeRuntimeFunctionData)(inputs, args).map((calldata) => {
        if ((0, exports.isRuntimeComposableValue)(calldata)) {
            return calldata?.inputParams;
        }
        return [
            (0, exports.prepareInputParam)(exports.InputParamFetcherType.RAW_BYTES, calldata)
        ];
    });
    return composableParams.flat();
};
exports.prepareComposableInputCalldataParams = prepareComposableInputCalldataParams;
const prepareRawComposableParams = (calldata) => {
    const composableParams = [
        (0, exports.prepareInputParam)(exports.InputParamFetcherType.RAW_BYTES, calldata)
    ];
    return composableParams.flat();
};
exports.prepareRawComposableParams = prepareRawComposableParams;
//# sourceMappingURL=composabilityCalls.js.map