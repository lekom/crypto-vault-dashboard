import { getTransactionReceipt as getTransactionReceiptFromViem } from "viem/actions";
import { getExplorerTxLink, getJiffyScanLink, getMeeScanLink } from "../../../account/utils/explorer.js";
import { parseErrorMessage } from "../../../account/utils/parseErrorMessage.js";
import { parseTransactionStatus } from "../../../account/utils/parseTransactionStatus.js";
export async function getSupertransactionReceipt(client, parameters) {
    const { confirmations = 2, waitForReceipts = true, ...params } = parameters;
    const account = parameters.account ?? client.account;
    // We will collect all receipts only after happy path
    let receipts = null;
    const explorerResponse = await client.request({
        path: `explorer/${params.hash}`,
        method: "GET"
    });
    const userOpsWithoutPayment = explorerResponse.userOps.slice(1);
    const metaStatus = await parseTransactionStatus(userOpsWithoutPayment);
    switch (metaStatus.status) {
        case "FAILED": {
            console.log({ metaStatus, explorerResponse, hash: params.hash });
            throw new Error(parseErrorMessage(metaStatus.message));
        }
        case "MINED_FAIL": {
            console.log({ metaStatus, explorerResponse, hash: params.hash });
            throw new Error(parseErrorMessage(metaStatus.message));
        }
        case "PENDING": {
            break;
        }
        case "MINING": {
            break;
        }
        case "MINED_SUCCESS": {
            if (waitForReceipts) {
                receipts = await Promise.all(userOpsWithoutPayment
                    .filter((userOp) => {
                    // Cleanup userOps are ignored for transaction receipt if it is not successful
                    if (userOp.isCleanUpUserOp &&
                        userOp.executionStatus !== "MINED_SUCCESS") {
                        return false;
                    }
                    // Only the main userOps will be considered
                    return true;
                })
                    .map(async ({ chainId, executionData }) => {
                    return getTransactionReceiptFromViem(account.deploymentOn(Number(chainId), true).publicClient, {
                        confirmations,
                        ...parameters,
                        hash: executionData
                    });
                }));
            }
            break;
        }
        default: {
            throw new Error("Unknown transaction status");
        }
    }
    const explorerLinks = userOpsWithoutPayment.reduce((acc, userOp) => {
        acc.push(getExplorerTxLink(userOp.executionData, userOp.chainId), getJiffyScanLink(userOp.userOpHash));
        return acc;
    }, [getMeeScanLink(params.hash)]);
    return {
        ...explorerResponse,
        userOps: userOpsWithoutPayment,
        explorerLinks,
        receipts,
        transactionStatus: metaStatus.status
    };
}
export default getSupertransactionReceipt;
//# sourceMappingURL=getSupertransactionReceipt.js.map