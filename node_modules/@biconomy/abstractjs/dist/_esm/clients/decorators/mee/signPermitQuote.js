import { concatHex, encodeAbiParameters, parseSignature } from "viem";
import { multicall } from "viem/actions";
import { PERMIT_TYPEHASH } from "../../../constants/index.js";
import { TokenWithPermitAbi } from "../../../constants/abi/TokenWithPermitAbi.js";
const PERMIT_PREFIX = "0x177eee02";
/**
 * Prepares the payload required for signing a permit quote.
 * This function validates the trigger, fetches necessary token data (nonce, name, version, domain separator),
 * and constructs the EIP-712 signable payload for an ERC20 permit signature.
 * The returned object contains the signable payload and metadata required for formatting the final signed quote.
 *
 * @param quoteParams - The permit quote parameters, including the quote and trigger
 * @param owner - The address of the token owner (signer)
 * @param spender - The address that will be approved to spend the tokens
 * @param publicClient - The public or wallet client to interact with the token contract
 * @returns Promise resolving to an object containing the signable payload and metadata
 *
 * @example
 * ```typescript
 * const { signablePayload, metadata } = await prepareSignablePermitQuotePayload(
 *   fusionQuote,
 *   ownerAddress,
 *   spenderAddress,
 *   publicClient
 * );
 * // signablePayload: EIP-712 structured data for permit
 * // metadata: { nonce, name, version, domainSeparator, owner, spender, amount }
 * ```
 */
export const prepareSignablePermitQuotePayload = async (quoteParams, owner, spender, publicClient) => {
    const { quote, trigger } = quoteParams;
    // Type guard to ensure we have a TokenTrigger
    if (trigger.call) {
        throw new Error("Custom triggers are not supported for permit quotes");
    }
    if (!trigger.amount)
        throw new Error("Amount is required to sign a permit quote");
    // Check if we have an explicit `approvalAmount` set and error if it's smaller than the trigger amount
    if (trigger.approvalAmount &&
        trigger.amount !== undefined &&
        trigger.approvalAmount < trigger.amount) {
        throw new Error(`Approval amount must be bigger or equal with the amount from the trigger (triggerAmount: ${trigger.amount} amount: ${trigger.approvalAmount})`);
    }
    const amount = trigger.approvalAmount ?? trigger.amount;
    // Fetch required token data for EIP-712 domain and permit using multicall
    const values = await multicall(publicClient, {
        contracts: [
            {
                address: trigger.tokenAddress,
                abi: TokenWithPermitAbi,
                functionName: "nonces",
                args: [owner]
            },
            {
                address: trigger.tokenAddress,
                abi: TokenWithPermitAbi,
                functionName: "name"
            },
            {
                address: trigger.tokenAddress,
                abi: TokenWithPermitAbi,
                functionName: "version"
            },
            {
                address: trigger.tokenAddress,
                abi: TokenWithPermitAbi,
                functionName: "DOMAIN_SEPARATOR"
            },
            {
                address: trigger.tokenAddress,
                abi: TokenWithPermitAbi,
                functionName: "eip712Domain"
            }
        ]
    });
    const [nonce, name, version, domainSeparator, eip712Domain] = values.map((value, i) => {
        const key = [
            "nonce",
            "name",
            "version",
            "domainSeparator",
            "eip712Domain"
        ][i];
        if (value.status === "success") {
            return value.result;
        }
        if (value.status === "failure") {
            if (key === "nonce") {
                // Tokens must implement the nonces function, otherwise we throw a error here
                throw new Error("Permit signing failed: Token does not implement nonces(). This function is required for EIP-2612 compliance.");
            }
            if (key === "domainSeparator") {
                // Tokens must implement the domainSeparator function, otherwise we throw a error here
                throw new Error("Permit signing failed: Token does not implement DOMAIN_SEPARATOR(). This function is required for EIP-712 domain separation.");
            }
            if (key === "name" || key === "version") {
                // Some tokens do not implement name and version; defaults to undefined
                return undefined;
            }
            if (key === "eip712Domain") {
                // Some tokens do not implement eip712Domain; default to []
                return [];
            }
        }
        // Fallback return value instead of throwing error
        return undefined;
    });
    const [, name_, version_] = eip712Domain;
    // Default version will be used as fallback
    const defaultVersion = "1";
    if (version?.length >= 0 && version_?.length >= 0) {
        if (version !== version_)
            console.warn("Warning: Mismatch between token version() and eip712Domain().version. This may cause permit signature verification to fail.");
    }
    if (name?.length >= 0 && name_?.length >= 0) {
        if (name !== name_)
            console.warn("Warning: Mismatch between token name() and eip712Domain().name. This may cause permit signature verification to fail.");
    }
    if (name === undefined && name_ === undefined) {
        throw new Error("Permit signing failed: Token name is missing. Neither name() nor eip712Domain().name is available.");
    }
    const signablePermitQuotePayload = {
        domain: {
            name: name_ ?? name, // name from eip712Domain is mostly safe and more priority is given
            version: version_ ?? version ?? defaultVersion, // version from eip712Domain is mostly safe and more priority is given
            chainId: trigger.chainId,
            verifyingContract: trigger.tokenAddress
        },
        types: {
            Permit: [
                { name: "owner", type: "address" },
                { name: "spender", type: "address" },
                { name: "value", type: "uint256" },
                { name: "nonce", type: "uint256" },
                { name: "deadline", type: "uint256" }
            ]
        },
        primaryType: "Permit",
        message: {
            owner: owner,
            spender: spender,
            value: amount,
            nonce,
            deadline: BigInt(quote.hash)
        }
    };
    return {
        signablePayload: signablePermitQuotePayload,
        metadata: {
            nonce,
            name: name_ ?? name,
            version: version_ ?? version ?? defaultVersion,
            domainSeparator,
            owner,
            spender,
            amount
        }
    };
};
/**
 * Formats the signed permit quote payload by encoding the signature and permit parameters,
 * and attaching the result to the original quote. The signature is prefixed and concatenated
 * as required by the MEE service for permit quotes.
 * Metadata is used to provide the necessary context for encoding.
 *
 * @param quoteParams - The original permit quote parameters
 * @param metadata - Metadata returned from prepareSignablePermitQuotePayload
 * @param signature - The EIP-712 signature to attach to the quote
 * @returns The signed permit quote payload with the signature field
 *
 * @example
 * ```typescript
 * const signedPermitQuote = formatSignedPermitQuotePayload(
 *   fusionQuote,
 *   metadata,
 *   signature
 * );
 * // signedPermitQuote: { ...quote, signature: '0x177eee02<encodedPermitSignature>' }
 * ```
 */
export const formatSignedPermitQuotePayload = (quoteParams, metadata, signature) => {
    const { quote, trigger } = quoteParams;
    const sigComponents = parseSignature(signature);
    const encodedSignature = encodeAbiParameters([
        { name: "token", type: "address" },
        { name: "spender", type: "address" },
        { name: "domainSeparator", type: "bytes32" },
        { name: "permitTypehash", type: "bytes32" },
        { name: "amount", type: "uint256" },
        { name: "chainId", type: "uint256" },
        { name: "nonce", type: "uint256" },
        { name: "v", type: "uint256" },
        { name: "r", type: "bytes32" },
        { name: "s", type: "bytes32" }
    ], [
        trigger.tokenAddress,
        metadata.spender,
        metadata.domainSeparator,
        PERMIT_TYPEHASH,
        metadata.amount,
        BigInt(trigger.chainId),
        metadata.nonce,
        sigComponents.v,
        sigComponents.r,
        sigComponents.s
    ]);
    return { ...quote, signature: concatHex([PERMIT_PREFIX, encodedSignature]) };
};
/**
 * Signs a permit quote using EIP-2612 permit signatures. This enables gasless
 * approvals for ERC20 tokens that implement the permit extension.
 *
 * @param client - The Mee client instance
 * @param parameters - Parameters for signing the permit quote
 * @param parameters.fusionQuote - The permit quote to sign
 * @param [parameters.account] - Optional account to use for signing
 *
 * @returns Promise resolving to the quote payload with permit signature
 *
 * @example
 * ```typescript
 * const signedPermitQuote = await signPermitQuote(meeClient, {
 *   fusionQuote: {
 *     quote: quotePayload,
 *     trigger: {
 *       tokenAddress: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
 *       chainId: 1,
 *       amount: 1000000n // 1 USDC
 *     }
 *   },
 *   account: smartAccount // Optional
 * });
 * ```
 */
export const signPermitQuote = async (client, parameters) => {
    const { companionAccount: account_ = client.account, fusionQuote: { trigger } } = parameters;
    const signer = account_.signer;
    const { walletClient, address: spender } = account_.deploymentOn(trigger.chainId, true);
    const owner = signer.address;
    const { signablePayload, metadata } = await prepareSignablePermitQuotePayload(parameters.fusionQuote, owner, spender, walletClient);
    const signature = await walletClient.signTypedData({
        ...signablePayload,
        account: walletClient.account
    });
    return formatSignedPermitQuotePayload(parameters.fusionQuote, metadata, signature);
};
export default signPermitQuote;
//# sourceMappingURL=signPermitQuote.js.map