import { toNexusAccount } from "./toNexusAccount.js";
import { buildComposable as buildComposableDecorator, build as buildDecorator } from "./decorators/build.js";
import { buildBridgeInstructions as buildBridgeInstructionsDecorator } from "./decorators/buildBridgeInstructions.js";
import { getUnifiedERC20Balance as getUnifiedERC20BalanceDecorator } from "./decorators/getUnifiedERC20Balance.js";
import { isDelegated as isDelegatedDecorator } from "./decorators/isDelegated.js";
import multichainRead, {} from "./decorators/multichainRead.js";
import { queryBridge as queryBridgeDecorator } from "./decorators/queryBridge.js";
import { unDelegate as unDelegateDecorator } from "./decorators/unDelegate.js";
import { waitForTransactionReceipts as waitForTransactionReceiptsDecorator } from "./decorators/waitForTransactionReceipts.js";
/**
 * Creates a multichain Nexus account across specified chains
 *
 * @param parameters - {@link MultichainNexusParams} Configuration for multichain account creation
 * @param parameters.signer - The signer instance used for account creation
 * @param parameters.chainConfigurations - Array of chain configuration objects where the account will be deployed
 *
 * @returns Promise resolving to {@link MultichainSmartAccount} instance
 *
 * @throws Error if account creation fails on any chain
 *
 * @example
 * const account = await toMultichainNexusAccount({
 *   signer: mySigner,
 *   chainConfigurations: [
 *     {
 *       chain: optimism,
 *       transport: http(),
 *       version: getMEEVersion(MEEversion.V2_1_0)
 *     },
 *     {
 *       chain: base,
 *       transport: http(),
 *       version: getMEEVersion(MEEversion.V2_1_0)
 *     }
 *   ]
 * });
 *
 * // Get deployment on specific chain
 * const optimismDeployment = account.deploymentOn(10);
 *
 * // Check token balance across chains
 * const balance = await account.getUnifiedERC20Balance(mcUSDC);
 *
 * // Build bridge transaction
 * const bridgeInstructions = await account.buildBridgeInstructions({
 *   amount: BigInt("1000000"), // 1 USDC
 *   mcToken: mcUSDC,
 *   toChain: base
 * });
 */
export async function toMultichainNexusAccount(multiChainNexusParams) {
    const { signer: unresolvedSigner, chainConfigurations, ...accountParameters } = multiChainNexusParams;
    if (chainConfigurations.length === 0) {
        throw new Error("No chain configuration provided");
    }
    const deployments = await Promise.all(chainConfigurations.map((chainConfiguration) => toNexusAccount({
        signer: unresolvedSigner,
        chainConfiguration,
        ...accountParameters
    })));
    function deploymentOn(chainId, strictMode) {
        const deployment = deployments.find((dep) => dep.client.chain?.id === chainId);
        if (!deployment && strictMode) {
            throw new Error(`Deployment not found for chainId: ${chainId}`);
        }
        return deployment;
    }
    function addressOn(chainId, strictMode) {
        const deployment = deploymentOn(chainId, strictMode);
        return deployment?.address;
    }
    const meeVersions = deployments.map(({ version, chain }) => ({
        chainId: chain.id,
        version
    }));
    const baseAccount = {
        signer: deployments[0].signer, // This signer is resolved
        deployments,
        deploymentOn,
        addressOn
    };
    const getUnifiedERC20Balance = (mcToken) => getUnifiedERC20BalanceDecorator({ mcToken, account: baseAccount });
    const build = (params, currentInstructions) => buildDecorator({
        currentInstructions,
        accountAddress: baseAccount.signer.address,
        meeVersions
    }, params);
    const buildComposable = (params, currentInstructions) => {
        let composabilityVersion = undefined;
        let chainId = undefined;
        const type = params.type;
        if (type === "acrossIntent") {
            chainId = params.data.originChainId;
        }
        else if (type !== "batch") {
            chainId = params.data.chainId;
        }
        if (chainId) {
            composabilityVersion = getComposabilityVersion(chainId);
        }
        return buildComposableDecorator({
            currentInstructions,
            accountAddress: baseAccount.signer.address,
            meeVersions
        }, params, composabilityVersion);
    };
    const buildBridgeInstructions = (params) => buildBridgeInstructionsDecorator({ ...params });
    const queryBridge = (params) => queryBridgeDecorator({ ...params });
    const isDelegated = (parameters) => isDelegatedDecorator({ ...parameters, account: baseAccount });
    const unDelegate = (parameters) => unDelegateDecorator({ ...parameters, account: baseAccount });
    const waitForTransactionReceipts = (parameters) => waitForTransactionReceiptsDecorator({ ...parameters, account: baseAccount });
    const getComposabilityVersion = (chainId) => {
        const chainConfiguration = chainConfigurations.find((chainConfiguration) => chainConfiguration.chain.id === chainId);
        if (!chainConfiguration) {
            throw new Error(`Chain configuration not found in mc account for chainId: ${chainId} that is used in the instruction params`);
        }
        return chainConfiguration.version.composabilityVersion;
    };
    const read = (params) => multichainRead(baseAccount, params);
    // The specific deployment doesn't matter here because chainId = 0
    const toDelegation = async () => await deployments[0].toDelegation({ multiChain: true });
    return {
        ...baseAccount,
        getUnifiedERC20Balance,
        build,
        buildComposable,
        buildBridgeInstructions,
        queryBridge,
        isDelegated,
        getComposabilityVersion,
        unDelegate,
        waitForTransactionReceipts,
        read,
        toDelegation
    };
}
//# sourceMappingURL=toMultiChainNexusAccount.js.map