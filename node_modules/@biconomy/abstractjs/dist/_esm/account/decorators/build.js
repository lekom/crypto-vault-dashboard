import { isRuntimeComposableValue } from "../../modules/utils/composabilityCalls.js";
import buildAcrossIntentComposable, {} from "./instructions/buildAcrossIntentComposable.js";
import { buildApprove } from "./instructions/buildApprove.js";
import buildBatch, {} from "./instructions/buildBatch.js";
import { buildComposableUtil } from "./instructions/buildComposable.js";
import { buildDefaultInstructions } from "./instructions/buildDefaultInstructions.js";
import { buildIntent } from "./instructions/buildIntent.js";
import { buildMultichainInstructions } from "./instructions/buildMultichainInstructions.js";
import buildNativeTokenTransfer, {} from "./instructions/buildNativeTokenTransfer.js";
import buildRawComposable, {} from "./instructions/buildRawComposable.js";
import { buildTransfer } from "./instructions/buildTransfer.js";
import { buildTransferFrom } from "./instructions/buildTransferFrom.js";
import buildWithdrawal, {} from "./instructions/buildWithdrawal.js";
/**
 * Builds transaction instructions based on the provided action type and parameters
 *
 * @param baseParams - {@link BaseInstructionsParams} Base configuration for instructions
 * @param baseParams.account - The multichain smart account to check balances for
 * @param baseParams.currentInstructions - Optional array of existing instructions to append to
 * @param parameters - {@link BuildInstructionTypes} The build action configuration
 * @param parameters.type - The type of build action ("default" | "intent")
 * @param parameters.data - Action-specific parameters based on the type
 *
 * @returns Promise resolving to an array of {@link Instruction}
 *
 * @example
 * // Bridge tokens example
 * const bridgeInstructions = await build(
 *   { accountAddres: mcNexus.signer.address },
 *   {
 *     type: "intent",
 *     data: {
 *       depositor: mcNexus.addressOn(paymentChain.id, true),
 *       recipient: mcNexus.addressOn(targetChain.id, true),
 *       amount: 1n,
 *       token: {
 *         mcToken: mcUSDC,
 *         unifiedBalance: await mcNexus.getUnifiedERC20Balance(mcUSDC)
 *       },
 *       toChainId: targetChain.id
 *     }
 *   }
 * );
 *
 * @example
 * // Default action example
 * const defaultInstructions = await build(
 *   { accountAddress: "0x00000000000000000000000000000000000a11ce" },
 *   {
 *     type: "default",
 *     data: {
 *       instructions: myExistingInstruction
 *     }
 *   }
 * );
 */
export const build = async (baseParams, parameters) => {
    const { type, data } = parameters;
    const containsRuntimeValues = Object.values(data).some((value) => isRuntimeComposableValue(value));
    if (containsRuntimeValues) {
        throw new Error("Runtime values are not supported for `build` action. Use `buildComposable` instead.");
    }
    switch (type) {
        case "intent": {
            return buildIntent(baseParams, data);
        }
        case "default": {
            return buildDefaultInstructions(baseParams, data);
        }
        case "transferFrom": {
            return buildTransferFrom(baseParams, data);
        }
        case "transfer": {
            return buildTransfer(baseParams, data);
        }
        case "nativeTokenTransfer": {
            return buildNativeTokenTransfer(baseParams, data);
        }
        case "approve": {
            return buildApprove(baseParams, data);
        }
        case "withdrawal": {
            return buildWithdrawal(baseParams, data);
        }
        case "batch": {
            return buildBatch(baseParams, data);
        }
        case "multichain": {
            return buildMultichainInstructions(baseParams, data);
        }
        default: {
            throw new Error(`Unknown build action type: ${type}`);
        }
    }
};
// Exactly same as build decorator, but forces to use composable call.
// If this is used via mcNexus.buildComposable, then the composabilityVersion is auto-detected for all the required cases.
export const buildComposable = async (baseParams, parameters, composabilityVersion) => {
    const { type, data, efficientMode } = parameters;
    // in batch mode only, we do not need to specify the composability version
    if (type !== "batch" && !composabilityVersion) {
        throw new Error(`Composability version param is required for composable type: ${type}`);
    }
    // so here and below we are sure, that composabilityVersion is defined
    switch (type) {
        case "default": {
            return buildComposableUtil(baseParams, data, {
                composabilityVersion: composabilityVersion,
                efficientMode
            });
        }
        case "rawCalldata": {
            return buildRawComposable(baseParams, data, {
                composabilityVersion: composabilityVersion
            });
        }
        case "transferFrom": {
            return buildTransferFrom(baseParams, data, {
                forceComposableEncoding: true,
                efficientMode,
                composabilityVersion: composabilityVersion
            });
        }
        case "transfer": {
            return buildTransfer(baseParams, data, {
                forceComposableEncoding: true,
                efficientMode,
                composabilityVersion: composabilityVersion
            });
        }
        case "nativeTokenTransfer": {
            return buildNativeTokenTransfer(baseParams, data, {
                forceComposableEncoding: true,
                efficientMode,
                composabilityVersion: composabilityVersion
            });
        }
        case "approve": {
            return buildApprove(baseParams, data, {
                forceComposableEncoding: true,
                efficientMode,
                composabilityVersion: composabilityVersion
            });
        }
        case "withdrawal": {
            return buildWithdrawal(baseParams, data, {
                forceComposableEncoding: true,
                efficientMode,
                composabilityVersion: composabilityVersion
            });
        }
        case "batch": {
            return buildBatch(baseParams, data);
        }
        case "acrossIntent": {
            return buildAcrossIntentComposable(baseParams, data, {
                composabilityVersion: composabilityVersion,
                efficientMode: false, // nothing to group in this case
                forceComposableEncoding: true // both subactions are composable
            });
        }
        default: {
            throw new Error(`Unknown build action type: ${type}`);
        }
    }
};
export default build;
//# sourceMappingURL=build.js.map