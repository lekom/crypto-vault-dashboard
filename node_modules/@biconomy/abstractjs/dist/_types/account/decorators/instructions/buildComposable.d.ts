import { type Abi, type Address } from "viem";
import type { Instruction } from "../../../clients/decorators/mee";
import type { InstructionMetadata } from "../../../clients/decorators/mee/types/instruction-metadata.type";
import { ComposabilityVersion } from "../../../constants";
import type { AnyData } from "../../../modules/utils/Types";
import { type ComposableCall, type InputParam } from "../../../modules/utils/composabilityCalls";
import { type ExecutionCondition } from "../../../modules/utils/conditions";
import { type RuntimeValue } from "../../../modules/utils/runtimeAbiEncoding";
import type { BaseInstructionsParams, ComposabilityParams } from "../build";
/**
 * Parameters for building a composable instruction
 */
export type BuildComposableParameters = {
    to: Address | RuntimeValue;
    functionName: string;
    args: Array<AnyData>;
    abi: Abi;
    chainId: number;
    gasLimit?: bigint;
    value?: bigint | RuntimeValue;
    /**
     * Optional conditions that must be satisfied before execution.
     * All conditions are evaluated via STATIC_CALL before the main function.
     * Transaction reverts if any condition fails.
     * @since v1.2.0
     */
    conditions?: ExecutionCondition[];
    /**
     * Optional metadata describing the instruction for display purposes
     */
    metadata?: InstructionMetadata[];
};
export type BuildNativeTokenTransferComposableParameters = {
    to: Address | RuntimeValue;
    gasLimit?: bigint;
    value: bigint | RuntimeValue;
    chainId: number;
    metadata?: InstructionMetadata[];
};
export declare const buildComposableCall: (parameters: BuildComposableParameters, composabilityParameters: ComposabilityParams) => Promise<ComposableCall[]>;
/**
 * Formats the composable call version based on the composability version
 * @param composabilityVersion
 * @param efficientMode
 * @param versionAgnosticComposableInputParams
 * @param functionContext
 * @param to
 * @param value
 * @param gasLimit
 * @returns
 */
export declare const formatComposableCallWithVersion: (composabilityVersion: ComposabilityVersion, efficientMode: boolean, versionAgnosticComposableInputParams: InputParam[], functionSig: string, to: Address | RuntimeValue, value?: bigint | RuntimeValue, gasLimit?: bigint) => ComposableCall;
/**
 * Formats the call data input params based on the composability version
 * @param composabilityVersion
 * @param efficientMode
 * @param versionAgnosticInputParams
 * @returns
 */
export declare const formatCallDataInputParamsWithVersion: (composabilityVersion: ComposabilityVersion, efficientMode: boolean, versionAgnosticInputParams: InputParam[]) => InputParam[];
/**
 * Builds an instruction for composable transaction. This is a generic function which creates the composable instructions
 * to execute against composability stack
 *
 * @param baseParams - Base configuration for the instruction
 * @param baseParams.account - The account that will execute the composable transaction
 * @param baseParams.currentInstructions - Optional array of existing instructions to append to
 * @param parameters - Parameters for generate composable instruction
 * @param parameters.to - Address of the target contract address
 * @param parameters.functionName - Function signature of the composable transaction call
 * @param parameters.args - Function arguments of the composable transaction call
 * @param parameters.abi - ABI of the contract where the composable transaction call is being generated from
 * @param parameters.chainId - Chain where the composable transaction will be executed
 * @param composabilityParams.composabilityVersion - Composability version to use
 * @param composabilityParams.efficientMode - boolean whether to compress the calldata input params or not
 * @param composabilityParams.forceComposableEncoding - boolean whether to force use composability or not
 * @param [parameters.gasLimit] - Optional gas limit
 * @param [parameters.value] - Optional native token value
 *
 * @returns Promise resolving to array of instructions
 *
 * @example
 * ```typescript
 * const instructions = buildComposable(
 *   { accountAddress: '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' },
 *   {
 *     to: targetContractAddress,
 *     functionName: 'exactInputSingle',
 *     args: [
 *        {
 *          tokenIn: inToken.addressOn(baseSepolia.id),
 *          tokenOut: outToken.addressOn(baseSepolia.id),
 *          fee: 3000,
 *          recipient: recipient,
 *          deadline: BigInt(Math.floor(Date.now() / 1000) + 900),
 *          amountIn: runtimeERC20BalanceOf({ targetAddress: recipient, tokenAddress: testnetMcTestUSDCP.addressOn(baseSepolia.id), constraints: [] }),
 *          amountOutMinimum: BigInt(1),
 *          sqrtPriceLimitX96: BigInt(0),
 *        },
 *     ]
 *     chainId: baseSepolia.id,
 *     abi: UniswapSwapRouterAbi
 *   },
 *   {
 *     composabilityVersion: ComposabilityVersion.V1_0_0
 *     efficientMode: true
 *     forceComposableEncoding: false
 *   }
 * )
 * ```
 */
export declare const buildComposableUtil: (baseParams: BaseInstructionsParams, parameters: BuildComposableParameters, composabilityParams: ComposabilityParams) => Promise<Instruction[]>;
export default buildComposableUtil;
//# sourceMappingURL=buildComposable.d.ts.map