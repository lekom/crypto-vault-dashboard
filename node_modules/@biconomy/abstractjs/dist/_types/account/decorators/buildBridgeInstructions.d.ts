import type { Address } from "viem";
import type { Instruction } from "../../clients/decorators/mee/getQuote";
import type { InstructionMetadata } from "../../clients/decorators/mee/types/instruction-metadata.type";
import type { UnifiedERC20Balance } from "./getUnifiedERC20Balance";
/**
 * Mapping of a token address to a specific chain
 * @property chainId - The numeric ID of the chain
 * @property address - {@link Address} The token's contract address on the chain
 */
export type AddressMapping = {
    chainId: number;
    address: Address;
};
/**
 * Cross-chain token address mapping with helper functions
 * @property deployments - Array of {@link AddressMapping} containing token addresses per chain
 * @property on - Function to retrieve token address for a specific chain ID
 */
export type MultichainAddressMapping = {
    deployments: AddressMapping[];
    on: (chainId: number) => Address;
};
/**
 * Fee data for the transaction fee
 * @property txFeeChainId - The chain ID where the tx fee is paid
 * @property txFeeAmount - The amount of tx fee to pay
 */
export type FeeData = {
    txFeeChainId: number;
    txFeeAmount: bigint;
};
/**
 * Parameters for multichain token bridging operations
 * @property depositor - {@link Address} The address initiating the bridge (sender)
 * @property recipient - {@link Address} The address receiving the bridged tokens (destination)
 * @property toChainId - The numeric chain ID of the destination chain
 * @property unifiedBalance - {@link UnifiedERC20Balance} Token balance information across all chains
 * @property amount - Amount of tokens to bridge as bigint
 * @property bridgingPlugins - Optional array of {@link BridgingPlugin} to use for bridging
 * @property feeData - Optional {@link FeeData} for the transaction
 * @property mode - Optional bridging mode, either "DEBIT" or "OPTIMISTIC"
 */
export type MultichainBridgingParams = {
    depositor: Address;
    recipient: Address;
    toChainId: number;
    unifiedBalance: UnifiedERC20Balance;
    amount: bigint;
    bridgingPlugins?: BridgingPlugin[];
    feeData?: FeeData;
    mode?: "DEBIT" | "OPTIMISTIC";
    metadata?: InstructionMetadata[];
};
/**
 * Result of a bridging plugin operation
 * @property userOp - {@link Instruction} User operation to execute the bridge
 * @property receivedAtDestination - Expected amount to be received after bridging
 * @property bridgingDurationExpectedMs - Expected duration of the bridging operation
 */
export type BridgingPluginResult = {
    userOp: Instruction;
    receivedAtDestination?: bigint;
    bridgingDurationExpectedMs?: number;
};
/**
 * Parameters for generating a bridge user operation
 * @property depositor - {@link Address} The address initiating the bridge (sender)
 * @property recipient - {@link Address} The address receiving the bridged tokens (destination)
 * @property fromChainId - The numeric chain ID of the source chain
 * @property toChainId - The numeric chain ID of the destination chain
 * @property tokenMapping - {@link MultichainAddressMapping} Token addresses across chains
 * @property bridgingAmount - Amount to bridge as BigInt
 */
export type BridgingUserOpParams = {
    depositor: Address;
    recipient: Address;
    fromChainId: number;
    toChainId: number;
    tokenMapping: MultichainAddressMapping;
    bridgingAmount: bigint;
};
/**
 * Interface for a bridging plugin implementation
 */
export type BridgingPlugin = {
    /** Generates a user operation for bridging tokens */
    encodeBridgeUserOp: (params: BridgingUserOpParams) => Promise<BridgingPluginResult>;
};
/**
 * Single bridge operation result
 * @property userOp - {@link Instruction} User operation to execute
 * @property receivedAtDestination - Expected amount to be received at destination
 * @property bridgingDurationExpectedMs - Expected duration of the bridging operation
 */
export type BridgingInstruction = {
    userOp: Instruction;
    receivedAtDestination?: bigint;
    bridgingDurationExpectedMs?: number;
};
/**
 * Complete set of bridging instructions and final outcome
 * @property instructions - Array of {@link Instruction} to execute
 * @property meta - Meta information about the bridging process
 */
export type BridgingInstructions = {
    instructions: Instruction[];
    meta: {
        totalAvailableOnDestination: bigint;
        bridgingInstructions: BridgingInstruction[];
    };
};
/**
 * Makes sure that the user has enough funds on the selected chain before filling the
 * supertransaction. Bridges funds from other chains if needed.
 *
 * @param params - {@link MultichainBridgingParams} Configuration for the bridge operation
 * @param params.depositor - The address initiating the bridge (sender)
 * @param params.recipient - The address receiving the bridged tokens (destination)
 * @param params.toChainId - The numeric chain ID of the destination chain
 * @param params.unifiedBalance - Current token balances across chains
 * @param params.amount - The amount to bridge
 * @param params.bridgingPlugins - Optional array of bridging plugins (defaults to Across)
 * @param params.feeData - Optional fee configuration
 * @param params.mode - The mode of the bridge operation, defaults to "DEBIT". In optimistic mode, the bridging instructions are returned without preexisting balance checks.
 *
 * @returns Promise resolving to {@link BridgingInstructions} containing all necessary operations
 *
 * @throws Error if insufficient balance is available for bridging
 * @throws Error if chain configuration is missing for any deployment
 *
 * @example
 * const bridgeInstructions = await buildBridgeInstructions({
 *   depositor: myAddress,
 *   recipient: recipientAddress,
 *   amount: BigInt("1000000"), // 1 USDC
 *   toChainId: optimism.id,
 *   unifiedBalance: myTokenBalance,
 *   bridgingPlugins: [acrossPlugin],
 *   feeData: {
 *     txFeeChainId: 1,
 *     txFeeAmount: BigInt("100000")
 *   }
 * });
 */
export declare const buildBridgeInstructions: (params: MultichainBridgingParams) => Promise<BridgingInstructions>;
export default buildBridgeInstructions;
//# sourceMappingURL=buildBridgeInstructions.d.ts.map