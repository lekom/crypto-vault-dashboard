import type { StatusFetchMode, UserOpStatus } from "../../clients/decorators/mee";
import type { MeeFilledUserOpDetails } from "../../clients/decorators/mee/getQuote";
/**
 * Transaction status result including status and finality information
 */
export type TransactionStatusResult = {
    /** The overall status of the transaction */
    status: UserOpStatus["executionStatus"];
    /** Whether the transaction has reached a final state (FAILED, MINED_SUCCESS, MINED_FAIL) */
    isFinalised: boolean;
    /** Error message when a transaction has failed, empty string otherwise */
    message: string;
};
/**
 * Final status types
 */
export declare const FINAL_STATUSES: string[];
/**
 * Calculate the overall transaction status based on individual userOp statuses.
 *
 * Status definitions:
 * - PENDING: node waiting for conditions to be met
 * - FAILED: off chain failure
 * - MINING: tx broadcasted
 * - MINED_SUCCESS: tx mined and userOp status: success
 * - MINED_FAIL: tx mined and userOp status: fail
 *
 * Overall status calculation rules:
 * 1. If any userOp has FAILED status, return "FAILED" (off-chain failure)
 * 2. If any userOp has MINED_FAIL status, return "MINED_FAIL" (on-chain failure)
 * 3. If any userOp has PENDING status, return "PENDING" (still waiting for conditions)
 * 4. If any userOp has MINING status, return "MINING" (transaction in progress)
 * 5. If all userOps have MINED_SUCCESS status, return "MINED_SUCCESS" (all successful)
 * 6. Otherwise, return "PENDING" (default fallback)
 *
 * @param userOps - The user operations with their execution statuses
 * @returns The calculated overall transaction status with finality information
 */
export declare const parseTransactionStatus: (userOps: (MeeFilledUserOpDetails & UserOpStatus)[], mode?: StatusFetchMode) => Promise<TransactionStatusResult>;
export default parseTransactionStatus;
//# sourceMappingURL=parseTransactionStatus.d.ts.map