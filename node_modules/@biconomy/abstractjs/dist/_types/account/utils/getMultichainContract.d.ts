import type { AbiParametersToPrimitiveTypes, ExtractAbiFunction, ExtractAbiFunctionNames } from "abitype";
import type { Abi, Address, Chain, ContractFunctionArgs, ContractFunctionName, ContractFunctionReturnType } from "viem";
import type { Instruction } from "../../clients/decorators/mee/getQuote";
import type { MultichainSmartAccount } from "../toMultiChainNexusAccount";
export declare const LARGE_DEFAULT_GAS_LIMIT = 700000n;
/**
 * Contract instance capable of encoding transactions across multiple chains
 * @template TAbi - The contract ABI type
 * @property abi - {@link Abi} The contract's ABI
 * @property deployments - Map of chain IDs to {@link Address} contract addresses
 * @property on - Function to get chain-specific contract instance
 * @property addressOn - Function to get contract address for a specific chain
 * @property read - Function to read contract state across multiple chains
 */
export type MultichainContract<TAbi extends Abi> = {
    abi: TAbi;
    deployments: Map<number, Address>;
    on: (chainId: number) => ChainSpecificContract<TAbi>;
    addressOn: (chainId: number) => Address;
    read: <TFunctionName extends ContractFunctionName<TAbi, "pure" | "view">>(params: {
        onChains: Chain[];
        functionName: TFunctionName;
        args: ContractFunctionArgs<TAbi, "pure" | "view", TFunctionName>;
        account: MultichainSmartAccount;
    }) => Promise<Array<{
        chainId: number;
        result: ContractFunctionReturnType<TAbi, "pure" | "view", TFunctionName>;
    }>>;
    build: <TFunctionName extends ContractFunctionName<TAbi, "payable" | "nonpayable">>(params: {
        type: TFunctionName;
        data: {
            chainId: number;
            args: ContractFunctionArgs<TAbi, "payable" | "nonpayable", TFunctionName>;
            gasLimit?: bigint;
        };
    }) => Promise<Instruction>;
};
/**
 * Chain-specific contract instance with typed function calls
 * @template TAbi - The contract ABI type
 * @property [functionName] - Each function from the ABI becomes a property that returns an {@link Instruction}
 */
export type ChainSpecificContract<TAbi extends Abi> = {
    [TFunctionName in ExtractAbiFunctionNames<TAbi>]: (params: {
        args: AbiParametersToPrimitiveTypes<ExtractAbiFunction<TAbi, TFunctionName>["inputs"]>;
        gasLimit?: bigint;
        value?: bigint;
    }) => Instruction;
};
/**
 * Creates a contract instance that can encode function calls across multiple chains
 *
 * @template TAbi - The contract ABI type
 * @param config - Configuration for the multichain contract
 * @param config.abi - {@link Abi} The contract's ABI
 * @param config.deployments - Array of tuples containing [address, chainId] for each deployment
 *
 * @returns {@link MultichainContract} A contract instance that works across multiple chains
 *
 * @throws Error if attempting to access contract on an unsupported chain
 * @throws Error if attempting to call a non-existent function
 * @throws Error if attempting to read a non-view/pure function
 *
 * @example
 * const mcUSDC = getMultichainContract({
 *   abi: erc20ABI,
 *   deployments: [
 *     ["0x7F5c764cBc14f9669B88837ca1490cCa17c31607", optimism.id], // Optimism USDC
 *     ["0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913", base.id]      // Base USDC
 *   ]
 * });
 *
 * // Encode a transfer on Optimism
 * const transferOp = mcUSDC.on(optimism.id).transfer({
 *   args: ["0x123...", BigInt("1000000")], // 1 USDC
 *   gasLimit: 100000n
 * });
 *
 * // Read balances across multiple chains
 * const balances = await mcUSDC.read({
 *   onChains: [optimism, base],
 *   functionName: "balanceOf",
 *   args: ["0x123..."],
 *   account: myMultichainAccount
 * });
 */
export declare function getMultichainContract<TAbi extends Abi>(config: {
    abi: TAbi;
    deployments: [Address, number][];
}): MultichainContract<TAbi>;
//# sourceMappingURL=getMultichainContract.d.ts.map