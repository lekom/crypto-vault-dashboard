import { type AbiParameter, type Address, type Hex } from "viem";
import type { Abi } from "viem";
import type { AnyData } from "../../modules/utils/Types";
import { type FunctionContext, type RuntimeValue } from "./runtimeAbiEncoding";
/**
 * fetcherType: Defines how to fetch the param
 * paramData: The data that is used during fetching the param
 * constraints: The constraints that the resulting param needs to satisfy
 * paramType: The type of the param. This field is optional and it is introduced in the composability version 1.1.0
 * If earlier versions are used, this field may not not present.
 */
export type InputParam = {
    paramType?: InputParamType;
    fetcherType: InputParamFetcherType;
    paramData: string;
    constraints: Constraint[];
};
export type OutputParam = {
    fetcherType: OutputParamFetcherType;
    paramData: string;
};
/**
 * paramType: The type of the param.
 * TARGET: The target address => used as a target address for the call
 * VALUE: The value => used as a native value for the call
 * CALL_DATA: processed param will be part of the calldata for the call
 * This field is optional and it is introduced in the composability version 1.1.0
 * If earlier versions are used, this field may not not present.
 */
export declare const InputParamType: {
    readonly TARGET: 0;
    readonly VALUE: 1;
    readonly CALL_DATA: 2;
};
/**
 * fetcherType: Defines how to fetch the param
 * RAW_BYTES: just use param data as is (raw bytes)
 * STATIC_CALL: param data defines the params for the static call
 * Outputs of the static call will form the processed param
 * BALANCE: param data defines the params for the balance query
 */
export declare const InputParamFetcherType: {
    readonly RAW_BYTES: 0;
    readonly STATIC_CALL: 1;
    readonly BALANCE: 2;
};
export declare const OutputParamFetcherType: {
    readonly EXEC_RESULT: 0;
    readonly STATIC_CALL: 1;
};
export declare const ConstraintType: {
    readonly EQ: 0;
    readonly GTE: 1;
    readonly LTE: 2;
    readonly IN: 3;
};
export type InputParamFetcherType = (typeof InputParamFetcherType)[keyof typeof InputParamFetcherType];
export type OutputParamFetcherType = (typeof OutputParamFetcherType)[keyof typeof OutputParamFetcherType];
export type ConstraintType = (typeof ConstraintType)[keyof typeof ConstraintType];
export type InputParamType = (typeof InputParamType)[keyof typeof InputParamType];
export type Constraint = {
    constraintType: ConstraintType;
    referenceData: string;
};
/**
 * Base composable call type
 * @param functionSig - The function signature of the composable call
 * @param inputParams - The input parameters of the composable call
 * @param outputParams - The output parameters of the composable call
 * @param to - The address of the target contract.
 * @param value - The value of the composable call.
 * Since Composability version 1.1.0, to and value are not required
 * as they are replaced by the input params with according types (TARGET, VALUE)
 */
export type BaseComposableCall = {
    to?: Address;
    value?: bigint;
    functionSig: string;
    inputParams: InputParam[];
    outputParams: OutputParam[];
};
export type ComposableCall = BaseComposableCall & {
    gasLimit?: bigint;
};
export type ConstraintField = {
    type: ConstraintType;
    value: AnyData;
};
export type RuntimeParamViaCustomStaticCallParams = {
    targetContractAddress: Address;
    functionAbi: Abi;
    args: Array<AnyData>;
    functionName?: string;
    constraints?: ConstraintField[];
};
export type runtimeERC20AllowanceOfParams = {
    owner: Address;
    spender: Address;
    tokenAddress: Address;
    constraints?: ConstraintField[];
};
export type RuntimeBalanceOfParams = {
    targetAddress: Address;
    tokenAddress: Address;
    constraints?: ConstraintField[];
};
export type RuntimeNativeBalanceOfParams = Omit<RuntimeBalanceOfParams, "tokenAddress">;
export type RuntimeNonceOfParams = {
    smartAccountAddress: Address;
    nonceKey: bigint;
    constraints?: ConstraintField[];
};
export declare const isRuntimeComposableValue: (value: AnyData) => boolean;
export declare const prepareInputParam: (fetcherType: InputParamFetcherType, paramData: string, constraints?: Constraint[]) => InputParam;
export declare const prepareOutputParam: (fetcherType: OutputParamFetcherType, paramData: string) => OutputParam;
export declare const prepareConstraint: (constraintType: ConstraintType, referenceData: string) => Constraint;
export declare const greaterThanOrEqualTo: (value: AnyData) => ConstraintField;
export declare const lessThanOrEqualTo: (value: AnyData) => ConstraintField;
export declare const equalTo: (value: AnyData) => ConstraintField;
/**
 * Validates and processes constraints for runtime functions
 * @param constraints - Array of constraint fields to validate and process
 * @returns Array of processed constraints ready for use
 */
export declare const validateAndProcessConstraints: (constraints: ConstraintField[]) => Constraint[];
export declare const runtimeNonceOf: ({ smartAccountAddress, nonceKey, constraints }: RuntimeNonceOfParams) => RuntimeValue;
export declare const runtimeParamViaCustomStaticCall: ({ targetContractAddress, functionAbi, functionName, args, constraints }: RuntimeParamViaCustomStaticCallParams) => RuntimeValue;
/**
 * Returns the runtime value for the ERC20 allowance of the owner for the spender
 * @param owner - The owner of the tokens
 * @param spender - The spender of the tokens
 * @param tokenAddress - The address of the ERC20 token
 * @returns The runtime value for the ERC20 allowance of the owner for the spender
 */
export declare const runtimeERC20AllowanceOf: ({ owner, spender, tokenAddress, constraints }: runtimeERC20AllowanceOfParams) => RuntimeValue;
/**
 * Returns the runtime value for the native balance of the target address
 * Utilizes the BALANCE fetcherType
 * @param targetAddress - The address of the target account
 * @returns The runtime value for the native balance of the target address
 */
export declare const runtimeNativeBalanceOf: ({ targetAddress, constraints }: RuntimeNativeBalanceOfParams) => RuntimeValue;
/**
 * Returns the runtime value for the ERC20 balance of the target address
 * @param targetAddress - The address of the target account
 * @param tokenAddress - The address of the ERC20 token
 * @returns The runtime value for the ERC20 balance of the target address
 */
export declare const runtimeERC20BalanceOf: ({ targetAddress, tokenAddress, constraints }: RuntimeBalanceOfParams) => RuntimeValue;
export declare const runtimeEncodeAbiParameters: (inputs: AbiParameter[], args: Array<AnyData>) => RuntimeValue;
export declare const isComposableCallRequired: (functionContext: FunctionContext, args: Array<AnyData>) => boolean;
export declare const prepareComposableInputCalldataParams: (inputs: AbiParameter[], args: Array<AnyData>) => InputParam[];
export declare const prepareRawComposableParams: (calldata: Hex) => InputParam[];
//# sourceMappingURL=composabilityCalls.d.ts.map