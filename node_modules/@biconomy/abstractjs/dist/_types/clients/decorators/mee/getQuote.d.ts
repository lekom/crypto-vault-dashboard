import type { Address, Hex, OneOf } from "viem";
import type { SignAuthorizationReturnType } from "viem/accounts";
import type { MultichainSmartAccount } from "../../../account/toMultiChainNexusAccount";
import type { RuntimeValue } from "../../../modules";
import { type ComposableCall } from "../../../modules/utils/composabilityCalls";
import type { GrantPermissionResponseEntry } from "../../../modules/validators/smartSessions/decorators/grantPermission";
import type { GrantMeePermissionPayload } from "../../../modules/validators/smartSessions/decorators/mee/grantMeePermission";
import { type Url } from "../../createHttpClient";
import { type BaseMeeClient } from "../../createMeeClient";
import type { QuoteType } from "./getQuoteType";
import type { TokenTrigger } from "./signPermitQuote";
import type { InstructionMetadata } from "./types/instruction-metadata.type";
export declare const USEROP_MIN_EXEC_WINDOW_DURATION = 180;
export declare const CLEANUP_USEROP_EXTENDED_EXEC_WINDOW_DURATION: number;
export declare const DEFAULT_GAS_LIMIT = 75000n;
export declare const DEFAULT_VERIFICATION_GAS_LIMIT = 150000n;
/**
 * Represents an abstract call to be executed in the transaction.
 * Each call specifies a target contract and optional parameters.
 */
export type AbstractCall = {
    /** Address of the contract to call */
    to: Address;
    /**
     * Gas limit for the call execution. Defaults to 500_000n.
     * Overestimated gas will be refunded.
     */
    gasLimit?: bigint;
} & OneOf<{
    value: bigint;
    data?: Hex;
} | {
    value?: bigint;
    data: Hex;
} | {
    value: bigint;
    data: Hex;
}>;
/**
 * Information about the fee token to be used for the transaction
 */
export type FeeTokenInfo = {
    /**
     * Address of the fee token
     * @example "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48" // USDC
     */
    address: Address;
    /**
     * Chain ID where the fee token is deployed
     * @example 1 // Ethereum Mainnet
     */
    chainId: number;
    /**
     * Custom gas refund address to get the refunds for the remaining unspent gas. Defaults to Nexus SCA.
     * The gas refunds will be always in ETH irrespective of any feeToken and will be refunded on multiple chains depends upon the userOps involved
     * @example "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48" // can be any address such as EOA, SCA, etc...
     */
    gasRefundAddress?: Address;
};
/**
 * Information about the instructions to be executed in the transaction
 * @internal
 */
export type Instruction = {
    /** Array of abstract calls to be executed in the transaction */
    calls: AbstractCall[] | ComposableCall[];
    /**
     * Chain ID where the transaction will be executed
     * @example 1 // Ethereum Mainnet
     */
    chainId: number;
    /** Flag for composable call */
    isComposable?: boolean;
    /** Instruction metadata */
    metadata?: InstructionMetadata[];
};
/**
 * Represents a supertransaction, which is a collection of instructions
 * to be executed in a single transaction across multiple chains
 */
export type Supertransaction = {
    /** Array of instructions to be executed in the transaction */
    instructions: Instruction[];
    /** Token to be used for paying transaction fees */
    feeToken: FeeTokenInfo;
};
/**
 * Union type for different instruction formats that can be provided
 */
export type InstructionLike = Promise<Instruction> | Promise<Instruction[]> | Instruction[] | Instruction;
/**
 * Parameters for creating a supertransaction with flexible instruction formats
 */
export type SupertransactionLike = {
    /** Array of instructions in various formats */
    instructions: InstructionLike[];
    /** Token to be used for paying fees */
    feeToken?: FeeTokenInfo;
};
/**
 * Supported wallet providers for executing transactions
 */
export type WalletProvider = "BICO_V2" | "BICO_V2_EOA" | "SAFE_V141" | "ZERODEV_V24" | "ZERODEV_V31";
/**
 * Parameters for a cleanup userops
 */
export type CleanUp = {
    /**
     * The address of the token to cleanup
     * @example "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48" // USDC
     */
    tokenAddress: Address;
    /**
     * The chainId to use
     * @example 1 // Ethereum Mainnet
     */
    chainId: number;
    /**
     * Amount of the token to use, in the token's smallest unit or a runtime value
     * @example 1000000n // 1 USDC (6 decimals) or runtimeERC20BalanceOf
     */
    amount?: bigint | RuntimeValue;
    /**
     * Custom gas limit for cleanup userOp
     * @example 1n
     */
    gasLimit?: bigint;
    /**
     * The address of the receiver where the token to cleanup
     * @example "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48" // EVM address
     */
    recipientAddress: Address;
    /**
     * The user ops dependency for nonce injection
     * @example [userOp(1)]
     */
    dependsOn?: number[];
};
/**
 * Parameters for a sponsorship
 */
export type SponsorshipOptionsParams = {
    /**
     * Sponsorship url for requesting sponsorship
     * @example http://dapp-backend/sponsor-supertx
     */
    url: Url;
    /**
     * Custom headers to be passed to self hosted sponsorship backends.
     */
    customHeaders?: Record<string, string>;
    /**
     * Gas tank parameters
     */
    gasTank: {
        /**
         * The chainId to use
         * @example 1 // Ethereum Mainnet
         */
        chainId: number;
        /**
         * The gas tank address for sponshorship
         * @example "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
         */
        address: Address;
        /**
         * The token address for sponshorship
         * @example "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48" // USDC
         */
        token: Address;
    };
};
export interface TokenOverride {
    /** Token contract address */
    tokenAddress: Address;
    /** Account address (EOA or Smart Contract Account) */
    accountAddress: Address;
    /** Chain ID */
    chainId: number;
    /** Token balance in wei */
    balance: bigint;
}
export interface CustomOverride {
    /** Contract address */
    contractAddress: Address;
    /** Storage slot in hex format */
    storageSlot: Hex;
    /** Chain ID */
    chainId: number;
    /** Override value - can be bigint, hex string, address, or regular string */
    value: bigint | Address | Hex | string;
}
export interface Overrides {
    /** Token balance overrides */
    tokenOverrides?: TokenOverride[];
    /** Custom contract storage overrides */
    customOverrides?: CustomOverride[];
}
export interface Simulation {
    /** Flag to enable/disable simulations  */
    simulate: boolean;
    /** Storage overrides to override token balance and some custom storage slots for simulation */
    overrides?: Overrides;
}
/**
 * Parameters required for requesting a quote from the MEE service
 */
export type GetQuoteParams = SupertransactionLike & {
    /**
     * Optional smart account to execute the transaction.
     * If not provided, uses the client's default account
     */
    account?: MultichainSmartAccount;
    /**
     * Path to the quote endpoint. Defaults to "/quote"
     * @example "/quote"
     */
    path?: string;
    /**
     * An address to be used as funds origin in the payment userOp
     *
     * Note: In fact this param should be named `paymentOrigin`,
     * as in some cases (for example MM DTK fusion mode) it
     * is not an EOA, but a smart account.
     *
     * We keep it as `eoa` for backward compatibility for now.
     * TODO: rename to `paymentOrigin` when it is possible.
     * It will require according changes on the node side.
     *
     * @example "0x1234567890123456789012345678901234567890"
     */
    eoa?: Address;
    /**
     * Lower bound execution timestamp to be applied to all user operations
     */
    lowerBoundTimestamp?: number;
    /**
     * Upper bound execution timestamp to be applied to all user operations
     */
    upperBoundTimestamp?: number;
    /**
     * gasLimit option to override the default payment gas limit
     */
    gasLimit?: bigint;
    /**
     * Simulation configuration to enable simulation and configure overrides for single chain or cross chain simulations
     */
    simulation?: Simulation;
    /**
     * token cleanup option to pull the funds on failure or dust cleanup
     */
    cleanUps?: CleanUp[];
    /**
     * batch flag to enable/disable instruction batching. Defaults to true
     */
    batch?: boolean;
    /**
     * Smart sessions permission info - Primarily used to detect smart sessions flow in quote phase and used for simulations as well
     */
    sessionDetails?: GrantMeePermissionPayload;
    /**
     * Smart sessions mode
     */
    smartSessionMode?: "ENABLE_AND_USE" | "USE";
    /**
     * Active module address. Used to fetch the nonce for the active module and resolve verification gas limit
     */
    moduleAddress?: Address;
    /**
     * The verification gas limit for the active module
     * @example 150000n
     */
    verificationGasLimit?: bigint;
    /**
     * Short encoding flag for fusion isValidsignatureWithSender/validateSignatureWithData functions
     * This flag is set true when the whole superTxn with all entries require short encoding
     * This is a special case when all the sigs are going to be validated via short flow. For example,
     * when the superTxn is signed with session key enabled via Smart Sessions Module.
     * For more details see https://github.com/bcnmy/mee-contracts/blob/main/contracts/lib/fusion/PermitValidatorLib.sol#L32-L58
     * https://github.com/bcnmy/mee-contracts/blob/main/contracts/lib/fusion/PermitValidatorLib.sol#L134C14-L156
     */
    shortEncodingSuperTxn?: boolean;
    /**
     * Tags to be used for the transaction
     */
    tags?: string[];
} & OneOf<{
    /**
     * The address of the account that will pay for the transaction fees
     */
    feePayer: Address;
} | {
    /**
     * EOA address to be used for the transaction.
     * Only required when using permit-enabled tokens
     */
    eoa?: Address;
}> & OneOf<{
    /**
     * Token to be used for paying transaction fees
     */
    feeToken: FeeTokenInfo;
} | {
    /**
     * sponsorship flag to enable the sponsored super transactions.
     */
    sponsorship: true;
    /**
     * Sponsorship options for overrides
     */
    sponsorshipOptions?: SponsorshipOptionsParams;
}> & OneOf<{
    /**
     * Whether to delegate the transaction to the account
     */
    delegate?: false;
    /**
     * Whether to delegate the transaction to the account with chain id zero
     */
    multichain7702Auth?: false;
} | {
    /**
     * Whether to delegate the transaction to the account
     */
    delegate: true;
    /**
     * Whether to delegate the transaction to the account with chain id zero
     */
    multichain7702Auth?: boolean;
    /**
     * The array of authorization data for the transaction. Should be a valid Viem compatible Authorization param
     * If not provided, the account will be delegated to the implementation address, using chainId 0.
     */
    authorizations?: SignAuthorizationReturnType[];
}>;
export type MeeAuthorization = {
    address: Hex;
    chainId: Hex;
    nonce: Hex;
    r: Hex;
    s: Hex;
    yParity: Hex;
};
export type UserOp = {
    /** Address of the account initiating the operation */
    sender: string;
    /** Encoded transaction data */
    callData: string;
    /** Gas limit for the call execution */
    callGasLimit: string;
    /** Account nonce */
    nonce: string;
    /** Chain ID where the operation will be executed */
    chainId: string;
    /** Lower bound timestamp for operation validity */
    lowerBoundTimestamp?: number;
    /** Upper bound timestamp for operation validity */
    upperBoundTimestamp?: number;
    /** EIP7702Auth */
    eip7702Auth?: MeeAuthorization;
    /** Cleanup userop flag - Special user op */
    isCleanUpUserOp?: boolean;
    /** Short encoding flag for fusion isValidsignatureWithSender/validateSignatureWithData functions
     * For more details see https://github.com/bcnmy/mee-contracts/blob/main/contracts/lib/fusion/PermitValidatorLib.sol#L32-L58
     * https://github.com/bcnmy/mee-contracts/blob/main/contracts/lib/fusion/PermitValidatorLib.sol#L134C14-L156
     **/
    shortEncoding?: boolean;
    /** UserOp instructions metadata */
    metadata?: InstructionMetadata[];
    /** Optional Session details for detecting the smart session mode in node during quote phase */
    sessionDetails?: GrantPermissionResponseEntry;
};
/**
 * Basic payment information required for a quote request
 */
export type PaymentInfo = {
    /** Address of the account used for the transaction */
    sender: Address;
    /** Address of the account paying for the transaction */
    eoa?: Address;
    /** Optional initialization code for account deployment */
    initCode?: Hex;
    /** Address of the token used for payment */
    token: Address;
    /** Current nonce of the sender account */
    nonce: string;
    /** Chain ID where the payment will be processed */
    chainId: string;
    /** Payment userop verificationGasLimit */
    verificationGasLimit?: bigint;
    /** EIP7702Auth */
    eip7702Auth?: MeeAuthorization;
    /** Short encoding flag @see QuoteRequest.shortEncoding */
    shortEncoding?: boolean;
    /** Payment userop callGasLimit */
    callGasLimit?: bigint;
    /** Sponsorship flag  */
    sponsored?: boolean;
    /** Sponsorship url  */
    sponsorshipUrl?: Url;
    /** Custom gas refund address to get the refunds for the remaining unspent gas. Defaults to Nexus SCA. */
    gasRefundAddress?: Address;
    /** Optional Session details for detecting the smart session mode in node */
    sessionDetails?: GrantPermissionResponseEntry;
};
/**
 * Extended payment information including calculated token amounts
 */
export type FilledPaymentInfo = Required<PaymentInfo> & {
    /** Human-readable token amount */
    tokenAmount: string;
    /** Token amount in wei */
    tokenWeiAmount: string;
    /** Token value in the transaction */
    tokenValue: string;
};
/**
 * Detailed user operation structure with all required fields
 */
export interface MeeFilledUserOp {
    /** Address of the account initiating the operation */
    sender: Address;
    /** Account nonce */
    nonce: string;
    /** Account initialization code */
    initCode: Hex;
    /** Encoded transaction data */
    callData: Hex;
    /** Gas limit for the call execution */
    callGasLimit: string;
    /** Gas limit for verification */
    verificationGasLimit: string;
    /** Maximum fee per gas unit */
    maxFeePerGas: string;
    /** Maximum priority fee per gas unit */
    maxPriorityFeePerGas: string;
    /** Encoded paymaster data */
    paymasterAndData: Hex;
    /** Gas required before operation verification */
    preVerificationGas: string;
    /** UserOp signature signed by paymaster for sponsorship  */
    signature?: Hex;
}
/**
 * Extended user operation details including timing and gas parameters
 */
export interface MeeFilledUserOpDetails {
    /** Complete user operation data */
    userOp: MeeFilledUserOp;
    /** Hash of the user operation */
    userOpHash: Hex;
    /** MEE-specific hash of the user operation */
    meeUserOpHash: Hex;
    /** Lower bound timestamp for operation validity */
    lowerBoundTimestamp: string;
    /** Upper bound timestamp for operation validity */
    upperBoundTimestamp: string;
    /** Maximum gas limit for the operation */
    maxGasLimit: string;
    /** Maximum fee per gas unit */
    maxFeePerGas: string;
    /** Chain ID where the operation will be executed */
    chainId: string;
    /** EIP7702 authorization info */
    eip7702Auth?: MeeAuthorization;
    /** Cleanup userop flag - Special user op */
    isCleanUpUserOp?: boolean;
    /** Optional Session details for redeeming a permission */
    sessionDetails?: GrantPermissionResponseEntry;
    /** Short encoding flag @see QuoteRequest.shortEncoding
     *  It is expected to be set here because it is returned by the node
     *  and the node always knows if the given superTxn entry's hash
     *  was short encoded or not. This flag is then passed to the node
     *  when signing the quote, so the node can build short or full
     *  fusion signature for a given userOp
     **/
    shortEncoding: boolean;
    /** Instruction metadata */
    metadata?: InstructionMetadata[];
    /** Userop signature signed by sponsorship service */
    signature?: Hex;
    /** Userop finality confirmation. Soft confirmation and Hard confirmation is supported */
    isConfirmed?: boolean;
}
/**
 * Complete quote response from the MEE service
 */
export type GetQuotePayload = {
    /** Hash of the supertransaction */
    hash: Hex;
    /** Address of the MEE node */
    node: Address;
    /** Commitment hash */
    commitment: Hex;
    /** Complete payment information with token amounts */
    paymentInfo: FilledPaymentInfo;
    /** Array of user operations with their details */
    userOps: MeeFilledUserOpDetails[];
    /** Quote type - determines the supertransaction mode */
    quoteType?: QuoteType;
};
export type InitData = {
    eip7702Auth: MeeAuthorization;
} | {
    initCode: Hex;
};
export type InitDataOrUndefined = InitData | undefined;
/**
 * Requests a quote from the MEE service for executing a set of instructions.
 * This function handles the complexity of creating a supertransaction quote
 * that can span multiple chains.
 *
 * @param client - MEE client instance used to make the request
 * @param parameters - Parameters for the quote request
 * @returns Promise resolving to a committed supertransaction quote
 *
 * @example
 * ```typescript
 * const quote = await getQuote(meeClient, {
 *   instructions: [{
 *     calls: [{
 *       to: "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
 *       data: "0x...",
 *       value: 0n
 *     }],
 *     chainId: 1 // Ethereum Mainnet
 *   }],
 *   feeToken: {
 *     address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", // USDC
 *     chainId: 1
 *   }
 * });
 * ```
 *
 * @throws Will throw an error if:
 * - The account is not deployed on required chains
 * - The fee token is not supported
 * - The chain(s) are not supported by the node
 */
export declare const getQuote: (client: BaseMeeClient, parameters: GetQuoteParams, quoteType?: QuoteType, trigger?: TokenTrigger) => Promise<GetQuotePayload>;
export declare const userOp: (userOpIndex: number) => number;
/**
 * Parameters for the resolveVerificationGasLimit function
 * @param moduleAddress - The active module address
 * @param verificationGasLimit - The custom verification gas limit
 * @param index - The index of the userOp during the userOps completion process
 * @param sponsorship - Whether the superTxn is sponsored
 */
export type resolveVerificationGasLimitParams = {
    moduleAddress?: Address;
    verificationGasLimit?: bigint;
    sponsorship: boolean;
    index: number;
};
/**
 * Returns the verification gas limit for the userOp, to be spread
 */
export type verificationGasLimitPayload = {
    verificationGasLimit: bigint;
};
export default getQuote;
//# sourceMappingURL=getQuote.d.ts.map