import { encodeFunctionData, getAddress, encodeAbiParameters, encodePacked, } from 'viem';
import { abi } from './abi.js';
import { SENTINEL_ADDRESS } from '../../common/constants.js';
import { GLOBAL_CONSTANTS } from '../../constants.js';
export const getSetOwnableValidatorThresholdAction = ({ threshold, }) => {
    const data = encodeFunctionData({
        functionName: 'setThreshold',
        abi,
        args: [BigInt(threshold)],
    });
    return {
        to: GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
        target: GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
export const getAddOwnableValidatorOwnerAction = async ({ owner, client, account, }) => {
    const owners = await getOwnableValidatorOwners({ account, client });
    const currentOwnerIndex = owners.findIndex((o) => o === owner);
    if (currentOwnerIndex !== -1) {
        throw new Error('Owner already exists');
    }
    const data = encodeFunctionData({
        functionName: 'addOwner',
        abi,
        args: [owner],
    });
    return {
        to: GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
        target: GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
export const getRemoveOwnableValidatorOwnerAction = async ({ client, account, owner, }) => {
    const owners = await getOwnableValidatorOwners({ account, client });
    let prevOwner;
    const currentOwnerIndex = owners.findIndex((o) => o === owner);
    if (currentOwnerIndex === -1) {
        throw new Error('Owner not found');
    }
    else if (currentOwnerIndex === 0) {
        prevOwner = SENTINEL_ADDRESS;
    }
    else {
        prevOwner = getAddress(owners[currentOwnerIndex - 1]);
    }
    const data = encodeFunctionData({
        functionName: 'removeOwner',
        abi,
        args: [prevOwner, owner],
    });
    return {
        to: GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
        target: GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
export const getOwnableValidatorOwners = async ({ account, client, }) => {
    try {
        const owners = (await client.readContract({
            address: GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
            abi,
            functionName: 'getOwners',
            args: [account.address],
        }));
        return owners;
    }
    catch (err) {
        console.error(err);
        return [];
    }
};
export const getOwnableValidatorThreshold = async ({ account, client, }) => {
    try {
        const threshold = (await client.readContract({
            address: GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
            abi,
            functionName: 'threshold',
            args: [account.address],
        }));
        return Number(threshold);
    }
    catch {
        throw new Error('Failed to get threshold');
    }
};
export const getIsValidSignatureStateless = async ({ hash, signature, data, client, }) => {
    try {
        return (await client.readContract({
            address: GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
            abi,
            functionName: 'validateSignatureWithData',
            args: [hash, signature, data],
        }));
    }
    catch {
        throw new Error('Failed to check signature');
    }
};
export const encodeValidationData = ({ threshold, owners, }) => {
    return encodeAbiParameters([
        {
            type: 'uint256',
        },
        {
            type: 'address[]',
        },
    ], [BigInt(threshold), owners.sort()]);
};
export const getOwnableValidatorSignature = ({ signatures, }) => {
    let signature = signatures[0];
    for (let i = 1; i < signatures.length; i++) {
        signature = encodePacked(['bytes', 'bytes'], [signature, signatures[i]]);
    }
    return signature;
};
export const getOwnableValidatorMockSignature = ({ threshold, }) => {
    const mockSignature = '0xe8b94748580ca0b4993c9a1b86b5be851bfc076ff5ce3a1ff65bf16392acfcb800f9b4f1aef1555c7fce5599fffb17e7c635502154a0333ba21f3ae491839af51c';
    return getOwnableValidatorSignature({
        signatures: Array(threshold).fill(mockSignature),
    });
};
//# sourceMappingURL=usage.js.map