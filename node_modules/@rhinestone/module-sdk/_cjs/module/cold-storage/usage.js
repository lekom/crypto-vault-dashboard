"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFlashloanWhitelist = exports.getFlashloanRemoveAddressAction = exports.getFlashloanAddAddressAction = exports.getRequestTimelockedModuleConfigExecution = exports.getRequestTimelockedExecution = exports.getColdStorageExecutionTime = exports.getColdStorageSetWaitPeriodAction = void 0;
const viem_1 = require("viem");
const abi_1 = require("./abi");
const flashloanAbi_1 = require("./flashloanAbi");
const constants_1 = require("../../common/constants");
const constants_2 = require("../../constants");
const getColdStorageSetWaitPeriodAction = ({ waitPeriod, }) => {
    const data = (0, viem_1.encodeFunctionData)({
        functionName: 'setWaitPeriod',
        abi: abi_1.abi,
        args: [BigInt(waitPeriod)],
    });
    return {
        to: constants_2.GLOBAL_CONSTANTS.COLD_STORAGE_HOOK_ADDRESS,
        target: constants_2.GLOBAL_CONSTANTS.COLD_STORAGE_HOOK_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
exports.getColdStorageSetWaitPeriodAction = getColdStorageSetWaitPeriodAction;
const getColdStorageExecutionTime = async ({ account, client, executionHash, }) => {
    try {
        const executionTimestamp = (await client.readContract({
            address: constants_2.GLOBAL_CONSTANTS.COLD_STORAGE_HOOK_ADDRESS,
            abi: abi_1.abi,
            functionName: 'checkHash',
            args: [account.address, executionHash],
        }));
        return Number(executionTimestamp);
    }
    catch (err) {
        console.error(err);
        throw new Error(`Failed to get execution time for account ${account.address} for execution ${executionHash}`);
    }
};
exports.getColdStorageExecutionTime = getColdStorageExecutionTime;
const getRequestTimelockedExecution = ({ execution, additionalWait, }) => {
    const data = (0, viem_1.encodeFunctionData)({
        functionName: 'requestTimelockedExecution',
        abi: abi_1.abi,
        args: [execution, additionalWait],
    });
    return {
        to: constants_2.GLOBAL_CONSTANTS.COLD_STORAGE_HOOK_ADDRESS,
        target: constants_2.GLOBAL_CONSTANTS.COLD_STORAGE_HOOK_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
exports.getRequestTimelockedExecution = getRequestTimelockedExecution;
const getRequestTimelockedModuleConfigExecution = ({ moduleTypeId, module, data, isInstall, additionalWait, }) => {
    const callData = (0, viem_1.encodeFunctionData)({
        functionName: 'requestTimelockedModuleConfig',
        abi: abi_1.abi,
        args: [
            BigInt(moduleTypeId),
            module,
            data,
            isInstall,
            BigInt(additionalWait),
        ],
    });
    return {
        to: constants_2.GLOBAL_CONSTANTS.COLD_STORAGE_HOOK_ADDRESS,
        target: constants_2.GLOBAL_CONSTANTS.COLD_STORAGE_HOOK_ADDRESS,
        value: BigInt(0),
        callData: callData,
        data: callData,
    };
};
exports.getRequestTimelockedModuleConfigExecution = getRequestTimelockedModuleConfigExecution;
const getFlashloanAddAddressAction = ({ addressToAdd, }) => {
    const data = (0, viem_1.encodeFunctionData)({
        functionName: 'addAddress',
        abi: flashloanAbi_1.abi,
        args: [addressToAdd],
    });
    return {
        to: constants_2.GLOBAL_CONSTANTS.COLD_STORAGE_FLASHLOAN_ADDRESS,
        target: constants_2.GLOBAL_CONSTANTS.COLD_STORAGE_FLASHLOAN_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
exports.getFlashloanAddAddressAction = getFlashloanAddAddressAction;
const getFlashloanRemoveAddressAction = async ({ client, account, addressToRemove, }) => {
    const whitelistAddresses = await (0, exports.getFlashloanWhitelist)({ account, client });
    let prevAddress;
    const currentAddressIndex = whitelistAddresses.findIndex((a) => a === addressToRemove);
    if (currentAddressIndex === -1) {
        throw new Error('Address not found');
    }
    else if (currentAddressIndex === 0) {
        prevAddress = constants_1.SENTINEL_ADDRESS;
    }
    else {
        prevAddress = (0, viem_1.getAddress)(whitelistAddresses[currentAddressIndex - 1]);
    }
    const data = (0, viem_1.encodeFunctionData)({
        functionName: 'removeAddress',
        abi: flashloanAbi_1.abi,
        args: [prevAddress, addressToRemove],
    });
    return {
        to: constants_2.GLOBAL_CONSTANTS.COLD_STORAGE_FLASHLOAN_ADDRESS,
        target: constants_2.GLOBAL_CONSTANTS.COLD_STORAGE_FLASHLOAN_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
exports.getFlashloanRemoveAddressAction = getFlashloanRemoveAddressAction;
const getFlashloanWhitelist = async ({ account, client, }) => {
    try {
        const whitelistAddresses = (await client.readContract({
            address: constants_2.GLOBAL_CONSTANTS.COLD_STORAGE_FLASHLOAN_ADDRESS,
            abi: flashloanAbi_1.abi,
            functionName: 'getWhitelist',
            args: [account.address],
        }));
        return whitelistAddresses;
    }
    catch (err) {
        console.error(err);
        return [];
    }
};
exports.getFlashloanWhitelist = getFlashloanWhitelist;
//# sourceMappingURL=usage.js.map