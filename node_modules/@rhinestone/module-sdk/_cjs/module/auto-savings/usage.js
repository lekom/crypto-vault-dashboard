"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAutoSavingAccountTokenConfig = exports.getAutoSaveAction = exports.getDeleteAutoSavingConfigAction = exports.getAutoSavingTokens = exports.getSetAutoSavingConfigAction = void 0;
const viem_1 = require("viem");
const constants_1 = require("../../constants");
const abi_1 = require("./abi");
const constants_2 = require("../../common/constants");
const uniswap_1 = require("../utils/uniswap");
const getSetAutoSavingConfigAction = ({ token, config, }) => {
    const data = (0, viem_1.encodeFunctionData)({
        functionName: 'setConfig',
        abi: abi_1.abi,
        args: [token, config],
    });
    return {
        to: constants_1.GLOBAL_CONSTANTS.AUTO_SAVINGS_ADDRESS,
        target: constants_1.GLOBAL_CONSTANTS.AUTO_SAVINGS_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
exports.getSetAutoSavingConfigAction = getSetAutoSavingConfigAction;
const getAutoSavingTokens = async ({ account, client, }) => {
    try {
        const tokens = (await client.readContract({
            address: constants_1.GLOBAL_CONSTANTS.AUTO_SAVINGS_ADDRESS,
            abi: abi_1.abi,
            functionName: 'getTokens',
            args: [account.address],
        }));
        return tokens;
    }
    catch (err) {
        console.error(err);
        return [];
    }
};
exports.getAutoSavingTokens = getAutoSavingTokens;
const getDeleteAutoSavingConfigAction = async ({ account, client, token, }) => {
    try {
        const allTokens = await (0, exports.getAutoSavingTokens)({ account, client });
        let prevToken;
        const currentTokenIndex = allTokens.findIndex((t) => t === token);
        if (currentTokenIndex === -1) {
            throw new Error('Token not found');
        }
        else if (currentTokenIndex === 0) {
            prevToken = constants_2.SENTINEL_ADDRESS;
        }
        else {
            prevToken = (0, viem_1.getAddress)(allTokens[currentTokenIndex - 1]);
        }
        const data = (0, viem_1.encodeFunctionData)({
            functionName: 'deleteConfig',
            abi: abi_1.abi,
            args: [prevToken, token],
        });
        return {
            to: constants_1.GLOBAL_CONSTANTS.AUTO_SAVINGS_ADDRESS,
            target: constants_1.GLOBAL_CONSTANTS.AUTO_SAVINGS_ADDRESS,
            value: BigInt(0),
            callData: data,
            data,
        };
    }
    catch {
        throw new Error(`Failed to delete config for token ${token}`);
    }
};
exports.getDeleteAutoSavingConfigAction = getDeleteAutoSavingConfigAction;
const getAutoSaveAction = ({ token, amountReceived, }) => {
    const swapDetails = (0, uniswap_1.getSwapDetails)();
    const data = (0, viem_1.encodeFunctionData)({
        functionName: 'autoSave',
        abi: abi_1.abi,
        args: [
            token,
            BigInt(amountReceived),
            swapDetails.sqrtPriceLimitX96,
            swapDetails.amountOutMin,
            swapDetails.fee,
        ],
    });
    return {
        to: constants_1.GLOBAL_CONSTANTS.AUTO_SAVINGS_ADDRESS,
        target: constants_1.GLOBAL_CONSTANTS.AUTO_SAVINGS_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
exports.getAutoSaveAction = getAutoSaveAction;
const getAutoSavingAccountTokenConfig = async ({ client, account, token, }) => {
    try {
        const config = (await client.readContract({
            address: constants_1.GLOBAL_CONSTANTS.AUTO_SAVINGS_ADDRESS,
            abi: abi_1.abi,
            functionName: 'config',
            args: [account.address, token],
        }));
        return config;
    }
    catch {
        throw new Error(`Failed to get config for token ${token}`);
    }
};
exports.getAutoSavingAccountTokenConfig = getAutoSavingAccountTokenConfig;
//# sourceMappingURL=usage.js.map