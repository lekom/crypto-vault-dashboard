"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOwnableValidatorMockSignature = exports.getOwnableValidatorSignature = exports.encodeValidationData = exports.getIsValidSignatureStateless = exports.getOwnableValidatorThreshold = exports.getOwnableValidatorOwners = exports.getRemoveOwnableValidatorOwnerAction = exports.getAddOwnableValidatorOwnerAction = exports.getSetOwnableValidatorThresholdAction = void 0;
const viem_1 = require("viem");
const abi_1 = require("./abi");
const constants_1 = require("../../common/constants");
const constants_2 = require("../../constants");
const getSetOwnableValidatorThresholdAction = ({ threshold, }) => {
    const data = (0, viem_1.encodeFunctionData)({
        functionName: 'setThreshold',
        abi: abi_1.abi,
        args: [BigInt(threshold)],
    });
    return {
        to: constants_2.GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
        target: constants_2.GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
exports.getSetOwnableValidatorThresholdAction = getSetOwnableValidatorThresholdAction;
const getAddOwnableValidatorOwnerAction = async ({ owner, client, account, }) => {
    const owners = await (0, exports.getOwnableValidatorOwners)({ account, client });
    const currentOwnerIndex = owners.findIndex((o) => o === owner);
    if (currentOwnerIndex !== -1) {
        throw new Error('Owner already exists');
    }
    const data = (0, viem_1.encodeFunctionData)({
        functionName: 'addOwner',
        abi: abi_1.abi,
        args: [owner],
    });
    return {
        to: constants_2.GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
        target: constants_2.GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
exports.getAddOwnableValidatorOwnerAction = getAddOwnableValidatorOwnerAction;
const getRemoveOwnableValidatorOwnerAction = async ({ client, account, owner, }) => {
    const owners = await (0, exports.getOwnableValidatorOwners)({ account, client });
    let prevOwner;
    const currentOwnerIndex = owners.findIndex((o) => o === owner);
    if (currentOwnerIndex === -1) {
        throw new Error('Owner not found');
    }
    else if (currentOwnerIndex === 0) {
        prevOwner = constants_1.SENTINEL_ADDRESS;
    }
    else {
        prevOwner = (0, viem_1.getAddress)(owners[currentOwnerIndex - 1]);
    }
    const data = (0, viem_1.encodeFunctionData)({
        functionName: 'removeOwner',
        abi: abi_1.abi,
        args: [prevOwner, owner],
    });
    return {
        to: constants_2.GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
        target: constants_2.GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
        value: BigInt(0),
        callData: data,
        data,
    };
};
exports.getRemoveOwnableValidatorOwnerAction = getRemoveOwnableValidatorOwnerAction;
const getOwnableValidatorOwners = async ({ account, client, }) => {
    try {
        const owners = (await client.readContract({
            address: constants_2.GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
            abi: abi_1.abi,
            functionName: 'getOwners',
            args: [account.address],
        }));
        return owners;
    }
    catch (err) {
        console.error(err);
        return [];
    }
};
exports.getOwnableValidatorOwners = getOwnableValidatorOwners;
const getOwnableValidatorThreshold = async ({ account, client, }) => {
    try {
        const threshold = (await client.readContract({
            address: constants_2.GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
            abi: abi_1.abi,
            functionName: 'threshold',
            args: [account.address],
        }));
        return Number(threshold);
    }
    catch {
        throw new Error('Failed to get threshold');
    }
};
exports.getOwnableValidatorThreshold = getOwnableValidatorThreshold;
const getIsValidSignatureStateless = async ({ hash, signature, data, client, }) => {
    try {
        return (await client.readContract({
            address: constants_2.GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
            abi: abi_1.abi,
            functionName: 'validateSignatureWithData',
            args: [hash, signature, data],
        }));
    }
    catch {
        throw new Error('Failed to check signature');
    }
};
exports.getIsValidSignatureStateless = getIsValidSignatureStateless;
const encodeValidationData = ({ threshold, owners, }) => {
    return (0, viem_1.encodeAbiParameters)([
        {
            type: 'uint256',
        },
        {
            type: 'address[]',
        },
    ], [BigInt(threshold), owners.sort()]);
};
exports.encodeValidationData = encodeValidationData;
const getOwnableValidatorSignature = ({ signatures, }) => {
    let signature = signatures[0];
    for (let i = 1; i < signatures.length; i++) {
        signature = (0, viem_1.encodePacked)(['bytes', 'bytes'], [signature, signatures[i]]);
    }
    return signature;
};
exports.getOwnableValidatorSignature = getOwnableValidatorSignature;
const getOwnableValidatorMockSignature = ({ threshold, }) => {
    const mockSignature = '0xe8b94748580ca0b4993c9a1b86b5be851bfc076ff5ce3a1ff65bf16392acfcb800f9b4f1aef1555c7fce5599fffb17e7c635502154a0333ba21f3ae491839af51c';
    return (0, exports.getOwnableValidatorSignature)({
        signatures: Array(threshold).fill(mockSignature),
    });
};
exports.getOwnableValidatorMockSignature = getOwnableValidatorMockSignature;
//# sourceMappingURL=usage.js.map