"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isModuleInstalled = void 0;
const viem_1 = require("viem");
const utils_1 = require("../../../common/utils");
const abis_1 = require("../constants/abis");
const types_1 = require("../types");
const isModuleInstalled = async ({ client, account, module, }) => {
    switch (module.type) {
        case 'validator':
        case 'executor':
        case 'hook':
        case 'policy':
        case 'signer':
            return await _isModuleInstalled({ client, account, module });
        case 'fallback':
            return await _isFallbackInstalled({ client, account, module });
        default:
            throw new Error(`Unknown module type ${module.type}`);
    }
};
exports.isModuleInstalled = isModuleInstalled;
const _isModuleInstalled = async ({ client, account, module, }) => {
    if (await (0, utils_1.isContract)({ client, address: account.address })) {
        return (await client.readContract({
            address: account.address,
            abi: (0, viem_1.parseAbi)(abis_1.accountAbi),
            functionName: 'isModuleInstalled',
            args: [types_1.kernelModuleTypeIds[module.type], module.module, module.initData],
        }));
    }
    return false;
};
const _isFallbackInstalled = async ({ client, account, module, }) => {
    if (!module.selector) {
        throw new Error(`Selector is required for module type ${module.type}`);
    }
    if (await (0, utils_1.isContract)({ client, address: account.address })) {
        return (await client.readContract({
            address: account.address,
            abi: (0, viem_1.parseAbi)(abis_1.accountAbi),
            functionName: 'isModuleInstalled',
            args: [
                types_1.kernelModuleTypeIds[module.type],
                module.module,
                (0, viem_1.encodePacked)(['bytes4'], [module.selector]),
            ],
        }));
    }
    return false;
};
//# sourceMappingURL=isModuleInstalled.js.map