// Crypto Vault Dashboard Application
// Plugin-based architecture for multiple data sources

const POLL_INTERVAL = 30000; // 30 seconds
const STORAGE_KEY = 'crypto_vault_dashboard_wallets';

// Supported chain IDs
const CHAIN_IDS = {
    ETHEREUM: 1,
    BASE: 8453,
    ARBITRUM: 42161
};

const SUPPORTED_CHAINS = [
    CHAIN_IDS.ETHEREUM,
    CHAIN_IDS.BASE,
    CHAIN_IDS.ARBITRUM
];

// =============================================================================
// PLUGIN ARCHITECTURE
// =============================================================================

/**
 * Base class for vault data source plugins
 */
class VaultPlugin {
    constructor(name, type) {
        this.name = name;
        this.type = type; // 'vault' or 'rewards'
    }

    /**
     * Fetch data for a single wallet address
     * @param {string} address - Wallet address
     * @returns {Promise<Array>} Array of vault/reward items
     */
    async fetchData(address) {
        throw new Error('fetchData must be implemented by plugin');
    }

    /**
     * Get supported chain IDs for this plugin
     * @returns {Array<number>} Array of chain IDs
     */
    getSupportedChains() {
        return SUPPORTED_CHAINS;
    }
}

/**
 * Plugin registry to manage all data source plugins
 */
class PluginRegistry {
    constructor() {
        this.plugins = [];
    }

    register(plugin) {
        this.plugins.push(plugin);
    }

    getVaultPlugins() {
        return this.plugins.filter(p => p.type === 'vault');
    }

    getRewardPlugins() {
        return this.plugins.filter(p => p.type === 'rewards');
    }

    getAllPlugins() {
        return this.plugins;
    }
}

// Create global plugin registry
const pluginRegistry = new PluginRegistry();

// State management
let wallets = [];
let vaultsData = [];
let rewardsData = [];
let pollTimer = null;

// Utility function to format numbers with comma separators
function formatNumber(num, decimals = 2) {
    return num.toLocaleString('en-US', {
        minimumFractionDigits: decimals,
        maximumFractionDigits: decimals
    });
}

// Get chain name from chain ID
function getChainName(chainId) {
    switch (chainId) {
        case CHAIN_IDS.ETHEREUM:
            return 'Ethereum';
        case CHAIN_IDS.BASE:
            return 'Base';
        case CHAIN_IDS.ARBITRUM:
            return 'Arbitrum';
        default:
            return `Chain ${chainId}`;
    }
}

// Initialize app
document.addEventListener('DOMContentLoaded', () => {
    loadWalletsFromStorage();
    setupEventListeners();
    if (wallets.length > 0) {
        fetchAllData();
        startPolling();
    }
});

// =============================================================================
// PLUGIN IMPLEMENTATIONS
// =============================================================================

/**
 * Morpho Vault Plugin
 * Fetches vault positions from Morpho across multiple chains
 */
class MorphoVaultPlugin extends VaultPlugin {
    constructor() {
        super('Morpho', 'vault');
        this.apiUrl = 'https://api.morpho.org/graphql';
    }

    async fetchData(address) {
        const promises = this.getSupportedChains().map(chainId =>
            this.fetchUserVaults(address, chainId)
        );
        const results = await Promise.all(promises);
        return results.flat();
    }

    async fetchUserVaults(userAddress, chainId) {
        const positionsQuery = `
            query GetUserPositions($chainId: Int!, $userAddress: String!) {
                vaultPositions(
                    where: {
                        chainId_in: [$chainId]
                        shares_gte: 0
                        userAddress_in: [$userAddress]
                    }
                ) {
                    items {
                        id
                        assets
                        shares
                        vault {
                            id
                            address
                        }
                    }
                }
            }
        `;

        try {
            const positionsResponse = await fetch(this.apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    query: positionsQuery,
                    variables: { chainId, userAddress }
                })
            });

            const positionsData = await positionsResponse.json();

            if (positionsData.errors) {
                console.warn(`GraphQL errors for ${getChainName(chainId)}:`, positionsData.errors);
                return [];
            }

            const positions = positionsData.data?.vaultPositions?.items || [];

            if (positions.length === 0) {
                return [];
            }

            const vaultDetailsPromises = positions.map(position =>
                this.fetchVaultDetails(position.vault.address, chainId)
            );
            const vaultDetails = await Promise.all(vaultDetailsPromises);

            return positions
                .map((position, index) => {
                    const details = vaultDetails[index];
                    if (!details) return null;

                    const decimals = details.assetDecimals;
                    const rawAssets = parseFloat(position.assets);
                    const adjustedAssets = rawAssets / Math.pow(10, decimals);

                    return {
                        source: this.name,
                        chainId,
                        chainName: getChainName(chainId),
                        userAddress,
                        vaultAddress: position.vault.address,
                        vaultName: details.name,
                        vaultSymbol: details.symbol,
                        assetSymbol: details.assetSymbol,
                        assetAddress: details.assetAddress,
                        assetDecimals: decimals,
                        assetPriceUsd: details.assetPriceUsd,
                        balanceShares: position.shares,
                        balanceAssets: adjustedAssets,
                        balanceUsd: details.totalAssetsUsd ? (adjustedAssets * details.assetPriceUsd) : 0,
                        apy: details.apy,
                        netApy: details.netApy
                    };
                })
                .filter(item => item !== null && item.balanceAssets > 0);
        } catch (error) {
            console.error(`Error fetching Morpho vaults for ${userAddress} on ${getChainName(chainId)}:`, error);
            return [];
        }
    }

    async fetchVaultDetails(vaultAddress, chainId) {
        const vaultQuery = `
            query GetVaultDetails($vaultAddress: String!, $chainId: Int!) {
                vaultByAddress(address: $vaultAddress, chainId: $chainId) {
                    address
                    name
                    symbol
                    state {
                        totalAssets
                        totalAssetsUsd
                        apy
                        netApy
                    }
                    asset {
                        address
                        symbol
                        decimals
                        priceUsd
                    }
                }
            }
        `;

        try {
            const response = await fetch(this.apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    query: vaultQuery,
                    variables: { vaultAddress, chainId }
                })
            });

            const data = await response.json();

            if (data.errors) {
                console.warn(`Could not fetch details for vault ${vaultAddress.slice(0, 8)}...`);
                return null;
            }

            const vault = data.data?.vaultByAddress;
            if (!vault) return null;

            return {
                name: vault.name || vault.symbol || 'Unknown Vault',
                symbol: vault.symbol || 'VAULT',
                assetSymbol: vault.asset?.symbol || 'TOKEN',
                assetAddress: vault.asset?.address || '',
                assetDecimals: parseInt(vault.asset?.decimals || 18),
                assetPriceUsd: parseFloat(vault.asset?.priceUsd || 0),
                totalAssetsUsd: parseFloat(vault.state?.totalAssetsUsd || 0),
                apy: parseFloat(vault.state?.apy || 0),
                netApy: parseFloat(vault.state?.netApy || 0)
            };
        } catch (error) {
            console.warn(`Error fetching vault details for ${vaultAddress.slice(0, 8)}...`);
            return null;
        }
    }
}

/**
 * Merkl Rewards Plugin
 * Fetches reward data from Merkl API
 */
class MerklRewardsPlugin extends VaultPlugin {
    constructor() {
        super('Merkl', 'rewards');
        this.apiUrl = 'https://api.merkl.xyz';
    }

    async fetchData(address) {
        const promises = this.getSupportedChains().map(chainId =>
            this.fetchRewardsForChain(address, chainId)
        );
        const results = await Promise.all(promises);
        return results.flat();
    }

    async fetchRewardsForChain(userAddress, chainId) {
        try {
            const response = await fetch(
                `${this.apiUrl}/v4/users/${userAddress}/rewards?chainId=${chainId}&breakdownPage=0`,
                {
                    method: 'GET',
                    headers: { 'Accept': '*/*' }
                }
            );

            if (!response.ok) {
                return [];
            }

            const data = await response.json();

            if (Array.isArray(data) && data.length > 0) {
                const allRewards = [];

                for (const chainData of data) {
                    if (chainData.rewards && Array.isArray(chainData.rewards)) {
                        for (const reward of chainData.rewards) {
                            allRewards.push({
                                source: this.name,
                                chainId: chainId,
                                chainName: getChainName(chainId),
                                userAddress: userAddress,
                                distributionChainId: reward.distributionChainId,
                                amount: reward.amount,
                                claimed: reward.claimed || "0",
                                pending: reward.pending || "0",
                                recipient: reward.recipient,
                                root: reward.root,
                                tokenSymbol: reward.token?.symbol || 'TOKEN',
                                tokenDecimals: reward.token?.decimals || 18,
                                tokenAddress: reward.token?.address || '',
                                tokenPrice: reward.token?.price || 0
                            });
                        }
                    }
                }

                return allRewards;
            }

            return [];
        } catch (error) {
            console.warn(`Could not fetch Merkl rewards for chain ${chainId}`);
            return [];
        }
    }
}

/**
 * Hyperliquid HLP Vault Plugin (Placeholder)
 * TODO: Implement actual API integration
 */
class HyperliquidVaultPlugin extends VaultPlugin {
    constructor() {
        super('Hyperliquid HLP', 'vault');
    }

    async fetchData(address) {
        // Placeholder - returns empty array for now
        console.log(`Hyperliquid HLP plugin called for ${address} (not yet implemented)`);
        return [];
    }

    getSupportedChains() {
        // Hyperliquid is its own chain, but we'll handle it separately
        return [];
    }
}

/**
 * Moonwell Vault Plugin (Placeholder)
 * TODO: Implement actual API integration
 */
class MoonwellVaultPlugin extends VaultPlugin {
    constructor() {
        super('Moonwell', 'vault');
    }

    async fetchData(address) {
        // Placeholder - returns empty array for now
        console.log(`Moonwell plugin called for ${address} (not yet implemented)`);
        return [];
    }

    getSupportedChains() {
        // Moonwell is on Base and Optimism
        return [CHAIN_IDS.BASE];
    }
}

// Register all plugins
pluginRegistry.register(new MorphoVaultPlugin());
pluginRegistry.register(new MerklRewardsPlugin());
pluginRegistry.register(new HyperliquidVaultPlugin());
pluginRegistry.register(new MoonwellVaultPlugin());

// =============================================================================
// EVENT LISTENERS
// =============================================================================

// Setup event listeners
function setupEventListeners() {
    const addButton = document.getElementById('addWallet');
    const walletInput = document.getElementById('walletInput');

    addButton.addEventListener('click', addWallet);
    walletInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            addWallet();
        }
    });
}

// Wallet management
function addWallet() {
    const input = document.getElementById('walletInput');
    const address = input.value.trim();

    if (!isValidAddress(address)) {
        alert('Please enter a valid EVM address');
        return;
    }

    if (wallets.includes(address.toLowerCase())) {
        alert('This wallet is already added');
        return;
    }

    wallets.push(address.toLowerCase());
    saveWalletsToStorage();
    renderWalletList();
    input.value = '';

    // Fetch data and start polling if this is the first wallet
    if (wallets.length === 1) {
        fetchAllData();
        startPolling();
    } else {
        fetchAllData();
    }
}

function removeWallet(address) {
    wallets = wallets.filter(w => w !== address);
    saveWalletsToStorage();
    renderWalletList();

    if (wallets.length === 0) {
        stopPolling();
        vaultsData = [];
        renderVaults();
        updateTotalBalance();
    } else {
        fetchAllData();
    }
}

function isValidAddress(address) {
    return /^0x[a-fA-F0-9]{40}$/.test(address);
}

// LocalStorage management
function saveWalletsToStorage() {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(wallets));
}

function loadWalletsFromStorage() {
    const stored = localStorage.getItem(STORAGE_KEY);
    if (stored) {
        try {
            wallets = JSON.parse(stored);
            renderWalletList();
        } catch (e) {
            console.error('Error loading wallets from storage:', e);
            wallets = [];
        }
    }
}

// Render wallet list
function renderWalletList() {
    const container = document.getElementById('walletList');

    if (wallets.length === 0) {
        container.innerHTML = '';
        return;
    }

    container.innerHTML = wallets.map(address => `
        <div class="wallet-tag">
            <span class="wallet-address">${formatAddress(address)}</span>
            <button class="btn btn-danger" onclick="removeWallet('${address}')">
                <span>âœ•</span>
            </button>
        </div>
    `).join('');
}

// Format address for display
function formatAddress(address) {
    return `${address.slice(0, 6)}...${address.slice(-4)}`;
}

// =============================================================================
// DATA FETCHING
// =============================================================================

// API calls using plugin system
async function fetchAllData(showLoadingOverlay = true) {
    if (showLoadingOverlay) {
        showLoading(true);
    }

    try {
        // Fetch vault data from all vault plugins
        const vaultPlugins = pluginRegistry.getVaultPlugins();
        const vaultPromises = [];

        for (const wallet of wallets) {
            for (const plugin of vaultPlugins) {
                vaultPromises.push(plugin.fetchData(wallet));
            }
        }

        const vaultResults = await Promise.all(vaultPromises);
        vaultsData = vaultResults.flat();

        // Fetch rewards data from all reward plugins
        const rewardPlugins = pluginRegistry.getRewardPlugins();
        const rewardPromises = [];

        for (const wallet of wallets) {
            for (const plugin of rewardPlugins) {
                rewardPromises.push(plugin.fetchData(wallet));
            }
        }

        const rewardResults = await Promise.all(rewardPromises);
        rewardsData = rewardResults.flat();

        updateVaultsUI();
    } catch (error) {
        console.error('Error fetching data:', error);
        if (showLoadingOverlay) {
            alert('Error fetching vault data. Please check console for details.');
        }
    } finally {
        if (showLoadingOverlay) {
            showLoading(false);
        }
    }
}

// Update UI without full page reload
function updateVaultsUI() {
    // Add subtle flash effect to show data is updating
    const totalElement = document.getElementById('totalBalance');
    totalElement.classList.add('updating');

    renderVaults();
    renderRewards();
    updateTotalBalance();
    updateSectionTotals();
    updateLastUpdateTime();

    // Remove updating class after transition
    setTimeout(() => {
        totalElement.classList.remove('updating');
    }, 300);
}

// =============================================================================
// RENDERING
// =============================================================================

// Render vaults
function renderVaults() {
    const container = document.getElementById('vaultsList');

    if (vaultsData.length === 0) {
        container.innerHTML = `
            <div class="empty-state">
                <div class="empty-icon">ðŸš€</div>
                <p>Add wallet addresses to begin tracking your Morpho vaults</p>
            </div>
        `;
        return;
    }

    // Sort vaults by display value (big green number) descending
    const sortedVaults = [...vaultsData].sort((a, b) => {
        return getDisplayValue(b) - getDisplayValue(a);
    });

    container.innerHTML = sortedVaults.map(vault => {
        const displayValue = getDisplayValue(vault);

        return `
            <div class="vault-item">
                <div class="vault-header">
                    <div class="vault-info">
                        <h3>
                            ${vault.vaultName || vault.vaultSymbol}
                            ${vault.source ? `<span class="source-badge">${vault.source}</span>` : ''}
                        </h3>
                        <div class="vault-address">
                            <span class="chain-badge">${vault.chainName}</span>
                            ${vault.vaultAddress ? `Vault: ${formatAddress(vault.vaultAddress)} |` : ''}
                            Wallet: ${formatAddress(vault.userAddress)}
                        </div>
                    </div>
                    <div class="vault-balance">
                        <div class="balance-amount">$${formatNumber(displayValue)}</div>
                        <div class="balance-asset">
                            ${formatNumber(vault.balanceAssets)} ${vault.assetSymbol}
                        </div>
                    </div>
                </div>
                <div class="vault-details">
                    ${vault.apy !== undefined ? `
                    <div class="detail-item">
                        <span class="detail-label">APY</span>
                        <span class="detail-value">${formatNumber(vault.apy * 100)}%</span>
                    </div>
                    ` : ''}
                    ${vault.netApy !== undefined ? `
                    <div class="detail-item">
                        <span class="detail-label">Net APY</span>
                        <span class="detail-value">${formatNumber(vault.netApy * 100)}%</span>
                    </div>
                    ` : ''}
                    ${vault.assetPriceUsd !== undefined ? `
                    <div class="detail-item">
                        <span class="detail-label">Asset Price</span>
                        <span class="detail-value">$${formatNumber(vault.assetPriceUsd)}</span>
                    </div>
                    ` : ''}
                </div>
            </div>
        `;
    }).join('');
}

// Render rewards
function renderRewards() {
    const container = document.getElementById('rewardsList');

    if (rewardsData.length === 0) {
        container.innerHTML = `
            <div class="empty-state">
                <div class="empty-icon">ðŸ’Ž</div>
                <p>Rewards will appear here when available</p>
            </div>
        `;
        return;
    }

    // Sort rewards by unclaimed USD value (big green number) descending
    const sortedRewards = [...rewardsData].sort((a, b) => {
        const aAdjusted = parseFloat(a.amount) / Math.pow(10, a.tokenDecimals);
        const aClaimed = parseFloat(a.claimed) / Math.pow(10, a.tokenDecimals);
        const aUnclaimed = aAdjusted - aClaimed;
        const aUsdValue = aUnclaimed * a.tokenPrice;

        const bAdjusted = parseFloat(b.amount) / Math.pow(10, b.tokenDecimals);
        const bClaimed = parseFloat(b.claimed) / Math.pow(10, b.tokenDecimals);
        const bUnclaimed = bAdjusted - bClaimed;
        const bUsdValue = bUnclaimed * b.tokenPrice;

        return bUsdValue - aUsdValue;
    });

    container.innerHTML = sortedRewards.map(reward => {
        const adjustedAmount = parseFloat(reward.amount) / Math.pow(10, reward.tokenDecimals);
        const adjustedClaimed = parseFloat(reward.claimed) / Math.pow(10, reward.tokenDecimals);
        const adjustedPending = parseFloat(reward.pending) / Math.pow(10, reward.tokenDecimals);
        const unclaimed = adjustedAmount - adjustedClaimed;
        const unclaimedUsdValue = unclaimed * reward.tokenPrice;
        const totalUsdValue = adjustedAmount * reward.tokenPrice;

        return `
            <div class="reward-item">
                <div class="vault-header">
                    <div class="vault-info">
                        <h3>
                            ${reward.tokenSymbol} Rewards
                            ${reward.source ? `<span class="source-badge">${reward.source}</span>` : ''}
                        </h3>
                        <div class="vault-address">
                            <span class="chain-badge">${reward.chainName}</span>
                            Wallet: ${formatAddress(reward.userAddress)}
                        </div>
                    </div>
                    <div class="vault-balance">
                        <div class="balance-amount">$${formatNumber(unclaimedUsdValue)}</div>
                        <div class="balance-asset">
                            ${formatNumber(unclaimed)} ${reward.tokenSymbol} Unclaimed
                        </div>
                    </div>
                </div>
                <div class="vault-details">
                    <div class="detail-item">
                        <span class="detail-label">Total Earned</span>
                        <span class="detail-value">${formatNumber(adjustedAmount)} ${reward.tokenSymbol}</span>
                    </div>
                    <div class="detail-item">
                        <span class="detail-label">Claimed</span>
                        <span class="detail-value">${formatNumber(adjustedClaimed)} ${reward.tokenSymbol}</span>
                    </div>
                    <div class="detail-item">
                        <span class="detail-label">Token Price</span>
                        <span class="detail-value">$${formatNumber(reward.tokenPrice)}</span>
                    </div>
                    <div class="detail-item">
                        <span class="detail-label">Distribution Chain</span>
                        <span class="detail-value">${getChainName(reward.distributionChainId)}</span>
                    </div>
                </div>
            </div>
        `;
    }).join('');
}

// Get display value (USDC or USD)
function getDisplayValue(vault) {
    // If asset is USDC or other stablecoin, use the asset balance
    const stablecoins = ['USDC', 'USDT', 'DAI', 'USDC.e'];
    if (stablecoins.includes(vault.assetSymbol)) {
        return vault.balanceAssets;
    }
    // Otherwise use USD value
    return vault.balanceUsd;
}

// Update total balance
function updateTotalBalance() {
    // Sum vault balances
    const vaultsTotal = vaultsData.reduce((sum, vault) => {
        return sum + getDisplayValue(vault);
    }, 0);

    // Sum unclaimed rewards
    const rewardsTotal = rewardsData.reduce((sum, reward) => {
        const adjustedAmount = parseFloat(reward.amount) / Math.pow(10, reward.tokenDecimals);
        const adjustedClaimed = parseFloat(reward.claimed) / Math.pow(10, reward.tokenDecimals);
        const unclaimed = adjustedAmount - adjustedClaimed;
        const unclaimedUsdValue = unclaimed * reward.tokenPrice;
        return sum + unclaimedUsdValue;
    }, 0);

    const total = vaultsTotal + rewardsTotal;

    const totalElement = document.getElementById('totalBalance');
    totalElement.textContent = `$${formatNumber(total)}`;
}

// Update section totals in headers
function updateSectionTotals() {
    // Calculate vaults total (sum of big green numbers)
    const vaultsTotal = vaultsData.reduce((sum, vault) => {
        return sum + getDisplayValue(vault);
    }, 0);

    // Calculate rewards total (sum of unclaimed USD values)
    const rewardsTotal = rewardsData.reduce((sum, reward) => {
        const adjustedAmount = parseFloat(reward.amount) / Math.pow(10, reward.tokenDecimals);
        const adjustedClaimed = parseFloat(reward.claimed) / Math.pow(10, reward.tokenDecimals);
        const unclaimed = adjustedAmount - adjustedClaimed;
        const unclaimedUsdValue = unclaimed * reward.tokenPrice;
        return sum + unclaimedUsdValue;
    }, 0);

    // Update DOM elements
    const vaultsTotalElement = document.getElementById('vaultsTotal');
    const rewardsTotalElement = document.getElementById('rewardsTotal');

    if (vaultsTotalElement) {
        vaultsTotalElement.textContent = `$${formatNumber(vaultsTotal)}`;
    }

    if (rewardsTotalElement) {
        rewardsTotalElement.textContent = `$${formatNumber(rewardsTotal)}`;
    }
}

// Update last update time
function updateLastUpdateTime() {
    const now = new Date();
    const timeString = now.toLocaleTimeString();
    const dateString = now.toLocaleDateString();

    const updateElement = document.getElementById('lastUpdate');
    updateElement.textContent = `Last updated: ${dateString} at ${timeString}`;

    // Add pulse effect
    updateElement.classList.add('updated');
    setTimeout(() => {
        updateElement.classList.remove('updated');
    }, 1000);
}

// Polling
function startPolling() {
    if (pollTimer) {
        clearInterval(pollTimer);
    }

    pollTimer = setInterval(() => {
        console.log('Polling for updates...');
        // Fetch in background without showing loading overlay
        fetchAllData(false);
    }, POLL_INTERVAL);
}

function stopPolling() {
    if (pollTimer) {
        clearInterval(pollTimer);
        pollTimer = null;
    }
}

// Loading overlay
function showLoading(show) {
    const overlay = document.getElementById('loadingOverlay');
    if (show) {
        overlay.classList.add('active');
    } else {
        overlay.classList.remove('active');
    }
}

// Make functions globally accessible for inline event handlers
window.removeWallet = removeWallet;
